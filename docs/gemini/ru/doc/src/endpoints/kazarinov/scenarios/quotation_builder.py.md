# Модуль для создания котировок
## Обзор

Модуль `quotation_builder.py` предназначен для обработки данных о товарах, полученных от различных поставщиков, их подготовки, обработки с использованием искусственного интеллекта и интеграции с Facebook для публикации рекламных объявлений.

## Подробней

Этот модуль является частью проекта `hypotez` и отвечает за автоматизацию процесса создания котировок на основе данных о товарах. Он включает в себя извлечение данных о товарах от различных поставщиков, их преобразование в формат, пригодный для обработки моделями искусственного интеллекта, и последующее использование этих моделей для генерации релевантного контента для рекламных объявлений. Кроме того, модуль обеспечивает интеграцию с Facebook для автоматической публикации этих объявлений.

## Классы

### `QuotationBuilder`

**Описание**: Класс `QuotationBuilder` отвечает за извлечение, разбор и сохранение данных о продуктах поставщиков. Он инициализирует веб-драйвер, модель Gemini и выполняет основные этапы обработки данных для создания котировок.

**Как работает класс**:

1.  **Инициализация**:
    *   При инициализации класса создается инстанс веб-драйвера (например, Firefox или Playwright) для взаимодействия с веб-сайтами поставщиков.
    *   Загружается конфигурация из JSON-файла, содержащая необходимые параметры для работы.
    *   Инициализируется модель Gemini для обработки текстовых данных и генерации контента.

2.  **Обработка данных**:
    *   Метод `convert_product_fields` преобразует поля продукта из формата `ProductFields` в словарь, удобный для использования в запросах к модели Gemini.
    *   Методы `process_ai` и `process_ai_async` отправляют данные о продуктах в модель Gemini для получения сгенерированного контента на разных языках.

3.  **Сохранение данных**:
    *   Метод `save_product_data` сохраняет обработанные данные о продуктах в JSON-файлы для дальнейшего использования.

4.  **Публикация в Facebook**:
    *   Метод `post_facebook_async` выполняет сценарий публикации рекламного объявления в Facebook, используя полученные данные и сгенерированный контент.

**Атрибуты**:

*   `base_path` (Path): Базовый путь к каталогу модуля.
*   `config` (SimpleNamespace): Конфигурация, загруженная из JSON-файла.
*   `html_path` (str | Path): Путь к HTML-файлу.
*   `pdf_path` (str | Path): Путь к PDF-файлу.
*   `docx_path` (str | Path): Путь к DOCX-файлу.
*   `driver` (Driver): Инстанс веб-драйвера для взаимодействия с веб-сайтами.
*   `export_path` (Path): Путь для экспорта данных.
*   `mexiron_name` (str): Имя процесса Mexiron.
*   `price` (float): Цена.
*   `timestamp` (str): Временная метка.
*   `products_list` (List): Список обработанных данных о продуктах.
*   `model` (GoogleGenerativeAI): Инстанс модели Google Gemini для обработки текста.
*   `translations` (SimpleNamespace): Переводы, загруженные из JSON-файла.
*   `required_fields` (tuple): Кортеж необходимых полей товара.

**Методы**:

*   `__init__`: Инициализирует класс `QuotationBuilder`.
*   `convert_product_fields`: Преобразует поля продукта в словарь.
*   `process_ai`: Обрабатывает список продуктов с использованием модели AI (синхронно).
*   `process_ai_async`: Обрабатывает список продуктов с использованием модели AI (асинхронно).
*   `save_product_data`: Сохраняет данные продукта в файл.
*   `post_facebook_async`: Публикует рекламное объявление в Facebook.

### `QuotationBuilder.__init__`

```python
def __init__(self, mexiron_name:Optional[str] = gs.now, driver:Optional[Firefox | Playwrid | str] = None,  **kwards):
    """
    Initializes Mexiron class with required components.

    Args:
        driver (Driver): Selenium WebDriver instance.
        mexiron_name (Optional[str]): Custom name for the Mexiron process.
        webdriver_name (Optional[str]): Name of the WebDriver to use. Defaults to 'firefox'. call to Firefox or Playwrid
        window_mode (Optional[str]): Оконный режим вебдрайвера. Может быть 'maximized', 'headless', 'minimized', 'fullscreen', 'normal', 'hidden', 'kiosk'

    """
```

**Назначение**: Инициализирует класс `QuotationBuilder`, настраивая необходимые компоненты, такие как веб-драйвер и модель Gemini.

**Как работает функция**:

1.  **Инициализация пути экспорта**:
    *   Формирует путь для экспорта данных на основе имени процесса Mexiron. Если возникает ошибка при формировании пути, логирует ошибку и завершает работу.

2.  **Инициализация веб-драйвера**:
    *   Если передан инстанс `Driver`, использует его напрямую.
    *   Если передан класс веб-драйвера (например, `Firefox` или `Playwrid`), создает инстанс `Driver` с использованием переданного класса и дополнительных аргументов `kwards`.
    *   Если передана строка с именем веб-драйвера (`'firefox'` или `'playwright'`), создает инстанс `Driver` с соответствующим классом и аргументами.
    *   Если веб-драйвер не передан, создает инстанс `Driver` с использованием `Firefox` по умолчанию.

3.  **Инициализация модели Gemini**:
    *   Загружает системную инструкцию для модели Gemini из файла.
    *   Получает API-ключ для Gemini из хранилища учетных данных.
    *   Инициализирует модель Gemini с использованием API-ключа, системной инструкции и конфигурации генерации.
    *   При возникновении ошибок в процессе инициализации модели, логирует их и завершает работу.

### `QuotationBuilder.convert_product_fields`

```python
def convert_product_fields(self, f: ProductFields) -> dict:
    """
    Converts product fields into a dictionary.
    Функция конвертирует поля из объекта `ProductFields` в простой словарь для модели ии.

    Args:
        f (ProductFields): Object containing parsed product data.

    Returns:
        dict: Formatted product data dictionary.

    .. note:: Правила построения полей определяются в `ProductFields`
    """
```

**Назначение**: Преобразует поля продукта из объекта `ProductFields` в словарь, пригодный для использования в запросах к модели Gemini.

**Как работает функция**:

1.  **Проверка наличия ID продукта**:
    *   Проверяет, установлен ли идентификатор продукта (`f.id_product`). Если ID отсутствует, логирует ошибку и возвращает пустой словарь.

2.  **Экранирование и очистка строк**:
    *   Определяет внутреннюю функцию `escape_and_strip`, которая очищает и экранирует текстовые строки. Она заменяет символы `'` и `"` на `\'` и `\"`, удаляет пробелы в начале и конце строки, а также заменяет `;` на `<br>`.

3.  **Извлечение и обработка данных**:
    *   Извлекает значения полей `name`, `description`, `description_short` и `specification` из объекта `ProductFields`, применяя функцию `escape_and_strip` для очистки и экранирования.
    *   Проверяет наличие имени продукта (`product_name`). Если имя отсутствует, возвращает пустой словарь.

4.  **Формирование словаря**:
    *   Формирует словарь с данными о продукте, включая имя продукта, ID продукта, краткое и полное описание, спецификацию и путь к локальному изображению.

5.  **Возврат результата**:
    *   Возвращает сформированный словарь с данными о продукте.

**Внутренние функции**:

*   `escape_and_strip(text: str) -> str`: Очищает и экранирует текстовую строку.

### `QuotationBuilder.process_ai`

```python
def process_ai(self, products_list: List[str], lang:str,  attempts: int = 3) -> tuple | bool:
    """
    Processes the product list through the AI model.

    Args:
        products_list (str): List of product data dictionaries as a string.
        attempts (int, optional): Number of attempts to retry in case of failure. Defaults to 3.

    Returns:
        tuple: Processed response in `ru` and `he` formats.
        bool: False if unable to get a valid response after retries.

    .. note::
        Модель может возвращать невалидный результат.
        В таком случае я переспрашиваю модель разумное количество раз.
    """
```

**Назначение**: Обрабатывает список продуктов с использованием модели искусственного интеллекта (AI) для генерации контента на указанном языке.

**Как работает функция**:

1.  **Проверка количества попыток**:
    *   Проверяет, осталось ли доступное количество попыток (`attempts`). Если попыток не осталось, возвращает пустой словарь.

2.  **Загрузка командной инструкции**:
    *   Загружает командную инструкцию для модели AI из файла, используя указанный язык (`lang`).

3.  **Формирование запроса**:
    *   Формирует запрос к модели AI, объединяя командную инструкцию и список продуктов, представленный в виде строки.

4.  **Отправка запроса к модели**:
    *   Отправляет запрос к модели AI с использованием метода `self.model.ask`.

5.  **Обработка ответа**:
    *   Если ответ от модели отсутствует, логирует ошибку и возвращает пустой словарь.
    *   Парсит ответ модели из формата JSON в словарь `response_dict` с использованием `j_loads`. Если парсинг не удался, логирует ошибку.

6.  **Повторные попытки**:
    *   Если парсинг ответа не удался и остались доступные попытки (`attempts > 1`), рекурсивно вызывает `self.process_ai` с уменьшенным количеством попыток.

7.  **Возврат результата**:
    *   Если парсинг ответа удался, возвращает полученный словарь `response_dict`.

### `QuotationBuilder.process_ai_async`

```python
async def process_ai_async(self, products_list: List[str], lang:str,  attempts: int = 3) -> tuple | bool:
    """
    Processes the product list through the AI model.

    Args:
        products_list (str): List of product data dictionaries as a string.
        attempts (int, optional): Number of attempts to retry in case of failure. Defaults to 3.

    Returns:
        tuple: Processed response in `ru` and `he` formats.
        bool: False if unable to get a valid response after retries.

    .. note::
        Модель может возвращать невалидный результат.
        В таком случае я переспрашиваю модель разумное количество раз.
    """
```

**Назначение**: Асинхронно обрабатывает список продуктов с использованием модели искусственного интеллекта (AI) для генерации контента на указанном языке.

**Как работает функция**:

1.  **Проверка количества попыток**:
    *   Проверяет, осталось ли доступное количество попыток (`attempts`). Если попыток не осталось, возвращает пустой словарь.

2.  **Загрузка командной инструкции**:
    *   Загружает командную инструкцию для модели AI из файла, используя указанный язык (`lang`).

3.  **Формирование запроса**:
    *   Формирует запрос к модели AI, объединяя командную инструкцию и список продуктов, представленный в виде строки.

4.  **Отправка запроса к модели**:
    *   Отправляет асинхронный запрос к модели AI с использованием метода `self.model.ask_async`.

5.  **Обработка ответа**:
    *   Если ответ от модели отсутствует, логирует ошибку и возвращает пустой словарь.
    *   Парсит ответ модели из формата JSON в словарь `response_dict` с использованием `j_loads`. Если парсинг не удался, логирует ошибку.

6.  **Повторные попытки**:
    *   Если парсинг ответа не удался и остались доступные попытки (`attempts > 1`), рекурсивно вызывает `self.process_ai_async` с уменьшенным количеством попыток.

7.  **Возврат результата**:
    *   Если парсинг ответа удался, возвращает полученный словарь `response_dict`.

### `QuotationBuilder.save_product_data`

```python
async def save_product_data(self, product_data: dict) -> bool:
    """
    Saves individual product data to a file.

    Args:
        product_data (dict): Formatted product data.
    """
```

**Назначение**: Сохраняет данные отдельного продукта в файл в формате JSON.

**Как работает функция**:

1.  **Формирование пути к файлу**:
    *   Формирует путь к файлу, в котором будут сохранены данные продукта, на основе идентификатора продукта (`product_data['product_id']`).

2.  **Сохранение данных в файл**:
    *   Сохраняет данные продукта в файл, используя функцию `j_dumps` для записи JSON-данных. Устанавливает `ensure_ascii=False`, чтобы обеспечить правильную запись символов Unicode.
    *   Если сохранение данных не удалось, логирует ошибку, содержащую данные продукта и путь к файлу.

3.  **Возврат результата**:
    *   Возвращает `True`, если данные успешно сохранены в файл. В случае ошибки возврата не происходит.

### `QuotationBuilder.post_facebook_async`

```python
async def post_facebook_async(self, mexiron:SimpleNamespace) -> bool:
    """Функция исполняет сценарий рекламного модуля `facvebook`."""
    ...
```

**Назначение**: Выполняет сценарий рекламного модуля `facebook` для публикации сообщения в Facebook.

**Как работает функция**:

1.  **Переход на страницу Facebook**:
    *   Использует `self.driver.get_url` для перехода на страницу Facebook.

2.  **Формирование заголовка**:
    *   Формирует заголовок сообщения, объединяя заголовок, описание и цену из объекта `mexiron`.

3.  **Публикация сообщения**:
    *   Вызывает функцию `post_message_title` для публикации заголовка сообщения. Если публикация не удалась, логирует предупреждение.
    *   Вызывает функцию `upload_post_media` для загрузки медиафайлов (изображений) к сообщению. Если загрузка не удалась, логирует предупреждение.
    *   Вызывает функцию `message_publish` для публикации сообщения. Если публикация не удалась, логирует предупреждение.

4.  **Возврат результата**:
    *   Возвращает `True`, если все этапы публикации выполнены успешно.

## Функции

### `main`

```python
def main():
    """"""
    ...
```

**Назначение**: Главная функция, которая выполняет основные шаги по созданию отчетов на основе данных о товарах.

**Как работает функция**:

1.  **Определение параметров**:
    *   Определяет язык (`lang`), имя процесса Mexiron (`mexiron_name`), базовый путь (`base_path`) и пути к HTML, PDF и DOCX файлам.

2.  **Загрузка данных**:
    *   Загружает данные о товарах из JSON-файла.

3.  **Создание отчетов**:
    *   Создает экземпляр класса `QuotationBuilder`.
    *   Вызывает асинхронную функцию `create_reports` для создания отчетов на основе загруженных данных.

## Переменные

*   `ENDPOINT` (str): Константа, определяющая имя каталога.