# סינגלטון (Singleton) ב-`Python`

## סקירה כללית

ב-`Python`, סינגלטון הוא תבנית עיצוב שמבטיחה שלמחלקה יהיה רק מופע אחד, ומספקת נקודת גישה גלובלית למופע זה. המשמעות היא שבעת ניסיון ליצור אובייקט חדש של מחלקה זו, תמיד תקבל את אותו האובייקט.

סינגלטונים שימושיים כאשר יש צורך להגביל את מספר המופעים של מחלקה, לדוגמה:

*   לניהול חיבור למסד נתונים (כדי לא לפתוח חיבורים רבים).
*   לאחסון תצורה גלובלית של האפליקציה (כדי שכל חלקי האפליקציה ישתמשו באותה תצורה).
*   לרישום יומן (כדי שכל ההודעות ילכו לקובץ אחד).

ישנן מספר דרכים ליישום סינגלטון ב-`Python`.

<hr>

## תוכן עניינים

1.  [שיטות יישום סינגלטון](#שיטות-יישום-סינגלטון)
    *   [דרך דריסת המתודה `__new__`](#דרך-דריסת-המתודה-__new__)
    *   [דרך דקורטור](#דרך-דקורטור)
    *   [דרך מטא-מחלקה](#דרך-מטא-מחלקה)
    *   [דרך מודול](#דרך-מודול)
2.  [יתרונות הסינגלטון](#יתרונות-הסינגלטון)
3.  [חסרונות הסינגלטון](#חסרונות-הסינגלטון)
4.  [מתי להשתמש בסינגלטון?](#מתי-להשתמש-בסינגלטון)

<hr>

## שיטות יישום סינגלטון

### דרך דריסת המתודה `__new__`

*   המתודה `__new__` אחראית ליצירת מופע של מחלקה. על ידי דריסתה, אוכל לשלוט בתהליך הזה.
*   בדוגמה זו, אאחסן את המופע היחיד של המחלקה במשתנה `_instance`.
*   אם אין עדיין מופע, אני יוצר אותו, אחרת אני מחזיר את המופע הקיים.
*   **`Python` Code:**

    ```python
    class Singleton:
        _instance = None  # Храню единственный экземпляр

        def __new__(cls, *args, **kwargs):
            """
            Переопределяю метод __new__, чтобы контролировать создание экземпляра.

            Args:
                cls: Класс, для которого создается экземпляр.
                *args: Позиционные аргументы для конструктора.
                **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if not cls._instance: # Если экземпляр еще не создан
                cls._instance = super().__new__(cls, *args, **kwargs) # Создаю новый экземпляр
            return cls._instance # Возвращаю существующий экземпляр

    # Пример использования
    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)  # Выведет True, так как это один и тот же объект
    ```

<hr>

### דרך דקורטור

*   דקורטור הוא פונקציה שמשנה מחלקה.
*   בדוגמה זו, אני יוצר פונקציית דקורטור `singleton`, שמקבלת מחלקה ומחזירה את הגרסה העטופה שלה.
*   בתוך הדקורטור, אני מאחסן מופעי מחלקות במילון `instances`.
*   אם עדיין לא נוצר מופע של המחלקה, אני יוצר אותו ושומר אותו במילון, אחרת אני מחזיר את המופע הקיים.
*   **`Python` Code:**

    ```python
    def singleton(cls):
        """
        Декоратор для создания синглтона.

        Args:
            cls: Класс, который нужно сделать синглтоном.

        Returns:
            Модифицированный класс, являющийся синглтоном.
        """
        instances = {} # Храню экземпляры классов

        def wrapper(*args, **kwargs):
            """
            Функция-обертка, которая возвращает единственный экземпляр класса.

            Args:
               *args: Позиционные аргументы для конструктора.
               **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if cls not in instances: # Если экземпляр еще не создан
                instances[cls] = cls(*args, **kwargs) # Создаю экземпляр и сохраняю его
            return instances[cls] # Возвращаю существующий экземпляр
        return wrapper

    @singleton # Применяю декоратор к классу
    class MyClass:
        pass

    # Пример использования
    obj1 = MyClass()
    obj2 = MyClass()

    print(obj1 is obj2)  # Выведет True, так как это один и тот же объект
    ```

<hr>

### דרך מטא-מחלקה

*   מטא-מחלקה מאפשרת לשלוט ביצירת מחלקות.
*   בדוגמה זו, אצור מטא-מחלקה `SingletonMeta` שתעקוב אחר יצירת מופעים.
*   מטא-המחלקה מאחסנת מופעי מחלקות במילון `_instances`.
*   בעת יצירת מופע חדש, אני בודק אם הוא כבר קיים במילון, אם לא – אני יוצר אותו, אחרת אני מחזיר את המופע הקיים.
*   **`Python` Code:**

    ```python
    class SingletonMeta(type):
        """
        Метакласс для создания синглтона.
        """
        _instances = {} # Храним экземпляры

        def __call__(cls, *args, **kwargs):
            """
            Переопределяю метод __call__, чтобы контролировать создание экземпляра.

            Args:
                cls: Класс, для которого создается экземпляр.
                *args: Позиционные аргументы для конструктора.
                **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if cls not in cls._instances: # Если экземпляр еще не создан
                cls._instances[cls] = super().__call__(*args, **kwargs) # Создаю новый экземпляр
            return cls._instances[cls] # Возвращаю существующий экземпляр

    class Singleton(metaclass=SingletonMeta):
        """
        Класс, который является синглтоном.
        """
        pass

    # Пример использования
    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)  # Выведет True, так как это один и тот же объект
    ```

<hr>

### דרך מודול

*   ב-`Python`, מודול עצמו הוא סינגלטון.
*   אני יכול ליצור אובייקט במודול, והוא יהיה המופע היחיד.
*   **`Python` Code:**

    ```python
    # Файл singleton.py
    class Singleton:
        pass

    instance = Singleton()
    ```

    ```python
    # В другом файле
    from singleton import instance

    obj1 = instance
    obj2 = instance

    print(obj1 is obj2)  # Выведет True, так как это один и тот же объект
    ```

<hr>

## יתרונות הסינגלטון

*   **אבטחת מופע יחיד:** סינגלטון מבטיח שלמחלקה יהיה רק מופע אחד. זה שימושי לניהול משאבים שצריכים להיות ייחודיים.
*   **גישה גלובלית:** סינגלטון מספק נקודת גישה גלובלית למופע המחלקה, מה שמקל על השימוש במופע זה בכל חלק בתוכנית.

## חסרונות הסינגלטון

*   **מצב גלובלי:** סינגלטון עלול להוביל לשימוש במצב גלובלי, מה שעלול לגרום לתופעות לוואי בלתי צפויות ולהקשות על הבדיקות.
*   **הפרת עקרונות ООП:** סינגלטון עלול להפר את עקרון האחריות היחידה והאינקפסולציה.

## מתי להשתמש בסינגלטון?

*   כאשר אתה צריך שאובייקט יתקיים במופע יחיד (לדוגמה, תצורה, לוגר, חיבור למסד נתונים).
*   כאשר אתה זקוק לגישה גלובלית לאובייקט זה.