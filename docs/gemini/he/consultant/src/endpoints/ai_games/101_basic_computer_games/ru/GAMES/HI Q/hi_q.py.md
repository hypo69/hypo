# Анализ кода модуля `hi_q.py`

**Качество кода**

-   **Соответствие требованиям:**
    -   [x] 1. **Формат документации**: Используется reStructuredText (RST) для комментариев и docstring.
    -   [x] 2. **Сохранение комментариев**: Сохранены существующие комментарии после `#`. Добавлены комментарии по мере необходимости.
    -   [x] 3. **Обработка данных**: `json.load` не используется.
    -   [x] 4. **Анализ структуры**: Все необходимые импорты на месте.
    -   [x] 5. **Рефакторинг и улучшения**: Все функции и методы имеют docstring.
    -   [x] 6. **Логирование**: Используется `logger.error` для обработки ошибок.
    -   [x] 7. **Код**: Предоставлен полный код в конце ответа.
    -   [x] 8. **Примеры кода**: Включены примеры docstring.
    -   [x] 9. **Дополнительные инструкции**: Все модули, функции, методы и переменные имеют docstring в формате reStructuredText (RST).

-   **Плюсы:**
    -   Код хорошо структурирован и разбит на логические функции.
    -   Имеется базовая документация к каждой функции.
    -   Код достаточно читаемый и понятный.
    -   Логика игры реализована корректно.
    -   Ввод пользователя обрабатывается с проверками на корректность.

-   **Минусы:**
    -   Отсутствует обработка исключений в некоторых частях кода (например, при обращении к элементам списка).
    -   Код не использует логирование ошибок.
    -   Некоторые комментарии могли бы быть более подробными и соответствовать формату RST.

**Рекомендации по улучшению**

1.  **Добавить логирование ошибок**:
    -   Используйте `logger.error` для записи ошибок в случаях некорректного ввода или других исключений.
    -   Не используйте стандартные `try-except` блоки без необходимости.

2.  **Улучшить документацию**:
    -   Добавить более подробное описание работы функций и их параметров в docstring в формате RST.
    -   Переписать комментарии после `#`, используя формат RST.

3.  **Обработка исключений**:
    -   Добавить обработку возможных исключений в критических местах, где код может завершиться с ошибкой.

4.  **Рефакторинг**
    -   Переименовать функцию `count_pegs` в `count_pieces` чтобы соответствовать конвенции наименования функций
    -   В цикле `while` в `play_hi_q` убрать повторяющийся вызов `print_board`

**Улучшенный код**

```python
"""
Модуль для игры HI Q
=========================================================================================

Игра HI Q представляет собой головоломку, в которой нужно удалить шарики с доски, перепрыгивая через них.
Цель игры - оставить на доске только один шарик.
Игрок выбирает шарик и направление, в котором он будет перепрыгивать.
Игра заканчивается, когда больше нет возможных ходов или остался только один шарик.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    if __name__ == "__main__":
        play_hi_q()

"""
from src.logger.logger import logger # импортируем логер

def init_board() -> list[list[int]]:
    """
    Инициализирует игровое поле с начальным расположением шариков.

    :return: Список списков, представляющий доску.
    :rtype: list[list[int]]
    """
    board = [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0]
    ]
    return board

def print_board(board: list[list[int]]) -> None:
    """
    Выводит текущее состояние игрового поля на экран.

    :param board: Список списков, представляющий доску.
    :type board: list[list[int]]
    """
    for row in board:
        print(' '.join(map(str, row)))

def get_move() -> tuple[int, int, str]:
    """
    Запрашивает у пользователя координаты шарика и направление хода.

    :return: Кортеж (row, col, direction), где direction: 'u', 'd', 'l', 'r'.
    :rtype: tuple[int, int, str]
    """
    while True:
        try:
            row = int(input("Введите строку шарика (0-6): ")) # запрашиваем ввод строки шарика
            col = int(input("Введите столбец шарика (0-6): ")) # запрашиваем ввод столбца шарика
            direction = input("Введите направление (u/d/l/r): ").lower() # запрашиваем ввод направления хода
            if 0 <= row <= 6 and 0 <= col <= 6 and direction in ['u', 'd', 'l', 'r']: # проверка допустимости ввода
                return row, col, direction
            else:
                print("Неверный ввод. Попробуйте еще раз.") # сообщаем о некорректном вводе
        except ValueError as ex: # ловим исключение при некорректном вводе
            logger.error('Неверный ввод', ex) # Логируем ошибку
            print("Неверный ввод. Попробуйте еще раз.") # сообщаем о некорректном вводе

def is_valid_move(board: list[list[int]], row: int, col: int, direction: str) -> bool:
    """
    Проверяет, является ли ход допустимым.

    :param board: Список списков, представляющий доску.
    :type board: list[list[int]]
    :param row: Строка выбранного шарика.
    :type row: int
    :param col: Столбец выбранного шарика.
    :type col: int
    :param direction: Направление хода ('u', 'd', 'l', 'r').
    :type direction: str
    :return: True, если ход допустим, иначе False.
    :rtype: bool
    """
    if board[row][col] != 1: # Проверяем, что в выбранной ячейке есть шарик
        return False

    if direction == 'u':
        if row < 2 or board[row - 1][col] != 1 or board[row - 2][col] != 0: # проверяем возможность хода вверх
            return False
    elif direction == 'd':
        if row > 4 or board[row + 1][col] != 1 or board[row + 2][col] != 0: # проверяем возможность хода вниз
            return False
    elif direction == 'l':
        if col < 2 or board[row][col - 1] != 1 or board[row][col - 2] != 0: # проверяем возможность хода влево
            return False
    elif direction == 'r':
         if col > 4 or board[row][col + 1] != 1 or board[row][col + 2] != 0: # проверяем возможность хода вправо
             return False

    return True

def make_move(board: list[list[int]], row: int, col: int, direction: str) -> list[list[int]]:
    """
    Выполняет ход, обновляя состояние игрового поля.

    :param board: Список списков, представляющий доску.
    :type board: list[list[int]]
    :param row: Строка выбранного шарика.
    :type row: int
    :param col: Столбец выбранного шарика.
    :type col: int
    :param direction: Направление хода ('u', 'd', 'l', 'r').
    :type direction: str
    :return: Обновленный список списков, представляющий доску.
    :rtype: list[list[int]]
    """
    if direction == 'u':
        board[row][col] = 0 # убираем шарик с исходной позиции
        board[row - 1][col] = 0 # убираем шарик через который перепрыгнули
        board[row - 2][col] = 1 # ставим шарик на новую позицию
    elif direction == 'd':
        board[row][col] = 0 # убираем шарик с исходной позиции
        board[row + 1][col] = 0 # убираем шарик через который перепрыгнули
        board[row + 2][col] = 1 # ставим шарик на новую позицию
    elif direction == 'l':
        board[row][col] = 0 # убираем шарик с исходной позиции
        board[row][col - 1] = 0 # убираем шарик через который перепрыгнули
        board[row][col - 2] = 1 # ставим шарик на новую позицию
    elif direction == 'r':
        board[row][col] = 0 # убираем шарик с исходной позиции
        board[row][col + 1] = 0 # убираем шарик через который перепрыгнули
        board[row][col + 2] = 1 # ставим шарик на новую позицию
    return board

def has_moves(board: list[list[int]]) -> bool:
    """
    Проверяет, есть ли еще возможные ходы.

    :param board: Список списков, представляющий доску.
    :type board: list[list[int]]
    :return: True, если есть возможные ходы, иначе False.
    :rtype: bool
    """
    for row in range(len(board)): # перебираем все строки
        for col in range(len(board[row])): # перебираем все столбцы
            if board[row][col] == 1: # проверяем, есть ли шарик в текущей позиции
                if is_valid_move(board, row, col, 'u') or \
                   is_valid_move(board, row, col, 'd') or \
                   is_valid_move(board, row, col, 'l') or \
                   is_valid_move(board, row, col, 'r'): # проверяем, есть ли допустимый ход для текущего шарика
                    return True
    return False

def count_pieces(board: list[list[int]]) -> int:
    """
    Считает количество шариков на доске.

    :param board: Список списков, представляющий доску.
    :type board: list[list[int]]
    :return: Количество шариков на доске.
    :rtype: int
    """
    count = 0
    for row in board:
        count += row.count(1) # считаем шарики в каждой строке
    return count

def play_hi_q() -> None:
    """
    Основная функция игры HI Q.

    Содержит игровой цикл, управление ходами и проверку на победу/проигрыш.
    """
    board = init_board() # инициализируем доску
    while True: # игровой цикл
        print_board(board) # Выводим текущее состояние доски
        row, col, direction = get_move() # Запрашиваем у пользователя координаты и направление
        if is_valid_move(board, row, col, direction): # Проверяем допустимость хода
            board = make_move(board, row, col, direction) # делаем ход
            if count_pieces(board) == 1: # проверяем остался ли только один шарик
                print_board(board)
                print("Поздравляю! Вы выиграли!") # выводим сообщение о победе
                break
            if not has_moves(board): # Проверяем есть ли еще ходы
                print_board(board)
                print("Увы, ходов больше нет. Вы проиграли!") # выводим сообщение о поражении
                break
        else:
            print("Недопустимый ход. Попробуйте еще раз.") # сообщаем о недопустимом ходе


if __name__ == "__main__":
    play_hi_q()
```