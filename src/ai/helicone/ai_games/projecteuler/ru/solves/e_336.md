## Ответ на Задачу No 336: Коробка плиток

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Задача заключается в нахождении количества способов покрытия прямоугольной области 2 x *n* плитками двух типов: 1x2 и 1x1.
*   *T*(*n*) - общее количество способов покрытия.
*   *M*(*n*) - количество способов покрытия, где используется хотя бы одна плитка 1x2.
*   *S*(*n*) - сумма всех *M*(*i*) для 1 ≤ *i* ≤ *n*.
*   Необходимо найти *S*(1 000 000) mod 100 000 007.

**Решение:**

1. **Вывод рекуррентных соотношений для T(n):**
   -   Если мы рассматриваем последнюю колонку, то её можно покрыть либо двумя квадратными плитками 1x1, либо одной прямоугольной 1x2 плиткой вертикально (две штуки), либо двумя прямоугольными 1x2 плитками горизонтально.
   -  Если в последнем столбце 2 квадратные плитки, то до этого имеем T(n-1) способов.
   -  Если в последнем столбце 2 прямоугольные плитки вертикально, то до этого имеем T(n-1) способов.
   -  Если в последних двух столбцах 2 прямоугольные плитки горизонтально, то до этого имеем T(n-2) способов.
   -  Это приводит к рекуррентному соотношению: *T*(*n*) = 2 * *T*(*n*-1) + *T*(*n*-2).
   -  Из условий задачи *T*(1) = 1, *T*(2) = 3.

2. **Вывод рекуррентных соотношений для M(n):**
   -  *M*(*n*) = *T*(*n*) - количество способов покрыть 2 x *n* только квадратами 1x1.
   -  Количество способов покрыть 2 x *n* только квадратами 1x1 - всего 1 способ.
   -  Таким образом, *M*(*n*) = *T*(*n*) - 1.

3. **Вычисление S(n):**
    -   *S*(*n*) = Σ *M*(*i*) для 1 ≤ *i* ≤ *n*.
    -  Так как *M*(*i*) = *T*(*i*) - 1, то *S*(*n*) =  Σ (*T*(*i*) - 1) для 1 ≤ *i* ≤ *n*.
    -  *S*(*n*) = Σ *T*(*i*) - n

4. **Оптимизация вычислений:**
   -   Чтобы избежать рекурсивных вызовов, мы будем использовать динамическое программирование для вычисления *T*(*n*)  и  *S*(*n*).
   -   Поскольку нам нужен результат по модулю 100 000 007, будем выполнять все операции по модулю.

### 2. Алгоритм решения
1.  Начать
2.  Задать константу `MOD = 1000000007`
3.  Инициализировать массив `T` размером `n + 1`, `T[1] = 1`, `T[2] = 3`.
4.  Инициализировать массив `S` размером `n + 1`, `S[0] = 0`, `S[1] = 0`.
5.  Вычислить значения `T[i]` от 3 до `n` по формуле: `T[i] = (2 * T[i-1] + T[i-2]) % MOD`
6.  Вычислить значения `S[i]` от 1 до `n` по формуле: `S[i] = (S[i-1] + T[i] - 1) % MOD`.
7.  Вернуть `S[n]`
8.  Конец

### 3. Реализация на Python 3.12
```python
def solve():
    MOD = 1000000007
    n = 1000000
    
    T = [0] * (n + 1)
    T[1] = 1
    if n > 1:
        T[2] = 3
    
    S = [0] * (n + 1)

    for i in range(3, n + 1):
        T[i] = (2 * T[i-1] + T[i-2]) % MOD
    
    for i in range(1, n+1):
        S[i] = (S[i-1] + T[i] - 1) % MOD

    return S[n]

result = solve()
print(result)

```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeConstants((Инициализировать MOD = 1000000007, n = 1000000))
    InitializeConstants --> InitializeArrays((Инициализировать массивы T и S))
    InitializeArrays --> CalculateTValues((Вычислить значения T[i] от 3 до n))
    CalculateTValues --> CalculateSValues((Вычислить значения S[i] от 1 до n))
    CalculateSValues --> ReturnResult((Вернуть S[n]))
    ReturnResult --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать MOD, n:** Присваивание значений константам.
*   **Инициализировать массивы T и S:** Создание массивов и установка начальных значений.
*   **Вычислить значения T[i] от 3 до n:** Цикл для вычисления значений T[i] на основе рекуррентного соотношения.
*   **Вычислить значения S[i] от 1 до n:** Цикл для вычисления значений S[i] на основе вычисленных T[i].
*   **Вернуть S[n]:** Возвращает результат S[n].
