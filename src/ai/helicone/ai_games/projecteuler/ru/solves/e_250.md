## Ответ на Задачу No 250

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Задача требует найти количество подмножеств множества {a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>}, где a<sub>i</sub> = i<sup>i</sup>,  сумма элементов которых делится на 250.
*   Необходимо вычислить это количество по модулю 10<sup>16</sup>.
*   Значение n равно 10<sup>16</sup>.  
*   Прямой перебор подмножеств и вычисление сумм невозможны из-за очень большого n.
*   Нам нужно понять, как свойства чисел i<sup>i</sup> и делимости на 250 помогут решить задачу. 

**Решение:**

1.  **Периодичность по модулю:**
    *   Заметим, что 250 = 2 * 5<sup>3</sup>.  
    *   Необходимо исследовать периодичность последовательности  `i^i  mod 250` .
    *   Поскольку нас интересует делимость на 250, имеет смысл изучить поведение  `i^i mod 2` и `i^i mod 125` отдельно.
    *   Для `mod 2`:  i<sup>i</sup> mod 2 = 0, если i четное, и 1, если i нечетное. Это просто.
    *   Для `mod 125`: Необходимо исследовать  период  `i^i mod 125` . Используем свойство, что  `φ(125) = 100`.  Значит, последовательность `i^i  mod 125` будет иметь некоторый период.

2.  **Группировка и динамическое программирование:**
    *  Из-за периодичности `i^i mod 250` можем сгруппировать значения `a_i`  в группы, где элементы в каждой группе дают одинаковый остаток при делении на 250.
    *  Идея использования динамического программирования: построить `dp[i][sum]`, где `dp[i][sum]` - это количество подмножеств из первых `i` групп, сумма элементов которых даёт остаток `sum` при делении на 250.

3. **Большое N.** Так как N = 10<sup>16</sup>, мы не можем хранить `dp` размером `N` на 250.
   Из-за периодичности i<sup>i</sup> mod 250 можно заметить, что  `i^i mod 250`  становится периодическим после некоторого момента. То есть, можно посчитать период и затем использовать этот период для вычислений. На самом деле, достаточно вычислить значения  `i^i mod 250` для достаточно небольшого числа i, поскольку последовательность  `i^i mod 250`  будет циклической.
   Пусть длина периода  `period_length`, тогда количество повторяющихся периодов будет `N // period_length`.  И остается  `N % period_length`   неполных элементов, которые необходимо обработать отдельно.

4.  **Вычисление ответа:**
    *   После построения dp, `dp[количество_групп][0]` будет содержать количество подмножеств, сумма которых делится на 250. Это и будет ответом.

### 2. Алгоритм решения

1.  **Начало:**
2.  **Определение периода:**
    *  Вычислить последовательность  `i^i mod 250` для i = 1, 2, 3 ... пока не будет найден период.
3.  **Создание групп:**
    *   Сгруппировать значения  `a_i` по остатку при делении на 250.
    *   Подсчитать количество каждого остатка в периоде.
4.  **Динамическое программирование:**
    *   Инициализировать `dp[0][0] = 1`, остальное 0.
    *   Для каждой группы `i` и каждого остатка `sum`
        *   `dp[i+1][sum] = dp[i][sum] `
        *   Для каждого элемента `a_i` в группе `i`
            *   `dp[i+1][(sum + a_i) % 250] = (dp[i+1][(sum+a_i)%250] + dp[i][sum]) % 10^16`
5.  **Обработка больших N:**
    *  Вычислить количество полных периодов `full_periods = N // period_length`.
    *  Применить динамическое программирование для одного периода.
    *  Использовать результаты для `full_periods`.
    *  Обработать остаток `N % period_length`  с помощью динамического программирования.
6.  **Возврат ответа:**
    *   Вернуть `dp[количество_групп][0]`.
7. **Конец.**

### 3. Реализация на Python 3.12
```python
def power(base, exp, mod):
    res = 1
    base %= mod
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2
    return res

def find_period(mod):
    values = []
    seen = {}
    i = 1
    while True:
        val = power(i, i, mod)
        if val in seen:
           start = seen[val]
           return values[start:], len(values)
        
        seen[val] = len(values)
        values.append(val)
        i += 1

def solve():
    n = 10**16
    mod = 10**16
    mod_250 = 250

    period, length = find_period(mod_250)
    period_counts = [0] * mod_250
    for val in period:
        period_counts[val] += 1

    dp = [[0] * mod_250 for _ in range(2)]
    dp[0][0] = 1

    full_periods = n // length
    for _ in range(full_periods):
        current_dp_index = 1
        prev_dp_index = 0
        for value_mod_250 in range(mod_250):
            if period_counts[value_mod_250] > 0:
                for s in range(mod_250):
                    dp[current_dp_index][s] = dp[prev_dp_index][s]
                    if dp[prev_dp_index][s] > 0:
                      dp[current_dp_index][(s+value_mod_250) % 250] = (dp[current_dp_index][(s+value_mod_250) % 250] + dp[prev_dp_index][s] * period_counts[value_mod_250]) % mod
                
        temp = prev_dp_index
        prev_dp_index = current_dp_index
        current_dp_index = temp

    remaining_elements = n % length
    for i in range(remaining_elements):
        current_dp_index = 1
        prev_dp_index = 0
        val = power(i+1, i+1, mod_250)
        for s in range(mod_250):
            dp[current_dp_index][s] = dp[prev_dp_index][s]
            if dp[prev_dp_index][s] > 0:
                dp[current_dp_index][(s + val) % 250] = (dp[current_dp_index][(s + val) % 250] + dp[prev_dp_index][s]) % mod

        temp = prev_dp_index
        prev_dp_index = current_dp_index
        current_dp_index = temp
    
    return dp[prev_dp_index][0]


result = solve()
print(result)

```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> FindPeriod((Найти период i^i mod 250))
    FindPeriod --> GroupValues((Сгруппировать значения по остаткам))
    GroupValues --> InitializeDP((Инициализировать dp[0][0] = 1, остальное 0))
    InitializeDP --> CalculateFullPeriods((Вычислить количество полных периодов))
    CalculateFullPeriods --> StartFullPeriodLoop((Начать цикл для полных периодов))
    StartFullPeriodLoop --> ApplyDP((Применить DP для одного периода))
    ApplyDP --> NextFullPeriod((Следующий полный период))
    NextFullPeriod -- Есть еще полные периоды --> StartFullPeriodLoop
    NextFullPeriod -- Нет полных периодов --> CalculateRemaining((Вычислить количество оставшихся элементов))
    CalculateRemaining --> StartRemainingLoop((Начать цикл для оставшихся элементов))
    StartRemainingLoop --> ApplyDPforRemaining((Применить DP для оставшегося элемента))
    ApplyDPforRemaining --> NextRemaining((Следующий оставшийся элемент))
    NextRemaining -- Есть еще оставшиеся элементы --> StartRemainingLoop
    NextRemaining -- Нет оставшихся элементов --> ReturnResult((Вернуть dp[количество_групп][0]))
    ReturnResult --> End((Конец))
```
**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Найти период i<sup>i</sup> mod 250:**  Функция находит период последовательности  i<sup>i</sup> mod 250.
*   **Сгруппировать значения по остаткам:** Группировка вычисленных значений  a<sub>i</sub> по остаткам при делении на 250.
*   **Инициализировать dp[0][0] = 1, остальное 0:** Инициализация начальных значений массива динамического программирования.
*  **Вычислить количество полных периодов:** Вычисляет количество полных периодов на основе N и длины найденного периода.
*   **Начать цикл для полных периодов:** Начало цикла для обработки целых периодов.
*   **Применить DP для одного периода:**  Применение динамического программирования для одного полного периода.
*   **Следующий полный период:** Переход к следующему полному периоду.
*  **Вычислить количество оставшихся элементов:** Определение количества элементов, которые не входят в полные периоды.
*   **Начать цикл для оставшихся элементов:** Начало цикла для обработки оставшихся элементов.
*   **Применить DP для оставшегося элемента:** Применение DP для каждого оставшегося элемента.
*   **Следующий оставшийся элемент:** Переход к следующему оставшемуся элементу.
*   **Вернуть dp[количество_групп][0]:** Возвращает итоговое значение количества подмножеств, дающих сумму, кратную 250.
