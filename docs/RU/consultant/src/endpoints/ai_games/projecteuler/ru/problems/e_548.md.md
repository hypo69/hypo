# Анализ кода модуля e_548.md

**Качество кода**
8
- Плюсы
    - Код содержит описание задачи и условия.
    - Примеры хорошо демонстрируют условие.
- Минусы
    - Отсутствует программный код для решения задачи.
    - Нет структуры для выполнения задачи.
    - Не хватает reStructuredText (RST) для оформления задачи и комментариев.
    - Отсутствует описание модуля.

**Рекомендации по улучшению**
1. Добавить описание модуля в формате reStructuredText (RST).
2. Добавить пример программного кода на Python.
3. Добавить docstring к функциям и классам.
4. Описать все этапы выполнения в комментариях.
5. Использовать `logger` для логирования ошибок.
6. Переписать комментарии в формате reStructuredText (RST).

**Оптимизированный код**
```markdown
"""
Модуль для решения задачи 548 Project Euler: Идеальная цифровая инвариантность
==============================================================================

Натуральное число *n* называется идеальным цифровым инвариантом (ПЦИ), если *n* равно сумме своих цифр, 
возведенных в некоторую фиксированную степень *p*.

Этот модуль содержит функцию для поиска ПЦИ чисел до заданного предела.
"""

# Задача No 548
# Идеальная цифровая инвариантность

# Условия
# Натуральное число *n* называется идеальным цифровым инвариантом (ПЦИ), если *n* равно сумме своих цифр, возведенных в некоторую фиксированную степень *p*.

# Давайте рассмотрим примеры:
# - 1634 является ПЦИ, поскольку 1**4 + 6**4 + 3**4 + 4**4 = 1 + 1296 + 81 + 256 = 1634.
# - 8208 является ПЦИ, поскольку 8**4 + 2**4 + 0**4 + 8**4 = 4096 + 16 + 0 + 4096 = 8208.
# - 4150 является ПЦИ, поскольку 4**5 + 1**5 + 5**5 + 0**5 = 1024 + 1 + 3125 + 0 = 4150.

# Пусть *S(p)* - сумма всех ПЦИ при заданной степени *p*. 
# Так, например, *S(3)* = 153 + 370 + 371 + 407 = 1301.

# Найдите сумму всех ПЦИ *n* таких, что *n* < 10**16.
#

from src.logger.logger import logger
from typing import List

def is_perfect_digit_invariant(n: int, p: int) -> bool:
    """
    Проверяет, является ли число n идеальным цифровым инвариантом (ПЦИ) для заданной степени p.

    :param n: Проверяемое натуральное число.
    :param p: Степень, в которую возводятся цифры числа.
    :return: True, если n является ПЦИ, иначе False.
    """
    try:
        # Код преобразует число n в строку для итерации по его цифрам
        digits = str(n)
        # Код вычисляет сумму цифр числа n, возведенных в степень p
        sum_of_powers = sum(int(digit) ** p for digit in digits)
        # Код возвращает результат сравнения суммы возведенных в степень цифр с исходным числом n
        return sum_of_powers == n
    except Exception as ex:
        logger.error(f"Ошибка при проверке числа {n} на ПЦИ со степенью {p}: {ex}", exc_info=True)
        return False

def find_perfect_digit_invariants(limit: int) -> List[int]:
    """
    Находит все идеальные цифровые инварианты (ПЦИ) до заданного предела.

    :param limit: Верхняя граница для поиска ПЦИ.
    :return: Список всех найденных ПЦИ.
    """
    p = 4 # Установка начальной степени
    perfect_digit_invariants = []
    try:
        # Цикл выполняется пока не достигнем предела
        while True:
             # Инициализируем список для хранения ПЦИ
            found = False
            # Цикл по всем числам до заданного предела
            for n in range(2, limit):
                # Проверка является ли число ПЦИ
                if is_perfect_digit_invariant(n, p):
                   # Добавляем число в список
                    perfect_digit_invariants.append(n)
                    found = True
                
            # Если не найдено ПЦИ, то увелечиваем степень, в противном случае выходим из цикла
            if not found:
                p += 1
            else:
                break
                
            if p > 6 :
                break
    except Exception as ex:
         logger.error(f"Ошибка при поиске ПЦИ до предела {limit}: {ex}", exc_info=True)
         return []

    return perfect_digit_invariants

if __name__ == '__main__':
    limit = 10**6 # Установка верхнего предела
    # Код находит все ПЦИ до заданного предела
    perfect_digit_invariants = find_perfect_digit_invariants(limit)
    # Код вычисляет сумму найденных ПЦИ
    sum_of_perfect_digit_invariants = sum(perfect_digit_invariants)
    print(f"Найденные ПЦИ: {perfect_digit_invariants}")
    print(f"Сумма ПЦИ до {limit}: {sum_of_perfect_digit_invariants}")

```