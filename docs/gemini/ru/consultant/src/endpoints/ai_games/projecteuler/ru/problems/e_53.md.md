# Анализ кода модуля e_53

**Качество кода**
9
- Плюсы
    - Код содержит описание задачи и условия.
    - Присутствует математическая формула.
- Минусы
    - Отсутствует реализация решения задачи.
    - Нет комментариев, поясняющих логику кода.
    - Не используются импорты и функции.
    - Не используется логирование.
    - Нет документации в стиле reStructuredText.

**Рекомендации по улучшению**

1.  **Добавить docstring модуля:**
    -   Добавить описание модуля в формате reStructuredText.
2.  **Реализовать функцию для вычисления факториала:**
    -   Создать функцию `factorial(n)`, которая вычисляет факториал числа `n`.
3.  **Реализовать функцию для вычисления комбинаций:**
    -   Создать функцию `combinations(n, r)`, которая вычисляет количество комбинаций `nCr`.
    -   Добавить проверку входных параметров.
    -   Использовать функцию `factorial` для расчета.
4.  **Реализовать основную логику решения задачи:**
    -   Создать цикл для перебора `n` от 1 до 100.
    -   Создать цикл для перебора `r` от 1 до `n`.
    -   Вычислить `nCr` с помощью функции `combinations`.
    -   Увеличить счетчик, если `nCr` больше миллиона.
5.  **Добавить обработку ошибок:**
    -   Использовать `logger.error` для логирования ошибок.
6.  **Добавить комментарии в формате reStructuredText:**
    -   Документировать каждую функцию и переменную.
7.  **Использовать `from src.logger.logger import logger`:**
    -   Импортировать и использовать логгер для отслеживания ошибок.

**Оптимизированный код**

```python
"""
Модуль для решения задачи 53 проекта Эйлера.
=========================================================================================

Задача заключается в поиске количества комбинаций nCr,
для 1 <= n <= 100, значения которых превышают один миллион.

Формула для расчета комбинаций:
nCr = n! / (r! * (n-r)!)
"""
from src.logger.logger import logger

def factorial(n: int) -> int:
    """
    Вычисляет факториал числа n.

    :param n: Целое число, для которого вычисляется факториал.
    :return: Факториал числа n.
    :raises TypeError: Если входной параметр не целое число.
    :raises ValueError: Если входной параметр отрицательный.

    Пример:
    >>> factorial(5)
    120
    """
    if not isinstance(n, int):
        logger.error(f'Некорректный тип данных: {n=}. Ожидался `int`')
        raise TypeError('Ожидалось целое число')
    if n < 0:
        logger.error(f'Некорректный ввод: {n=}. Ожидается неотрицательное число')
        raise ValueError('Факториал определен только для неотрицательных чисел')
    result = 1
    # код вычисляет факториал числа n
    for i in range(1, n + 1):
        result *= i
    return result


def combinations(n: int, r: int) -> int:
    """
    Вычисляет количество комбинаций nCr.

    :param n: Общее количество элементов.
    :param r: Количество элементов для выбора.
    :return: Количество комбинаций nCr.
    :raises TypeError: Если n или r не целые числа.
    :raises ValueError: Если n или r отрицательные или r > n.
    """
    if not isinstance(n, int) or not isinstance(r, int):
        logger.error(f'Некорректный тип данных: {n=}, {r=}. Ожидался `int`')
        raise TypeError('Ожидались целые числа')
    if n < 0 or r < 0:
        logger.error(f'Некорректный ввод: {n=}, {r=}. Ожидаются неотрицательные числа')
        raise ValueError('Числа n и r должны быть неотрицательными')
    if r > n:
        logger.error(f'Некорректный ввод: {n=}, {r=}. r должно быть <= n')
        raise ValueError('r не может быть больше n')
    # код вычисляет количество комбинаций nCr
    try:
        return factorial(n) // (factorial(r) * factorial(n - r))
    except Exception as ex:
        logger.error(f'Ошибка при вычислении комбинаций: {ex}')
        return 0


def solve_problem_53() -> int:
    """
    Решает задачу 53 проекта Эйлера.

    :return: Количество комбинаций nCr, превышающих один миллион, для 1 <= n <= 100.
    """
    count = 0
    # Код перебирает все возможные значения n от 1 до 100
    for n in range(1, 101):
        # Код перебирает все возможные значения r от 1 до n
        for r in range(1, n + 1):
            # Код вычисляет количество комбинаций nCr
            try:
                if combinations(n, r) > 1000000:
                    # код увеличивает счетчик, если nCr больше миллиона
                    count += 1
            except Exception as ex:
                 logger.error(f'Ошибка при вычислении комбинаций для n={n}, r={r}: {ex}')
                 ...
    return count

if __name__ == '__main__':
    # код исполняет решение задачи и выводит результат
    result = solve_problem_53()
    print(f'Количество комбинаций nCr, превышающих один миллион: {result}')
```