## Ответ на Задачу No 323: Бросание монеты

### 1. Анализ задачи и решение
**Понимание задачи:**
* Задача заключается в нахождении математического ожидания количества бросков монеты до тех пор, пока не выпадет заданное количество орлов подряд (*k*).
* Обозначим *f(k)* как ожидаемое количество бросков до выпадения *k* орлов подряд.
* Идея решения заключается в анализе процесса бросания монеты и построении рекуррентной зависимости для *f(k)*.

**Решение:**
1.  **Базовый случай:**  *f(1) = 2*. Это понятно, потому что в среднем нужно два броска чтобы выпал 1 орёл (с вероятностью 1/2 - орёл в первом броске, с вероятностью 1/4 - решка потом орёл и т.д. в итоге  1 + 1/2 + 1/4 + ... = 2).
2.  **Рекуррентное соотношение:** Рассмотрим *f(k)*.  Предположим, мы ждем *k* орлов подряд. Пусть первый бросок - решка. Вероятность этого 1/2. Тогда мы оказываемся в начале, и нам все еще нужно *k* орлов подряд. Таким образом, среднее число бросков с учетом этого случая - *1 + f(k)*. Если же первый бросок - орёл, и второй - орёл и так далее до k-1 орла, а k-тый бросок решка, то мы имеем *k* орлов подряд и 1 решку. В данном случае ожидаемое количество бросков = *k + f(k)*. И если мы, наконец, получаем k орлов подряд, то ожидаемое число бросков - это k.
    
    Обозначим *p = 1/2* - вероятность выпадения орла, тогда:
    *  Если  последовательность бросков начинается с *k* орлов подряд, то ожидаемое количество бросков будет *k*, а вероятность этого события - p^k.
    *   Если последовательность начинается с меньшего количества орлов m (0 <= m < k)  и потом идет решка,  то ожидаемое количество бросков будет *m+1+f(k)*, а вероятность этого события - p^m*(1-p)
    *   Отсюда получаем формулу:
       
       *f(k) = p^k * k + sum(p^m * (1 - p) * (m + 1 + f(k)))* по m от 0 до k-1
      
       Учитывая, что вероятность p = 1/2, и что 1-p = p, преобразуем формулу
        
        *f(k) = (1/2)^k * k +  sum((1/2)^(m+1) * (m + 1 + f(k)))* по m от 0 до k-1
        
        *f(k) = (1/2)^k * k +  (f(k) * sum((1/2)^(m+1)) + sum((m+1) * (1/2)^(m+1)))* по m от 0 до k-1
        
        *sum((1/2)^(m+1)) = (1/2) * (1 - (1/2)^k) / (1 - 1/2) = 1 - (1/2)^k*
        
        *f(k) = (1/2)^k * k +  f(k)*(1 - (1/2)^k) + sum((m+1) * (1/2)^(m+1))* по m от 0 до k-1*
        
         *sum((m+1) * (1/2)^(m+1))* по m от 0 до k-1 = 2 - (k+2) * (1/2)^k*
         
         *f(k) = (1/2)^k * k +  f(k)*(1 - (1/2)^k) + 2 - (k+2) * (1/2)^k*
         
         *f(k) -  f(k)*(1 - (1/2)^k) = (1/2)^k * k + 2 - (k+2) * (1/2)^k*
         
          *f(k)*(1/2)^k =  (1/2)^k * k + 2 - (k+2) * (1/2)^k*
          
          *f(k) = k + 2 * (1/2)^-k  - k - 2 = 2^(k+1) - 2*
        
3.  **Вычисление:** Наконец, вычисляем *f(10^6) = 2^(10^6 + 1) - 2*.

### 2. Алгоритм решения
1.  Начать
2.  Ввод: заданное число `k`.
3.  Вычислить  `result = 2^(k + 1) - 2`
4.  Вывод: `result`
5.  Конец

### 3. Реализация на Python 3.12
```python
def expected_flips(k):
  """
  Calculates the expected number of coin flips until k consecutive heads appear.

  Args:
    k: The number of consecutive heads.

  Returns:
    The expected number of flips.
  """
  result = (2**(k+1)) - 2
  return result

# Пример использования
k = 10**6
result = expected_flips(k)
print(f"{result:.10f}")
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InputK(Ввод: k)
    InputK --> CalculateResult(Вычислить: result = 2^(k+1) - 2)
    CalculateResult --> OutputResult(Вывод: result)
    OutputResult --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Ввод: k:**  Получение значения `k` от пользователя или из заданного контекста.
* **Вычислить: result = 2^(k+1) - 2:** Вычисление значения математического ожидания бросков монеты.
* **Вывод: result:** Вывод результата вычисления.
