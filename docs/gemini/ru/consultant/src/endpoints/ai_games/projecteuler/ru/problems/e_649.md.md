# Анализ кода модуля e_649.md

**Качество кода**
8
- Плюсы
    - Приведено описание задачи Project Euler на русском языке.
    - Условие задачи понятно и точно изложено.
- Минусы
    - Отсутствует программный код.
    - Нет примеров использования функций и классов.
    - Нет документации в формате reStructuredText.
    - Не хватает инструкций по импорту и использованию сторонних библиотек.

**Рекомендации по улучшению**

1.  **Добавить программный код:** Необходимо реализовать функцию для нахождения совершенных чисел и вычисления G(n).
2.  **Документировать код:** Использовать reStructuredText для документирования всех функций и переменных.
3.  **Реализовать функции и классы:** Разделить код на логические блоки, например, функции для проверки, является ли число совершенным и для подсчета количества совершенных чисел.
4.  **Логирование:** Добавить логирование для отслеживания ошибок и отладки кода.
5.  **Импорт библиотек:** Добавить импорт необходимых модулей.
6.  **Примеры использования:** Добавить примеры использования реализованных функций и классов.

**Оптимизированный код**

```python
"""
Модуль для решения задачи 649 проекта Эйлера.
=========================================================================================

Этот модуль содержит функции для работы с совершенными числами и вычисления их количества
в заданных интервалах. Также реализована функция для расчета суммы F(1, k) для k = 1, 2, ..., n.

Пример использования
--------------------

Пример использования функций для нахождения совершенных чисел и вычисления G(n):

.. code-block:: python

    from src.logger.logger import logger  #  импортируем logger

    n = 10000
    result = calculate_g(n)
    print(f"G({n}) = {result}")
"""

from typing import List
from src.logger.logger import logger # импорт логгера

def is_perfect(n: int) -> bool:
    """
    Проверяет, является ли число совершенным.

    :param n: Проверяемое число.
    :return: True, если число совершенное, иначе False.
    """
    if n <= 1:
        return False
    divisors_sum = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors_sum += i
            if i != n // i:
                divisors_sum += n // i
    return divisors_sum == n

def count_perfect_numbers(a: int, b: int) -> int:
    """
    Подсчитывает количество совершенных чисел в интервале [a, b].

    :param a: Начало интервала.
    :param b: Конец интервала.
    :return: Количество совершенных чисел в заданном интервале.
    """
    count = 0
    for i in range(a, b + 1):
        if is_perfect(i):
            count += 1
    return count

def calculate_g(n: int) -> int:
    """
    Вычисляет сумму F(1, k) для k = 1, 2, ..., n.

    :param n: Верхняя граница диапазона.
    :return: Сумма F(1, k) для k = 1, 2, ..., n.
    """
    total_sum = 0
    for k in range(1, n + 1):
        total_sum += count_perfect_numbers(1, k)
    return total_sum

if __name__ == "__main__":
    # примеры использования
    n_values = [10, 100, 1000, 10000]
    for n in n_values:
        result = calculate_g(n)
        print(f"G({n}) = {result}")

    # расчет G(10^14) - может занять много времени
    try:
       large_n = 10**6 # Изменено на 10**6 для демонстрации
       result_large = calculate_g(large_n)
       print(f"G({large_n}) = {result_large}")
    except Exception as ex:
        logger.error(f"Произошла ошибка при расчете G({10**14})", exc_info=ex)
```