## <алгоритм>

**Функция `md2dict(md_string: str)`:**

1.  **Входные данные:** Строка `md_string` в формате Markdown.
2.  **Попытка извлечения JSON:** Вызывает функцию `extract_json_from_string(md_string)` для поиска JSON-контента в строке.
    *   **Пример:** Если `md_string` содержит `"{'key': 'value'}"`, то `extract_json_from_string` вернет `{'key': 'value'}`.
3.  **Проверка наличия JSON:**
    *   **Если JSON найден:** Функция возвращает словарь `{"json": json_content}` и завершает работу.
        *   **Пример:** Если `json_content` это `{'key': 'value'}`, то функция вернет `{"json": {'key': 'value'}}`.
    *   **Если JSON не найден:** Продолжает обработку Markdown.
4.  **Конвертация Markdown в HTML:** Вызывает функцию `markdown(md_string)` из библиотеки `markdown2` для конвертации Markdown в HTML.
    *   **Пример:** Если `md_string` это `"## Заголовок"`, то `markdown(md_string)` вернет `"<h2>Заголовок</h2>"`.
5.  **Инициализация:** Создает пустой словарь `sections: Dict[str, list] = {}`, который будет хранить структурированный контент, и переменную `current_section = None` для отслеживания текущей секции.
6.  **Разбор HTML:** Разделяет HTML на строки и начинает их обработку в цикле.
    *   **Обработка заголовков:** Если строка начинается с `<h`, это может быть заголовок.
        *   Извлекает уровень заголовка (h1, h2 и т.д.) с помощью регулярного выражения `r'h(\\d)'`.
            *   **Пример:** Для строки `"<h1>Заголовок</h1>"` регулярное выражение выделит `1`.
        *   Извлекает текст заголовка, удаляя HTML-теги.
            *   **Пример:** Для строки `"<h1>Заголовок</h1>"` будет извлечено `"Заголовок"`.
        *   **Если это заголовок h1:** Создает новую секцию в словаре `sections` с заголовком в качестве ключа и пустым списком в качестве значения, обновляет `current_section`.
            *   **Пример:** Если заголовок `"Раздел 1"`, создастся элемент `sections["Раздел 1"] = []`.
        *   **Если это заголовок h2 и выше:** Добавляет текст заголовка в список текущей секции, если `current_section` не равен `None`.
             *   **Пример:** Если `current_section` это `"Раздел 1"`, а текст заголовка `"Подраздел 1"`, то `sections["Раздел 1"].append("Подраздел 1")`.
    *   **Обработка текста:** Если строка не пустая и `current_section` не равен `None`, добавляет текст в список текущей секции.
        *   Удаляет HTML-теги из строки.
             *   **Пример:** Для строки `"<p>Текст</p>"` будет извлечено `"Текст"`.
         *   Добавляет текст в текущую секцию.
            *   **Пример:** Если `current_section` это `"Раздел 1"`, а текст `"Пример текста"`, то `sections["Раздел 1"].append("Пример текста")`.
7.  **Возврат результата:** Возвращает словарь `sections`.
8.  **Обработка ошибок:** В случае возникновения исключения при парсинге, логирует ошибку и возвращает пустой словарь `{}`.

**Функция `extract_json_from_string(text: str)`:**

1.  **Входные данные:** Строка `text`, в которой нужно найти JSON.
2.  **Поиск JSON:** Ищет JSON-строку, используя регулярное выражение `r"\\{.*\\}"`.
    *   **Пример:** Для строки `"Some text {\"key\": \"value\"} more text"` регулярка выделит `{\\"key\\": \\"value\\"}`.
3.  **Извлечение JSON:** Если JSON найден, извлекает его с помощью `json_match.group()`
4.  **Десериализация:** преобразует строку JSON в словарь python с помощью `eval()`.
5.  **Возврат результата:** Возвращает словарь (JSON) если JSON найден, иначе `None`.
6.  **Обработка ошибок:** В случае возникновения исключения при извлечении или десериализации JSON, логирует ошибку и возвращает `None`.

## <mermaid>

```mermaid
graph LR
    A[Начало md2dict] --> B{Извлечь JSON};
    B -- JSON найден --> C{Вернуть {"json": json_content}};
    B -- JSON не найден --> D{Markdown в HTML};
    D --> E{Инициализация словаря sections и current_section};
    E --> F{Разбор HTML по строкам};
    F -- Строка - заголовок h1 --> G{Создать секцию sections[section_title]};
    G --> H{Обновить current_section};
    H --> F;
    F -- Строка - заголовок h2+ --> I{Добавить заголовок в current_section};
    I --> F;
    F -- Строка - текст --> J{Добавить текст в current_section};
    J --> F;
     F -- Конец HTML --> K{Вернуть sections};
    K --> L[Конец md2dict];
    F -- Строка не заголовок не текст --> F
    A --> Z[Начало extract_json_from_string];
    Z --> AA{Поиск JSON по регулярному выражению};
    AA -- JSON найден --> AB{Извлечь JSON};
    AB --> AC{Десериализация JSON в словарь}
    AC --> AD{Вернуть JSON словарь};
    AD --> AE[Конец extract_json_from_string];
    AA -- JSON не найден --> AF{Вернуть None};
    AF --> AE;
    C --> L;
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
     style L fill:#f9f,stroke:#333,stroke-width:2px
    style Z fill:#ccf,stroke:#333,stroke-width:2px
    style AE fill:#ccf,stroke:#333,stroke-width:2px
```

**Разбор `mermaid` диаграммы:**

*   `Начало md2dict` (A): Начало функции `md2dict`.
*   `Извлечь JSON` (B): Вызов функции `extract_json_from_string` для извлечения JSON.
*   `Вернуть {"json": json_content}` (C): Возврат словаря с JSON-контентом.
*   `Markdown в HTML` (D): Конвертация Markdown в HTML.
*   `Инициализация словаря sections и current_section` (E): Создание переменных для хранения данных.
*   `Разбор HTML по строкам` (F): Итерация по строкам HTML.
*   `Создать секцию sections[section_title]` (G): Создание новой секции при нахождении заголовка h1.
*   `Обновить current_section` (H): Обновление текущей секции.
*   `Добавить заголовок в current_section` (I): Добавление заголовка в текущую секцию.
*   `Добавить текст в current_section` (J): Добавление текста в текущую секцию.
*   `Вернуть sections` (K): Возврат словаря со структурированными данными.
*   `Конец md2dict` (L): Конец функции `md2dict`.
*   `Начало extract_json_from_string` (Z): Начало функции `extract_json_from_string`.
*   `Поиск JSON по регулярному выражению` (AA): Поиск JSON в тексте с помощью регулярного выражения.
*   `Извлечь JSON` (AB): Извлечение JSON из найденного фрагмента.
*   `Десериализация JSON в словарь` (AC): Преобразование JSON-строки в словарь Python.
*   `Вернуть JSON словарь` (AD): Возврат JSON-словаря.
*  `Конец extract_json_from_string` (AE): Конец функции `extract_json_from_string`.
*  `Вернуть None` (AF): Возврат None, если JSON не найден.

**Импорты в `mermaid`:**

*   Нет явных импортов библиотек в коде `mermaid`.

## <объяснение>

### Импорты

*   `import re`: Модуль `re` используется для работы с регулярными выражениями. Он применяется для поиска заголовков в HTML (`re.search`) и удаления HTML-тегов (`re.sub`).
*   `from typing import Dict`: Импортирует `Dict` для статической типизации словарей, что повышает читаемость и помогает в отладке кода.
*   `from markdown2 import markdown`: Импортирует функцию `markdown` из библиотеки `markdown2`, которая конвертирует Markdown-текст в HTML.
*   `from src.logger.logger import logger`: Импортирует объект `logger` из модуля `src.logger.logger`, который используется для записи ошибок и отладочной информации. Это часть системы логирования проекта.

### Классы

В данном коде нет классов.

### Функции

1.  **`md2dict(md_string: str) -> Dict[str, dict | list]`**:
    *   **Аргументы:**
        *   `md_string` (str): Строка Markdown для конвертации.
    *   **Возвращаемое значение:**
        *   `Dict[str, dict | list]`: Структурированный словарь, содержащий либо JSON-контент (если он есть), либо структуру разделов Markdown.
    *   **Назначение:** Конвертирует строку Markdown в словарь. Если в строке есть JSON, извлекает его и возвращает в виде словаря `{"json": json_content}`. В противном случае, парсит HTML, полученный из Markdown, и строит словарь со структурой разделов (заголовки и их содержимое).
    *   **Примеры:**
        *   `md2dict("# Заголовок\nТекст")` вернет `{'Заголовок': ['Текст']}`.
        *   `md2dict("{'key': 'value'}")` вернет `{'json': {'key': 'value'}}`.
        *   `md2dict("## Заголовок2\nТекст2")` вернет `{}`.
        *    `md2dict("# Заголовок1\nТекст1\n## Заголовок2\nТекст2")` вернет `{'Заголовок1': ['Текст1', 'Заголовок2','Текст2']}`.
            *   Заголовки h2 и выше добавляются в текущую секцию, как текст.
            *    Заголовок h1 создает новую секцию.
2.  **`extract_json_from_string(text: str) -> dict | None`**:
    *   **Аргументы:**
        *   `text` (str): Строка для поиска JSON-контента.
    *   **Возвращаемое значение:**
        *   `dict | None`: Извлеченный JSON контент в виде словаря, если найден, или `None` в противном случае.
    *   **Назначение:** Извлекает JSON из строки, используя регулярное выражение. Если JSON найден, возвращает его в виде словаря python.
    *   **Примеры:**
        *   `extract_json_from_string("Some text {'key': 'value'} more text")` вернет `{'key': 'value'}`.
        *   `extract_json_from_string("No JSON here")` вернет `None`.

### Переменные

*   ``: Глобальная переменная, определяющая режим работы скрипта.
*   `sections: Dict[str, list]`: Словарь, хранящий структуру Markdown в виде пар "заголовок секции" : "список строк".
*   `current_section: str | None`: Переменная, отслеживающая текущую обрабатываемую секцию.
*   `json_pattern: str`: Регулярное выражение для поиска JSON в тексте.
*   `json_match`: Результат поиска по регулярному выражению.
*   `html: str`: HTML, полученный из Markdown.
*   `heading_level_match`: Результат поиска уровня заголовка.
*   `heading_level: int`: Уровень заголовка.
*    `section_title: str`: Текст заголовка без HTML тегов.
*   `line: str`: Строка HTML.
*   `clean_text: str`: Строка текста без HTML тегов.

### Потенциальные ошибки и области для улучшения

1.  **Безопасность `eval()`**: Использование `eval()` в функции `extract_json_from_string` небезопасно, так как может привести к выполнению произвольного кода, если входящая строка содержит вредоносный код. Вместо `eval` следует использовать `json.loads()`.
2.  **Обработка различных типов контента**: Код обрабатывает только текст и заголовки. Хорошо бы добавить поддержку для списков, таблиц и других элементов Markdown.
3.  **Улучшение разбора HTML**: Парсинг HTML на основе строк может быть хрупким. Использование библиотеки для парсинга HTML, например BeautifulSoup, сделает код более надежным.
4.  **Обработка вложенных секций**: Текущий алгоритм не поддерживает вложенные секции.
5.  **Отсутствие обработки ошибок в функции** `extract_json_from_string`:  Если не найден json по регулярному выражению, возвращается `None`, а не пустой словарь.
6.  **Неоднозначность:** Функция `md2dict` возвращает либо структуру разделов Markdown, либо JSON. Хорошо бы сделать возвращаемую структуру более унифицированной.

### Цепочка взаимосвязей

*   `src.utils.convertors.md2dict` использует `src.logger.logger` для логирования, что является частью системы логирования проекта.
*   Функция `markdown` из библиотеки `markdown2` используется для конвертации Markdown в HTML, эта библиотека импортируется из внешнего проекта.
*   Результаты работы `md2dict` могут использоваться в других частях проекта, где требуется структурированное представление Markdown или JSON, например, для извлечения метаданных из описания задач, или для вывода отчетов.

Таким образом, код `md2dict.py` обеспечивает функциональность конвертации Markdown-текста в структурированный формат (словарь), что может быть использовано в разных частях проекта для обработки и хранения текстовых данных.