## Ответ на Задачу No 279: Треугольники с целыми сторонами, имеющие угол в 60 градусов

### 1. Анализ задачи и решение
**Понимание задачи:**
* Необходимо найти количество треугольников с целыми сторонами `a`, `b`, `c` (где `a ≤ b ≤ c`) и углом в 60 градусов.
* Для таких треугольников выполняется условие: `b² = a² + ac`.
* Максимальная длина стороны `c` не должна превышать 1 000 000 000.

**Решение:**
1. **Преобразование уравнения:**
   Из уравнения `b² = a² + ac` выразим `c`:
   `c = (b² - a²) / a`
   `c = (b - a)(b + a) / a`
   Так как `c` должно быть целым числом, то `(b - a)(b + a)` должно делиться на `a`. Это значит что `b` должен быть равен `k*a`, где `k > 1`. 
   Тогда уравнение принимает вид: 
    `c = (k*a - a)(k*a + a) / a`
    `c = a*(k-1)*a*(k+1) / a`
    `c = a*(k-1)(k+1)`
    `c = a*(k^2-1)`
    Значит: `b = k*a`, и `c = a*(k^2-1)`
    Так как `a <= b <= c`
    `a <= k*a <= a*(k^2-1)`, тогда `1 <= k <= k^2-1` , `k > 1`
    То есть `k` должно быть целым числом большим 1.
2. **Перебор:**
   Мы перебираем значения `a` и `k` для поиска подходящих треугольников.
3. **Условие c <= max_c:**
   Проверяем, что `c` не превышает 1 000 000 000 (max_c).
4. **Подсчет:**
   Подсчитываем количество найденных треугольников.
5. **Оптимизация:**  
   Так как `c = a*(k^2-1)`, a `c <= max_c`, то максимальное значение для `a`  можно определить как `max_c / (k^2 - 1)`, таким образом перебирая `k` от 2, уменьшаем перебор `a`.

### 2. Алгоритм решения
1. Начать.
2. Инициализировать переменную `count` (счетчик треугольников) значением 0.
3. Инициализировать `max_c` = 1 000 000 000.
4. Начать внешний цикл для `k` от 2 до тех пор пока `a*(k^2 - 1) < max_c`.
    * Найти `max_a = max_c / (k^2 - 1)`.
    * Начать внутренний цикл для `a` от 1 до `max_a`.
        * Вычислить `b = k * a`.
        * Вычислить `c = a * (k^2 - 1)`.
        * Увеличить счетчик `count` на 1.
    * Закончить внутренний цикл.
5.  Закончить внешний цикл.
6. Вернуть `count`.
7. Конец.

### 3. Реализация на Python 3.12
```python
def count_triangles_with_60_degree_angle(max_c):
    """
    Counts the number of triangles with integer sides, a 60-degree angle,
    and the longest side not exceeding max_c.

    Args:
      max_c: The maximum length of the longest side.

    Returns:
      The number of such triangles.
    """
    count = 0
    k = 2
    while True:
        max_a = max_c // (k * k - 1)
        if max_a == 0:
            break
        for a in range(1, max_a + 1):
            b = k * a
            c = a * (k * k - 1)
            if c <= max_c:
                count += 1
        k += 1
    return count

# Пример использования:
max_side = 1_000_000_000
result = count_triangles_with_60_degree_angle(max_side)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeCount((Инициализировать счетчик треугольников count = 0))
    InitializeCount --> InitializeMaxC((Инициализировать max_c = 1 000 000 000))
    InitializeMaxC --> InitializeK((Инициализировать k = 2))
    InitializeK --> OuterLoopStart((Начать внешний цикл: while true))
    OuterLoopStart --> CalculateMaxA((Вычислить max_a = max_c / (k^2 - 1)))
    CalculateMaxA --> CheckMaxA((max_a == 0?))
    CheckMaxA -- Да --> OuterLoopEnd((Конец внешнего цикла))
    CheckMaxA -- Нет --> InnerLoopStart((Начать внутренний цикл: for a from 1 to max_a))
    InnerLoopStart --> CalculateB((Вычислить b = k * a))
    CalculateB --> CalculateC((Вычислить c = a * (k^2 - 1)))
     CalculateC --> CheckC((c <= max_c?))
    CheckC -- Да --> IncrementCount((Увеличить count на 1))
    IncrementCount --> InnerLoopStart
    CheckC -- Нет --> InnerLoopStart
    InnerLoopStart --> IncrementK((Увеличить k на 1))
    IncrementK --> OuterLoopStart
    OuterLoopEnd --> ReturnCount((Вернуть count))
    ReturnCount --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать счетчик треугольников:** Создаем переменную `count` для подсчета найденных треугольников и присваиваем ей начальное значение 0.
*   **Инициализировать max_c:** Инициализируем переменную `max_c` максимальным значением длины стороны треугольника (1 000 000 000).
*   **Инициализировать k:** Инициализируем переменную `k` значением 2.
*   **Начать внешний цикл:** Начало цикла while, который работает пока  `max_a` больше 0.
*   **Вычислить max_a:** Вычисляем максимальное значение для стороны `a`.
*   **max_a == 0?**: Проверяем, что `max_a` больше 0.
*    **Конец внешнего цикла:** Завершение цикла while.
*   **Начать внутренний цикл:** Начало цикла перебора значения `a`.
*   **Вычислить b:** Вычисляем значение стороны `b` как `k * a`.
*   **Вычислить c:** Вычисляем значение стороны `c` как `a * (k^2 - 1)`.
*   **c <= max_c?**: Проверяем, что сторона `c` меньше или равна максимальному значению `max_c`.
*   **Увеличить count на 1:** Если условия выполнены, увеличиваем счетчик `count` на 1.
*   **Увеличить k на 1:** Увеличиваем значение `k` на 1 для следующей итерации.
*  **Вернуть count:** Возвращаем общее количество найденных треугольников.
