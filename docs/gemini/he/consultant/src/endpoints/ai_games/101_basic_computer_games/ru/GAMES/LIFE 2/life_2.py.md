# Анализ кода модуля `life_2.py`

**Качество кода**

- **Соблюдение требований к формату кода (1-10):**
    - **Преимущества:**
        - Код хорошо структурирован, разбит на отдельные функции, что делает его читаемым и поддерживаемым.
        - Присутствует подробное описание модуля и функций в виде docstring.
        - Логика игры реализована четко и соответствует правилам игры "Жизнь".
        - Используются осмысленные имена переменных и функций.
        - Есть пояснения к алгоритму в комментариях.
    - **Недостатки:**
        - Не используются `j_loads` или `j_loads_ns` для чтения данных, хотя это требуется.
        - Отсутствует импорт `logger` для обработки ошибок.
        - Не все docstring соответствуют формату reStructuredText (RST).
        - Не используется единый стиль кавычек, как указано в требованиях.
        - Отсутствуют подробные построчные комментарии к измененным частям кода.

**Рекомендации по улучшению**

1.  **Импорт `j_loads_ns` и `logger`:** Добавить импорт `j_loads_ns` из `src.utils.jjson` и `logger` из `src.logger.logger`.
2.  **Обработка ошибок:** Заменить стандартные блоки `try-except` на использование `logger.error` для вывода ошибок.
3.  **Формат docstring:** Переписать все docstring в соответствии с форматом reStructuredText (RST).
4.  **Стиль кавычек:** Использовать только одинарные кавычки (`'`) для строк.
5.  **Построчные комментарии:** Добавить построчные комментарии к измененным частям кода, особенно к тем, где были внесены исправления.

**Улучшенный код**

```python
"""
Модуль LIFE 2:
=================
Сложность: 5
-----------------
Игра "Жизнь 2" - это симуляция клеточного автомата, разработанная Джоном Конвеем.
Она представляет собой поле клеток, каждая из которых может быть либо живой, либо мертвой.
Состояние клетки в следующем поколении зависит от количества живых соседей в текущем поколении.
Игра демонстрирует, как простые правила могут привести к возникновению сложных и интересных паттернов.
Игрок может задавать начальную конфигурацию живых клеток, и наблюдать за эволюцией этой конфигурации с течением времени.

Правила игры:
1. Игровое поле представлено в виде сетки, где каждая клетка может быть либо живой (обозначена как '*'), либо мертвой (обозначена как пробел ' ').
2. В начале игры игроку предлагается ввести количество строк и столбцов для игрового поля, а также количество живых клеток.
3. После ввода начальных параметров поле заполняется мертвыми клетками, а затем случайным образом размещаются живые клетки, количество которых указал игрок.
4. После инициализации поля программа выводит начальное состояние поля.
5. Итерации продолжаются, пока пользователь не введет "0".
6. Для каждого нового поколения:
     - Каждая живая клетка с 2 или 3 живыми соседями остается живой в следующем поколении.
    - Каждая живая клетка с менее чем 2 живыми соседями умирает в следующем поколении.
    - Каждая живая клетка с более чем 3 живыми соседями умирает в следующем поколении.
    - Каждая мертвая клетка рождается в следующем поколении, если у нее ровно 3 живых соседа.
7. Поле отображается после каждой итерации.
-----------------
Алгоритм:
1. Запросить у пользователя количество строк и столбцов для игрового поля.
2. Запросить у пользователя количество начальных живых клеток.
3. Инициализировать игровое поле как матрицу, заполненную мертвыми клетками (' ').
4. Разместить случайным образом указанное пользователем количество живых клеток ('*') на игровом поле.
5. Вывести начальное состояние игрового поля.
6. Запустить бесконечный цикл:
    6.1 Вычислить следующее поколение клеток:
        6.1.1 Создать новое поле, скопировав текущее поле.
        6.1.2 Для каждой клетки в текущем поле:
           6.1.2.1 Подсчитать количество живых соседей.
           6.1.2.2 Применить правила "Жизни", чтобы определить состояние клетки в новом поле.
        6.1.3 Заменить текущее поле новым полем.
    6.2 Вывести текущее состояние игрового поля.
    6.3 Запросить у пользователя ввод. Если введено "0", завершить игру, иначе продолжить.
-----------------

"""
import random
import copy
from src.logger.logger import logger # Добавлен импорт logger
# from src.utils.jjson import j_loads_ns # Предположительно, j_loads_ns не используется в этом коде

def initialize_grid(num_rows: int, num_cols: int) -> list[list[str]]:
    """
    Создает и инициализирует игровое поле (сетку) с мертвыми клетками.

    :param num_rows: Количество строк в сетке.
    :type num_rows: int
    :param num_cols: Количество столбцов в сетке.
    :type num_cols: int
    :return: Игровое поле представленное в виде списка списков.
    :rtype: list[list[str]]
    """
    grid = [[' ' for _ in range(num_cols)] for _ in range(num_rows)] # Инициализация сетки с пробелами
    return grid

def place_alive_cells(grid: list[list[str]], initial_alive_cells: int) -> None:
    """
    Размещает начальные живые клетки на игровом поле случайным образом.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    :param initial_alive_cells: Количество начальных живых клеток.
    :type initial_alive_cells: int
    """
    num_rows = len(grid) # Получение количества строк в сетке
    num_cols = len(grid[0]) # Получение количества столбцов в сетке
    
    placed_cells = 0 # Инициализация счетчика размещенных клеток
    while placed_cells < initial_alive_cells: # Пока не размещены все живые клетки
        row = random.randint(0, num_rows - 1) # Случайный выбор строки
        col = random.randint(0, num_cols - 1) # Случайный выбор столбца
        if grid[row][col] == ' ': # Если клетка мертвая
            grid[row][col] = '*' # Делаем клетку живой
            placed_cells += 1 # Увеличиваем счетчик размещенных клеток

def display_grid(grid: list[list[str]]) -> None:
    """
     Выводит текущее состояние игрового поля на экран.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    """
    for row in grid: # Итерация по строкам сетки
        print(' '.join(row)) # Вывод строки, клетки разделены пробелом
    print() # Пустая строка для разделения поколений

def count_alive_neighbors(grid: list[list[str]], row: int, col: int) -> int:
    """
    Подсчитывает количество живых соседей у клетки.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    :param row: Индекс строки клетки.
    :type row: int
    :param col: Индекс столбца клетки.
    :type col: int
    :return: Количество живых соседей.
    :rtype: int
    """
    num_rows = len(grid) # Получение количества строк в сетке
    num_cols = len(grid[0]) # Получение количества столбцов в сетке
    alive_neighbors = 0 # Инициализация счетчика живых соседей

    for i in range(max(0, row - 1), min(num_rows, row + 2)): # Итерация по соседним строкам
        for j in range(max(0, col - 1), min(num_cols, col + 2)): # Итерация по соседним столбцам
            if (i, j) != (row, col) and grid[i][j] == '*': # Если соседняя клетка живая и не является текущей
                alive_neighbors += 1 # Увеличиваем счетчик живых соседей

    return alive_neighbors

def compute_next_generation(grid: list[list[str]]) -> list[list[str]]:
    """
    Вычисляет следующее поколение клеток на основе текущего состояния поля и правил игры "Жизнь".

    :param grid: Текущее игровое поле.
    :type grid: list[list[str]]
    :return: Новое игровое поле, представляющее следующее поколение.
    :rtype: list[list[str]]
    """
    num_rows = len(grid) # Получение количества строк в сетке
    num_cols = len(grid[0]) # Получение количества столбцов в сетке
    next_grid = copy.deepcopy(grid) # Создание глубокой копии текущего поля
    
    for row in range(num_rows): # Итерация по строкам сетки
        for col in range(num_cols): # Итерация по столбцам сетки
            alive_neighbors = count_alive_neighbors(grid, row, col) # Подсчет живых соседей для текущей клетки
            if grid[row][col] == '*': # Если клетка живая
                if alive_neighbors < 2 or alive_neighbors > 3: # Если у клетки меньше 2 или больше 3 живых соседей
                    next_grid[row][col] = ' ' # Клетка умирает
            else: # Если клетка мертвая
                if alive_neighbors == 3: # Если у клетки ровно 3 живых соседа
                    next_grid[row][col] = '*' # Клетка рождается

    return next_grid
    
# Основная логика игры
if __name__ == "__main__":
    # Запрашиваем у пользователя размер поля
    try:
      num_rows = int(input("Введите количество строк: ")) # Запрос количества строк
      num_cols = int(input("Введите количество столбцов: ")) # Запрос количества столбцов
    except ValueError as e: # Обработка ошибки, если введенное значение не целое число
        logger.error(f'Ошибка при вводе размера поля: {e}') # Вывод ошибки в лог
        exit()
    # Запрашиваем количество начальных живых клеток
    try:
      initial_alive_cells = int(input("Введите количество начальных живых клеток: ")) # Запрос количества живых клеток
    except ValueError as e: # Обработка ошибки, если введенное значение не целое число
        logger.error(f'Ошибка при вводе количества живых клеток: {e}') # Вывод ошибки в лог
        exit()

    # Инициализируем и выводим начальное состояние поля
    grid = initialize_grid(num_rows, num_cols) # Инициализация игрового поля
    place_alive_cells(grid, initial_alive_cells) # Размещение живых клеток
    print("Начальное состояние поля:") # Вывод начального состояния
    display_grid(grid) # Отображение игрового поля

    # Основной игровой цикл
    while True: # Бесконечный цикл
        # Вычисляем следующее поколение
        next_grid = compute_next_generation(grid) # Вычисление следующего поколения
        grid = next_grid # Обновление игрового поля
        # Отображаем новое состояние поля
        display_grid(grid) # Отображение игрового поля

        # Спрашиваем пользователя, хочет ли он продолжить
        user_input = input("Нажмите Enter для продолжения или введите '0' для выхода: ") # Запрос ввода пользователя
        if user_input == '0': # Если введен "0"
            break # Завершение цикла
"""
Объяснение кода:
1.  **Импорт модулей**:
    - ``import random``: Импортирует модуль random для генерации случайных чисел.
    - ``import copy``: Импортирует модуль copy для создания глубоких копий списков.
    - ``from src.logger.logger import logger``: Импортирует логгер для обработки ошибок.
2.  **Функция ``initialize_grid(num_rows, num_cols)``**:
    - Создает и инициализирует игровое поле (сетку) с мертвыми клетками (пробелы).
    - ``num_rows`` (int): Количество строк в сетке.
    - ``num_cols`` (int): Количество столбцов в сетке.
    - Возвращает: список списков (двумерный массив), представляющий игровое поле.
3.  **Функция ``place_alive_cells(grid, initial_alive_cells)``**:
    - Размещает начальные живые клетки ('*') на игровом поле случайным образом.
    - ``grid`` (list of lists): Игровое поле.
    - ``initial_alive_cells`` (int): Количество начальных живых клеток.
4.  **Функция ``display_grid(grid)``**:
    - Выводит текущее состояние игрового поля на экран.
    - ``grid`` (list of lists): Игровое поле.
5.  **Функция ``count_alive_neighbors(grid, row, col)``**:
    - Подсчитывает количество живых соседей у клетки.
    - ``grid`` (list of lists): Игровое поле.
    - ``row`` (int): Индекс строки клетки.
    - ``col`` (int): Индекс столбца клетки.
    - Возвращает: количество живых соседей (int).
6.  **Функция ``compute_next_generation(grid)``**:
    - Вычисляет следующее поколение клеток на основе текущего состояния поля и правил игры "Жизнь".
    - ``grid`` (list of lists): Текущее игровое поле.
    - Возвращает: новое игровое поле (list of lists), представляющее следующее поколение.
    - Делает глубокую копию текущего поля ``next_grid = copy.deepcopy(grid)``
    - Правила игры "Жизнь":
        - Каждая живая клетка с 2 или 3 живыми соседями остается живой.
        - Каждая живая клетка с менее чем 2 живыми соседями умирает.
        - Каждая живая клетка с более чем 3 живыми соседями умирает.
        - Каждая мертвая клетка рождается, если у нее ровно 3 живых соседа.
7. **Основная логика игры (``if __name__ == "__main__":``)**:
    - Запрашивает у пользователя размер поля (количество строк и столбцов) и количество начальных живых клеток.
    - Инициализирует и выводит начальное состояние поля, используя функции ``initialize_grid``, ``place_alive_cells`` и ``display_grid``.
    - Запускает основной игровой цикл ``while True:``.
    - Вычисляет следующее поколение, используя ``compute_next_generation``, и обновляет поле.
    - Отображает текущее состояние поля на экране, используя ``display_grid``.
    - Запрашивает у пользователя ввод для продолжения (любое значение, кроме "0") или для выхода из игры ("0").
    - Если пользователь ввел "0", цикл прерывается и игра завершается.
"""
```