# Анализ кода модуля e_37.md

**Качество кода**
9
-   Плюсы
    -   Код хорошо структурирован и разбит на функции, что облегчает его чтение и понимание.
    -   Используются информативные имена переменных и функций.
    -   Присутствуют docstring для каждой функции, описывающие ее назначение и параметры.
    -   Алгоритм решения задачи подробно описан в тексте перед кодом.
    -   Предоставлена блок-схема алгоритма в формате Mermaid.
-   Минусы
    -   Отсутствуют импорты для `logger`, `j_loads` или `j_loads_ns` из `src.utils.jjson`, если требуется.
    -   Не используется `logger.error` для обработки ошибок, если они возникнут в будущем (хотя их не ожидается).
    -   Комментарии `#` не всегда поясняют последующие строки кода и не используют reStructuredText.
    -   Не используются одинарные кавычки `'` для строк (используются двойные).

**Рекомендации по улучшению**

1.  **Добавить импорты:**  Добавьте `from src.logger.logger import logger` и `from src.utils.jjson import j_loads, j_loads_ns`, если это необходимо в данном контексте.
2.  **Использовать `logger.error`:**  Для потенциальных ошибок (хотя в данном коде ошибок нет) можно добавить обработку ошибок с `logger.error`.
3.  **Комментарии в стиле reStructuredText:** Переписать все комментарии в формате reStructuredText (RST)
4.  **Использовать одинарные кавычки:** Замените все двойные кавычки на одинарные в строковых литералах.
5.  **Добавить комментарии, поясняющие код:**  В блоках кода комментарии `#` должны пояснять, что делает последующая строка кода.

**Оптимизированный код**
```markdown
## Ответ на Задачу No 37: Усекаемые простые числа

### 1. Анализ задачи и решение
**Понимание задачи:**
* Нам необходимо найти 11 усекаемых простых чисел. Усекаемое простое число - это число, которое остается простым при последовательном удалении цифр слева направо и справа налево.
* Числа 2, 3, 5 и 7 не считаются усекаемыми простыми.
* После нахождения этих чисел, необходимо посчитать их сумму.

**Решение:**
1. **Функция проверки простоты:** Создадим функцию `is_prime(number)`, которая проверяет, является ли число простым.
2. **Функция проверки усекаемости:** Создадим функцию `is_truncatable_prime(number)`, которая проверяет, является ли число усекаемым простым.
3. **Поиск усекаемых простых чисел:** Перебираем числа, начиная с 11, и проверяем, является ли число усекаемым простым.
4. **Накопление суммы:** Накапливаем сумму найденных усекаемых простых чисел, пока не найдем 11 таких чисел.
5. **Возврат результата:** Возвращаем накопленную сумму.

### 2. Алгоритм решения
1. Начать
2. Инициализировать переменную `truncatable_primes` как пустой список
3. Инициализировать переменную `current_number` со значением 11
4. Пока количество элементов в `truncatable_primes` меньше 11
   * Если `current_number` является усекаемым простым числом
     * Добавить `current_number` в `truncatable_primes`
   * Увеличить `current_number` на 2 (пропускаем четные числа)
5. Инициализировать переменную `sum_of_primes` со значением 0
6. Для каждого `prime` в `truncatable_primes`
   * Прибавить `prime` к `sum_of_primes`
7. Вернуть `sum_of_primes`
8. Конец

### 3. Реализация на Python 3.12
```python
from math import sqrt
# from src.logger.logger import logger # TODO: Добавить импорт logger, если потребуется
# from src.utils.jjson import j_loads, j_loads_ns # TODO: Добавить импорт j_loads, j_loads_ns если потребуется


def is_prime(number: int) -> bool:
    """
    Проверяет, является ли число простым.

    :param number: Число для проверки.
    :return: True, если число простое, иначе False.
    """
    if number < 2:
        return False
    # Код выполняет перебор делителей от 2 до квадратного корня из числа
    for i in range(2, int(sqrt(number)) + 1):
        # Код выполняет проверку деления числа на делитель без остатка
        if number % i == 0:
            return False
    return True


def is_truncatable_prime(number: int) -> bool:
    """
    Проверяет, является ли число усекаемым простым.

    :param number: Число для проверки.
    :return: True, если число является усекаемым простым, иначе False.
    """
    str_num = str(number)

    # Проверка слева направо
    for i in range(len(str_num)):
        # Код выполняет проверку простоты для усеченного числа слева направо
        if not is_prime(int(str_num[i:])):
            return False

    # Проверка справа налево
    for i in range(len(str_num)):
        # Код выполняет проверку простоты для усеченного числа справа налево
        if not is_prime(int(str_num[:len(str_num)-i])):
             return False
    return True


def find_truncatable_primes_sum(count: int) -> int:
    """
    Находит сумму первых 'count' усекаемых простых чисел.

    :param count: Количество усекаемых простых чисел для поиска.
    :return: Сумма найденных усекаемых простых чисел.
    """
    truncatable_primes = []
    current_number = 11
    # Код выполняет поиск усекаемых простых чисел, пока их количество не достигнет заданного значения
    while len(truncatable_primes) < count:
      # Код выполняет проверку, является ли текущее число усекаемым простым
      if is_truncatable_prime(current_number):
          truncatable_primes.append(current_number)
      # Код увеличивает текущее число на 2, пропуская четные числа
      current_number += 2

    # Код возвращает сумму найденных усекаемых простых чисел
    return sum(truncatable_primes)


# Код выполняет поиск и вывод суммы первых 11 усекаемых простых чисел
result = find_truncatable_primes_sum(11)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializePrimes((Инициализировать truncatable_primes = []))
    InitializePrimes --> InitializeNumber((Инициализировать current_number = 11))
    InitializeNumber --> LoopStart((Начать цикл: пока len(truncatable_primes) < 11))
    LoopStart --> CheckTruncatablePrime((Проверить: current_number является усекаемым простым?))
    CheckTruncatablePrime -- Да --> AddToPrimes((Добавить current_number в truncatable_primes))
    AddToPrimes --> IncrementNumber((current_number = current_number + 2))
    CheckTruncatablePrime -- Нет --> IncrementNumber
    IncrementNumber --> LoopStart
    LoopStart --> InitializeSum((Инициализировать sum_of_primes = 0))
    InitializeSum --> SumLoopStart((Начать цикл: для каждого prime в truncatable_primes))
    SumLoopStart --> AddPrimeToSum((Добавить prime к sum_of_primes))
    AddPrimeToSum --> SumLoopStart
    SumLoopStart --> Output((Вернуть sum_of_primes))
    Output --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать truncatable_primes:** Создаем пустой список для хранения найденных усекаемых простых чисел.
* **Инициализировать current_number:** Инициализируем переменную, которая будет проверятся на усекаемость и простоту.
* **Начать цикл (пока len(truncatable_primes) < 11):**  Цикл поиска усекаемых простых чисел до тех пор, пока их количество не станет равным 11.
* **Проверить: current_number является усекаемым простым?**: Проверяем, является ли текущее число усекаемым простым.
* **Добавить current_number в truncatable_primes:** Если текущее число является усекаемым простым, добавляем его в список.
* **current_number = current_number + 2:**  Увеличиваем текущее число на 2 (пропускаем четные числа).
* **Инициализировать sum_of_primes:** Создаем переменную для хранения суммы усекаемых простых чисел и присваиваем ей значение 0.
* **Начать цикл (для каждого prime в truncatable_primes):**  Цикл для суммирования всех элементов в списке усекаемых простых чисел.
* **Добавить prime к sum_of_primes:** Добавляем каждое усекаемое простое число к общей сумме.
* **Вернуть sum_of_primes:** Возвращаем полученную сумму.
```