# Модуль `src.utils.convertors.any`

## Обзор

Модуль предоставляет утилиты для преобразования данных из различных типов в словари и другие структуры данных Python. Это полезно для обработки данных, полученных из разных источников, и приведения их к единому формату.

## Подробнее

Модуль содержит функцию `any2dict`, которая рекурсивно преобразует любой тип данных в словарь. Это позволяет унифицировать представление данных, независимо от их исходного типа. Функция обрабатывает различные типы данных, такие как списки, множества, числа, строки, булевы значения и `None`, а также пользовательские классы и объекты `SimpleNamespace`.

## Функции

### `any2dict`

```python
def any2dict(any_data: Any) -> dict | list | Any | bool:
    """
    Рекурсивно преобразует любой тип данных в словарь.

    Args:
        any_data: Любой тип данных.

    Returns:
        Словарь, представляющий входные данные, список или исходное значение,
        или False, если преобразование невозможно.
    """
```

**Назначение**: Рекурсивное преобразование любого типа данных в словарь.

**Параметры**:
- `any_data` (Any): Данные любого типа, которые необходимо преобразовать.

**Возвращает**:
- `dict | list | Any | bool`: Словарь, представляющий входные данные, список или исходное значение, или `False`, если преобразование невозможно.

**Как работает функция**:

1.  **Проверка типа данных**: Функция проверяет, является ли входной аргумент `any_data` одним из базовых типов (set, list, int, float, str, bool, type(None)).

2.  **Обработка объектов и словарей**:
    *   Если `any_data` не является базовым типом, функция пытается получить его атрибуты через `__dict__`, если таковые имеются. Если `any_data` является словарем, то его элементы напрямую используются.
    *   Если атрибуты не получены, функция возвращает `False`.

3.  **Рекурсивное преобразование**:
    *   Для каждого элемента (ключ-значение) в полученных атрибутах или словаре, функция рекурсивно вызывает саму себя (`any2dict`) для преобразования ключа и значения.
    *   Если преобразование ключа возвращает `False`, элемент не добавляется в результирующий словарь. Преобразованное значение (или пустая строка, если преобразование значения вернуло `False`) присваивается преобразованному ключу.

4.  **Обработка списков и кортежей**:
    *   Если `any_data` является списком или кортежем, функция создает новый список.
    *   Для каждого элемента в списке или кортеже, функция рекурсивно вызывает `any2dict`.
    *   Если преобразование элемента возвращает `False`, в результирующий список добавляется пустая строка. В противном случае добавляется преобразованный элемент.

5.  **Обработка множеств**:
    *   Если `any_data` является множеством, функция создает новый список.
    *   Для каждого элемента в множестве, функция рекурсивно вызывает `any2dict`.
    *   Если преобразование элемента возвращает `False`, в результирующий список добавляется пустая строка. В противном случае добавляется преобразованный элемент.

6.  **Обработка базовых типов**:
    *   Если `any_data` является одним из базовых типов (int, float, str, bool, type(None)), функция возвращает его без изменений.

7.  **Неподдерживаемые типы**:
    *   Если `any_data` имеет неподдерживаемый тип, функция возвращает `False`.

**ASCII flowchart**:

```
    Начало
    │
    ├── Проверка типа данных (базовый, list/tuple, set, dict/object)
    │
    ├── Базовый тип: Возврат значения
    │
    ├── List/Tuple:
    │   │
    │   └── Создание нового списка
    │   │
    │   └── Для каждого элемента:
    │       │
    │       └── Рекурсивный вызов any2dict
    │       │
    │       └── Добавление преобразованного элемента в новый список (или "" если False)
    │   │
    │   └── Возврат нового списка
    │
    ├── Set:
    │   │
    │   └── Создание нового списка
    │   │
    │   └── Для каждого элемента:
    │       │
    │       └── Рекурсивный вызов any2dict
    │       │
    │       └── Добавление преобразованного элемента в новый список (или "" если False)
    │   │
    │   └── Возврат нового списка
    │
    ├── Dict/Object:
    │   │
    │   └── Получение атрибутов (__dict__) или элементов (dict)
    │   │
    │   └── Если атрибуты/элементы отсутствуют: Возврат False
    │   │
    │   └── Создание нового словаря
    │   │
    │   └── Для каждой пары ключ-значение:
    │       │
    │       └── Рекурсивный вызов any2dict для ключа и значения
    │       │
    │       └── Если преобразование ключа успешно:
    │           │
    │           └── Добавление пары в новый словарь (или "" если преобразование значения вернуло False)
    │   │
    │   └── Возврат нового словаря
    │
    └── Неподдерживаемый тип: Возврат False
    │
    Конец
```

**Примеры**:

```python
import types

data1 = {
    "name": "John",
    "age": 30,
    "address": {
        "city": "New York",
        "street": "Main St",
        "numbers": [1, 2, 3]
    },
   "phones": ["123-456-7890", "987-654-3210"],
   "skills": {"python", "java", "c++"}
}

print(any2dict(data1))
# Вывод: {'name': 'John', 'age': 30, 'address': {'city': 'New York', 'street': 'Main St', 'numbers': [1, 2, 3]}, 'phones': ['123-456-7890', '987-654-3210'], 'skills': ['python', 'java', 'c++']}

data2 = [1, 2, "three", {"key": "value"}]
print(any2dict(data2))
# Вывод: [1, 2, 'three', {'key': 'value'}]

data3 = 123
print(any2dict(data3))
# Вывод: 123

data4 = "string"
print(any2dict(data4))
# Вывод: string

data5 = None
print(any2dict(data5))
# Вывод: None

class MyClass:
    def __init__(self, x):
        self.x = x

data6 = MyClass(10)
print(any2dict(data6))
# Вывод: {}

# Тестируем SimpleNamespace
data7 = types.SimpleNamespace(a=1, b='hello', c=[1,2,3])
print(any2dict(data7))
# Вывод: {'a': 1, 'b': 'hello', 'c': [1, 2, 3]}

data8 = {'a':1, 'b': types.SimpleNamespace(x=2, y=3)}
print(any2dict(data8))
# Вывод: {'a': 1, 'b': {'x': 2, 'y': 3}}

data9 = [types.SimpleNamespace(x=2), 3, 'str']
print(any2dict(data9))
# Вывод: [{'x': 2}, 3, 'str']

data10 = types.SimpleNamespace(a=1, b=MyClass(3))
print(any2dict(data10))
# Вывод: {'a': 1, 'b': ''}

data11 = {"a":1, "b": MyClass(10)}
print(any2dict(data11))
# Вывод: {'a': 1, 'b': ''}