# Анализ кода модуля `gomoko.py`

**Качество кода**
    
-  **Соответствие требованиям к формату кода (1-10):**
     -  **Плюсы:**
        - Код написан на языке Python.
        -  Имеется подробное описание игры, алгоритма и блок-схемы на русском языке.
        -  Код структурирован и разделен на логические блоки (инициализация, функции, игровой цикл).
        -  Код содержит комментарии, описывающие его функциональность.
        -  Функции и переменные имеют достаточно понятные названия.
     -  **Минусы:**
         -  Не используются docstrings для описания функций и модуля в целом.
         -  Отсутствует обработка исключений при некорректном вводе пользователя (кроме ValueError).
         -  Используется стандартный `print` для вывода информации, что не подходит для логирования.
         -  Не используются константы для размеров игрового поля, символов игроков и т.д., что затрудняет модификацию кода.
         -  Не используется проверка на корректность ввода координат пользователем (проверка на целые числа есть, но нет проверки на выход за границы поля).
         -  Отсутствует импорт логгера.
         -  Код не соответствует требованиям к формату документации reStructuredText (RST).
         -  Не использованы `j_loads` или `j_loads_ns` для загрузки данных (в коде нет работы с файлами, но необходимо отметить это).

**Рекомендации по улучшению**

1.  **Документация:**
    -   Добавить docstrings в формате reStructuredText (RST) для модуля, функций и переменных.
    -   Использовать rST-разметку для более подробного описания модуля, функций, параметров и возвращаемых значений.
2.  **Логирование:**
    -   Импортировать `logger` из `src.logger.logger`.
    -   Заменить `print` на `logger.info`, `logger.error` для вывода информации и ошибок.
    -   Внедрить обработку ошибок в `try-except` блоках, использовать `logger.error` для регистрации исключений.
3.  **Обработка ввода:**
    -  Добавить проверку на корректность ввода координат пользователем (не только на целые числа, но и на выход за границы поля).
    -  Использовать `try-except` для обработки исключений, связанных с вводом.
4.  **Константы:**
    -   Определить константы для размеров игрового поля (например, `BOARD_SIZE = 15`), символов игроков (например, `PLAYER_X = 'X'`, `PLAYER_O = 'O'`) и т. д. Это повысит читаемость и модифицируемость кода.
5.  **Проверка на победу:**
    -  Можно упростить проверки на победу, возможно, с помощью вспомогательных функций.
6.  **Функциональное разделение:**
     - Разбить логику игры на более мелкие и переиспользуемые функции.
7.  **Улучшение алгоритма:**
    -  Можно улучшить алгоритм хода компьютера, например, использовать минимаксный алгоритм, или его упрощенный вариант, вместо случайного хода.

**Улучшенный код**
```python
"""
Модуль для реализации игры Гомоку (Пять в ряд)
=========================================================================================

В этом модуле реализована консольная версия игры Гомоку. Игроки по очереди
ставят свои фишки (X и O) на игровое поле 15x15, пытаясь выстроить непрерывную
линию из пяти своих фишек по горизонтали, вертикали или диагонали.

Правила игры:
1. Игра проходит на доске 15x15.
2. Игроки ходят по очереди, ставя свои фишки ('X' для первого игрока, 'O' для второго).
3. Цель игры - первым выстроить линию из пяти своих фишек.
4. Игра заканчивается победой одного из игроков или ничьей, если доска полностью заполнена.

Пример использования:
--------------------

.. code-block:: python

   python gomoko.py

"""
import random  # Импортируем модуль random для выбора случайного хода компьютера
from src.logger.logger import logger  # Импортируем logger для логирования
from typing import List # Импорт типа List

# Константы для размеров доски и символов игроков
BOARD_SIZE = 15  # Размер игрового поля
PLAYER_X = 'X'  # Символ первого игрока
PLAYER_O = 'O'  # Символ второго игрока
EMPTY_CELL = ' ' # Символ пустой ячейки


# 1. Инициализация:
# 1.1. Создаем пустую доску 15x15
board: List[List[str]] = [[EMPTY_CELL for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)] # Используем константу EMPTY_CELL # Типизация board
# 1.2. Устанавливаем флаг начала игры G = 1
game_on = True
# 1.3. Устанавливаем флаг игрока, P = 1 (игрок 1 ходит первым)
current_player = 1


def print_board(board: List[List[str]]) -> None:
    """
    Выводит текущее состояние игрового поля в консоль.

    :param board: Игровое поле, представленное в виде списка списков строк.
    :return: None
    """
    print("   ", end="")
    for i in range(BOARD_SIZE): # Используем константу BOARD_SIZE
         print(f"{i:2}", end=" ")
    print()
    print("  " + "----" * BOARD_SIZE) # Используем константу BOARD_SIZE
    for i, row in enumerate(board):
        print(f"{i:2}|", end=" ")
        for cell in row:
            print(f"{cell:2}", end=" ")
        print()
    print()


def check_line(board: List[List[str]], row: int, col: int, row_step: int, col_step: int, symbol: str) -> bool:
    """
    Проверяет наличие линии из пяти фишек в заданном направлении.

    :param board: Игровое поле.
    :param row: Начальная строка.
    :param col: Начальный столбец.
    :param row_step: Шаг по строкам.
    :param col_step: Шаг по столбцам.
    :param symbol: Символ игрока ('X' или 'O').
    :return: True, если есть линия из пяти фишек, иначе False.
    """
    try:
        return all(board[row + i * row_step][col + i * col_step] == symbol for i in range(5))
    except IndexError:
        return False # Если вышли за границы доски, то линии нет


def check_winner(board: List[List[str]], player: int) -> bool:
    """
    Проверяет наличие победителя на игровом поле.

    :param board: Игровое поле.
    :param player: Номер игрока (1 или 2).
    :return: True, если победитель найден, иначе False.
    """
    symbol = PLAYER_X if player == 1 else PLAYER_O # Используем константы PLAYER_X и PLAYER_O
    # Проверка горизонтальных линий
    for row in range(BOARD_SIZE): # Используем константу BOARD_SIZE
        for col in range(BOARD_SIZE - 4): # Используем константу BOARD_SIZE
           if check_line(board, row, col, 0, 1, symbol):
               return True
    # Проверка вертикальных линий
    for row in range(BOARD_SIZE - 4): # Используем константу BOARD_SIZE
        for col in range(BOARD_SIZE): # Используем константу BOARD_SIZE
           if check_line(board, row, col, 1, 0, symbol):
              return True
    # Проверка диагоналей (сверху-слева направо-вниз)
    for row in range(BOARD_SIZE - 4): # Используем константу BOARD_SIZE
        for col in range(BOARD_SIZE - 4): # Используем константу BOARD_SIZE
            if check_line(board, row, col, 1, 1, symbol):
                return True
    # Проверка диагоналей (сверху-справа налево-вниз)
    for row in range(BOARD_SIZE - 4): # Используем константу BOARD_SIZE
        for col in range(4, BOARD_SIZE): # Используем константу BOARD_SIZE
           if check_line(board, row, col, 1, -1, symbol):
                return True

    return False


def check_full_board(board: List[List[str]]) -> bool:
    """
    Проверяет, заполнено ли игровое поле (нет пустых ячеек).

    :param board: Игровое поле.
    :return: True, если поле заполнено, иначе False.
    """
    return all(cell != EMPTY_CELL for row in board for cell in row) # Используем константу EMPTY_CELL

# 2. Основной игровой цикл
while game_on:
    # 2.1. Выводим текущее состояние доски
    print_board(board)

    # 2.2. Ход игрока (P = 1)
    if current_player == 1:
        while True:
             try:
                # 2.2.1. Запрашиваем координаты хода X, Y
                x = int(input(f"Игрок 1 ({PLAYER_X}) введите x (0-{BOARD_SIZE - 1}): ")) # Используем константу BOARD_SIZE
                y = int(input(f"Игрок 1 ({PLAYER_X}) введите y (0-{BOARD_SIZE - 1}): ")) # Используем константу BOARD_SIZE

                # 2.2.2. Проверяем допустимость хода:
                if 0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board[x][y] == EMPTY_CELL: # Используем константу BOARD_SIZE и EMPTY_CELL
                    # 2.2.3. Ставим на доску символ хода текущего игрока (X)
                    board[x][y] = PLAYER_X # Используем константу PLAYER_X
                    break
                else:
                     logger.error("Недопустимый ход. Попробуйте еще раз.") # Используем logger
             except ValueError:
                 logger.error("Некорректный ввод. Пожалуйста, введите целые числа") # Используем logger
             except Exception as e:
                 logger.error(f"Произошла ошибка при вводе: {e}", exc_info=True) # Используем logger
        # 2.2.4. Меняем флаг игрока
        current_player = 2
    # 2.3. Ход компьютера (P = 2)
    else:
        logger.info("Ход компьютера:")  # Используем logger
        while True:
            # 2.3.1. Компьютер выбирает случайный ход
            x = random.randint(0, BOARD_SIZE - 1) # Используем константу BOARD_SIZE
            y = random.randint(0, BOARD_SIZE - 1) # Используем константу BOARD_SIZE
            if board[x][y] == EMPTY_CELL: # Используем константу EMPTY_CELL
                 # 2.3.2. Ставим на доску символ хода текущего игрока (O)
                board[x][y] = PLAYER_O # Используем константу PLAYER_O
                break

        # 2.3.3. Меняем флаг игрока
        current_player = 1

    # 2.4. Проверка на победителя или ничью
    if check_winner(board, 1 if current_player == 2 else 2 ):
        print_board(board)
        logger.info(f"Победил игрок {'1 (X)' if current_player == 2 else '2 (O)'}!") # Используем logger
        game_on = False  # Завершаем игру
    elif check_full_board(board):
         print_board(board)
         logger.info("Ничья!") # Используем logger
         game_on = False  # Завершаем игру

"""
Объяснение кода:
1. **Инициализация**:
    -  `board = [[EMPTY_CELL for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]`: Создает игровое поле 15x15, заполненное пробелами (пустые ячейки).
    - `game_on = True`: Устанавливает флаг, сигнализирующий, что игра продолжается.
    - `current_player = 1`: Устанавливает текущего игрока на первого (игрок 1).

2. **Функция `print_board(board)`**:
    -  Выводит текущее состояние игрового поля в консоль. Нумерация строк и столбцов для удобства.

3.  **Функция `check_line(board, row, col, row_step, col_step, symbol)`**:
    - Проверяет наличие линии из пяти фишек в заданном направлении.
    - `board`: Игровое поле.
    - `row`: Начальная строка.
    - `col`: Начальный столбец.
    - `row_step`: Шаг по строкам.
    - `col_step`: Шаг по столбцам.
    - `symbol`: Символ игрока ('X' или 'O').
    - Возвращает `True`, если есть линия из пяти фишек, иначе `False`.
    - Ловит исключения `IndexError` для избежания ошибок при выходе за границы доски.

4. **Функция `check_winner(board, player)`**:
    -  Проверяет, есть ли победитель.
    -  Символ текущего игрока ('X' для игрока 1, 'O' для игрока 2).
    -  Вызывает `check_line` для проверки горизонтальных, вертикальных и обе диагональные линии на наличие пяти подряд идущих символов.
    - Возвращает `True`, если победитель найден, иначе `False`.

5.  **Функция `check_full_board(board)`**:
    - Проверяет, заполнено ли игровое поле.
    - Возвращает `True`, если нет пустых клеток, иначе `False`.

6. **Основной цикл игры `while game_on:`**:
    -  Продолжается, пока `game_on` равно `True`.
    -  Выводит текущую доску.
    -  **Ход игрока**:
        -  Если `current_player` равен 1, то это ход первого игрока.
        -  Запрашивает ввод координат x и y.
        -  Проверяет, что координаты в допустимых пределах и ячейка пуста. Если нет, повторяет запрос.
        -  Устанавливает символ 'X' в выбранную ячейку.
        -  Переключает текущего игрока на второго (`current_player = 2`).
    -  **Ход компьютера**:
        -  Если `current_player` равен 2, то это ход компьютера.
        -  Компьютер выбирает случайные координаты x и y.
        -  Проверяет, что ячейка не занята.
        -  Устанавливает символ 'O' в выбранную ячейку.
        -  Переключает текущего игрока на первого (`current_player = 1`).
    -  **Проверка на победу или ничью**:
        -  Вызывает `check_winner()` для проверки наличия победителя, и если он есть выводит на консоль сообщение о победе, и устанавливает `game_on` в `False`.
        -  Вызывает `check_full_board()` для проверки, заполнено ли поле. Если поле заполнено, то выводит сообщение о ничьей и завершает игру.

"""
```