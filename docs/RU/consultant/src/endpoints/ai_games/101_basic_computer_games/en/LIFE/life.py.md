# Анализ кода модуля `life.py`

**Качество кода**
9
 -  Плюсы
    - Код хорошо структурирован, разбит на логические функции, что упрощает понимание и поддержку.
    - Присутствует подробная документация в виде docstring для каждой функции, что соответствует требованиям.
    - Имеется блок-схема, описывающая алгоритм работы программы.
    - Логика игры "Жизнь" реализована корректно в соответствии с правилами.
 -  Минусы
    - Отсутствует обработка ошибок, связанных с неправильным форматом ввода начальной конфигурации (например, если вводятся символы, отличные от '*' и ' ', или длина строки не соответствует ожидаемой).
    - Не используется `j_loads` или `j_loads_ns` из `src.utils.jjson`, что является нарушением инструкции.
    - Не используется логирование ошибок через `src.logger.logger import logger`.
    - В цикле игры используется `time.sleep(0.5)`, что замедляет выполнение без явной необходимости.
    - Не все комментарии соответствуют стандарту RST.
    - Код использует `print` для вывода, что может быть менее гибко, чем логирование.

**Рекомендации по улучшению**

1. **Обработка ошибок ввода**: 
   - Добавить обработку `ValueError` и других исключений при вводе начальной конфигурации. 
   - Проверять, что вводимые строки имеют правильную длину и содержат только допустимые символы.
   - Добавить логирование ошибок ввода с помощью `logger.error`.
2. **Использование `j_loads`**: 
   - Поскольку в этом коде нет работы с файлами, то этот пункт не применим. Но в будущих реализациях обязательно нужно использовать `j_loads` или `j_loads_ns` для чтения файлов.
3.  **Логирование ошибок**:
   -  Использовать `logger.error` вместо `print` для вывода сообщений об ошибках и исключениях.
4.  **Удаление `time.sleep`**:
   -  Убрать `time.sleep` из цикла, если это не требуется для конкретного варианта использования. 
5.  **Улучшение документации**:
   -  Переписать все комментарии в формате reStructuredText (RST).
   -  Дополнить документацию модуля, если это необходимо.
6.  **Улучшение форматирования кода**:
   -  Добавить пустые строки между блоками кода для улучшения читаемости.
7. **Дополнительно**:
    - Можно добавить возможность сохранения начальной конфигурации и финального состояния в файл.

**Оптимизированный код**

```python
"""
Модуль для симуляции игры "Жизнь"
=========================================================================================

Этот модуль реализует игру "Жизнь" - клеточный автомат, разработанный Джоном Конвеем.
Игровое поле представляет собой сетку из клеток, которые могут быть "живыми" или "мертвыми".
Состояние каждой клетки в следующем поколении зависит от состояния ее соседей в текущем поколении.

Правила игры:
    1.  Игровое поле состоит из клеток, каждая из которых может быть "живой" (обозначено символом "*") или "мертвой" (обозначено пробелом).
    2.  Изначально поле заполняется случайным образом или задается определенная конфигурация клеток.
    3.  Переход к следующему поколению осуществляется по следующим правилам:
        -  Живая клетка с менее чем двумя живыми соседями умирает от одиночества.
        -  Живая клетка с двумя или тремя живыми соседями выживает в следующем поколении.
        -  Живая клетка с более чем тремя живыми соседями умирает от перенаселения.
        -  Мертвая клетка с ровно тремя живыми соседями оживает.
    4.  Игра продолжается заданное количество поколений.

Пример использования
--------------------

Пример запуска игры "Жизнь":

.. code-block:: python

    play_game_of_life()
"""
import random
#  Импортируем модуль random для генерации случайных чисел.
# import time
#  Импортируем модуль time для добавления задержки между поколениями.
from src.logger.logger import logger
#  Импортируем logger для логирования ошибок.

def get_grid_size() -> tuple[int, int]:
    """
    Запрашивает у пользователя размеры сетки.

    :return: Кортеж, содержащий количество строк и столбцов.
    :rtype: tuple[int, int]
    
    :raises ValueError: Если введены некорректные данные (не целое число или неположительное значение).
    """
    while True:
        try:
            rows = int(input("Введите количество строк: "))
            cols = int(input("Введите количество столбцов: "))
            if rows > 0 and cols > 0:
                return rows, cols
            else:
                print("Пожалуйста, введите положительные значения для строк и столбцов.")
        except ValueError as e:
           logger.error("Ошибка при вводе размера сетки.", exc_info=True)
           print("Пожалуйста, введите целое число.")

def get_generations() -> int:
    """
    Запрашивает у пользователя количество поколений.
    
    :return: Количество поколений для симуляции.
    :rtype: int

    :raises ValueError: Если введено не целое число или неположительное значение.
    """
    while True:
        try:
            generations = int(input("Введите количество поколений: "))
            if generations > 0:
                return generations
            else:
                print("Пожалуйста, введите положительное количество поколений.")
        except ValueError as e:
            logger.error("Ошибка при вводе количества поколений.", exc_info=True)
            print("Пожалуйста, введите целое число.")


def get_initial_config(rows: int, cols: int) -> list[str]:
    """
    Запрашивает у пользователя ввод начальной конфигурации или использует случайную.

    :param rows: Количество строк в сетке.
    :type rows: int
    :param cols: Количество столбцов в сетке.
    :type cols: int
    :return: Список строк, представляющих начальную конфигурацию.
    :rtype: list[str]
    """
    use_random = input("Использовать случайную конфигурацию (y/n)? ").lower()
    if use_random != 'y':
        print("Введите начальную конфигурацию, используя '*' для живых клеток и ' ' для мертвых.")
        print("Введите каждую строку отдельно:")
        initial_config = []
        for _ in range(rows):
            while True:
                row_input = input()
                if len(row_input) == cols and all(cell in ['*', ' '] for cell in row_input):
                    initial_config.append(row_input)
                    break
                else:
                    logger.error(f"Неверный ввод начальной конфигурации: {row_input=}. Ожидается строка длиной {cols} символов '*' или ' '")
                    print(f"Неверный ввод. Введите строку длиной {cols} символов '*' или ' '")
        return initial_config
    else:
        return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]


def create_grid(rows: int, cols: int, initial_config: list[str] = None) -> list[list[str]]:
    """
    Создает сетку на основе заданных размеров и начальной конфигурации.
    
    :param rows: Количество строк в сетке.
    :type rows: int
    :param cols: Количество столбцов в сетке.
    :type cols: int
    :param initial_config: Начальная конфигурация сетки, defaults to None
    :type initial_config: list[str], optional
    :return: Сетка, представляющая собой список списков символов.
    :rtype: list[list[str]]
    """
    if initial_config:
        return [list(row) for row in initial_config]
    else:
        return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]


def print_grid(grid: list[list[str]]):
    """
    Выводит сетку на экран.
    
    :param grid: Сетка для вывода.
    :type grid: list[list[str]]
    """
    for row in grid:
        print(''.join(row))
    print("-" * len(grid[0]))


def count_live_neighbours(grid: list[list[str]], row: int, col: int) -> int:
    """
    Подсчитывает количество живых соседей для заданной клетки.
    
    :param grid: Игровая сетка.
    :type grid: list[list[str]]
    :param row: Строка клетки.
    :type row: int
    :param col: Столбец клетки.
    :type col: int
    :return: Количество живых соседей.
    :rtype: int
    """
    rows = len(grid)
    cols = len(grid[0])
    count = 0
    for i in range(max(0, row - 1), min(rows, row + 2)):
        for j in range(max(0, col - 1), min(cols, col + 2)):
            if (i, j) != (row, col) and grid[i][j] == '*':
                count += 1
    return count


def apply_rules(grid: list[list[str]], row: int, col: int) -> str:
    """
    Применяет правила игры "Жизнь" для определения состояния клетки в следующем поколении.
    
    :param grid: Игровая сетка.
    :type grid: list[list[str]]
    :param row: Строка клетки.
    :type row: int
    :param col: Столбец клетки.
    :type col: int
    :return: Новое состояние клетки ('*' или ' ').
    :rtype: str
    """
    live_neighbours = count_live_neighbours(grid, row, col)
    if grid[row][col] == '*':
        if live_neighbours < 2 or live_neighbours > 3:
            return ' '  # Клетка умирает
        else:
            return '*'  # Клетка выживает
    else:
        if live_neighbours == 3:
            return '*'  # Клетка оживает
        else:
            return ' '  # Клетка остается мертвой


def next_generation(grid: list[list[str]]) -> list[list[str]]:
    """
    Создает следующее поколение сетки.
    
    :param grid: Текущая игровая сетка.
    :type grid: list[list[str]]
    :return: Новая игровая сетка, представляющая следующее поколение.
    :rtype: list[list[str]]
    """
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [[' ' for _ in range(cols)] for _ in range(rows)]
    for row in range(rows):
        for col in range(cols):
            new_grid[row][col] = apply_rules(grid, row, col)
    return new_grid


def play_game_of_life():
    """
    Основная функция, управляющая симуляцией игры "Жизнь".
    """
    rows, cols = get_grid_size()
    #  Запрос размера сетки у пользователя.
    generations = get_generations()
    #  Запрос количества поколений у пользователя.
    initial_config = get_initial_config(rows, cols)
    #  Запрос начальной конфигурации у пользователя
    grid = create_grid(rows, cols, initial_config)
    #  Создание игровой сетки.

    for generation in range(generations):
        print(f"Поколение: {generation + 1}")
        print_grid(grid)
        grid = next_generation(grid)
        # time.sleep(0.5) # Удаляем задержку, если она не требуется

    print("Симуляция завершена")
    print("Финальное состояние поля:")
    print_grid(grid)

if __name__ == "__main__":
    play_game_of_life()
"""
Объяснение кода:
1. **Импорт модулей**:
    -   `import random`: Импортирует модуль `random` для генерации случайных чисел.
    -   `import time`: Импортирует модуль `time` для добавления задержки между поколениями. # Удалено в оптимизированном коде
    -   `from src.logger.logger import logger`: Импортирует логгер для логирования ошибок.
2.  **Функция `get_grid_size()`**:
    - Запрашивает у пользователя размеры сетки (количество строк и столбцов), проверяя корректность ввода.
    - Возвращает кортеж `rows, cols` целых чисел.
3.  **Функция `get_generations()`**:
    - Запрашивает у пользователя количество поколений для симуляции, проверяя корректность ввода.
    - Возвращает целое число `generations`.
4.  **Функция `get_initial_config(rows, cols)`**:
    - Запрашивает у пользователя, использовать ли случайную начальную конфигурацию или ввести свою.
    - Если пользователь не выбирает случайную конфигурацию, то запрашивает начальную конфигурацию, построчно, проверяя корректность ввода.
    - Если пользователь выбирает случайную, то возвращает случайную начальную конфигурацию.
    - Возвращает список строк (начальная конфигурация).
5. **Функция `create_grid(rows, cols, initial_config=None)`**:
    -   Создает и возвращает сетку (список списков) на основе заданных размеров `rows`, `cols` и начальной конфигурации `initial_config`.
    -   Если `initial_config` предоставлена, использует её для создания сетки.
    -   Если `initial_config` не предоставлена, генерирует случайную сетку, где каждая клетка имеет 50% шанс быть живой (`'*'`) или мертвой (`' '`).
6. **Функция `print_grid(grid)`**:
    -   Выводит текущую сетку на экран.
    -   Каждая строка сетки выводится на отдельной строке, а также добавляется разделительная линия.
7. **Функция `count_live_neighbours(grid, row, col)`**:
    -   Подсчитывает количество живых соседей у клетки с координатами `row` и `col` в сетке `grid`.
    -   Соседями считаются все клетки, прилегающие к данной клетке по горизонтали, вертикали и диагонали.
    -   Возвращает целое число - количество живых соседей.
8. **Функция `apply_rules(grid, row, col)`**:
    - Применяет правила игры "Жизнь" для клетки с координатами `row` и `col`.
    - Возвращает '*' если клетка должна быть живой, и ' ' если клетка должна быть мертвой.
    -   Возвращает новое состояние клетки.
9. **Функция `next_generation(grid)`**:
    - Создает и возвращает сетку следующего поколения на основе текущей сетки.
    - Применяет функцию apply_rules к каждой клетке.
    -   Создает новую сетку (список списков) и применяет правила игры для определения состояния каждой клетки в следующем поколении.
10. **Функция `play_game_of_life()`**:
    - Основная функция, управляющая симуляцией игры "Жизнь".
    - Вызывает функции get_grid_size(), get_generations() и create_grid() для инициализации игры.
    - В цикле for выводит на экран текущее поколение, рассчитывает и выводит следующее поколение.
    - После цикла for выводит на экран финальное состояние поля.
11. **Запуск игры**:
    -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_game_of_life()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `play_game_of_life()`: Вызывает функцию для начала игры.
"""
```