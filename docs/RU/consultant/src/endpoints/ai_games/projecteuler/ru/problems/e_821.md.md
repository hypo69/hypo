# Анализ кода модуля e_821.md

**Качество кода**

7
-  Плюсы
    - Код задачи представлен в формате markdown.
    - Описание задачи четкое и понятное.
-  Минусы
    - Отсутствует код решения задачи.
    - Нет необходимых импортов.
    - Нет функций или классов для решения задачи.
    - Отсутствуют комментарии в формате reStructuredText (RST).

**Рекомендации по улучшению**
1. **Добавить код решения**: Необходимо реализовать функцию или класс, который решает задачу подсчета путей в лабиринте.
2. **Использовать reStructuredText для комментариев**: Необходимо добавить документацию к функциям, классам и модулю в формате RST.
3. **Добавить импорты**: Необходимо добавить все нужные импорты для работы кода.
4. **Реализовать логирование**: Использовать `logger` для обработки ошибок.
5. **Рефакторинг**: Переписать код так, чтобы он был более читаемым и соответствовал pep8.
6. **Добавить проверку на валидность входных данных**: Проверить, что `n` и `k` больше 0.

**Оптимизированный код**
```python
"""
Модуль для решения задачи 821 проекта Эйлера.
=================================================

В модуле реализована функция для подсчета количества путей
в "почти правильном лабиринте" размером n x n.

Пример использования:
--------------------

.. code-block:: python

    result = count_paths(n=100, k=10, mod=1_000_000_007)
    print(result)
"""
from functools import lru_cache
from src.logger.logger import logger


def count_paths(n: int, k: int, mod: int) -> int:
    """
    Вычисляет количество путей в "почти правильном лабиринте"
    размером n x n от верхнего левого угла (0, 0) до нижнего правого угла (n-1, n-1).

    :param n: Размер лабиринта.
    :param k: Максимальная разница сумм координат.
    :param mod: Модуль, по которому возвращается результат.
    :return: Количество путей по модулю mod.
    """
    if n <= 0 or k <= 0:
        logger.error(f"Невалидные входные данные: n={n}, k={k}")
        return 0

    @lru_cache(maxsize=None)
    def _count_paths(x: int, y: int) -> int:
        """
        Рекурсивная функция для подсчета путей из точки (x, y) до (n-1, n-1).

        :param x: Координата x текущей позиции.
        :param y: Координата y текущей позиции.
        :return: Количество путей до (n-1, n-1).
        """
        if x == n - 1 and y == n - 1:
            return 1

        count = 0
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and abs((x + y) - (nx + ny)) < k:
                count = (count + _count_paths(nx, ny)) % mod
        return count

    return _count_paths(0, 0)


if __name__ == '__main__':
    # Код исполняет примеры из условия
    print(f"M(2, 1) = {count_paths(n=2, k=1, mod=1_000_000_007)}")
    print(f"M(3, 1) = {count_paths(n=3, k=1, mod=1_000_000_007)}")
    print(f"M(7, 3) = {count_paths(n=7, k=3, mod=1_000_000_007)}")
    print(f"M(10, 5) = {count_paths(n=10, k=5, mod=1_000_000_007)}")

    # Код исполняет решение для M(10000, 100)
    result = count_paths(n=10000, k=100, mod=1_000_000_007)
    print(f"M(10000, 100) = {result}")
```