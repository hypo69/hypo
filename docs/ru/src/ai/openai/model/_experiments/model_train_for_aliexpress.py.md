# Модуль `model_train_for_aliexpress`

## Обзор

Модуль предназначен для экспериментов с AI-моделями (OpenAI и Google Gemini) для обработки данных, связанных с AliExpress кампаниями. Он загружает названия продуктов из текстовых файлов, передает их в модели AI и получает ответы.

## Подробней

Модуль используется для обучения и тестирования AI-моделей, чтобы они могли генерировать релевантные ответы на основе названий продуктов из AliExpress. Это позволяет автоматизировать процесс создания контента для рекламных кампаний и улучшить их эффективность.

## Функции

### `recursively_get_filenames`

```python
from src.utils.file import recursively_get_filenames
def recursively_get_filenames(path: Path | str, file_name: str = "*") -> list[str]:
    """
    Рекурсивно получает список файлов с указанным именем в каталоге и его подкаталогах.

    Args:
        path (Path | str): Путь к каталогу для поиска файлов.
        file_name (str, optional): Имя файла для поиска. По умолчанию "*", что соответствует любому имени файла.

    Returns:
        list[str]: Список полных путей к найденным файлам.

    Raises:
        FileNotFoundError: Если указанный путь не существует.
        PermissionError: Если нет прав доступа к указанному пути или его подкаталогам.
        OSError: В случае других ошибок, связанных с файловой системой.

    Example:
        >>> from pathlib import Path
        >>> path = Path('.')
        >>> filenames = recursively_get_filenames(path, 'example.txt')
        >>> print(filenames)
        []
    """
    ...
```

**Назначение**: Рекурсивно получает список файлов с указанным именем в каталоге и его подкаталогах.

**Параметры**:

- `path` (Path | str): Путь к каталогу для поиска файлов.
- `file_name` (str, optional): Имя файла для поиска. По умолчанию `*`, что соответствует любому имени файла.

**Возвращает**:

- `list[str]`: Список полных путей к найденным файлам.

**Вызывает исключения**:

- `FileNotFoundError`: Если указанный путь не существует.
- `PermissionError`: Если нет прав доступа к указанному пути или его подкаталогам.
- `OSError`: В случае других ошибок, связанных с файловой системой.

**Как работает функция**:

1. Функция принимает путь к каталогу и имя файла в качестве входных данных.
2. Она рекурсивно проходит по всем подкаталогам указанного каталога.
3. Для каждого файла в подкаталоге она проверяет, соответствует ли имя файла заданному имени.
4. Если имя файла соответствует, функция добавляет полный путь к файлу в список результатов.
5. Функция возвращает список полных путей к найденным файлам.

```
    Начало
    │
    ├───Проверка существования пути
    │   │
    │   └───Если путь не существует: Возврат ошибки FileNotFoundError
    │   │
    │   └───Если путь существует: Продолжение
    │
    ├───Рекурсивный обход каталогов
    │   │
    │   └───Для каждого файла в каталоге:
    │       │
    │       └───Проверка имени файла
    │           │
    │           └───Если имя файла соответствует заданному: Добавление пути к файлу в список результатов
    │           │
    │           └───Если имя файла не соответствует: Продолжение
    │
    └───Возврат списка найденных файлов
```

**Примеры**:

```python
from pathlib import Path
path = Path('.')
filenames = recursively_get_filenames(path, 'example.txt')
print(filenames)
# []
```

### `read_text_file`

```python
from typing import Generator, Optional, List
from pathlib import Path


def read_text_file(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[List[str]] = None,
    chunk_size: int = 8192,
) -> Generator[str, None, None] | str | None:
    """
    Считывает содержимое файла (или файлов из каталога) с использованием генератора для экономии памяти.

    Args:
        file_path (str | Path): Путь к файлу или каталогу.
        as_list (bool): Если `True`, возвращает генератор строк.
        extensions (Optional[List[str]]): Список расширений файлов для чтения из каталога.
        chunk_size (int): Размер чанков для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или `None` в случае ошибки.

    Raises:
        Exception: Если возникает ошибка при чтении файла.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> content = read_text_file(file_path)
        >>> if content:
        ...    print(f'File content: {content[:100]}...')
        File content: Example text...
    """
    ...
```

**Назначение**: Считывает содержимое файла (или файлов из каталога) с использованием генератора для экономии памяти.

**Параметры**:

- `file_path` (str | Path): Путь к файлу или каталогу.
- `as_list` (bool): Если `True`, возвращает генератор строк.
- `extensions` (Optional[List[str]]): Список расширений файлов для чтения из каталога.
- `chunk_size` (int): Размер чанков для чтения файла в байтах.

**Возвращает**:

- `Generator[str, None, None] | str | None`: Генератор строк, объединенная строка или `None` в случае ошибки.

**Вызывает исключения**:

- `Exception`: Если возникает ошибка при чтении файла.

**Как работает функция**:

1. Функция принимает путь к файлу или каталогу в качестве входных данных.
2. Если указан путь к файлу, функция открывает файл и читает его содержимое по частям (chunk_size).
3. Если указан путь к каталогу, функция перебирает все файлы в каталоге с указанными расширениями (extensions) и читает их содержимое по частям.
4. Если `as_list` установлен в `True`, функция возвращает генератор строк. В противном случае функция возвращает объединенную строку, содержащую все содержимое файла(ов).
5. В случае возникновения ошибки функция возвращает `None`.

```
    Начало
    │
    ├───Определение типа пути (файл или каталог)
    │   │
    │   ├───Если файл:
    │   │   │
    │   │   └───Открытие файла и чтение по частям (chunk_size)
    │   │   │
    │   │   └───Возврат генератора строк (если as_list) или объединенной строки
    │   │
    │   └───Если каталог:
    │       │
    │       └───Перебор файлов в каталоге с указанными расширениями (extensions)
    │           │
    │           └───Чтение каждого файла по частям (chunk_size)
    │           │
    │           └───Возврат генератора строк (если as_list) или объединенной строки
    │
    └───Обработка ошибок:
        │
        └───В случае ошибки: Возврат None
```

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
   print(f'File content: {content[:100]}...')
# File content: Example text...
```

### `csv2json_csv2dict`

```python
from src.utils.convertors import csv2json_csv2dict
def csv2json_csv2dict(csv_file: str, json_file: str = None, delimiter: str = ";") -> list[dict] | None:
    """
    Преобразует CSV-файл в JSON-файл и возвращает список словарей.

    Args:
        csv_file (str): Путь к CSV-файлу.
        json_file (str, optional): Путь к JSON-файлу для сохранения результата. По умолчанию `None`.
        delimiter (str, optional): Разделитель в CSV-файле. По умолчанию ";".

    Returns:
        list[dict] | None: Список словарей, представляющих данные из CSV-файла, или `None` в случае ошибки.

    Raises:
        FileNotFoundError: Если CSV-файл не найден.
        IOError: Если возникает ошибка при чтении или записи файла.
        json.JSONDecodeError: Если возникает ошибка при декодировании JSON.

    Example:
        >>> data = csv2json_csv2dict('data.csv', 'data.json')
        >>> if data:
        ...     print(data[0])
        {'header1': 'value1', 'header2': 'value2'}
    """
    ...
```

**Назначение**: Преобразует CSV-файл в JSON-файл и возвращает список словарей.

**Параметры**:

- `csv_file` (str): Путь к CSV-файлу.
- `json_file` (str, optional): Путь к JSON-файлу для сохранения результата. По умолчанию `None`.
- `delimiter` (str, optional): Разделитель в CSV-файле. По умолчанию ";".

**Возвращает**:

- `list[dict] | None`: Список словарей, представляющих данные из CSV-файла, или `None` в случае ошибки.

**Вызывает исключения**:

- `FileNotFoundError`: Если CSV-файл не найден.
- `IOError`: Если возникает ошибка при чтении или записи файла.
- `json.JSONDecodeError`: Если возникает ошибка при декодировании JSON.

**Как работает функция**:

1. Функция принимает путь к CSV-файлу, путь к JSON-файлу (опционально) и разделитель в CSV-файле в качестве входных данных.
2. Она открывает CSV-файл и читает его содержимое, используя указанный разделитель.
3. Функция преобразует данные из CSV-файла в список словарей, где ключи словарей соответствуют заголовкам столбцов в CSV-файле.
4. Если указан путь к JSON-файлу, функция записывает список словарей в JSON-файл.
5. Функция возвращает список словарей.
6. В случае возникновения ошибки функция возвращает `None`.

```
    Начало
    │
    ├───Открытие CSV-файла
    │   │
    │   └───Чтение содержимого CSV-файла с использованием указанного разделителя
    │
    ├───Преобразование данных в список словарей
    │   │
    │   └───Ключи словарей соответствуют заголовкам столбцов CSV-файла
    │
    ├───Запись списка словарей в JSON-файл (если указан путь к JSON-файлу)
    │   │
    │   └───Если указан путь к JSON-файлу: Запись данных в JSON-файл
    │
    └───Возврат списка словарей
```

**Примеры**:

```python
data = csv2json_csv2dict('data.csv', 'data.json')
if data:
    print(data[0])
# {'header1': 'value1', 'header2': 'value2'}
```

### `pprint`

```python
from src.utils.printer import pprint
def pprint(*args, stream:object = None, **kwargs) -> None:
    """
    Аналог `print`, но лучше.
    """
    ...
```

**Назначение**: Аналог `print`, но с улучшенным форматированием вывода.

**Параметры**:

- `*args`: Переменное количество аргументов для вывода.
- `stream` (object, optional): Объект потока для вывода. По умолчанию `None` (стандартный вывод).
- `**kwargs`: Дополнительные аргументы, передаваемые в функцию `pprint` из модуля `pprint`.

**Возвращает**:

- `None`: Функция ничего не возвращает.

**Как работает функция**:

1. Функция принимает переменное количество аргументов для вывода, объект потока (опционально) и дополнительные аргументы.
2. Она использует функцию `pprint` из модуля `pprint` для форматированного вывода аргументов в указанный поток (или стандартный вывод, если поток не указан).

```
    Начало
    │
    ├───Подготовка аргументов для вывода
    │   │
    │   └───Получение переменных аргументов (*args), объекта потока (stream) и дополнительных аргументов (**kwargs)
    │
    ├───Форматированный вывод
    │   │
    │   └───Использование функции pprint из модуля pprint для вывода аргументов в указанный поток
    │
    └───Завершение
        │
        └───Функция ничего не возвращает
```

**Примеры**:

```python
data = {'key1': 'value1', 'key2': 'value2'}
pprint(data)
# {'key1': 'value1', 'key2': 'value2'}
```

## Переменные

### `product_titles_files`

```python
product_titles_files:list = recursively_get_filenames(gs.path.google_drive / 'aliexpress' / 'campaigns','product_titles.txt')
```

Список файлов, содержащих названия продуктов. Получается путем рекурсивного поиска файлов с именем `product_titles.txt` в каталоге `aliexpress/campaigns` на Google Drive.

### `system_instruction_path`

```python
system_instruction_path = gs.path.src / 'ai' / 'prompts' / 'aliexpress_campaign' / 'system_instruction.txt'
```

Путь к файлу, содержащему системные инструкции для AI-моделей. Файл расположен в каталоге `src/ai/prompts/aliexpress_campaign` и называется `system_instruction.txt`.

### `system_instruction`

```python
system_instruction: str = read_text_file(system_instruction_path)
```

Строка, содержащая системные инструкции для AI-моделей. Загружается из файла, путь к которому указан в `system_instruction_path`.

### `openai`

```python
openai = OpenAIModel(system_instruction = system_instruction)
```

Экземпляр класса `OpenAIModel`, инициализированный с системными инструкциями.

### `gemini`

```python
gemini = GoogleGenerativeAI(system_instruction = system_instruction)
```

Экземпляр класса `GoogleGenerativeAI`, инициализированный с системными инструкциями.

## Цикл обработки файлов

```python
for file in product_titles_files:
    ...
    product_titles = read_text_file(file)
    response_openai = openai.ask(product_titles)
    response_gemini = gemini.ask(product_titles)
    ...
```

Этот цикл перебирает все файлы с названиями продуктов, считывает содержимое каждого файла, передает его в AI-модели OpenAI и Gemini, и получает ответы от каждой модели.

```
    Начало цикла
    │
    ├───Для каждого файла в списке product_titles_files:
    │   │
    │   ├───Чтение содержимого файла (product_titles)
    │   │
    │   ├───Запрос к OpenAIModel (response_openai)
    │   │
    │   ├───Запрос к GoogleGenerativeAI (response_gemini)
    │   │
    │   └───Обработка ответов (пропущено в предоставленном коде)
    │
    └───Конец цикла