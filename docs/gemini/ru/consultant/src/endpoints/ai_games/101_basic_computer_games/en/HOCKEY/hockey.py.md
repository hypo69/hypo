# Анализ кода модуля `hockey.py`

**Качество кода**
8
 -  Плюсы
        - Код хорошо структурирован и логически понятен.
        - Присутствуют подробные комментарии, описывающие каждый блок кода, а также правила и алгоритм игры.
        - Используются `try-except` блоки для обработки ошибок ввода, что делает код более устойчивым к некорректным пользовательским данным.
 -  Минусы
    - Отсутствует описание модуля в формате reStructuredText (RST).
    - Отсутствует импорт `logger` из `src.logger.logger`.
    - Не все комментарии оформлены в стиле RST.
    - Использование стандартных `try-except` блоков можно заменить на более лаконичную обработку ошибок с помощью `logger.error`.
    -  Присутствует дублирование кода в блоках `try-except` (можно вынести проверку ввода в отдельную функцию).
    -  Нет документации к переменным и константам.

**Рекомендации по улучшению**

1.  Добавить описание модуля в формате reStructuredText (RST) в начале файла.
2.  Импортировать `logger` из `src.logger.logger` для логирования ошибок.
3.  Переписать комментарии к функциям, переменным и константам в формате RST.
4.  Заменить избыточное использование стандартных `try-except` блоков на обработку ошибок с помощью `logger.error`.
5.  Рефакторинг кода для избежания дублирования логики ввода и валидации данных.
6.  Добавить проверку на корректный ввод (не число) перед преобразованием в int.

**Оптимизиробанный код**

```python
"""
Модуль для реализации игры "Хоккей".
====================================

Этот модуль предоставляет реализацию простой игры в хоккей для двух игроков.
Игроки по очереди выбирают действия: бросок, защиту или пас.
Очки начисляются в зависимости от комбинации действий игроков.
Игра продолжается до тех пор, пока один из игроков не наберет 10 очков.

Правила игры:
    - Два игрока по очереди вводят свои ходы.
    - Ходы представляются числами: 1 - бросок, 2 - защита, 3 - пас.
    - Очки начисляются по следующим правилам:
        - Бросок против защиты: защищающийся игрок получает 1 очко.
        - Бросок против паса: бросающий игрок получает 2 очка.
        - Защита против броска: защищающийся игрок получает 1 очко.
        - Защита против паса: защищающийся игрок получает 1 очко.
        - Пас против броска: бросающий игрок получает 2 очка.
        - Пас против защиты: защищающийся игрок получает 1 очко.
    - Игрок, первым набравший 10 очков, побеждает.

Пример использования
--------------------

.. code-block:: python

    python hockey.py
"""


from src.logger.logger import logger # Импортируем logger для обработки ошибок

#: Инициализация счета первого игрока.
player1Score = 0
#: Инициализация счета второго игрока.
player2Score = 0

def get_player_move(player_number: int) -> int:
    """
    Запрашивает ход игрока и проверяет его корректность.

    :param player_number: Номер игрока (1 или 2).
    :return: Ход игрока (1, 2 или 3).
    :raises ValueError: Если введен некорректный ход.
    """
    while True:
        try:
            move = input(f"Ход игрока {player_number} (1-бросок, 2-защита, 3-пас): ")
            if not move.isdigit(): # Проверяем, является ли ввод числом
                print("Неверный ввод! Введите число от 1 до 3")
                continue
            move = int(move)
            if 1 <= move <= 3:
                return move
            print("Неверный ввод! Введите число от 1 до 3")
        except ValueError:
           logger.error(f"Неверный ввод хода игрока {player_number}", exc_info=True)
           print("Неверный ввод! Введите число от 1 до 3")
           continue

# Основной игровой цикл
while player1Score < 10 and player2Score < 10:
    # Запрос ввода хода у первого игрока
    player1Move = get_player_move(1) # Код запрашивает ввод хода у первого игрока, используя функцию get_player_move
    
    # Запрос ввода хода у второго игрока
    player2Move = get_player_move(2) # Код запрашивает ввод хода у второго игрока, используя функцию get_player_move

    # Проверка и начисление очков в зависимости от ходов
    if player1Move == 1 and player2Move == 2:
        player2Score += 1 # Код увеличивает счет второго игрока на 1, если первый игрок бросает, а второй защищается
    elif player1Move == 1 and player2Move == 3:
        player1Score += 2 # Код увеличивает счет первого игрока на 2, если первый игрок бросает, а второй пасует
    elif player1Move == 2 and player2Move == 1:
        player1Score += 1 # Код увеличивает счет первого игрока на 1, если первый игрок защищается, а второй бросает
    elif player1Move == 2 and player2Move == 3:
        player1Score += 1 # Код увеличивает счет первого игрока на 1, если первый игрок защищается, а второй пасует
    elif player1Move == 3 and player2Move == 1:
        player2Score += 2 # Код увеличивает счет второго игрока на 2, если первый игрок пасует, а второй бросает
    elif player1Move == 3 and player2Move == 2:
        player2Score += 1 # Код увеличивает счет второго игрока на 1, если первый игрок пасует, а второй защищается

    # Вывод текущего счета
    print(f"Счет: Игрок 1 - {player1Score}, Игрок 2 - {player2Score}") # Код выводит текущий счет игроков

# Определение победителя и вывод сообщения
if player1Score >= 10:
    print("ПЕРВЫЙ ИГРОК ПОБЕДИЛ") # Код выводит сообщение о победе первого игрока, если его счет больше или равен 10
else:
    print("ВТОРОЙ ИГРОК ПОБЕДИЛ") # Код выводит сообщение о победе второго игрока, если счет первого игрока меньше 10

"""
Объяснение кода:
1. **Инициализация переменных**:
   - `player1Score = 0`: Инициализирует счет первого игрока нулем.
   - `player2Score = 0`: Инициализирует счет второго игрока нулем.
2. **Основной игровой цикл `while player1Score < 10 and player2Score < 10:`**:
   - Цикл продолжается до тех пор, пока счет хотя бы одного из игроков не достигнет 10.
   - **Ввод ходов игроков**:
     - Функция `get_player_move` запрашивает ввод хода у игрока (1 - бросок, 2 - защита, 3 - пас) и сохраняет его в `player1Move` или `player2Move`.
     - **Обработка исключений**:
     - В функции `get_player_move` блок `try-except` обрабатывает возможные ошибки ввода. Если пользователь введет не целое число, то будет выведено сообщение об ошибке и логирование.
   - **Проверка и начисление очков**:
     - `if player1Move == 1 and player2Move == 2:`: Если первый игрок бросает, а второй защищается, то счет второго игрока увеличивается на 1.
     - `elif player1Move == 1 and player2Move == 3:`: Если первый игрок бросает, а второй пасует, то счет первого игрока увеличивается на 2.
     - `elif player1Move == 2 and player2Move == 1:`: Если первый игрок защищается, а второй бросает, то счет первого игрока увеличивается на 1.
     - `elif player1Move == 2 and player2Move == 3:`: Если первый игрок защищается, а второй пасует, то счет первого игрока увеличивается на 1.
     - `elif player1Move == 3 and player2Move == 1:`: Если первый игрок пасует, а второй бросает, то счет второго игрока увеличивается на 2.
     - `elif player1Move == 3 and player2Move == 2:`: Если первый игрок пасует, а второй защищается, то счет второго игрока увеличивается на 1.
   - **Вывод текущего счета**:
     - `print(f"Счет: Игрок 1 - {player1Score}, Игрок 2 - {player2Score}")`: Выводит текущий счет игроков.
3. **Определение победителя**:
   - `if player1Score >= 10:`: Проверяет, достиг ли счет первого игрока 10 или более.
     - `print("ПЕРВЫЙ ИГРОК ПОБЕДИЛ")`: Выводит сообщение о победе первого игрока.
   - `else:`: Если условие выше не выполнено, значит, победил второй игрок.
     - `print("ВТОРОЙ ИГРОК ПОБЕДИЛ")`: Выводит сообщение о победе второго игрока.
"""
```