# Анализ кода модуля e_451.md

**Качество кода**
7
 -  Плюсы
        - Код содержит четкое описание задачи Project Euler на русском языке.
        - Присутствуют математические определения и примеры, что облегчает понимание.
 -  Минусы
    - Код не содержит реализации решения.
    - Отсутствуют docstring и комментарии в формате reStructuredText (RST).
    - Нет импортов и обработки ошибок.
    - Не приведен пример кода, который можно проверить.
    - Нет необходимых директив для Sphinx.

**Рекомендации по улучшению**

1.  **Добавить импорты**: Импортировать необходимые модули, такие как `math` для НОД.
2.  **Реализовать функции**:
    -   Реализовать функцию `R(a, b, n)` для вычисления наименьшего `k`.
    -   Реализовать функцию `G(n)` для вычисления суммы `R(a, 1, n)`.
    -   Реализовать функцию `S(n)` для вычисления суммы `G(i)`.
3.  **Добавить docstring**: Добавить docstring для каждой функции в формате reStructuredText (RST)
4.  **Добавить логирование**: Использовать `from src.logger.logger import logger` для логирования.
5.  **Добавить комментарии**: Добавить подробные комментарии к каждой строке кода, описывающие их назначение.
6.  **Обработка ошибок**: Вместо `try-except` использовать `logger.error` для отслеживания ошибок.
7.  **Пример использования**: Добавить пример использования функций.

**Оптимизированный код**

```python
"""
Модуль для решения задачи Project Euler 451.
=========================================================================================

Этот модуль содержит функции для расчета значений R(a, b, n), G(n) и S(n),
описанных в условии задачи.

Функции:
    - R(a, b, n): Вычисляет наименьшее целое k > 0 такое, что a^k ≡ b (mod n).
    - G(n): Вычисляет сумму всех значений R(a, 1, n) для 1 <= a < n, где НОД(a, n) = 1.
    - S(n): Вычисляет сумму значений G(i) для 2 <= i <= n.

Пример использования
--------------------

.. code-block:: python

    from src.logger.logger import logger
    from math import gcd

    n = 10
    result = S(n)
    print(f'S({n}) = {result}')

"""
from src.logger.logger import logger
from math import gcd

def R(a: int, b: int, n: int) -> int:
    """
    Вычисляет наименьшее целое k > 0 такое, что a^k ≡ b (mod n).

    :param a: Основание.
    :param b: Цель.
    :param n: Модуль.
    :return: Наименьшее целое k, удовлетворяющее условию, или 0, если такого k не существует.
    """
    # Проверяет, что a, b и n являются целыми числами
    if not all(isinstance(arg, int) for arg in [a, b, n]):
         logger.error(f"Неверный тип аргумента для R {a=} {b=} {n=}")
         return 0
    # Проверяет, что a и n не равны нулю
    if a == 0 or n == 0:
        logger.error(f"Аргумент не должен быть равен нулю, {a=} {b=} {n=}")
        return 0

    k = 1
    ak = a % n # Инициализируем переменную ak как a mod n
    while k <= n: #  Код исполняет цикл пока k меньше или равно n
        if ak == b % n: # Проверка, что ak равно b по модулю n
            return k # Возвращаем k, если условие выполнено
        ak = (ak * a) % n # Вычисление следующего значения ak
        k += 1 # Увеличение k на 1
    return 0 # Возвращаем 0, если такого k не существует

def G(n: int) -> int:
    """
    Вычисляет сумму всех значений R(a, 1, n) для 1 <= a < n таких, что НОД(a, n) = 1.

    :param n: Модуль.
    :return: Сумма значений R(a, 1, n).
    """
    # Проверяет, что n является целым числом
    if not isinstance(n, int):
        logger.error(f"Неверный тип аргумента для G {n=}")
        return 0
    # Проверяет, что n больше 0
    if n <= 0:
         logger.error(f"Аргумент n должен быть больше нуля, {n=}")
         return 0
    total = 0 # Инициализируем total как 0
    for a in range(1, n): # Цикл по всем a от 1 до n-1
        if gcd(a, n) == 1: # Проверяем, что НОД(a, n) равен 1
            total += R(a, 1, n) # Добавляем R(a, 1, n) к total
    return total # Возвращает total

def S(n: int) -> int:
    """
    Вычисляет сумму значений G(i) для 2 <= i <= n.

    :param n: Верхняя граница диапазона.
    :return: Сумма значений G(i).
    """
    # Проверяет, что n является целым числом
    if not isinstance(n, int):
        logger.error(f"Неверный тип аргумента для S {n=}")
        return 0
    # Проверяет, что n больше 1
    if n <= 1 :
         logger.error(f"Аргумент n должен быть больше единицы, {n=}")
         return 0
    total = 0 # Инициализируем total как 0
    for i in range(2, n + 1): # Цикл по всем i от 2 до n
        total += G(i) # Добавляем G(i) к total
    return total # Возвращаем total

if __name__ == '__main__':
    # Пример использования
    n = 10
    result = S(n) # вызываем функцию S
    print(f'S({n}) = {result}') # выводим результат
```