## Ответ на Задачу No 182: Выбор подходящего ключа шифрования RSA

### 1. Анализ задачи и решение

**Понимание задачи:**
* Нам дана криптосистема RSA, где `n = p * q`, `φ(n) = (p-1)(q-1)`.
* Слабый ключ `e` удовлетворяет условию `m^e ≡ m (mod n)` для всех `0 < m < n`.
* Известно, что слабые ключи для `n = p * q` - это числа `e` такие что `e ≡ 1 (mod lcm(p-1, q-1))`. 
* Нам нужно найти сумму всех таких слабых ключей `e` при заданном `n`.
* Нужно найти `lcm(p-1, q-1)`,  где `n = p * q`.
* Если `n = p*q`, тогда слабые ключи это решения уравнения `x ≡ 1 mod lcm(p-1, q-1)`. Это означает что слабые ключи это числа вида  `1 + k*lcm(p-1,q-1)`, где k - натуральное число.
* Зная `n`, нужно разложить его на два простых числа `p` и `q`
* Задача требует поиска таких `e`, что `m^e ≡ m (mod n)` для всех `0 < m < n`. Это условие выполняется, если `e ≡ 1 (mod lcm(p-1, q-1))`.

**Решение:**
1.  **Факторизация n:** Разложить `n` на два простых множителя `p` и `q`. Это наиболее сложная часть задачи, так как факторизация больших чисел может быть вычислительно затратной.
2.  **Вычисление lcm(p-1, q-1):** Найти наименьшее общее кратное чисел `p-1` и `q-1`. Для этого можно воспользоваться формулой `lcm(a, b) = (a * b) // gcd(a, b)`.
3.  **Генерация слабых ключей:** Слабые ключи `e` имеют вид `1 + k * lcm(p-1, q-1)`. Необходимо найти все такие `e`, которые меньше `n`, то есть `1 + k * lcm < n`, отсюда можно найти максимальное `k`, как `k = (n-1)//lcm`.
4. **Суммирование слабых ключей:** Просуммировать все найденные слабые ключи. Для этого можно использовать формулу суммы арифметической прогрессии. Сумма будет равна `количество * (2 * first_element + (количество - 1) * diff) // 2`. В нашем случае `first_element = 1 + lcm`, `diff = lcm` и `количество = k`.
    Сумма слабых ключей = `количество * (2 + (количество -1) * lcm) // 2`

### 2. Алгоритм решения

1.  Начать.
2.  Ввод: `n` = 1000036000099.
3.  Разложить `n` на простые множители `p` и `q`.
4.  Вычислить `lcm_val = lcm(p-1, q-1)`.
5. Вычислить `k = (n-1) // lcm_val`
6. Вычислить сумму слабых ключей `sum_weak_keys = k * (2 + (k-1) * lcm_val) // 2`
7.  Вывод: `sum_weak_keys`.
8.  Конец.

### 3. Реализация на Python 3.12

```python
import math

def gcd(a, b):
  """Calculates the greatest common divisor of a and b."""
  while b:
    a, b = b, a % b
  return a

def lcm(a, b):
  """Calculates the least common multiple of a and b."""
  return (a * b) // gcd(a, b)

def find_factors(n):
    """Finds two prime factors of n."""
    if n % 2 == 0:
      return 2, n // 2
    
    i = 3
    while i * i <= n:
        if n % i == 0:
            return i, n // i
        i += 2
    return n, 1 # In case n is prime
   
def sum_of_weak_keys(n):
    """Calculates the sum of all weak keys for a given n."""
    
    p, q = find_factors(n)
    if q == 1:
       return "Error: N is a prime"
    
    lcm_val = lcm(p - 1, q - 1)
    k = (n - 1) // lcm_val
    sum_weak_keys = k * (2 + (k-1) * lcm_val) // 2
    return sum_weak_keys

# Пример использования:
n = 1000036000099
result = sum_of_weak_keys(n)
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InputN(Ввод: n = 1000036000099)
    InputN --> FactorizeN(Разложить n на p и q)
    FactorizeN --> CalculateLCM(Вычислить lcm = lcm(p-1, q-1))
    CalculateLCM --> CalculateK(Вычислить k = (n-1)//lcm)
    CalculateK --> CalculateSum(Вычислить sum_weak_keys = k*(2 + (k-1)*lcm)//2)
    CalculateSum --> OutputSum(Вывод: sum_weak_keys)
    OutputSum --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Ввод: n = 1000036000099:** Ввод заданного значения n.
*   **Разложить n на p и q:** Факторизация n на два простых множителя p и q.
*   **Вычислить lcm = lcm(p-1, q-1):** Вычисление наименьшего общего кратного чисел p-1 и q-1.
*   **Вычислить k = (n-1)//lcm:**  Вычисление максимального k для слабых ключей.
*   **Вычислить sum_weak_keys = k\*(2 + (k-1)\*lcm)//2:** Вычисление суммы всех слабых ключей.
*   **Вывод: sum\_weak\_keys:** Вывод полученной суммы.
