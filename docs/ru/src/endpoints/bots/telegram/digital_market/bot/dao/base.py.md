# Модуль `base.py`

## Обзор

Модуль `base.py` предоставляет базовый класс `BaseDAO` для Data Access Objects (DAO), который обеспечивает общие операции для взаимодействия с базой данных, такие как создание, чтение, обновление и удаление (CRUD). Он использует `SQLAlchemy` для работы с базой данных и предназначен для асинхронного выполнения операций.

## Подробнее

Этот модуль определяет параметризованный класс `BaseDAO`, который принимает модель `SQLAlchemy` в качестве типа. Он предоставляет методы для выполнения стандартных операций с базой данных, таких как поиск одной или нескольких записей, добавление, обновление, удаление и подсчет записей. Все методы логируют свои действия с использованием модуля `logger` из `src.logger` и обрабатывают исключения `SQLAlchemyError`, логируя ошибки и перевыбрасывая их для дальнейшей обработки.

## Классы

### `BaseDAO`

**Описание**:
Базовый класс DAO, параметризованный моделью SQLAlchemy, предоставляет стандартные методы для взаимодействия с базой данных.

**Принцип работы**:
Класс `BaseDAO` предоставляет методы для выполнения основных операций с базой данных, таких как поиск, добавление, обновление и удаление записей. Он использует `SQLAlchemy` для взаимодействия с базой данных и предназначен для асинхронного выполнения операций. Класс является параметризованным, что позволяет ему работать с различными моделями базы данных.

**Атрибуты**:
- `model` (`type[T]`): Тип модели SQLAlchemy, с которой работает данный DAO.

**Методы**:
- `find_one_or_none_by_id(cls, data_id: int, session: AsyncSession)`
- `find_one_or_none(cls, session: AsyncSession, filters: BaseModel)`
- `find_all(cls, session: AsyncSession, filters: BaseModel | None = None)`
- `add(cls, session: AsyncSession, values: BaseModel)`
- `add_many(cls, session: AsyncSession, instances: List[BaseModel])`
- `update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel)`
- `delete(cls, session: AsyncSession, filters: BaseModel)`
- `count(cls, session: AsyncSession, filters: BaseModel | None = None)`
- `paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None)`
- `find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]`
- `upsert(cls, session: AsyncSession, unique_fields: List[str], values: BaseModel)`
- `bulk_update(cls, session: AsyncSession, records: List[BaseModel]) -> int`

## Функции

### `find_one_or_none_by_id`

```python
@classmethod
async def find_one_or_none_by_id(cls, data_id: int, session: AsyncSession):
    """
    Найти запись по ID.

    Args:
        data_id (int): ID записи для поиска.
        session (AsyncSession): Асинхровая сессия SQLAlchemy.

    Returns:
        T | None: Найденная запись или None, если запись не найдена.

    Raises:
        SQLAlchemyError: Если возникает ошибка при поиске записи.
    """
    ...
```

**Назначение**:
Поиск записи в базе данных по ее ID.

**Параметры**:
- `data_id` (`int`): ID записи, которую необходимо найти.
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.

**Возвращает**:
- `T | None`: Найденная запись, если она существует, или `None`, если запись с указанным ID не найдена.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Логирование начала поиска**: Функция начинает с логирования информации о начале поиска записи с указанным `data_id` в таблице, соответствующей модели `cls.model`.
2.  **Выполнение запроса к базе данных**: Формируется запрос `SQLAlchemy` для выбора записи из таблицы `cls.model` с указанным `id`. Запрос выполняется асинхронно с использованием переданной сессии `session`.
3.  **Обработка результата запроса**: После выполнения запроса извлекается результат. Если запись с указанным `id` найдена, она возвращается. Если запись не найдена, возвращается `None`.
4.  **Логирование результата поиска**: В зависимости от того, была ли найдена запись, функция логирует соответствующее сообщение.
5.  **Обработка ошибок**: Если в процессе выполнения запроса возникает исключение `SQLAlchemyError`, оно логируется, и затем перевыбрасывается для дальнейшей обработки.

```
Начало поиска
│
└───►  Выполнение запроса к БД (SELECT ... FROM ... WHERE id = data_id)
│
└───►  Обработка результата
│       ├───► Запись найдена  ───► Логирование "Запись найдена" ───► Возврат записи
│       └───► Запись не найдена ───► Логирование "Запись не найдена" ───► Возврат None
│
└───►  Обработка ошибок (SQLAlchemyError) ───► Логирование ошибки ───► Перевыброс исключения
```

**Примеры**:

```python
# Пример поиска записи по ID
async def example():
    async with async_session() as session:
        record = await BaseDAO.find_one_or_none_by_id(data_id=123, session=session)
        if record:
            print(f"Найденная запись: {record}")
        else:
            print("Запись не найдена")
```

### `find_one_or_none`

```python
@classmethod
async def find_one_or_none(cls, session: AsyncSession, filters: BaseModel):
    """
    Найти одну запись по фильтрам.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        filters (BaseModel): Pydantic модель с фильтрами.

    Returns:
        T | None: Найденная запись или None, если запись не найдена.

    Raises:
        SQLAlchemyError: Если возникает ошибка при поиске записи.
    """
    ...
```

**Назначение**:
Поиск одной записи в базе данных по заданным фильтрам.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `filters` (`BaseModel`): Pydantic модель, содержащая фильтры для поиска записи.

**Возвращает**:
- `T | None`: Найденная запись, если она соответствует заданным фильтрам, или `None`, если запись не найдена.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров**: Функция преобразует Pydantic модель `filters` в словарь, исключая неустановленные значения, для использования в запросе `SQLAlchemy`.
2.  **Логирование начала поиска**: Логируется информация о начале поиска записи с использованием предоставленных фильтров.
3.  **Выполнение запроса к базе данных**: Формируется запрос `SQLAlchemy` для выбора записи из таблицы `cls.model` с применением указанных фильтров. Запрос выполняется асинхронно с использованием переданной сессии `session`.
4.  **Обработка результата запроса**: После выполнения запроса извлекается результат. Если запись, соответствующая фильтрам, найдена, она возвращается. Если запись не найдена, возвращается `None`.
5.  **Логирование результата поиска**: В зависимости от того, была ли найдена запись, функция логирует соответствующее сообщение.
6.  **Обработка ошибок**: Если в процессе выполнения запроса возникает исключение `SQLAlchemyError`, оно логируется, и затем перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров (BaseModel -> dict)
│
└───►  Логирование начала поиска
│
└───►  Выполнение запроса к БД (SELECT ... FROM ... WHERE ...)
│
└───►  Обработка результата
│       ├───► Запись найдена  ───► Логирование "Запись найдена" ───► Возврат записи
│       └───► Запись не найдена ───► Логирование "Запись не найдена" ───► Возврат None
│
└───►  Обработка ошибок (SQLAlchemyError) ───► Логирование ошибки ───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str
    age: int

# Пример поиска пользователя по имени и возрасту
async def example():
    async with async_session() as session:
        filters = UserFilter(name="John", age=30)
        record = await BaseDAO.find_one_or_none(session=session, filters=filters)
        if record:
            print(f"Найденная запись: {record}")
        else:
            print("Запись не найдена")
```

### `find_all`

```python
@classmethod
async def find_all(cls, session: AsyncSession, filters: BaseModel | None = None):
    """
    Найти все записи по фильтрам.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        filters (BaseModel | None, optional): Pydantic модель с фильтрами. По умолчанию None.

    Returns:
        List[T]: Список найденных записей.

    Raises:
        SQLAlchemyError: Если возникает ошибка при поиске записей.
    """
    ...
```

**Назначение**:
Поиск всех записей в базе данных, соответствующих заданным фильтрам.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `filters` (`BaseModel | None`, optional): Pydantic модель, содержащая фильтры для поиска записей. Если `None`, возвращаются все записи. По умолчанию `None`.

**Возвращает**:
- `List[T]`: Список найденных записей, соответствующих заданным фильтрам.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров**: Если предоставлены фильтры (`filters` не `None`), Pydantic модель `filters` преобразуется в словарь, исключая неустановленные значения. Если фильтры не предоставлены, создается пустой словарь.
2.  **Логирование начала поиска**: Логируется информация о начале поиска записей с использованием предоставленных фильтров.
3.  **Выполнение запроса к базе данных**: Формируется запрос `SQLAlchemy` для выбора всех записей из таблицы `cls.model` с применением указанных фильтров. Запрос выполняется асинхронно с использованием переданной сессии `session`.
4.  **Обработка результата запроса**: После выполнения запроса извлекается список всех найденных записей.
5.  **Логирование количества найденных записей**: Логируется количество найденных записей.
6.  **Обработка ошибок**: Если в процессе выполнения запроса возникает исключение `SQLAlchemyError`, оно логируется, и затем перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров (BaseModel -> dict или {})
│
└───►  Логирование начала поиска
│
└───►  Выполнение запроса к БД (SELECT ... FROM ... WHERE ...)
│
└───►  Обработка результата
│       └───► Получение списка записей
│
└───►  Логирование количества найденных записей
│
└───►  Обработка ошибок (SQLAlchemyError) ───► Логирование ошибки ───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

# Пример поиска всех пользователей с определенным именем
async def example():
    async with async_session() as session:
        filters = UserFilter(name="John")
        records = await BaseDAO.find_all(session=session, filters=filters)
        print(f"Найденные записи: {records}")

# Пример поиска всех пользователей
async def example_all():
    async with async_session() as session:
        records = await BaseDAO.find_all(session=session)
        print(f"Все записи: {records}")
```

### `add`

```python
@classmethod
async def add(cls, session: AsyncSession, values: BaseModel):
    """
    Добавить одну запись.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        values (BaseModel): Pydantic модель со значениями для добавления.

    Returns:
        T: Новая добавленная запись.

    Raises:
        SQLAlchemyError: Если возникает ошибка при добавлении записи.
    """
    ...
```

**Назначение**:
Добавление новой записи в базу данных.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `values` (`BaseModel`): Pydantic модель, содержащая значения для добавления новой записи.

**Возвращает**:
- `T`: Новая добавленная запись.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование значений**: Pydantic модель `values` преобразуется в словарь, исключая неустановленные значения.
2.  **Логирование добавления записи**: Логируется информация о добавлении записи с указанными параметрами.
3.  **Создание нового экземпляра модели**: Создается новый экземпляр модели `cls.model` с использованием предоставленных значений.
4.  **Добавление экземпляра в сессию**: Новый экземпляр добавляется в сессию SQLAlchemy для последующей записи в базу данных.
5.  **Фиксация изменений**: Вызывается метод `session.flush()` для фиксации изменений в базе данных.
6.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, выполняется откат изменений с использованием `session.rollback()`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование значений (BaseModel -> dict)
│
└───►  Логирование добавления записи
│
└───►  Создание нового экземпляра модели
│
└───►  Добавление экземпляра в сессию
│
└───►  Фиксация изменений (session.flush())
│
└───►  Обработка ошибок (SQLAlchemyError)
│       ├───► Откат изменений (session.rollback())
│       └───► Логирование ошибки
│       └───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel

class UserCreate(BaseModel):
    name: str
    age: int

# Пример добавления нового пользователя
async def example():
    async with async_session() as session:
        user_data = UserCreate(name="Alice", age=25)
        new_user = await BaseDAO.add(session=session, values=user_data)
        print(f"Новый пользователь: {new_user}")
```

### `add_many`

```python
@classmethod
async def add_many(cls, session: AsyncSession, instances: List[BaseModel]):
    """
    Добавить несколько записей.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        instances (List[BaseModel]): Список Pydantic моделей со значениями для добавления.

    Returns:
        List[T]: Список новых добавленных записей.

    Raises:
        SQLAlchemyError: Если возникает ошибка при добавлении записей.
    """
    ...
```

**Назначение**:
Добавление нескольких записей в базу данных за один раз.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `instances` (`List[BaseModel]`): Список Pydantic моделей, содержащих значения для добавления новых записей.

**Возвращает**:
- `List[T]`: Список новых добавленных записей.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование списка значений**: Каждый экземпляр `BaseModel` в списке `instances` преобразуется в словарь, исключая неустановленные значения.
2.  **Логирование добавления записей**: Логируется информация о добавлении нескольких записей.
3.  **Создание новых экземпляров модели**: Создаются новые экземпляры модели `cls.model` на основе преобразованных значений.
4.  **Добавление экземпляров в сессию**: Все новые экземпляры добавляются в сессию SQLAlchemy.
5.  **Фиксация изменений**: Вызывается метод `session.flush()` для фиксации изменений в базе данных.
6.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, выполняется откат изменений с использованием `session.rollback()`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование списка значений (List[BaseModel] -> List[dict])
│
└───►  Логирование добавления записей
│
└───►  Создание новых экземпляров модели
│
└───►  Добавление экземпляров в сессию
│
└───►  Фиксация изменений (session.flush())
│
└───►  Обработка ошибок (SQLAlchemyError)
│       ├───► Откат изменений (session.rollback())
│       └───► Логирование ошибки
│       └───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel
from typing import List

class UserCreate(BaseModel):
    name: str
    age: int

# Пример добавления нескольких пользователей
async def example():
    async with async_session() as session:
        users_data = [
            UserCreate(name="Alice", age=25),
            UserCreate(name="Bob", age=30)
        ]
        new_users = await BaseDAO.add_many(session=session, instances=users_data)
        print(f"Новые пользователи: {new_users}")
```

### `update`

```python
@classmethod
async def update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel):
    """
    Обновить записи по фильтрам.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        filters (BaseModel): Pydantic модель с фильтрами для поиска записей.
        values (BaseModel): Pydantic модель со значениями для обновления.

    Returns:
        int: Количество обновленных записей.

    Raises:
        SQLAlchemyError: Если возникает ошибка при обновлении записей.
    """
    ...
```

**Назначение**:
Обновление записей в базе данных, соответствующих заданным фильтрам.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `filters` (`BaseModel`): Pydantic модель, содержащая фильтры для поиска записей, которые необходимо обновить.
- `values` (`BaseModel`): Pydantic модель, содержащая значения для обновления записей.

**Возвращает**:
- `int`: Количество обновленных записей.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров и значений**: Pydantic модели `filters` и `values` преобразуются в словари, исключая неустановленные значения.
2.  **Логирование обновления записей**: Логируется информация об обновлении записей с указанными фильтрами и значениями.
3.  **Формирование запроса на обновление**: Формируется запрос `SQLAlchemy` для обновления записей в таблице `cls.model`, соответствующих заданным фильтрам, с использованием предоставленных значений.
4.  **Выполнение запроса**: Запрос выполняется асинхронно с использованием переданной сессии `session`.
5.  **Фиксация изменений**: Вызывается метод `session.flush()` для фиксации изменений в базе данных.
6.  **Обработка результатов**: Извлекается количество обновленных записей из результата выполнения запроса.
7.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, выполняется откат изменений с использованием `session.rollback()`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров и значений (BaseModel -> dict)
│
└───►  Логирование обновления записей
│
└───►  Формирование запроса на обновление
│
└───►  Выполнение запроса
│
└───►  Фиксация изменений (session.flush())
│
└───►  Обработка результатов
│       └───► Извлечение количества обновленных записей
│
└───►  Обработка ошибок (SQLAlchemyError)
│       ├───► Откат изменений (session.rollback())
│       └───► Логирование ошибки
│       └───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    id: int

class UserUpdate(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

# Пример обновления имени пользователя
async def example():
    async with async_session() as session:
        filters = UserFilter(id=1)
        values = UserUpdate(name="Updated Name")
        updated_count = await BaseDAO.update(session=session, filters=filters, values=values)
        print(f"Обновлено записей: {updated_count}")
```

### `delete`

```python
@classmethod
async def delete(cls, session: AsyncSession, filters: BaseModel):
    """
    Удалить записи по фильтру.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        filters (BaseModel): Pydantic модель с фильтрами для поиска записей.

    Returns:
        int: Количество удаленных записей.

    Raises:
        ValueError: Если не указаны фильтры для удаления.
        SQLAlchemyError: Если возникает ошибка при удалении записей.
    """
    ...
```

**Назначение**:
Удаление записей из базы данных, соответствующих заданным фильтрам.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `filters` (`BaseModel`): Pydantic модель, содержащая фильтры для поиска записей, которые необходимо удалить.

**Возвращает**:
- `int`: Количество удаленных записей.

**Вызывает исключения**:
- `ValueError`: Если не указаны фильтры для удаления.
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров**: Pydantic модель `filters` преобразуется в словарь, исключая неустановленные значения.
2.  **Проверка наличия фильтров**: Проверяется, что фильтры указаны. Если фильтры отсутствуют, вызывается исключение `ValueError`.
3.  **Логирование удаления записей**: Логируется информация об удалении записей с указанными фильтрами.
4.  **Формирование запроса на удаление**: Формируется запрос `SQLAlchemy` для удаления записей из таблицы `cls.model`, соответствующих заданным фильтрам.
5.  **Выполнение запроса**: Запрос выполняется асинхронно с использованием переданной сессии `session`.
6.  **Фиксация изменений**: Вызывается метод `session.flush()` для фиксации изменений в базе данных.
7.  **Обработка результатов**: Извлекается количество удаленных записей из результата выполнения запроса.
8.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, выполняется откат изменений с использованием `session.rollback()`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров (BaseModel -> dict)
│
└───►  Проверка наличия фильтров
│       ├───► Фильтры отсутствуют ───► Выброс ValueError
│       └───► Фильтры присутствуют ───► Логирование удаления записей
│
└───►  Формирование запроса на удаление
│
└───►  Выполнение запроса
│
└───►  Фиксация изменений (session.flush())
│
└───►  Обработка результатов
│       └───► Извлечение количества удаленных записей
│
└───►  Обработка ошибок (SQLAlchemyError)
│       ├───► Откат изменений (session.rollback())
│       └───► Логирование ошибки
│       └───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel

class UserFilter(BaseModel):
    id: int

# Пример удаления пользователя по ID
async def example():
    async with async_session() as session:
        filters = UserFilter(id=1)
        deleted_count = await BaseDAO.delete(session=session, filters=filters)
        print(f"Удалено записей: {deleted_count}")
```

### `count`

```python
@classmethod
async def count(cls, session: AsyncSession, filters: BaseModel | None = None):
    """
    Подсчитать количество записей.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        filters (BaseModel | None, optional): Pydantic модель с фильтрами для поиска записей. По умолчанию None.

    Returns:
        int: Количество записей, соответствующих фильтрам.

    Raises:
        SQLAlchemyError: Если возникает ошибка при подсчете записей.
    """
    ...
```

**Назначение**:
Подсчет количества записей в базе данных, соответствующих заданным фильтрам.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `filters` (`BaseModel | None`, optional): Pydantic модель, содержащая фильтры для поиска записей. Если `None`, подсчитываются все записи. По умолчанию `None`.

**Возвращает**:
- `int`: Количество записей, соответствующих заданным фильтрам.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров**: Если предоставлены фильтры (`filters` не `None`), Pydantic модель `filters` преобразуется в словарь, исключая неустановленные значения. Если фильтры не предоставлены, создается пустой словарь.
2.  **Логирование подсчета записей**: Логируется информация о подсчете записей с использованием предоставленных фильтров.
3.  **Формирование запроса на подсчет**: Формируется запрос `SQLAlchemy` для подсчета количества записей в таблице `cls.model`, соответствующих заданным фильтрам.
4.  **Выполнение запроса**: Запрос выполняется асинхронно с использованием переданной сессии `session`.
5.  **Обработка результатов**: Извлекается количество записей из результата выполнения запроса.
6.  **Логирование количества найденных записей**: Логируется количество найденных записей.
7.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров (BaseModel -> dict или {})
│
└───►  Логирование подсчета записей
│
└───►  Формирование запроса на подсчет
│
└───►  Выполнение запроса
│
└───►  Обработка результатов
│       └───► Извлечение количества записей
│
└───►  Логирование количества найденных записей
│
└───►  Обработка ошибок (SQLAlchemyError) ───► Логирование ошибки ───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

# Пример подсчета всех пользователей с определенным именем
async def example():
    async with async_session() as session:
        filters = UserFilter(name="John")
        count = await BaseDAO.count(session=session, filters=filters)
        print(f"Количество пользователей с именем John: {count}")

# Пример подсчета всех пользователей
async def example_all():
    async with async_session() as session:
        count = await BaseDAO.count(session=session)
        print(f"Общее количество пользователей: {count}")
```

### `paginate`

```python
@classmethod
async def paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None):
    """
    Пагинация записей.

    Args:
        session (AsyncSession): Асинхровая сессия SQLAlchemy.
        page (int, optional): Номер страницы. По умолчанию 1.
        page_size (int, optional): Размер страницы. По умолчанию 10.
        filters (BaseModel, optional): Pydantic модель с фильтрами для поиска записей. По умолчанию None.

    Returns:
        List[T]: Список записей на указанной странице.

    Raises:
        SQLAlchemyError: Если возникает ошибка при пагинации записей.
    """
    ...
```

**Назначение**:
Получение записей из базы данных с пагинацией и фильтрацией.

**Параметры**:
- `session` (`AsyncSession`): Асинхровая сессия SQLAlchemy для выполнения запросов к базе данных.
- `page` (`int`, optional): Номер страницы для пагинации. По умолчанию 1.
- `page_size` (`int`, optional): Количество записей на странице. По умолчанию 10.
- `filters` (`BaseModel`, optional): Pydantic модель, содержащая фильтры для поиска записей. Если `None`, возвращаются все записи. По умолчанию `None`.

**Возвращает**:
- `List[T]`: Список записей на указанной странице, соответствующих заданным фильтрам.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Преобразование фильтров**: Если предоставлены фильтры (`filters` не `None`), Pydantic модель `filters` преобразуется в словарь, исключая неустановленные значения. Если фильтры не предоставлены, создается пустой словарь.
2.  **Логирование пагинации записей**: Логируется информация о пагинации записей с указанными параметрами.
3.  **Формирование запроса на выборку**: Формируется запрос `SQLAlchemy` для выборки записей из таблицы `cls.model`, соответствующих заданным фильтрам, с учетом параметров пагинации (`page` и `page_size`).
4.  **Выполнение запроса**: Запрос выполняется асинхронно с использованием переданной сессии `session`.
5.  **Обработка результатов**: Извлекается список записей, соответствующих текущей странице и фильтрам.
6.  **Логирование количества найденных записей**: Логируется количество найденных записей на текущей странице.
7.  **Обработка ошибок**: Если в процессе выполнения операции возникает исключение `SQLAlchemyError`, логируется информация об ошибке, и исключение перевыбрасывается для дальнейшей обработки.

```
Преобразование фильтров (BaseModel -> dict или {})
│
└───►  Логирование пагинации записей
│
└───►  Формирование запроса на выборку с пагинацией
│
└───►  Выполнение запроса
│
└───►  Обработка результатов
│       └───► Извлечение списка записей
│
└───►  Логирование количества найденных записей
│
└───►  Обработка ошибок (SQLAlchemyError) ───► Логирование ошибки ───► Перевыброс исключения
```

**Примеры**:

```python
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

# Пример получения первой страницы пользователей с именем John, размер страницы 10
async def example():
    async with async_session() as session:
        filters = UserFilter(name="John")
        records = await BaseDAO.paginate(session=session, page=1, page_size=10, filters=filters)
        print(f"Записи на странице 1: {records}")

# Пример получения второй страницы всех пользователей, размер страницы 5
async def example_all():
    async with async_session() as session:
        records = await BaseDAO.paginate(session=session, page=2, page_size=5)
        print(f"Записи на странице 2: {records}")
```

### `find_by_ids`

```python
@classmethod
async def find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]:
    """Найти несколько записей по списку ID"""
    ...
```

**Назначение**:
Поиск нескольких записей в базе данных по списку их идентификаторов.

**Параметры**:
- `session` (`AsyncSession`): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `ids` (`List[int]`): Список идентификаторов записей, которые необходимо найти.

**Возвращает**:
- `List[Any]`: Список найденных записей, соответствующих указанным идентификаторам.

**Вызывает исключения**:
- `SQLAlchemyError`: Возникает в случае ошибки при выполнении запроса к базе данных.

**Как работает функция**:

1.  **Логирование начала поиска**: Функция начинает с логирования информации о начале поиска записей с указанными идентификаторами.
2