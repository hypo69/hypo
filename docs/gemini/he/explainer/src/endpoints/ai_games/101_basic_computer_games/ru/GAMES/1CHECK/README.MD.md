## <algorithm>

הקוד מדמה משחק לוח דמקה בו המטרה היא להסיר כמה שיותר כלים על ידי קפיצות.

1. **אתחול לוח המשחק (`__init__`)**:
   - יוצר לוח 8x8 שמיוצג על ידי רשימה דו-ממדית.
   - מאתחל את הלוח עם 48 כלים בשורות החיצוניות (שורה 1 ו-8).
   - מאתחל מונה של כלים שהוסרו ל-0.
   - דוגמה:
     ```
     board = [
         [1, 1, 1, 1, 1, 1, 1, 1],  # שורה 1 (כלים)
         [1, 1, 1, 1, 1, 1, 1, 1],  # שורה 2 (כלים)
         [0, 0, 0, 0, 0, 0, 0, 0],  # שורה 3 (ריק)
         [0, 0, 0, 0, 0, 0, 0, 0],  # שורה 4 (ריק)
         [0, 0, 0, 0, 0, 0, 0, 0],  # שורה 5 (ריק)
         [0, 0, 0, 0, 0, 0, 0, 0],  # שורה 6 (ריק)
         [1, 1, 1, 1, 1, 1, 1, 1],  # שורה 7 (כלים)
         [1, 1, 1, 1, 1, 1, 1, 1]   # שורה 8 (כלים)
     ]
     removed_checkers = 0
     ```

2. **אתחול כלים (`initialize_checkers`)**:
   - ממקם 48 כלים בשתי השורות החיצוניות (1 ו-8) של הלוח.
   - עובר על כל העמודות בשורות 0 ו-7 (שורה ראשונה ושורה אחרונה במערך הדו מימדי) ומסמן אותן כ-1 (כלים).
   - דוגמה:
     ```
     for row in [0, 7]:
         for col in range(8):
             board[row][col] = 1
     ```

3. **בדיקת קפיצה חוקית (`is_valid_jump`)**:
   - מקבל כקלט את מיקום ההתחלה (start) והסיום (end) של הקפיצה.
   - בודק אם מיקום הסיום בתוך הלוח.
   - בודק אם מיקום הסיום ריק.
   - מחשב את מיקום האמצע (mid) בין ההתחלה לסיום.
   - בודק אם יש כלי באמצע.
   - בודק אם הקפיצה היא אלכסונית (הפרש השורות והעמודות הוא 2).
   - אם כל התנאים מתקיימים, מחזיר `True`, אחרת `False`.
   - דוגמה:
     ```
     start = (0, 0), end = (2, 2)  # קפיצה אפשרית אם יש כלי ב-(1,1)
     is_valid_jump((0, 0), (2, 2))  # אם board[1][1] == 1, מחזיר True
     ```

4. **ביצוע קפיצה (`perform_jump`)**:
   - מקבל כקלט את מיקום ההתחלה והסיום.
   - מעדכן את הלוח - מזיז את הכלי ממיקום ההתחלה למיקום הסיום.
   - מסיר את הכלי שקפצו מעליו.
   - מגדיל את מונה הכלים שהוסרו.
   - דוגמה:
     ```
     start = (0, 0), end = (2, 2)
     perform_jump((0, 0), (2, 2))
     # board[0][0] = 0, board[2][2] = 1, board[1][1] = 0
     removed_checkers = 1
     ```

5. **חיפוש קפיצות אפשריות (`find_possible_jumps`)**:
   - עובר על כל הלוח.
   - עבור כל כלי, בודק את ארבעת הכיוונים האלכסוניים האפשריים לקפיצה.
   - אם הקפיצה חוקית, מוסיף את מיקום ההתחלה והסיום לרשימת הקפיצות.
   - מחזיר את רשימת כל הקפיצות האפשריות.
   - דוגמה:
     ```
     jumps = []
     for row in range(8):
         for col in range(8):
             if board[row][col] == 1:
                 for dr, dc in [(-2, -2), (-2, 2), (2, -2), (2, 2)]:
                     start = (row, col)
                     end = (row + dr, col + dc)
                     if is_valid_jump(start, end):
                         jumps.append((start, end))
     ```

6. **משחק (`play`)**:
   - כל עוד קיימות קפיצות אפשריות:
     - מוצא את כל הקפיצות האפשריות.
     - מבצע את הקפיצה הראשונה ברשימה.
   - מדפיס את מספר הכלים שהוסרו.
   - דוגמה:
     ```
     while True:
         jumps = find_possible_jumps()
         if not jumps:
             break
         start, end = jumps[0]
         perform_jump(start, end)
     print(f"Total checkers removed: {removed_checkers}")
     ```

7. **הצגת הלוח (`display_board`)**:
   - מדפיס את הלוח למסך כאשר כלים מיוצגים על ידי `•` ומשבצות ריקות על ידי `.`.
   - דוגמה:
     ```
     for row in board:
        print(" ".join("•" if cell == 1 else "." for cell in row))
     ```

## <mermaid>

```mermaid
flowchart TD
    Start --> InitializeBoard[אתחול לוח משחק: <br><code>board</code>: לוח 8x8, <br><code>removed_checkers</code>: 0]
    InitializeBoard --> InitializeCheckers[אתחול כלים: <br>48 כלים בשורות 1 ו-8]
    InitializeCheckers --> GameLoop[לולאת המשחק]

    subgraph Game Loop
        GameLoop --> FindJumps[חיפוש קפיצות אפשריות: <br><code>find_possible_jumps()</code>]
        FindJumps -- קפיצות קיימות --> PerformJump[ביצוע קפיצה: <br><code>perform_jump()</code>]
        PerformJump --> GameLoop
        FindJumps -- אין קפיצות --> EndGame[סוף משחק]
    end
    
     EndGame --> PrintRemoved[הדפסת מספר הכלים שהוסרו]
    PrintRemoved --> DisplayFinalBoard[הצגת הלוח הסופי]
   DisplayFinalBoard --> Stop[סיום]


    
    subgraph Function Details
      direction LR
    FindJumps -->  ValidateJump[בדיקת חוקיות הקפיצה: <br><code>is_valid_jump()</code>]
     ValidateJump -- קפיצה חוקית -->  AddJumpToList[הוספת קפיצה לרשימה]
    
    
    PerformJump --> UpdateBoard[עדכון לוח המשחק: <br>הזזת כלי, <br>הסרת כלי שנקפץ מעליו]
    UpdateBoard --> IncrementRemoved[הגדלת מונה הכלים שהוסרו]
    
    
    end
  
  
```

## <explanation>

### ייבואים (Imports)

אין ייבוא של חבילות חיצוניות בקוד הזה. הקוד בנוי כמודול עצמאי, כך שאין תלות בחבילות `src.` אחרות.

### מחלקות (Classes)

- `Checkerboard`:
  - **תפקיד**: מייצגת את לוח הדמקה ומנהלת את כללי המשחק.
  - **מאפיינים**:
    - `board`: רשימה דו-ממדית המייצגת את לוח המשחק. 0 מסמן משבצת ריקה, 1 מסמן כלי דמקה.
    - `removed_checkers`: מונה של כלים שהוסרו במהלך המשחק.
  - **שיטות**:
    - `__init__()`: אתחול לוח המשחק עם 48 כלים.
    - `initialize_checkers()`: ממקם את הכלים בשורות החיצוניות.
    - `is_valid_jump(start, end)`: בודק אם קפיצה ממיקום התחלה למיקום סיום חוקית.
    - `perform_jump(start, end)`: מבצע את הקפיצה, מעדכן את הלוח ומגדיל את מונה הכלים שהוסרו.
    - `find_possible_jumps()`: מוצא את כל הקפיצות האפשריות בלוח.
    - `play()`: מדמה את המשחק על ידי ביצוע קפיצות עד שאין עוד אפשרויות.
    - `display_board()`: מציג את מצב הלוח הנוכחי למסך.

    **אינטראקציה**: מחלקת `Checkerboard` עומדת בפני עצמה ואינה מקיימת אינטראקציה עם חלקים אחרים בפרויקט.

### פונקציות (Functions)

- אין פונקציות חיצוניות, כל הפונקציות הן שיטות בתוך המחלקה `Checkerboard`.
- הפירוט של כל אחת מהפונקציות מופיע תחת הסעיף "מחלקות".

### משתנים (Variables)

- `board`: רשימה דו-ממדית (רשימה של רשימות) המייצגת את לוח המשחק. סוג: רשימה. השימוש: אחסון מצב הלוח בכל רגע נתון.
- `removed_checkers`: מונה של מספר הכלים שהוסרו. סוג: int. השימוש: מעקב אחרי כמות הכלים שהוסרו במהלך המשחק.
- `start`, `end`: מיקומים בלוח המשחק, מיוצגים כזוגות (tuple) של (row, col). סוג: tuple. השימוש: סימון מיקום ההתחלה והסיום של קפיצה.
- `dr`, `dc`: שינוי המיקום בשורות ועמודות, המשמש לבדיקת קפיצות אפשריות. סוג: int. השימוש: קביעת הכיוון של הקפיצות האלכסוניות.
- `jumps`: רשימה של כל הקפיצות האפשריות. סוג: list. השימוש: אחסון הקפיצות האפשריות במהלך המשחק.

### בעיות אפשריות ותחומים לשיפור

- **בחירת קפיצות**: הקוד הנוכחי מבצע את הקפיצה הראשונה שהוא מוצא. ניתן לשפר זאת על ידי יישום אלגוריתם שבוחר את הקפיצות האופטימליות להסרת כמות מקסימלית של כלים.
- **אופטימיזציה**: אפשר לשפר את הקוד מבחינת מהירות על ידי אופטימיזציה של הלולאות והבדיקות.
- **משחק אינטראקטיבי**: הקוד הנוכחי מבצע את המשחק באופן אוטומטי. אפשר להוסיף אפשרות למשתמש לשחק ולבחור את הקפיצות.
- **ממשק משתמש**: אפשר ליצור ממשק גרפי (GUI) למשחק במקום להציג את הלוח בטקסט.
- **הרחבת הכללים**: אפשר להרחיב את המשחק עם כללים נוספים, כמו הפיכת כלי למלכה.

### שרשרת קשרים עם חלקים אחרים בפרויקט

- אין קשר ישיר עם חלקים אחרים בפרויקט, מכיוון שהקוד הוא עצמאי. ניתן להשתמש במחלקה `Checkerboard` כחלק ממערכת גדולה יותר של משחקי AI.
- ניתן להרחיב את הפרויקט על ידי יצירת מודולים נוספים עבור AI שיכול לשחק את המשחק, מודול לאינטראקציה עם משתמש וכו'.