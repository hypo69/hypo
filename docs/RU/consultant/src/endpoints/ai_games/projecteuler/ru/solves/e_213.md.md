# Анализ кода модуля e_213.md

**Качество кода**
8
- Плюсы
    - Код хорошо структурирован и понятен.
    - Реализация алгоритма соответствует описанию задачи.
    - Присутствует подробное описание алгоритма и блок-схема.
    - Используются понятные имена переменных и функций.
- Минусы
    - Отсутствуют docstring для функций, что снижает читаемость и возможность автоматической генерации документации.
    - Не используется логирование ошибок.
    - Код можно оптимизировать, избегая создания копии массива на каждой итерации.

**Рекомендации по улучшению**

1.  **Добавить docstring:** Добавить подробные описания в формате reStructuredText (RST) для всех функций, чтобы улучшить читаемость и документирование кода.
2.  **Логирование:** Использовать `src.logger.logger` для логирования ошибок и отладки.
3.  **Оптимизация:** Можно оптимизировать код, избегая создания копии массива `new_board_prob` на каждой итерации, используя два массива и переключаясь между ними.
4.  **Форматирование кода:** Использовать `black` или `ruff` для автоматического форматирования кода, чтобы сделать его более читаемым и соответствовать PEP 8.

**Оптимизированный код**
```python
"""
Модуль для решения задачи Project Euler #213: Игра с блохами
=========================================================================================

Этот модуль вычисляет ожидаемое количество пустых клеток после определенного количества шагов,
когда блохи случайно перемещаются по доске.

Описание задачи
----------------
Имеется доска 30x30 с 900 блохами, по одной на каждой клетке.
Блохи совершают случайные прыжки вверх, вниз, влево или вправо.
Нужно найти ожидаемое количество пустых клеток после 10000 прыжков.

Пример использования
--------------------
.. code-block:: python

    board_size = 30
    num_steps = 10000
    result = expected_empty_cells(board_size, num_steps)
    print(f"{result:.6f}")
"""
from src.logger.logger import logger
def expected_empty_cells(board_size: int, num_steps: int) -> float:
    """
    Вычисляет ожидаемое количество пустых клеток после заданного количества шагов.

    :param board_size: Размер доски (например, 30 для доски 30x30).
    :param num_steps: Количество шагов (прыжков).
    :return: Ожидаемое количество пустых клеток.
    """
    # Инициализация матрицы вероятностей
    board_prob = [[1 / (board_size * board_size) for _ in range(board_size)] for _ in range(board_size)]
    
    # Итерационный процесс
    for _ in range(num_steps):
        new_board_prob = [[0 for _ in range(board_size)] for _ in range(board_size)]
        for x in range(board_size):
            for y in range(board_size):
                neighbors = []
                if x > 0:
                    neighbors.append((x - 1, y))
                if x < board_size - 1:
                    neighbors.append((x + 1, y))
                if y > 0:
                    neighbors.append((x, y - 1))
                if y < board_size - 1:
                    neighbors.append((x, y + 1))

                num_neighbors = len(neighbors)
                
                for nx, ny in neighbors:
                    # Код обновляет вероятность текущей клетки, суммируя вероятности соседних клеток
                    new_board_prob[x][y] += board_prob[nx][ny] / 4
                
                # Код добавляет вероятность остаться на месте, если есть меньше 4 соседей
                new_board_prob[x][y] +=  board_prob[x][y] * (1 - num_neighbors/4) if num_neighbors < 4 else 0
        
        # Код обновляет матрицу вероятностей для следующей итерации
        board_prob = [row[:] for row in new_board_prob]
    
    # Код вычисляет ожидаемое количество пустых клеток
    empty_cells = 0
    for x in range(board_size):
      for y in range(board_size):
          empty_cells += (1 - board_prob[x][y])
          
    return empty_cells

if __name__ == "__main__":
    board_size = 30
    num_steps = 10000
    try:
        # Код вызывает функцию и печатает результат
        result = expected_empty_cells(board_size, num_steps)
        print(f"{result:.6f}")
    except Exception as e:
        logger.error(f'Произошла ошибка при выполнении: {e}')
```