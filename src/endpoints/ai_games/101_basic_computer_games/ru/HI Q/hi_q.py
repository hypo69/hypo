
HI Q:
=================
Сложность: 4
-----------------
Игра "HI Q" представляет собой головоломку, в которой нужно удалить шарики с доски, перепрыгивая через них. Цель игры - оставить на доске только один шарик. Игрок выбирает шарик и направление, в котором он будет перепрыгивать. Игра заканчивается, когда больше нет возможных ходов или остался только один шарик.
Правила игры:
1.  На доске расположено некоторое количество шариков.
2.  Игрок выбирает шарик и направление (вверх, вниз, влево, вправо).
3.  Выбранный шарик перепрыгивает через соседний шарик в указанном направлении, удаляя тот шарик, через который перепрыгнули.
4.  Перепрыгивание возможно, если за соседним шариком есть свободное место.
5.  Цель игры - оставить на доске только один шарик.
6.  Игра заканчивается, когда больше нет возможных ходов или остался только один шарик.
-----------------
Алгоритм:
1.  Инициализировать доску (массив) с шариками.
2.  Начать игровой цикл:
3.  Вывести текущее состояние доски на экран.
4.  Запросить у пользователя координаты шарика и направление.
5.  Проверить, допустим ли ход (есть ли шарик в выбранной позиции, есть ли шарик для перепрыгивания и есть ли свободная клетка для приземления).
6.  Если ход допустим:
    6.1. Удалить шарик, через который перепрыгнули.
    6.2. Переместить выбранный шарик на новое место.
7.  Если ход недопустим:
    7.1. Сообщить об ошибке и повторить ввод.
8.  Проверить, есть ли еще возможные ходы (есть ли шарики, которые могут перепрыгнуть через другие шарики).
9.  Если возможных ходов нет или остался только один шарик, завершить игру.
10. Если остался один шарик, вывести сообщение о победе.
11. Если возможных ходов нет, вывести сообщение о поражении.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["Инициализация доски с шариками"]
    InitializeBoard --> GameLoopStart{"Начало игрового цикла"}
    GameLoopStart --> DisplayBoard["Вывод текущего состояния доски"]
    DisplayBoard --> GetMove["Получение ввода пользователя: координаты шарика и направление"]
    GetMove --> ValidateMove{"Проверка допустимости хода"}
    ValidateMove -- Ход допустим --> MakeMove["Выполнение хода: удаление перепрыгнутого шарика, перемещение выбранного шарика"]
    MakeMove --> CheckEndGame{"Проверка окончания игры: нет возможных ходов или остался один шарик"}
    ValidateMove -- Ход недопустим --> OutputInvalidMove["Вывод сообщения об ошибке"]
    OutputInvalidMove --> GameLoopStart
    CheckEndGame -- Игра не закончена --> GameLoopStart
    CheckEndGame -- Остался один шарик --> OutputWin["Вывод сообщения о победе"]
    OutputWin --> End["Конец игры"]
    CheckEndGame -- Нет возможных ходов --> OutputLose["Вывод сообщения о поражении"]
    OutputLose --> End

```
**Legenda**:
    Start - Начало программы.
    InitializeBoard - Инициализация игрового поля (доски) с шариками в начальной конфигурации.
    GameLoopStart - Начало цикла, представляющего основную логику игры.
    DisplayBoard - Вывод текущего состояния игрового поля на экран.
    GetMove - Получение ввода от пользователя: выбор шарика и направления хода.
    ValidateMove - Проверка, является ли выбранный ход допустимым согласно правилам игры.
    MakeMove - Выполнение хода, включая удаление перепрыгнутого шарика и перемещение выбранного шарика на новое место.
    CheckEndGame - Проверка, завершена ли игра (остался один шарик или нет возможных ходов).
    OutputInvalidMove - Вывод сообщения об ошибке, если ход был недопустим.
    OutputWin - Вывод сообщения о победе, если остался один шарик.
    OutputLose - Вывод сообщения о поражении, если нет возможных ходов.
    End - Конец программы.
```
```python
# Игра HI Q
# Эта игра является реализацией головоломки, в которой нужно удалить шарики с доски, перепрыгивая через них.
# Цель игры - оставить на доске только один шарик.
# Игрок выбирает шарик и направление, в котором он будет перепрыгивать.
# Игра заканчивается, когда больше нет возможных ходов или остался только один шарик.

def init_board():
    """
    Инициализирует игровое поле с начальным расположением шариков.
    Возвращает список списков, представляющий доску.
    """
    board = [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0]
    ]
    return board

def print_board(board):
    """
    Выводит текущее состояние игрового поля на экран.
    Принимает список списков board, представляющий доску.
    """
    for row in board:
        print(' '.join(map(str, row)))

def get_move():
    """
    Запрашивает у пользователя координаты шарика и направление хода.
    Возвращает кортеж (row, col, direction), где direction: 'u', 'd', 'l', 'r'.
    """
    while True:
        try:
            row = int(input("Введите строку шарика (0-6): "))
            col = int(input("Введите столбец шарика (0-6): "))
            direction = input("Введите направление (u/d/l/r): ").lower()
            if 0 <= row <= 6 and 0 <= col <= 6 and direction in ['u', 'd', 'l', 'r']:
                return row, col, direction
            else:
                print("Неверный ввод. Попробуйте еще раз.")
        except ValueError:
            print("Неверный ввод. Попробуйте еще раз.")

def is_valid_move(board, row, col, direction):
    """
    Проверяет, является ли ход допустимым.
    Принимает board, row, col, и direction.
    Возвращает True, если ход допустим, иначе False.
    """
    if board[row][col] != 1: # Проверяем, что в выбранной ячейке есть шарик
        return False

    if direction == 'u':
        if row < 2 or board[row - 1][col] != 1 or board[row - 2][col] != 0:
            return False
    elif direction == 'd':
        if row > 4 or board[row + 1][col] != 1 or board[row + 2][col] != 0:
            return False
    elif direction == 'l':
        if col < 2 or board[row][col - 1] != 1 or board[row][col - 2] != 0:
             return False
    elif direction == 'r':
         if col > 4 or board[row][col + 1] != 1 or board[row][col + 2] != 0:
             return False

    return True

def make_move(board, row, col, direction):
    """
    Выполняет ход, обновляя состояние игрового поля.
    Принимает board, row, col, и direction.
    Возвращает обновленный board.
    """
    if direction == 'u':
        board[row][col] = 0
        board[row - 1][col] = 0
        board[row - 2][col] = 1
    elif direction == 'd':
        board[row][col] = 0
        board[row + 1][col] = 0
        board[row + 2][col] = 1
    elif direction == 'l':
        board[row][col] = 0
        board[row][col - 1] = 0
        board[row][col - 2] = 1
    elif direction == 'r':
        board[row][col] = 0
        board[row][col + 1] = 0
        board[row][col + 2] = 1
    return board


def has_moves(board):
    """
     Проверяет, есть ли еще возможные ходы.
     Принимает board.
     Возвращает True, если есть возможные ходы, иначе False.
    """
    for row in range(len(board)):
        for col in range(len(board[row])):
            if board[row][col] == 1:
                if is_valid_move(board, row, col, 'u') or \
                   is_valid_move(board, row, col, 'd') or \
                   is_valid_move(board, row, col, 'l') or \
                   is_valid_move(board, row, col, 'r'):
                    return True
    return False

def count_pegs(board):
    """
     Считает количество шариков на доске.
     Принимает board.
     Возвращает количество шариков.
    """
    count = 0
    for row in board:
        count += row.count(1)
    return count


def play_hi_q():
    """
    Основная функция игры HI Q.
    Содержит игровой цикл, управление ходами и проверку на победу/проигрыш.
    """
    board = init_board() # инициализируем доску
    while True: # игровой цикл
        print_board(board) # Выводим текущее состояние доски
        row, col, direction = get_move() # Запрашиваем у пользователя координаты и направление
        if is_valid_move(board, row, col, direction): # Проверяем допустимость хода
            board = make_move(board, row, col, direction) # делаем ход
            if count_pegs(board) == 1: # проверяем остался ли только один шарик
                print_board(board)
                print("Поздравляю! Вы выиграли!")
                break
            if not has_moves(board): # Проверяем есть ли еще ходы
                print_board(board)
                print("Увы, ходов больше нет. Вы проиграли!")
                break
        else:
            print("Недопустимый ход. Попробуйте еще раз.")

if __name__ == "__main__":
    play_hi_q()
```
```
Объяснение кода:
1. **Функция `init_board()`:**
   -   Инициализирует игровое поле (доску) как список списков (матрицу) и возвращает его.
   -   Игровое поле имеет размер 7x7, где `1` обозначает наличие шарика, а `0` - отсутствие.
   -   Начальное расположение шариков соответствует правилам игры HI Q.
2. **Функция `print_board(board)`:**
   -   Принимает текущее состояние доски (`board`) в качестве аргумента.
   -   Выводит текущее состояние доски на экран, отображая `1` как шарики и `0` как пустые места.
3. **Функция `get_move()`:**
   -   Запрашивает у пользователя координаты шарика (строка и столбец) и направление перемещения (`u` - вверх, `d` - вниз, `l` - влево, `r` - вправо).
   -   Использует цикл `while True` для повторного запроса ввода, если введенные данные некорректны.
   -   Возвращает кортеж из строки, столбца и направления.
4. **Функция `is_valid_move(board, row, col, direction)`:**
   -   Проверяет, является ли выбранный ход допустимым согласно правилам игры.
   -   Принимает игровое поле (`board`), строку, столбец и направление как аргументы.
   -   Проверяет, есть ли шарик в выбранной позиции.
   -   Проверяет, есть ли шарик для перепрыгивания и свободное место для приземления в выбранном направлении.
   -   Возвращает `True`, если ход допустим, и `False` в противном случае.
5. **Функция `make_move(board, row, col, direction)`:**
   -   Выполняет ход, обновляя состояние игрового поля.
   -   Принимает игровое поле (`board`), строку, столбец и направление как аргументы.
   -   Удаляет перепрыгнутый шарик, перемещает выбранный шарик на новое место.
   -   Возвращает обновленное игровое поле.
6. **Функция `has_moves(board)`:**
    - Проверяет, есть ли еще возможные ходы на игровом поле.
    - Проходит по всем ячейкам, проверяя, может ли шарик в данной ячейке совершить допустимый ход.
    - Возвращает `True`, если есть хотя бы один возможный ход, иначе `False`.
7. **Функция `count_pegs(board)`:**
    - Считает количество шариков (единиц) на игровом поле.
    - Проходит по всем строкам и подсчитывает общее количество `1`.
    - Возвращает общее количество шариков на доске.
8. **Функция `play_hi_q()`:**
   -   Содержит основной игровой цикл.
   -   Инициализирует доску, вызывает функции ввода хода, проверки допустимости хода, выполнения хода, и проверки на победу/проигрыш.
   -   Выводит сообщения о победе или поражении.
9.  **Условие `if __name__ == "__main__":`:**
    -   Запускает функцию `play_hi_q()` только при непосредственном запуске скрипта.

```