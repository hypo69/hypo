## <algorithm>

1. **הגדרת משתנים וייבוא ספריות:**
    - ייבוא מודולים `os`, `pathlib`, ו-`google.generativeai`.
    - הגדרת מחלקה `GoogleGenerativeAI`.
    - הגדרת משתנה `MODELS` המכיל רשימה של מודלים של ג'מיני.

2. **אתחול המחלקה `GoogleGenerativeAI`:**
   - מקבל מפתח API, הוראה למערכת ושם מודל כפרמטרים.
   - מגדיר את מפתח ה-API ומשתנה השם של המודל.
   - מגדיר את המודל `genai.GenerativeModel`.
   - *דוגמה:*  `model = GoogleGenerativeAI(api_key="your_api_key", system_instruction="You are a helpful assistant", model_name="gemini-2-13b")`

3. **שיטת `ask` של המחלקה `GoogleGenerativeAI`:**
   - מקבלת שאילתה כקלט.
   - מנסה לשלוח את השאילתה למודל.
   - מחזירה את תגובת המודל או הודעת שגיאה.
   - *דוגמה:*  `response = model.ask("What is 2 + 2?")`
   - *זרימת נתונים:*  קלט `q` (שאילתה) -> מודל genai -> פלט `response.text` (תגובה).

4. **פונקציה `set_key`:**
   - מקבלת נתיב לקובץ `.env`, מפתח וערך.
   - אם הקובץ קיים, היא מעדכנת את המפתח או מוסיפה אותו אם הוא לא קיים.
   - אם הקובץ לא קיים, היא יוצרת את הקובץ ומוסיפה את המפתח והערך.
   - *דוגמה:*  `set_key(".env", "API_KEY", "new_api_key")`

5. **התחלת התוכנית (`if __name__ == '__main__':`)**
    -   קבלת הנתיב המוחלט של הקובץ הנוכחי.
    -   הגדרת נתיב יחסי לספריית המשחקים.
    -   יצירת נתיב מוחלט לספריית המשחקים.
    -   קריאת מפתח ה-API ממשתנה הסביבה.
    -   אם מפתח ה-API לא נמצא, הוא מתקבל כקלט מהמשתמש ונשמר בקובץ `.env`.
    - הגדרת מילון `instructions` המקשר בין בחירת משחק למסמך ההוראות שלו.
    - הדפסת הודעת פתיחה ורשימת משחקים.

6. **לולאה ראשית:**
   - הצגת תפריט למשתמש ובקשה לבחירת משחק.
    - אם המשתמש בוחר "q", הלולאה מסתיימת והתוכנית נסגרת.
    - אם המשתמש בוחר משחק:
        - קריאת ההוראות למערכת מקובץ ה-MD המתאים.
        - יצירת מופע של המחלקה `GoogleGenerativeAI` עם מפתח ה-API והוראות המערכת.
        - אם נבחר המשחק "1" ("input_output"):
            - לולאה פנימית לקבלת קלט מהמשתמש.
            - אם המשתמש בוחר "q", הלולאה מסתיימת.
            - שליחת השאילתה למודל והדפסת התגובה.
        - אם נבחר המשחק "2" ("ten_cent_computer"):
            - לולאה פנימית לקבלת קלט מהמשתמש.
            - אם המשתמש בוחר "q", הלולאה מסתיימת.
            - שליחת השאילתה למודל והדפסת התגובה.
   - אם הבחירה של המשתמש לא תקינה, הודעת שגיאה תוצג.

## <mermaid>

```mermaid
flowchart TD
    A[Start] --> B{קבלת נתיב מוחלט של הקובץ};
    B --> C{הגדרת נתיב יחסי לספריית המשחקים};
    C --> D{יצירת נתיב מוחלט לספריית המשחקים};
    D --> E{קריאת מפתח API ממשתנה סביבה};
    E --> F{מפתח API קיים?};
    F -- כן --> G{הגדרת מילון הוראות};
    F -- לא --> H{קבלת מפתח API מהמשתמש};
    H --> I{שמירת מפתח API בקובץ .env};
    I --> G;
    G --> J{הצגת תפריט למשתמש};
    J --> K{בחירת משחק};
    K --> L{האם המשתמש בחר לצאת ("q")?};
    L -- כן --> M[סיום];
    L -- לא --> N{האם בחירת משחק תקינה?};
    N -- כן --> O{קריאת הוראות מערכת מקובץ MD};
    O --> P{יצירת מופע של המחלקה GoogleGenerativeAI};
    P --> Q{האם נבחר משחק "1" (input_output)?};
    Q -- כן --> R{לולאה: קבלת קלט מהמשתמש};
    R --> S{האם המשתמש בחר לצאת ("q")?};
    S -- כן --> K;
    S -- לא --> T{שליחת שאילתה למודל והדפסת תגובה};
    T --> R;
    Q -- לא --> U{האם נבחר משחק "2" (ten_cent_computer)?};
    U -- כן --> V{לולאה: קבלת קלט מהמשתמש};
        V --> W{האם המשתמש בחר לצאת ("q")?};
    W -- כן --> K;
    W -- לא --> X{שליחת שאילתה למודל והדפסת תגובה};
        X --> V;
     U -- לא --> Y{הודעת שגיאה};
     Y --> K;
    
    
```

## <explanation>

**ייבואים (Imports):**

*   `import os`: מספק דרך לקיים אינטראקציה עם מערכת ההפעלה, כגון קריאת משתני סביבה.
*   `from pathlib import Path`: מספק דרך אובייקטית לעבודה עם נתיבי קבצים וספריות.
*   `import google.generativeai as genai`: מייבא את הספריה של גוגל generative ai, ומאפשר להשתמש במודלים של ג'מיני.

**מחלקות (Classes):**

*   `GoogleGenerativeAI`:
    *   תפקיד: מחלקה זו מגדירה את האינטראקציה עם מודל ה-Generative AI של גוגל.
    *   מאפיינים:
        *   `MODELS`: רשימה של מודלים זמינים של ג'מיני.
        *   `api_key`: מפתח API לאימות מול גוגל.
        *   `model_name`: שם המודל הספציפי של ג'מיני לשימוש.
        *   `model`: מופע של המודל `genai.GenerativeModel`.
    *   שיטות:
        *   `__init__(api_key, system_instruction, model_name)`: מאתחלת את המודל עם מפתח ה-API, ההוראות למערכת ושם המודל.
        *   `ask(q)`: שולחת שאילתה למודל ומחזירה את התגובה.

**פונקציות (Functions):**

*   `set_key(dotenv_path, key, value)`:
    *   פרמטרים:
        *   `dotenv_path`: נתיב לקובץ `.env`.
        *   `key`: מפתח לשימור.
        *   `value`: הערך לשמירה.
    *   מטרה: שומרת זוג מפתח-ערך בקובץ `.env`. אם הקובץ קיים, מעדכנת את המפתח או מוסיפה אותו. אם הקובץ לא קיים, יוצרת אותו.
    *   דוגמה: `set_key(".env", "API_KEY", "your_api_key")`

**משתנים (Variables):**

*   `__root__`: נתיב מוחלט לספרייה הראשית של הפרויקט.
*   `relative_path`: נתיב יחסי לספריית המשחקים.
*   `base_path`: נתיב מוחלט לספריית המשחקים.
*   `API_KEY`: מפתח API של ג'מיני (נקרא ממשתני סביבה או קלט מהמשתמש).
*   `instructions`: מילון הממפה בין מספר בחירת המשחק לשם קובץ הוראות המשחק.
*   `choice`: בחירת המשתמש של המשחק הרצוי.
*   `system_instruction`: ההוראות למערכת נקראות מקובץ MD בהתאם לבחירת המשחק.
*   `model`: מופע של המחלקה `GoogleGenerativeAI`.
*   `user_input`: קלט מהמשתמש עבור משחק ספציפי.
*   `response`: תגובת המודל על הקלט של המשתמש.

**בעיות אפשריות או תחומים לשיפור:**

*   **טיפול בשגיאות:** הקוד מטפל בשגיאות כלליות בשיטת ה`ask`, אבל כדאי להוסיף טיפול ספציפי יותר בסוגים שונים של שגיאות אפשריות.
*   **ניהול תצורה:** כרגע, מפתח ה-API נשמר בקובץ `.env`. כדאי לשקול להשתמש במערכת ניהול תצורה מתקדמת יותר, במיוחד כאשר יש יותר הגדרות.
*   **גמישות:** הקוד קבוע למשחקים 1 ו-2. כדאי להפוך אותו ליותר גמיש, כך שניתן יהיה להוסיף משחקים נוספים בקלות.
*   **ארגון קוד:** אפשר לפצל את הלוגיקה של המשחקים לקבצים נפרדים כדי לשפר את קריאות הקוד ואת היכולת לתחזק אותו.
*   **אימות קלט:** יש צורך לוודא שהמשתמש מכניס רק את הערכים הנכונים ולטפל בשגיאות קלט.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

*   הקוד הנוכחי תלוי בספריה `google.generativeai` להתחברות למודל ג'מיני.
*   הוא משתמש במודולים `os` ו-`pathlib` כדי לעבוד עם מערכת הקבצים.
*   המשחקים עצמם מוגדרים בקבצי markdown (`input_output.md` ו-`ten_cent_computer.md`) בתוך תיקיית `games/ai` בתוך הפרוייקט.

בסך הכל, הקוד מספק מבנה בסיסי למשחקי AI, אבל ניתן לשפר אותו מבחינת גמישות, טיפול בשגיאות וארגון קוד.