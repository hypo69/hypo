## Ответ на Задачу No 366: Каноническое множество

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Необходимо найти сумму всех элементов канонического множества, все элементы которого не превосходят заданного числа `n`.
*   Каноническое множество определяется тем, что для каждого элемента `n` множества существует ровно один способ представить `n` в виде суммы двух различных элементов множества.
*   Необходимо найти `S(10^7)`.

**Решение:**

1.  **Представление множества:** Будем хранить текущее каноническое множество в виде `set`, чтобы эффективно проверять наличие элементов и выполнять операции.
2.  **Генерация элементов:** Начнем с минимального элемента 1, и будем добавлять элементы, проверяя, чтобы множество оставалось каноническим.
3.  **Проверка каноничности:** Для проверки каноничности необходимо для каждого нового элемента проверить количество способов его получения в виде суммы двух различных элементов из текущего множества. Если таких способов больше 1, то элемент не подходит.
4.  **Построение канонического множества:**
    *   Начнем с множества `{1}`.
    *   Рассмотрим кандидатов, начиная с 2, и для каждого кандидата проверяем:
    *   Перебираем все пары различных элементов из текущего множества.
    *   Если сумма пары равна кандидату, то увеличиваем счетчик представлений.
    *   Если количество представлений для кандидата равно нулю, то добавляем кандидата в множество, и продолжаем поиск.
    *   Если количество представлений для кандидата равно единице, то переходим к следующему кандидату.
    *   Если количество представлений больше единицы, то переходим к следующему кандидату.
5.  **Суммирование:** Когда сгенерированное множество достигнет предельного значения `n`, суммируем все его элементы.
6.  **Оптимизации:**
    *  На самом деле, нам не нужно проверять все пары на каждом шаге добавления. Последовательно добавляя элементы в множество, мы можем отслеживать количество представлений в виде суммы для каждого числа и если есть больше 1, значит этот кандидат не подходит. 
    *  Можно заметить, что каноническое множество генерируется последовательностью, где мы добавляем следующее наименьшее число, которое не может быть представлено более чем одним способом.

### 2. Алгоритм решения

1. Начать
2. Инициализировать каноническое множество `canonical_set` как `{1}`
3. Инициализировать сумму элементов `canonical_sum` как `1`
4. Для каждого числа `candidate` от 2 до `n`
   *  Инициализировать счетчик представлений `representation_count` как 0
   *  Для каждой пары `(i, j)` различных элементов из `canonical_set`
        * Если `i + j == candidate`
            *  Увеличить `representation_count` на 1
   *  Если `representation_count == 0`
        *   Добавить `candidate` в `canonical_set`
        *   Увеличить `canonical_sum` на `candidate`
        *   Перейти к следующему `candidate`
   *  Если `representation_count == 1`
        *  Перейти к следующему `candidate`
   *  Если `representation_count > 1`
        *  Перейти к следующему `candidate`
5. Вернуть `canonical_sum`
6. Конец

### 3. Реализация на Python 3.12
```python
def is_canonical(current_set, candidate):
    count = 0
    for i in current_set:
        for j in current_set:
            if i != j and i + j == candidate:
                count += 1
    return count == 0

def sum_canonical_set(limit):
    canonical_set = {1}
    total_sum = 1
    candidate = 2
    while True:
        if is_canonical(canonical_set, candidate):
            canonical_set.add(candidate)
            total_sum += candidate
        if candidate >= limit:
           break
        candidate +=1

    return total_sum

limit = 10**7
result = sum_canonical_set(limit)
print(result)
```
### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeSet((Инициализировать canonical_set = {1}, canonical_sum = 1, candidate = 2))
    InitializeSet --> LoopStart((Начать цикл: candidate от 2 до n))
    LoopStart --> InitializeCount((Инициализировать representation_count = 0))
    InitializeCount --> InnerLoopStart((Начать цикл по парам i, j в canonical_set, i != j))
    InnerLoopStart --> CheckSum((Проверить: i + j == candidate?))
    CheckSum -- Да --> IncrementCount((Увеличить representation_count))
    IncrementCount --> InnerLoopStart
    CheckSum -- Нет --> InnerLoopStart
    InnerLoopStart --> CheckCount((representation_count == 0?))
    CheckCount -- Да --> AddToSet((Добавить candidate в canonical_set, добавить candidate к canonical_sum))
    AddToSet --> CheckLimit((candidate >= limit?))
    CheckCount -- Нет --> CheckCountOne((representation_count == 1?))
    CheckCountOne -- Да --> CheckLimit
    CheckCountOne -- Нет --> CheckLimit
    CheckLimit -- Да --> Output((Вернуть canonical_sum))
    CheckLimit -- Нет --> LoopStart
    Output --> End((Конец))
```

**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать canonical\_set = {1}, canonical\_sum = 1, candidate = 2:** Инициализируем множество, сумму и кандидата.
*   **Начать цикл: candidate от 2 до n:** Цикл перебора всех кандидатов от 2 до n.
*   **Инициализировать representation\_count = 0:** Сбрасываем счетчик представлений для каждого кандидата.
*   **Начать цикл по парам i, j в canonical\_set, i != j:** Вложенный цикл перебора пар элементов множества.
*  **Проверить: i + j == candidate?:** Проверка, являются ли i и j парой элементов, сумма которых равна текущему кандидату.
*   **Увеличить representation\_count:** Увеличиваем счетчик представлений, если найдена пара.
*   **representation\_count == 0?:** Проверка на то, что количество представлений равно 0.
*   **Добавить candidate в canonical\_set, добавить candidate к canonical\_sum:** Если представлений нет, то кандидат добавляется в множество и его значение добавляется к общей сумме.
*   **candidate >= limit?:** Проверка, достигнут ли предел для кандидата.
* **representation_count == 1?:** Проверка, что представление единственно.
*   **Вернуть canonical\_sum:** Вывод суммы всех элементов.
