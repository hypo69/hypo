## Ответ на Задачу No 191: Призовые строки

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Нам нужно найти количество допустимых призовых билетов длиной 30 символов, где каждый символ может быть 'P', 'A' или 'L'.
*   Существуют два ограничения: не более двух 'L' в билете и не допускаются две 'A' подряд.

**Решение:**
*   Для решения данной задачи можно использовать динамическое программирование.
*   Создадим трехмерный массив `dp`, где `dp[i][j][k]` будет представлять количество допустимых билетов длины `i`, с `j` опозданиями ('L') и `k` - флаг, показывающий, заканчивается ли билет на 'A'(1) или нет(0).
*   Базовые случаи: для билета длины 1.
*   Переход: перебираем последний символ ('P', 'A', 'L') и обновляем `dp`.
*   Суммируем все допустимые варианты, т.е. `dp[30][j][k]` для всех допустимых `j` и `k`.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать трехмерный массив `dp` размером `[31][3][2]` нулями.
3.  Базовые случаи:
    *   `dp[1][0][0] = 1` (билет 'P')
    *   `dp[1][0][1] = 1` (билет 'A')
    *   `dp[1][1][0] = 1` (билет 'L')
4.  Для `i` от 2 до 30: (длина билета)
    *   Для `j` от 0 до 2: (количество 'L')
        *   Для `k` от 0 до 1: (флаг 'A' на конце)
            *   Если `dp[i-1][j][k] > 0`: (есть допустимые билеты)
                *   // Добавляем 'P'
                `dp[i][j][0] += dp[i-1][j][k]`
                *   // Добавляем 'L', если `j < 2`
                если `j < 2`:
                   `dp[i][j+1][0] += dp[i-1][j][k]`
                *   // Добавляем 'A', если предыдущий символ не 'A'
                если `k == 0`:
                    `dp[i][j][1] += dp[i-1][j][k]`
5.  Инициализировать переменную `total_tickets` = 0
6.  Для `j` от 0 до 2
    *  Для `k` от 0 до 1:
         `total_tickets += dp[30][j][k]`
7.  Вернуть `total_tickets`
8.  Конец

### 3. Реализация на Python 3.12

```python
def count_prize_tickets(days):
    """
    Calculates the number of valid prize tickets of a given length.

    Args:
        days: The length of the prize ticket.

    Returns:
        The number of valid prize tickets.
    """
    dp = [[[0 for _ in range(2)] for _ in range(3)] for _ in range(days + 1)]

    # Базовые случаи для билетов длиной 1
    dp[1][0][0] = 1  # P
    dp[1][0][1] = 1  # A
    dp[1][1][0] = 1  # L

    for i in range(2, days + 1):
        for j in range(3):
            for k in range(2):
                if dp[i - 1][j][k] > 0:
                    # Добавляем 'P'
                    dp[i][j][0] += dp[i - 1][j][k]
                    # Добавляем 'L', если количество опозданий меньше 2
                    if j < 2:
                        dp[i][j + 1][0] += dp[i - 1][j][k]
                    # Добавляем 'A', если предыдущий символ не 'A'
                    if k == 0:
                        dp[i][j][1] += dp[i - 1][j][k]

    total_tickets = 0
    for j in range(3):
        for k in range(2):
            total_tickets += dp[days][j][k]

    return total_tickets


# Пример использования:
days = 30
result = count_prize_tickets(days)
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeDP((Инициализировать DP[31][3][2] = 0))
    InitializeDP --> BaseCases((Установить базовые случаи DP[1]))
    BaseCases --> LoopIStart((Начать цикл: i от 2 до 30))
    LoopIStart --> LoopJStart((Начать цикл: j от 0 до 2))
    LoopJStart --> LoopKStart((Начать цикл: k от 0 до 1))
    LoopKStart --> CheckDPValue((Проверить: DP[i-1][j][k] > 0?))
    CheckDPValue -- Да --> AddP((DP[i][j][0] += DP[i-1][j][k]))
    AddP --> CheckL((j < 2?))
    CheckL -- Да --> AddL((DP[i][j+1][0] += DP[i-1][j][k]))
    AddL --> CheckA((k == 0?))
    CheckL -- Нет --> CheckA
    CheckA -- Да --> AddA((DP[i][j][1] += DP[i-1][j][k]))
     AddA --> LoopKEnd((Конец цикла k))
    CheckA -- Нет -->  LoopKEnd
    CheckDPValue -- Нет --> LoopKEnd
    LoopKEnd --> LoopJEnd((Конец цикла j))
     LoopJEnd --> LoopIEnd((Конец цикла i))
    LoopIEnd --> InitializeTotalTickets((Инициализировать total_tickets = 0))
    InitializeTotalTickets --> LoopJTotal((Начать цикл j от 0 до 2))
    LoopJTotal --> LoopKTotal((Начать цикл k от 0 до 1))
    LoopKTotal --> AddToTotal((total_tickets += DP[30][j][k]))
    AddToTotal --> LoopKTotalEnd((Конец цикла k))
     LoopKTotalEnd --> LoopJTotalEnd((Конец цикла j))
    LoopJTotalEnd --> OutputTotal((Вернуть total_tickets))
    OutputTotal --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать DP:** Создание и заполнение нулями массива для хранения промежуточных результатов.
*   **Установить базовые случаи DP[1]:** Заполнение начальных значений DP для билетов длиной 1.
*   **Начать цикл: i от 2 до 30:** Цикл для перебора длин билетов.
*   **Начать цикл: j от 0 до 2:** Цикл для перебора количества опозданий.
*   **Начать цикл: k от 0 до 1:** Цикл для перебора флага окончания на 'A'.
*  **Проверить: DP[i-1][j][k] > 0?**: Проверка наличия допустимых билетов.
*   **DP[i][j][0] += DP[i-1][j][k]:** Добавление 'P' к текущему билету.
*   **j < 2?:** Проверка условия на максимальное количество опозданий.
*    **DP[i][j+1][0] += DP[i-1][j][k]:** Добавление 'L' к текущему билету.
*   **k == 0?:** Проверка предыдущего символа на 'A'.
*   **DP[i][j][1] += DP[i-1][j][k]:** Добавление 'A' к текущему билету.
*  **Конец цикла k:** Завершение цикла k
*  **Конец цикла j:** Завершение цикла j
*  **Конец цикла i:** Завершение цикла i
*   **Инициализировать total_tickets = 0:**  Инициализация переменной для хранения результата
*   **Начать цикл j от 0 до 2:**  Цикл перебора всех возможных опозданий
*   **Начать цикл k от 0 до 1:** Цикл перебора флага окончания на 'A'
*   **total_tickets += DP[30][j][k]:** Суммирование всех допустимых вариантов билетов
*   **Вернуть total_tickets:** Возвращение финального результата.
