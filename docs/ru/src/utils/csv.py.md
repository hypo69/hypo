# Модуль для работы с CSV и JSON файлами
=================================================

Модуль содержит функции для сохранения, чтения и конвертации данных между форматами CSV и JSON.
Он включает функции для записи списка словарей в CSV-файл, чтения CSV-файла в виде списка словарей,
конвертации CSV-файла в JSON-формат и чтения CSV-файла в виде словаря.

## Обзор

Модуль `src.utils.csv` предоставляет набор утилит для работы с CSV и JSON файлами. Он предназначен для упрощения операций чтения и записи данных в этих форматах, а также для конвертации между ними.
Модуль использует стандартные библиотеки `csv`, `json`, `pathlib` и `typing`, а также библиотеку `pandas` для расширенных возможностей.
Все функции модуля поддерживают обработку исключений и журналирование ошибок с использованием модуля `src.logger.logger`.

## Подробней

Этот модуль предоставляет инструменты для работы с CSV и JSON файлами, обеспечивая гибкость и удобство при обработке данных.
Он позволяет сохранять данные в формате CSV, читать CSV файлы в различных форматах (список словарей, словарь),
а также конвертировать CSV файлы в JSON формат. Использование модуля упрощает интеграцию с другими частями проекта,
где требуется работа с данными в этих форматах. Все функции модуля поддерживают журналирование ошибок, что облегчает отладку и мониторинг.

## Функции

### `save_csv_file`

```python
def save_csv_file(
    data: List[Dict[str, str]],
    file_path: Union[str, Path],
    mode: str = 'a',
    exc_info: bool = True,
) -> bool:
    """
    Сохраняет список словарей в CSV-файл.

    Args:
        data (List[Dict[str, str]]): Список словарей для сохранения.
        file_path (Union[str, Path]): Путь к CSV-файлу.
        mode (str): Режим файла ('a' для добавления, 'w' для перезаписи). По умолчанию 'a'.
        exc_info (bool): Включать ли информацию об исключении в логи.

    Returns:
        bool: True, если успешно, иначе False.

    Raises:
        TypeError: Если входные данные не являются списком словарей.
        ValueError: Если входные данные пусты.
    """
    ...
```

**Назначение**: Сохраняет список словарей в CSV-файл по указанному пути. Функция позволяет добавлять данные в существующий файл или перезаписывать его.

**Параметры**:
- `data` (List[Dict[str, str]]): Список словарей, которые нужно сохранить в CSV-файл. Каждый словарь представляет строку данных, где ключи словаря становятся заголовками столбцов.
- `file_path` (Union[str, Path]): Путь к CSV-файлу, в который будут сохранены данные. Может быть строкой или объектом `Path`.
- `mode` (str, optional): Режим открытия файла. `'a'` означает добавление данных в конец файла (если он существует), `'w'` означает перезапись файла. По умолчанию `'a'`.
- `exc_info` (bool, optional): Определяет, нужно ли включать трассировку исключений в сообщения журнала при возникновении ошибки. По умолчанию `True`.

**Возвращает**:
- `bool`: Возвращает `True`, если запись в файл прошла успешно, и `False` в случае ошибки.

**Вызывает исключения**:
- `TypeError`: Если `data` не является списком словарей.
- `ValueError`: Если `data` пуст.

**Как работает функция**:
1. **Проверка входных данных**: Функция проверяет, что входные данные являются списком словарей и не пусты. Если это не так, вызываются исключения `TypeError` или `ValueError` соответственно.
2. **Создание пути к файлу**: Преобразует `file_path` в объект `Path` для удобства работы с путями.
3. **Создание директории**: Создает родительскую директорию для файла, если она не существует. Параметр `exist_ok=True` предотвращает возникновение ошибки, если директория уже существует.
4. **Запись в файл**: Открывает файл в указанном режиме (`mode`) и записывает данные из списка словарей в CSV-файл.
    - Используется `csv.DictWriter` для записи словарей в CSV-файл.
    - Если файл открывается для записи (`mode == 'w'`) или файл не существует, записываются заголовки столбцов (ключи первого словаря).
    - Затем записываются все строки данных из списка словарей.
5. **Обработка исключений**: Если во время записи в файл возникает исключение, оно логируется с использованием `logger.error`, и функция возвращает `False`.

```
Проверка данных -> Преобразование пути -> Создание директории -> Открытие файла -> Запись данных -> Успех/Ошибка
```

**Примеры**:

```python
from pathlib import Path
import os

# Пример 1: Сохранение данных в новый CSV-файл
data = [{'name': 'John', 'age': '30'}, {'name': 'Jane', 'age': '25'}]
file_path = 'output.csv'
result = save_csv_file(data, file_path, mode='w')
print(f"Результат сохранения: {result}")  # Вывод: Результат сохранения: True

# Пример 2: Добавление данных в существующий CSV-файл
data = [{'name': 'Mike', 'age': '35'}]
file_path = 'output.csv'
result = save_csv_file(data, file_path, mode='a')
print(f"Результат добавления: {result}")  # Вывод: Результат добавления: True

# Пример 3: Указание пути через Path
data = [{'name': 'Alice', 'age': '28'}]
file_path = Path('output.csv')
result = save_csv_file(data, file_path, mode='a')
print(f"Результат добавления через Path: {result}")  # Вывод: Результат добавления через Path: True

# Пример 4: Путь к несуществующему файлу
file_path = Path('path/to/new/file.csv')
data = [{'col1': 'data1', 'col2': 'data2'}]
result = save_csv_file(data, file_path, mode='w')
print(f"Результат сохранения в новый файл: {result}")

# очистка
os.remove('output.csv')
```

### `read_csv_file`

```python
def read_csv_file(file_path: Union[str, Path], exc_info: bool = True) -> List[Dict[str, str]] | None:
    """
    Читает содержимое CSV-файла в виде списка словарей.

    Args:
        file_path (Union[str, Path]): Путь к CSV-файлу.
        exc_info (bool): Включать ли информацию об исключении в логи.

    Returns:
        List[Dict[str, str]] | None: Список словарей или None, если не удалось прочитать файл.

    Raises:
        FileNotFoundError: Если файл не найден.
    """
    ...
```

**Назначение**: Читает CSV-файл и преобразует его содержимое в список словарей, где каждый словарь представляет строку из CSV-файла.

**Параметры**:
- `file_path` (Union[str, Path]): Путь к CSV-файлу, который нужно прочитать. Может быть строкой или объектом `Path`.
- `exc_info` (bool, optional): Определяет, нужно ли включать трассировку исключений в сообщения журнала при возникновении ошибки. По умолчанию `True`.

**Возвращает**:
- `List[Dict[str, str]] | None`: Возвращает список словарей, где каждый словарь соответствует строке CSV-файла. Ключами словаря являются заголовки столбцов из первой строки CSV-файла. Возвращает `None`, если не удалось прочитать файл.

**Вызывает исключения**:
- `FileNotFoundError`: Если файл, указанный в `file_path`, не найден.

**Как работает функция**:
1. **Открытие файла**: Открывает CSV-файл, указанный в `file_path`, в режиме чтения (`'r'`) с кодировкой `utf-8`. Используется конструкция `with`, чтобы файл был автоматически закрыт после завершения работы.
2. **Чтение данных**: Использует `csv.DictReader` для чтения CSV-файла. `csv.DictReader` преобразует каждую строку CSV-файла в словарь, где ключами являются заголовки столбцов.
3. **Преобразование в список**: Преобразует итерируемый объект, возвращаемый `csv.DictReader`, в список словарей с помощью `list(reader)`.
4. **Обработка исключений**:
   - Если файл не найден (`FileNotFoundError`), функция логирует ошибку с использованием `logger.error` и возвращает `None`.
   - Если возникает любая другая ошибка (`Exception`), функция также логирует ошибку и возвращает `None`.

```
Открытие файла -> Чтение данных -> Преобразование в список -> Успех/Ошибка
```

**Примеры**:

```python
from pathlib import Path
import os
# Создаем временный CSV-файл для примера
file_path = "temp.csv"
with open(file_path, 'w', newline='', encoding='utf-8') as f:
    writer = csv.DictWriter(f, fieldnames=['name', 'age'])
    writer.writeheader()
    writer.writerow({'name': 'John', 'age': '30'})
    writer.writerow({'name': 'Jane', 'age': '25'})

# Пример 1: Чтение существующего CSV-файла
result = read_csv_file(file_path)
print(f"Результат чтения: {result}")
# Вывод: Результат чтения: [{'name': 'John', 'age': '30'}, {'name': 'Jane', 'age': '25'}]

# Пример 2: Чтение несуществующего CSV-файла
non_existent_file = "non_existent.csv"
result = read_csv_file(non_existent_file)
print(f"Результат чтения несуществующего файла: {result}")
# Вывод: Результат чтения несуществующего файла: None
os.remove(file_path)
```

### `read_csv_as_json`

```python
def read_csv_as_json(csv_file_path: Union[str, Path], json_file_path: Union[str, Path], exc_info: bool = True) -> bool:
    """
    Преобразует CSV-файл в JSON-формат и сохраняет его.

    Args:
        csv_file_path (Union[str, Path]): Путь к CSV-файлу.
        json_file_path (Union[str, Path]): Путь для сохранения JSON-файла.
        exc_info (bool): Включать ли информацию об исключении в логи.

    Returns:
        bool: True, если преобразование успешно, иначе False.
    """
    ...
```

**Назначение**: Преобразует содержимое CSV-файла в JSON-формат и сохраняет результат в новый файл.

**Параметры**:
- `csv_file_path` (Union[str, Path]): Путь к CSV-файлу, который нужно преобразовать. Может быть строкой или объектом `Path`.
- `json_file_path` (Union[str, Path]): Путь к файлу, в который будет сохранен JSON-файл. Может быть строкой или объектом `Path`.
- `exc_info` (bool, optional): Определяет, нужно ли включать трассировку исключений в сообщения журнала при возникновении ошибки. По умолчанию `True`.

**Возвращает**:
- `bool`: Возвращает `True`, если преобразование и сохранение прошли успешно, и `False` в случае ошибки.

**Как работает функция**:
1. **Чтение CSV-файла**: Использует функцию `read_csv_file` для чтения содержимого CSV-файла в виде списка словарей. Если чтение CSV-файла не удалось, функция возвращает `False`.
2. **Запись в JSON-файл**: Открывает JSON-файл, указанный в `json_file_path`, в режиме записи (`'w'`) с кодировкой `utf-8`. Используется конструкция `with`, чтобы файл был автоматически закрыт после завершения работы.
3. **Преобразование в JSON**: Преобразует список словарей в JSON-формат с помощью `json.dump`. Параметр `indent=4` добавляет отступы для улучшения читаемости JSON-файла.
4. **Обработка исключений**: Если во время преобразования или записи в файл возникает исключение, оно логируется с использованием `logger.error`, и функция возвращает `False`.

```
Чтение CSV -> Запись в JSON -> Успех/Ошибка
```

**Примеры**:

```python
from pathlib import Path
import os
# Создаем временный CSV-файл для примера
csv_file_path = "temp.csv"
with open(csv_file_path, 'w', newline='', encoding='utf-8') as f:
    writer = csv.DictWriter(f, fieldnames=['name', 'age'])
    writer.writeheader()
    writer.writerow({'name': 'John', 'age': '30'})
    writer.writerow({'name': 'Jane', 'age': '25'})

# Пример 1: Преобразование CSV-файла в JSON-файл
json_file_path = "temp.json"
result = read_csv_as_json(csv_file_path, json_file_path)
print(f"Результат преобразования: {result}")
# Вывод: Результат преобразования: True

# Пример 2: Обработка ошибки при чтении CSV-файла
non_existent_csv = "non_existent.csv"
json_file_path = "non_existent.json"
result = read_csv_as_json(non_existent_csv, json_file_path)
print(f"Результат преобразования несуществующего файла: {result}")
# Вывод: Результат преобразования несуществующего файла: False

# Пример 3: Преобразование с использованием pathlib
csv_file_path = Path("temp.csv")
json_file_path = Path("temp_pathlib.json")
result = read_csv_as_json(csv_file_path, json_file_path)
print(f"Результат преобразования с pathlib: {result}")
os.remove(csv_file_path)
os.remove(json_file_path)
```

### `read_csv_as_dict`

```python
def read_csv_as_dict(csv_file: Union[str, Path]) -> dict | None:
    """
    Преобразует содержимое CSV-файла в словарь.

    Args:
        csv_file (Union[str, Path]): Путь к CSV-файлу.

    Returns:
        dict | None: Словарь, представляющий содержимое CSV-файла, или None, если не удалось прочитать файл.
    """
    ...
```

**Назначение**: Читает CSV-файл и преобразует его содержимое в словарь, где ключ `"data"` содержит список словарей, представляющих строки CSV-файла.

**Параметры**:
- `csv_file` (Union[str, Path]): Путь к CSV-файлу, который нужно прочитать. Может быть строкой или объектом `Path`.

**Возвращает**:
- `dict | None`: Возвращает словарь, содержащий ключ `"data"`, значением которого является список словарей, представляющих строки CSV-файла. Возвращает `None`, если не удалось прочитать файл.

**Как работает функция**:
1. **Открытие файла**: Открывает CSV-файл, указанный в `csv_file`, в режиме чтения (`'r'`) с кодировкой `utf-8`. Используется конструкция `with`, чтобы файл был автоматически закрыт после завершения работы.
2. **Чтение данных**: Использует `csv.DictReader` для чтения CSV-файла. `csv.DictReader` преобразует каждую строку CSV-файла в словарь, где ключами являются заголовки столбцов.
3. **Преобразование в словарь**: Создает словарь, содержащий ключ `"data"`, значением которого является список словарей, полученных из CSV-файла.
4. **Обработка исключений**: Если во время чтения файла возникает исключение, оно логируется с использованием `logger.error`, и функция возвращает `None`.

```
Открытие файла -> Чтение данных -> Преобразование в словарь -> Успех/Ошибка
```

**Примеры**:

```python
from pathlib import Path
import os

# Создаем временный CSV-файл для примера
csv_file = "temp.csv"
with open(csv_file, 'w', newline='', encoding='utf-8') as f:
    writer = csv.DictWriter(f, fieldnames=['name', 'age'])
    writer.writeheader()
    writer.writerow({'name': 'John', 'age': '30'})
    writer.writerow({'name': 'Jane', 'age': '25'})

# Пример 1: Чтение существующего CSV-файла
result = read_csv_as_dict(csv_file)
print(f"Результат чтения: {result}")
# Вывод: Результат чтения: {'data': [{'name': 'John', 'age': '30'}, {'name': 'Jane', 'age': '25'}]}

# Пример 2: Чтение несуществующего CSV-файла
non_existent_csv = "non_existent.csv"
result = read_csv_as_dict(non_existent_csv)
print(f"Результат чтения несуществующего файла: {result}")
# Вывод: Результат чтения несуществующего файла: None
os.remove(csv_file)
```

### `read_csv_as_ns`

```python
def read_csv_as_ns(file_path: Union[str, Path]) -> List[dict]:
    """!
    Загружает данные CSV в список словарей с использованием Pandas.

    Args:
        file_path (Union[str, Path]): Путь к CSV-файлу.

    Returns:
        List[dict]: Список словарей, представляющих содержимое CSV.

    Raises:
        FileNotFoundError: Если файл не найден.
    """
    ...
```

**Назначение**: Загружает данные из CSV-файла в список словарей, используя библиотеку `pandas`.

**Параметры**:
- `file_path` (Union[str, Path]): Путь к CSV-файлу, который нужно прочитать. Может быть строкой или объектом `Path`.

**Возвращает**:
- `List[dict]`: Возвращает список словарей, где каждый словарь соответствует строке CSV-файла. Ключами словаря являются заголовки столбцов из первой строки CSV-файла.

**Вызывает исключения**:
- `FileNotFoundError`: Если файл, указанный в `file_path`, не найден.

**Как работает функция**:
1. **Чтение CSV-файла с помощью Pandas**: Использует `pd.read_csv` для чтения CSV-файла в DataFrame.
2. **Преобразование в список словарей**: Преобразует DataFrame в список словарей с помощью `df.to_dict(orient='records')`. Параметр `orient='records'` указывает, что каждая строка DataFrame должна быть преобразована в словарь.
3. **Обработка исключений**:
   - Если файл не найден (`FileNotFoundError`), функция логирует ошибку с использованием `logger.error` и возвращает пустой список (`[]`).
   - Если возникает любая другая ошибка (`Exception`), функция также логирует ошибку и возвращает пустой список (`[]`).

```
Чтение CSV с помощью Pandas -> Преобразование в список словарей -> Успех/Ошибка
```

**Примеры**:

```python
from pathlib import Path
import os
import pandas as pd

# Создаем временный CSV-файл для примера
csv_file = "temp.csv"
data = {'name': ['John', 'Jane'], 'age': [30, 25]}
df = pd.DataFrame(data)
df.to_csv(csv_file, index=False)

# Пример 1: Чтение существующего CSV-файла
result = read_csv_as_ns(csv_file)
print(f"Результат чтения: {result}")
# Вывод: Результат чтения: [{'name': 'John', 'age': 30}, {'name': 'Jane', 'age': 25}]

# Пример 2: Чтение несуществующего CSV-файла
non_existent_csv = "non_existent.csv"
result = read_csv_as_ns(non_existent_csv)
print(f"Результат чтения несуществующего файла: {result}")
# Вывод: Результат чтения несуществующего файла: []
os.remove(csv_file)