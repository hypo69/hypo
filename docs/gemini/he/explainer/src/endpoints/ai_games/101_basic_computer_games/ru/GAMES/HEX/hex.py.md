## ניתוח קוד: משחק HEX

### 1. <algorithm>

**תיאור אלגוריתם:**

1.  **אתחול:**
    *   יצירת לוח משחק ריק בגודל 11x11, המיוצג על ידי רשימה דו-ממדית.
        *   דוגמה: `board = [[' ' for _ in range(11)] for _ in range(11)]` יוצר לוח ריק.
    *   הגדרת השחקן הנוכחי כשחקן '1'.
        *   דוגמה: `current_player = '1'`
2.  **לולאת משחק:**
    *   הדפסת מצב הלוח הנוכחי למסך.
        *   דוגמה: `print_board(board)` מציג את הלוח הנוכחי.
    *   קבלת קלט מהשחקן הנוכחי (שורה ועמודה) עבור מיקום המהלך.
        *   דוגמה: `row, col = get_move(board, current_player)` קולט קלט מהמשתמש.
    *   בדיקת תקינות הקלט:
        *   אם הקלט לא תקין, בקש קלט חדש.
    *   בדיקה האם התא שנבחר ריק:
        *   אם התא תפוס, בקש קלט חדש.
        *   אם התא ריק, המשך.
    *   הצבת סימן השחקן הנוכחי בתא שנבחר.
        *   דוגמה: `board[row][col] = current_player` מציב את הסימן.
    *   בדיקה האם השחקן הנוכחי ניצח:
        *   אם השחקן ניצח, הדפס הודעה מתאימה וסיים את המשחק.
        *   אם השחקן לא ניצח, המשך.
    *   החלפת השחקן הנוכחי לשחקן השני.
        *   דוגמה: `current_player = '2' if current_player == '1' else '1'`
3.  **סיום המשחק:**
    *   הדפסת הודעה על ניצחון השחקן.
    *   המשחק מסתיים.

**זרימת נתונים:**

*   הפונקציה `play_hex` יוצרת את הלוח ומנהלת את המשחק.
*   הפונקציה `print_board` מקבלת את הלוח ומדפיסה אותו למסך.
*   הפונקציה `get_move` מקבלת את הלוח ואת השחקן הנוכחי, קולטת קלט מהמשתמש ומחזירה את השורה והעמודה המבוקשים.
*   הפונקציה `check_win` מקבלת את הלוח ואת השחקן הנוכחי ומחזירה `True` אם השחקן ניצח, אחרת `False`.

### 2. <mermaid>

```mermaid
flowchart TD
    Start["התחל"] --> InitializeBoard["<p align='left'>אתחול הלוח:<br><code>board = 11x11 array</code><br><code>current_player = '1'</code></p>"]
    InitializeBoard --> LoopStart{"<p>התחלת לולאה:<br><code>while True</code></p>"}
    LoopStart --> DisplayBoard["הצגת הלוח"]
    DisplayBoard --> GetInput["<p>קבלת קלט מהשחקן הנוכחי:<br><code>row, col = get_move()</code></p>"]
    GetInput --> ValidateInput{"<p>בדיקת תקינות הקלט:<br><code>validate_input(row, col)</code></p>"}
    ValidateInput -- "קלט לא תקין" --> GetInput
    ValidateInput -- "קלט תקין" --> CheckCellEmpty{"<p>בדיקת תא פנוי:<br><code>board[row][col] == ' '</code></p>"}
    CheckCellEmpty -- "תא תפוס" --> GetInput
    CheckCellEmpty -- "תא פנוי" --> PlaceMove["<p>הצבת סימן השחקן:<br><code>board[row][col] = current_player</code></p>"]
    PlaceMove --> CheckWin["<p>בדיקת ניצחון:<br><code>check_win(board, current_player)</code></p>"]
    CheckWin -- "שחקן ניצח" --> OutputWin["<p>הודעת ניצחון:<br><code>print('ניצחון לשחקן')</code></p>"]
    OutputWin --> End["סיום"]
    CheckWin -- "אין ניצחון" --> SwitchPlayer["<p>החלפת שחקן:<br><code>current_player = next_player</code></p>"]
    SwitchPlayer --> LoopStart
    LoopStart -- "המשחק הסתיים" --> End
    
  subgraph get_move_flow [get_move_flow]
    direction TB
       input_move["קבל קלט מהמשתמש (לדוגמא A1)"] --> parse_move["פונקציה המפרקת את הקלט"]
       parse_move --> validate_move["בדיקת תקינות הקלט (כולל האם הקלט בתוך הלוח)"]
       validate_move -->|תא פנוי| return_result[החזרת מיקום (row, col)]
        validate_move -->|תא תפוס| print_error_cell_is_taken[הודעת שגיאה - התא תפוס]
          print_error_cell_is_taken --> input_move
         validate_move -->|קלט לא תקין| print_error_format[הודעת שגיאה - קלט לא תקין]
             print_error_format --> input_move
  end
   
   subgraph check_win_flow[check_win_flow]
    direction TB
         check_win_start["תחילת בדיקה לניצחון"] --> start_position_player["קביעת נקודת התחלה לפי השחקן"]
      
        start_position_player --> dfs_start{"הפעלת DFS (חיפוש לעומק)"}
         dfs_start -->|נתיב נמצא| return_win_true[החזרת True (ניצחון)]
         dfs_start -->|נתיב לא נמצא| return_win_false[החזרת False (אין ניצחון)]
  end
    
  linkStyle default stroke:#333,stroke-width:2px
```

**הסבר תלויות:**

*   **אין תלויות חיצוניות**: הקוד משתמש רק במודול `sys` שאינו רלוונטי לתרשים הזרימה, כיוון שהוא משמש רק לסיים את התוכנית. כל שאר התלויות הן פנימיות, כלומר הן מתייחסות לפונקציות ולמשתנים המוגדרים בתוך אותו קובץ.

### 3. <explanation>

**ייבואים (Imports):**

*   `import sys`: ייבוא של מודול `sys` משמש להפסיק את ביצוע התוכנית, לא בשימוש פעיל בקוד המשחק הנוכחי. לא משפיע על הלוגיקה של המשחק ולכן לא מופיע בתרשים הזרימה.

**פונקציות (Functions):**

*   **`print_board(board)`:**
    *   **פרמטרים:** `board` - רשימה דו-ממדית המייצגת את לוח המשחק.
    *   **ערך מוחזר:** אין (הפונקציה מדפיסה את הלוח לקונסולה).
    *   **מטרה:** להציג את לוח המשחק הנוכחי בצורה ברורה למשתמש.
    *   **דוגמה לשימוש:** `print_board(board)`
*   **`get_move(board, player)`:**
    *   **פרמטרים:** `board` - לוח המשחק הנוכחי, `player` - השחקן הנוכחי ('1' או '2').
    *   **ערך מוחזר:** `tuple` המכיל את השורה והעמודה הנבחרות על ידי השחקן.
    *   **מטרה:** לקבל מהשחקן את הקלט עבור המהלך הבא שלו ולבדוק שהקלט תקין.
    *   **דוגמה לשימוש:** `row, col = get_move(board, '1')`
*   **`check_win(board, player)`:**
    *   **פרמטרים:** `board` - לוח המשחק הנוכחי, `player` - השחקן הנוכחי ('1' או '2').
    *   **ערך מוחזר:** `True` אם השחקן ניצח, אחרת `False`.
    *   **מטרה:** לבדוק האם השחקן הנוכחי ניצח במשחק.
    *   **דוגמה לשימוש:** `if check_win(board, '1'): print("Player 1 wins")`
*   **`dfs(row, col, visited, player)`:**
    *   **פרמטרים:** `row`, `col` - קואורדינטות נוכחיות, `visited` - סט של תאים שכבר ביקרנו בהם, `player` - השחקן הנוכחי.
    *   **ערך מוחזר:** `True` אם נמצא נתיב ניצחון, אחרת `False`.
    *   **מטרה:** פונקציית עזר רקורסיבית לביצוע חיפוש לעומק בלוח, לבדיקה האם יש נתיב ניצחון לשחקן הנוכחי.
    *   **דוגמה לשימוש:**  `dfs(i, 0, set(), '1')` (לבדוק אם שחקן 1 ניצח).
*   **`play_hex()`:**
    *   **פרמטרים:** אין.
    *   **ערך מוחזר:** אין (מנהלת את המשחק).
    *   **מטרה:** מכילה את הלוגיקה המרכזית של המשחק, כולל אתחול, לולאת המשחק, וסיום.
    *   **דוגמה לשימוש:** `play_hex()`
*   **`is_valid(row, col)`:**
    *   **פרמטרים:** `row`, `col` - קואורדינטות תא.
    *   **ערך מוחזר:** `True` אם הקואורדינטות בתוך הלוח, אחרת `False`.
    *   **מטרה:** לבדוק אם הקואורדינטות נכונות (לא יוצאות מגבולות הלוח).
    *   **דוגמה לשימוש:** `if is_valid(row, col):`

**משתנים (Variables):**

*   `board`: רשימה דו-ממדית המייצגת את לוח המשחק.
*   `current_player`: מחזיק את הסימון של השחקן הנוכחי ('1' או '2').
*   `row`, `col`: מחזיקים את השורה והעמודה שהשחקן בחר.
*   `board_size`: גודל לוח המשחק.
*   `move`: קלט מהמשתמש.
*   `directions` : רשימה של כיוונים לחיפוש בחיפוש לעומק.

**בעיות אפשריות או תחומים לשיפור:**

*   **ממשק משתמש:** ממשק הטקסט של המשחק בסיסי וניתן לשיפור עם ממשק גרפי.
*   **בדיקת תקינות קלט:** ניתן להוסיף בדיקות קלט נוספות כדי להפוך את המשחק ליציב יותר.
*   **ביצועים:** ניתן לייעל את פונקציית `check_win` על ידי שימוש באלגוריתמים מורכבים יותר לזיהוי חיבורים.
*   **חוסר תמיכה בבינה מלאכותית:** המשחק משחק רק בין שני שחקנים אנושיים וניתן לשלב בו בינה מלאכותית.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**
אין קשרים מוגדרים עם חלקים אחרים בפרויקט. זהו קובץ עצמאי המגדיר את הלוגיקה של משחק ה-HEX.