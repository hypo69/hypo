## Ответ на Задачу No 326: Перемешивание колоды

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Задача описывает процесс перемешивания бесконечной колоды карт, пронумерованных 1, 2, 3 и так далее.
*   Операция перемешивания заключается в перемещении верхней карты (с номером `p`) на позицию `p mod n`, где `n` - количество карт в колоде перед перемещением.
*   Необходимо найти сумму позиций всех карт `s(n)` после `n` таких перемешиваний и вычислить `s(10^7) mod 10^8`.

**Решение:**
1.  **Имитация перемешивания:** Основная сложность - это моделирование перемешивания для большого числа операций (10^7). Прямое моделирование будет очень неэффективным. Вместо этого, можно отслеживать изменения позиций карт.
2.  **Отслеживание позиций:** Заменим колоду на массив `positions`, где `positions[i]` будет содержать позицию карты с номером `i+1`. Изначально `positions = [1, 2, 3, ...]`.
3.  **Операция перемешивания:**
    *   На `p`-м шаге перемещаем карту с номером `p`.
    *   Находим позицию `k = p % n`, куда нужно вставить карту.
    *   Сдвигаем все карты, которые были после `k`, на одну позицию вправо.
    *   Вставляем карту `p` в позицию `k+1`.
    *   Обновляем массив `positions` для отслеживания новых позиций.
4.  **Оптимизация:** Моделировать всю колоду в памяти будет неэффективно, так как колода бесконечная, но нам не нужны все карты, а только те, которые участвовали в первых `n` операциях. Так как мы вставляем только карты от 1 до n, то мы можем хранить только их позиции.
5.  **Суммирование и взятие по модулю:** После каждой операции, вычисляем сумму позиций всех карт от 1 до n. Берем остаток от деления на 10^8.
6.  **Ключевая оптимизация:**  Заметим, что если мы не меняем позиции первых n элементов массива positions, то на n-м шаге, позиция n-го элемента всегда будет равна 1. Это связано с тем, что мы сначала ставим его в позицию `n % n = 0`, т.е. в начало массива, а после этого увеличиваем на 1 все остальные позиции.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать `totalSum = 0`.
3.  Для `n` от 1 до `10^7`
    *   Инициализировать массив `positions` размером `n`.
    *   Заполнить `positions[i] = i + 1`.
    *   Для `p` от 1 до `n`:
        *   `k = p % len(positions)`.
        *   `card = positions[p - 1]`
        *   Удалить карту `p` из `positions`.
        *   Вставить карту `p` в позицию `k`.
        *   Обновить positions,  позиции всех карт сдвигаем если вставка не в конец
        *   Обновить positions,  карта `p` встаёт на позицию `k + 1`.
    *   Вычислить сумму `currentSum` = суммы значений в `positions`.
    *   `totalSum = (totalSum + currentSum) mod 10^8`.
4.  Вывести `totalSum`
5.  Конец

### 3. Реализация на Python 3.12

```python
def calculate_sum_of_positions(limit):
    total_sum = 0
    for n in range(1, limit + 1):
      positions = list(range(1, n + 1))
      for p in range (1, n+1):
            k = p % len(positions)
            card = positions[p - 1]
            positions.pop(p - 1)
            positions.insert(k, card)

      current_sum = sum(positions)
      total_sum = (total_sum + current_sum) % 100000000
    return total_sum
limit = 10**7
result = calculate_sum_of_positions(limit)
print(result)

```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeTotalSum((Инициализировать totalSum = 0))
    InitializeTotalSum --> LoopNStart((Начать цикл: n от 1 до 10^7))
    LoopNStart --> InitializePositions((Инициализировать positions = [1, 2, ..., n]))
    InitializePositions --> LoopPStart((Начать цикл: p от 1 до n))
    LoopPStart --> CalculateK((k = p mod len(positions)))
    CalculateK --> GetCard((card = positions[p-1]))
    GetCard --> RemoveCard((Удалить карту card из positions))
    RemoveCard --> InsertCard((Вставить карту card в позицию k))
    InsertCard --> UpdatePositions((Обновить positions))
    UpdatePositions --> LoopPCheck((p < n))
    LoopPCheck -- Да --> LoopPStart
    LoopPCheck -- Нет --> CalculateCurrentSum((currentSum = sum(positions)))
    CalculateCurrentSum --> UpdateTotalSum((totalSum = (totalSum + currentSum) mod 10^8))
    UpdateTotalSum --> LoopNCheck((n < 10^7))
    LoopNCheck -- Да --> LoopNStart
    LoopNCheck -- Нет --> OutputResult((Вывести totalSum))
    OutputResult --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать totalSum:** Присваиваем переменной `totalSum` значение 0.
*   **Начать цикл: n от 1 до 10^7:**  Внешний цикл, итерирующийся от 1 до 10^7 включительно.
*   **Инициализировать positions:** Создаем список `positions`, содержащий числа от 1 до `n`.
*  **Начать цикл: p от 1 до n:** Внутренний цикл, итерирующийся от 1 до `n`.
*   **k = p mod len(positions):** Вычисляем позицию `k`, куда будет вставлена карта.
*   **card = positions[p-1]:** Получаем карту, которую нужно переместить.
*   **Удалить карту card из positions:** Удаляем карту из текущей позиции.
*  **Вставить карту card в позицию k:** Вставляем карту на новую позицию.
*   **Обновить positions:** Обновляем позиции карт в массиве после вставки.
*   **p < n :** Проверка, не закончился ли внутренний цикл.
*   **currentSum = sum(positions):** Вычисляем сумму позиций карт в массиве.
*   **totalSum = (totalSum + currentSum) mod 10^8:** Обновляем `totalSum`, беря остаток от деления на 10^8.
*   **n < 10^7 :** Проверка, не закончился ли внешний цикл.
*   **Вывести totalSum:** Выводим конечное значение `totalSum`.
