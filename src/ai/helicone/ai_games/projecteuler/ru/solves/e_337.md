## Ответ на Задачу No 337: Загадочные множества

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Нам дано множество S(n), состоящее из чисел от 1 до n.
*   Загадочным называется подмножество S(n), если существует такое m, что сумма любых m его элементов является простым числом.
*   Нам нужно найти количество таких загадочных подмножеств F(n) для n = 100 000.

**Ключевые наблюдения:**
*   Если m=1, то все элементы должны быть простыми числами. В этом случае, мы должны проверить, что все элементы являются простыми числами и это подмножество загадочное.
*  Если подмножество содержит число 1, то оно не может быть загадочным при m > 1, потому что мы всегда можем выбрать 1 и еще несколько элементов так, чтобы их сумма была не простая. В результате, мы должны строить все загадочные множества только из простых чисел.
*   Если мы рассматриваем случай m=2 то, для того чтобы множество было загадочным, суммы любых двух элементов должны быть простыми числами. Это условие сильно ограничивает размер загадочного множества, поэтому мы можем попробовать сгенерировать подмножества из простых чисел и проверить это условие. 
*  На самом деле, условие m>1 очень сильно ограничивает размер множества. Это означает, что загадочные множества, которые нас интересуют, могут состоять либо из одного простого числа (m=1), либо из простых чисел, которые в сумме дают простые числа (m=2). Иных вариантов нет, посколько  m > 2 не удовлетворит условие.

**Вывод:**

*   Загадочные множества либо содержат одно простое число (m=1), либо два простых числа, сумма которых также является простым числом (m=2).
*   Необходимо перебрать все простые числа от 1 до n, составить все возможные пары таких простых чисел и проверить, является ли сумма этих пар простым числом.

**Решение:**

1.  **Генерация простых чисел:** Сгенерируем список простых чисел до 100 000.
2.  **Подсчет загадочных множеств m=1**:  Количество таких множеств будет равно количеству простых чисел.
3.  **Подсчет загадочных множеств m=2**:  Переберем все пары простых чисел и если сумма этих чисел является простым числом, увеличиваем счетчик. 
4.  Сложим эти значения и получим результат F(n).

### 2. Алгоритм решения

1.  **Начало**
2.  Сгенерировать список `primes`, содержащий все простые числа до `limit = 100000`
3.  Инициализировать `count` = `len(primes)` (считаем множества с m = 1)
4.  Для каждого простого числа `p1` из `primes`:
    *   Для каждого простого числа `p2` из `primes` после `p1`:
        *   Вычислить сумму `sum_of_primes = p1 + p2`
        *   Если `sum_of_primes` является простым числом:
            *   Увеличить `count` на 1
5.  Вернуть `count`
6.  **Конец**

### 3. Реализация на Python 3.12

```python
import math

def is_prime(number):
    """Проверяет, является ли число простым."""
    if number <= 1:
        return False
    if number <= 3:
        return True
    if number % 2 == 0 or number % 3 == 0:
        return False
    for i in range(5, int(math.sqrt(number)) + 1, 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True

def generate_primes(limit):
    """Генерирует список простых чисел до заданного предела."""
    primes = []
    for num in range(2, limit + 1):
        if is_prime(num):
            primes.append(num)
    return primes

def count_mysterious_sets(limit):
    """Подсчитывает количество загадочных подмножеств."""
    primes = generate_primes(limit)
    count = len(primes)  # M=1
    
    for i in range(len(primes)):
      for j in range(i + 1, len(primes)):
        if is_prime(primes[i] + primes[j]):
          count += 1 # M=2
          
    return count
  
limit = 100000
result = count_mysterious_sets(limit)
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> GeneratePrimes((Генерировать список простых чисел primes до limit))
    GeneratePrimes --> InitializeCount((Инициализировать count = len(primes)))
    InitializeCount --> LoopPrimes1((Начать цикл для p1 в primes))
    LoopPrimes1 --> LoopPrimes2((Начать цикл для p2 в primes после p1))
    LoopPrimes2 --> CalculateSum((Вычислить sum_of_primes = p1 + p2))
    CalculateSum --> CheckPrimeSum((Проверить: sum_of_primes является простым числом?))
    CheckPrimeSum -- Да --> IncrementCount((Увеличить count на 1))
    IncrementCount --> LoopPrimes2
    CheckPrimeSum -- Нет --> LoopPrimes2
    LoopPrimes2 --> LoopPrimes1
    LoopPrimes1 --> ReturnCount((Вернуть count))
    ReturnCount --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Генерировать список простых чисел primes до limit:** Создаем список всех простых чисел до заданного предела.
*   **Инициализировать count = len(primes):**  Устанавливаем начальное значение счетчика равное количеству простых чисел(множество из одного простого числа).
*   **Начать цикл для p1 в primes:** Начало внешнего цикла перебора простых чисел.
*   **Начать цикл для p2 в primes после p1:** Начало внутреннего цикла перебора простых чисел (начиная со следующего после p1).
*  **Вычислить sum_of_primes = p1 + p2:** Вычисляем сумму двух простых чисел
*   **Проверить: sum_of_primes является простым числом?:** Проверяем, является ли сумма двух простых чисел простым числом
*   **Увеличить count на 1:** Если сумма простых чисел простая, то увеличиваем счетчик на 1.
*   **Вернуть count:** Возвращаем общее количество загадочных подмножеств.
