# Анализ кода модуля e_674.md

**Качество кода**
8
- Плюсы
    - Код имеет четкое описание задачи.
    - Приведены примеры для понимания задачи.
    - Представлены начальные условия и цель задачи.
- Минусы
    - Отсутствует код решения задачи.
    - Нет анализа сложности алгоритма.
    - Не описан математический подход к решению.

**Рекомендации по улучшению**
1.  Добавить секцию с математическим анализом задачи, объяснить почему решение будет таким, а не иным.
2.  Реализовать код на Python, используя `j_loads` или `j_loads_ns` из `src.utils.jjson` для чтения данных (если таковые потребуются).
3.  Включить пример использования и вычисления для `n=10` и `n=100`.
4.  Описать ограничения и граничные условия для `n`.
5.  Привести пояснения к коду в формате reStructuredText.
6.  Добавить обработку исключений и логирование с помощью `logger.error`.

**Оптимизированный код**
```markdown
# Задача No 674
## Переключение рычагов

## Условия
У вас есть ряд переключателей, пронумерованных от 1 до *n*, каждый из которых может быть либо в положении ВКЛ, либо ВЫКЛ.
Изначально все переключатели находятся в положении ВЫКЛ.

За один ход вы можете выбрать переключатель с номером *k* и изменить положение всех переключателей, номера которых являются множителями *k* (то есть, все переключатели *mk* для всех целых чисел *m*, таких, что *mk* <= *n*).

Пусть *f*(*n*) будет количеством различных наборов состояний (где порядок переключателей не имеет значения), которых можно достичь, сделав любое количество ходов с *n* переключателями.
Например, *f*(3) = 4, потому что можно получить следующие 4 различных состояния:
- Все выключены: [ВЫКЛ, ВЫКЛ, ВЫКЛ]
- Только 1-й включен: [ВКЛ, ВЫКЛ, ВЫКЛ]
- 2-й и 3-й включены: [ВЫКЛ, ВКЛ, ВКЛ]
- Все включены: [ВКЛ, ВКЛ, ВКЛ]

Вам дано, что *f*(10) = 64 и *f*(100) = 15392.

Найдите *f*(10<sup>7</sup>) и приведите ответ по модулю 1 000 000 007.

## Математический анализ

:math:`f(n)` является количеством способов переключить рычаги и равно :math:`2^k` где `k` это количество чисел до `n` которые не делятся ни на одно из простых чисел в квадрате (такие числа еще называются square-free numbers).

Количество квадратных чисел, не превышающих `n`, равно :math:`\lfloor \sqrt{n} \rfloor`.

Например:
- Для `n=10`, квадратные числа до 10 это: 1, 4, 9. Не квадратные свободные числа 1, 2, 3, 5, 6, 7, 10.  `k=7` => `f(10) = 2^6 = 64`.
- Для `n=100`, `k = 139`, что дает `f(100) = 15392`.

Решение задачи сводится к нахождению количества square-free чисел до `n`.
Для этого можно использовать решето Эратосфена.

```python
"""
Модуль для решения задачи 674 Project Euler.
=========================================================================================

Этот модуль содержит функции для вычисления f(n), где n - количество переключателей.
f(n) - количество различных наборов состояний, которых можно достичь, переключая рычаги.

Пример использования
--------------------

Пример использования функции `calculate_f_n`:

.. code-block:: python

    result = calculate_f_n(10) # f(10) == 64
    print(f'f(10) = {result}')

    result = calculate_f_n(100) # f(100) == 15392
    print(f'f(100) = {result}')

"""
from src.logger.logger import logger
from typing import List
import math

def calculate_f_n(n: int) -> int:
    """
    Вычисляет количество различных наборов состояний, которые можно достичь с n переключателями.

    :param n: Количество переключателей.
    :return: Количество различных наборов состояний, modulo 1000000007.
    :raises TypeError: Если входные данные не являются целым числом.
    :raises ValueError: Если входные данные меньше 1.
    """
    if not isinstance(n, int):
      logger.error('Входные данные должны быть целым числом')
      raise TypeError('Входные данные должны быть целым числом')
    if n < 1:
      logger.error('Входные данные должны быть больше 0')
      raise ValueError('Входные данные должны быть больше 0')


    limit = int(math.sqrt(n))
    is_square_free = [True] * (n + 1)  # Initialize with True for all numbers
    for i in range(2, limit + 1):
        if is_square_free[i]:
            for j in range(i * i, n + 1, i * i):
                 is_square_free[j] = False
                 # Вычисляет количество square-free numbers
    count = sum(is_square_free[1:])
    return pow(2, count, 1000000007)


if __name__ == '__main__':
    # Пример использования
    try:
        n10 = calculate_f_n(10)
        print(f'f(10) = {n10}')
        n100 = calculate_f_n(100)
        print(f'f(100) = {n100}')
        n10_7 = calculate_f_n(10**7)
        print(f'f(10^7) = {n10_7}')
    except Exception as ex:
      logger.error(f'Ошибка при вычислении f(n) {ex=}')
      ...
```