# סינגלטון (Singleton) ב-`Python`

## סקירה כללית

ב-`Python`, סינגלטון הוא תבנית עיצוב המבטיחה שלמחלקה יהיה רק מופע אחד, ומספקת נקודת גישה גלובלית למופע זה. זה אומר שכשמנסים ליצור אובייקט חדש של המחלקה הזו, תמיד יתקבל אותו אובייקט.

סינגלטונים שימושיים כאשר צריך להגביל את מספר המופעים של מחלקה, לדוגמה:

*   לניהול חיבור למסד נתונים (כדי לא לפתוח חיבורים רבים).
*   לאחסון תצורה גלובלית של האפליקציה (כדי שכל חלקי האפליקציה ישתמשו באותה תצורה).
*   לרישום יומן (כדי שכל ההודעות ילכו לאותו קובץ).

ישנן מספר דרכים ליישם סינגלטון ב-`Python`.

<hr>

## תוכן עניינים

*   [סקירה כללית](#סקירה-כללית)
*   [דרכים ליישום סינגלטון](#דרכים-ליישום-סינגלטון)
    *   [באמצעות שינוי של המתודה `__new__`](#באמצעות-שינוי-של-המתודה-__new__)
    *   [באמצעות דקורטור](#באמצעות-דקורטור)
    *   [באמצעות מטקלאס](#באמצעות-מטקלאס)
    *   [באמצעות מודול](#באמצעות-מודול)
*   [יתרונות הסינגלטון](#יתרונות-הסינגלטון)
*   [חסרונות הסינגלטון](#חסרונות-הסינגלטון)
*   [מתי להשתמש בסינגלטון?](#מתי-להשתמש-בסינגלטון)

<hr>

## דרכים ליישום סינגלטון

### באמצעות שינוי של המתודה `__new__`

*   המתודה `__new__` אחראית ליצירת מופע של המחלקה. על ידי שינויה, אני יכול לשלוט בתהליך הזה.
*   בדוגמה זו, אאחסן את המופע היחיד של המחלקה במשתנה `_instance`.
*   אם אין עדיין מופע, אצור אותו, אחרת אחזיר את המופע הקיים.
*   **קוד `Python`:**

    ```python
    class Singleton:
        _instance = None  # Храню единственный экземпляр

        def __new__(cls, *args, **kwargs):
            """
            Переопределяю метод __new__, чтобы контролировать создание экземпляра.

            Args:
                cls: Класс, для которого создается экземпляр.
                *args: Позиционные аргументы для конструктора.
                **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if not cls._instance: # Если экземпляр еще не создан
                cls._instance = super().__new__(cls, *args, **kwargs) # Создаю новый экземпляр
            return cls._instance # Возвращаю существующий экземпляр

    # Пример использования
    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)  # Выведет True, так как это один и тот же объект
    ```
<hr>

### באמצעות דקורטור

*   דקורטור היא פונקציה שמשנה את המחלקה.
*   בדוגמה זו, אני יוצר פונקציית-דקורטור `singleton`, שמקבלת מחלקה ומחזירה את הגרסה העטופה שלה.
*   בתוך הדקורטור, אני מאחסן את מופעי המחלקות במילון `instances`.
*   אם מופע של המחלקה עדיין לא נוצר, אני יוצר אותו ושומר אותו במילון, אחרת אני מחזיר את המופע הקיים.
*   **קוד `Python`:**

    ```python
    def singleton(cls):
        """
        Декоратор для создания синглтона.

        Args:
            cls: Класс, который нужно сделать синглтоном.

        Returns:
            Модифицированный класс, являющийся синглтоном.
        """
        instances = {} # Храню экземпляры классов

        def wrapper(*args, **kwargs):
            """
            Функция-обертка, которая возвращает единственный экземпляр класса.

            Args:
               *args: Позиционные аргументы для конструктора.
               **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if cls not in instances: # Если экземпляр еще не создан
                instances[cls] = cls(*args, **kwargs) # Создаю экземпляр и сохраняю его
            return instances[cls] # Возвращаю существующий экземпляр
        return wrapper

    @singleton # Применяю декоратор к классу
    class MyClass:
        pass

    # Пример использования
    obj1 = MyClass()
    obj2 = MyClass()

    print(obj1 is obj2)  # Выведет True, так как это один и тот же объект
    ```
<hr>

### באמצעות מטקלאס

*   מטקלאס מאפשר לשלוט ביצירת מחלקות.
*   בדוגמה זו, אני יוצר מטקלאס `SingletonMeta`, שיעקוב אחר יצירת המופעים.
*   המטקלאס מאחסן את מופעי המחלקות במילון `_instances`.
*   בעת יצירת מופע חדש, אני בודק אם הוא כבר קיים במילון, אם לא - יוצר אותו, אחרת מחזיר את המופע הקיים.
*   **קוד `Python`:**

    ```python
    class SingletonMeta(type):
        """
        Метакласс для создания синглтона.
        """
        _instances = {} # Храним экземпляры

        def __call__(cls, *args, **kwargs):
            """
            Переопределяю метод __call__, чтобы контролировать создание экземпляра.

            Args:
                cls: Класс, для которого создается экземпляр.
                *args: Позиционные аргументы для конструктора.
                **kwargs: Именованные аргументы для конструктора.

            Returns:
                Единственный экземпляр класса.
            """
            if cls not in cls._instances: # Если экземпляр еще не создан
                cls._instances[cls] = super().__call__(*args, **kwargs) # Создаю новый экземпляр
            return cls._instances[cls] # Возвращаю существующий экземпляр

    class Singleton(metaclass=SingletonMeta):
        """
        Класс, который является синглтоном.
        """
        pass

    # Пример использования
    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)  # Выведет True, так как это один и тот же объект
    ```
  <hr>

### באמצעות מודול

*   ב-`Python`, מודול הוא בעצמו סינגלטון.
*   אני יכול ליצור אובייקט במודול, והוא יהיה המופע היחיד.
*   **קוד `Python`:**
    ```python
    # Файл singleton.py
    class Singleton:
        pass

    instance = Singleton()
    ```
    ```python
    # В другом файле
    from singleton import instance

    obj1 = instance
    obj2 = instance

    print(obj1 is obj2)  # Выведет True, так как это один и тот же объект
    ```

## יתרונות הסינגלטון

*   **הבטחת מופע יחיד:** סינגלטון מבטיח שלמחלקה יהיה רק מופע אחד. זה שימושי לניהול משאבים שצריכים להיות ייחודיים.
*   **גישה גלובלית:** סינגלטון מספק נקודת גישה גלובלית למופע של המחלקה, מה שמקל על השימוש במופע זה בכל חלק של התוכנית.

## חסרונות הסינגלטון

*   **מצב גלובלי:** סינגלטון יכול להוביל לשימוש במצב גלובלי, מה שעלול לגרום לתופעות לוואי בלתי צפויות ולסבך את הבדיקות.
*   **הפרה של עקרונות תכנות מונחה עצמים:** סינגלטון עלול להפר את עקרון האחריות היחידה והאינקפסולציה.

## מתי להשתמש בסינגלטון?

*   כאשר צריך שאובייקט יתקיים במופע יחיד (למשל, תצורה, לוגר, חיבור למסד נתונים).
*   כאשר נדרשת גישה גלובלית לאובייקט הזה.