## Ответ на Задачу No 411: Окрашенные квадраты

### 1. Анализ задачи и решение

**Понимание задачи:**
* Необходимо определить количество способов покрасить квадраты сетки n x n четырьмя цветами, так чтобы никакие два соседних квадрата не были покрашены одним цветом.
* Соседние квадраты – это те, что имеют общую сторону (не только по диагонали).
* Нужно вычислить f(10,000,000) mod 100,000,007.
* По условию, f(1) = 4, f(2) = 12, f(3) = 24

**Решение:**
1.  **Анализ f(n):**
    * Для n=1, есть 1 квадрат. Его можно покрасить в любой из 4-х цветов. f(1) = 4.
    * Для n=2, есть 4 квадрата. Можно заметить, что цвета квадратов чередуются, как на шахматной доске. Для первого квадрата (0,0) есть 4 варианта. Для квадрата (1,0), (0,1) и (1,1) есть 3 варианта, потому что цвета соседних квадратов должны различаться. Значит f(2) = 4 * 3 = 12.
    * Для n=3, у нас есть 9 квадратов. Квадраты можно раскрасить, чередуя два цвета, как на шахматной доске, тогда у нас есть 2 варианта выбора первой пары цветов 4*3 = 12 или 12*2 = 24.

2. **Упрощение задачи:**
   Рассмотрим случай n=2, у нас 4 квадрата
   ```
   A B
   C D
   ```
   У нас 4 варианта покраски для А, 3 варианта для В (т.к. он сосед с А), 3 варианта для С (т.к. он сосед с А) и 2 варианта для D, если В и С одного цвета, и 3 варианта для D если В и С разных цветов. Рассмотрим случаи: 
   1. Если В и С одного цвета, тогда D имеет 3 варианта окраски, и в таком случае у нас 4*3*1*3=36
   2. Если B и C разного цвета, тогда у нас 4 варианта выбора А, 3 варианта выбора В, 2 варианта выбора C, и 2 варианта для D, всего 4*3*2*2= 48

   У нас f(1) = 4,  f(2) = 12 , f(3) = 24
  
   Заметим, что для каждого нового ряда и столбца количество вариантов умножается на 3, за исключением варианта с первым рядом и столбцом.
    При рассмотрение вариантов видим что у нас 4 варианта для первого квадрата, и потом умножение на 3 для всех остальных квадратов (с учетом того, что квадраты будут чередоваться). Можно сказать, что при f(n) = 4 * (3^(n-1) + 3^(n-1)) - тут ошибка, количество вариантов для 2x2 не 4 * 3^3

   Квадраты в сетке можно раскрасить, как шахматную доску, используя два цвета. Рассмотрим два варианта выбора двух цветов:
     1. Чередование двух цветов: 4*3 * 4*3 = 12 - можно выбрать первую пару, затем вторую
     2. Учитываем что это шахматная доска - 4 варианта для первого квадрата, и 3 для каждого последующего.
     Итого, мы имеем всего два варианта покраски. В первом варианте используем 2 цвета, во втором другие 2 цвета.
     f(n) =  2 * 4 * 3 ^ (n*n-1) - данное рассуждение также не верно, нам не нужно рассматривать все n*n квадратов
     
     Правильный вариант: Для n=1: 4 варианта, для n=2: 12 вариантов. Для n=3: 24.
     Можно заметить что у нас есть 2 варианта раскраски (шахматная доска).
     Для n = 1: 4
     Для n = 2: 4 * 3 = 12 
     Для n = 3: 4 * 3 * 2 = 24
     Для n = 4: 4 * 3 * 2 * 3 = 72 
   
   В итоге получаем формулу, что f(n) = 4 * 3 ^ (n-1) * 2^(n-1), где 2 - это варианты выбора шахматной доски, 3 - варианты выбора цвета соседнего квадрата
    f(n) = 4 * (3 * 2) ^ (n-1) = 4 * 6 ^ (n-1)

3. **Вычисление f(10000000) mod 100000007:**
   Используем модульное возведение в степень для эффективности.

### 2. Алгоритм решения
1.  Начать.
2.  Инициализировать переменную `n` значением 10000000.
3.  Инициализировать переменную `modulo` значением 100000007.
4.  Вычислить `result` как `(4 * pow(6, n-1, modulo)) % modulo`.
5.  Вернуть `result`.
6.  Конец.

### 3. Реализация на Python 3.12
```python
def solve_squares(n, modulo):
  """
  Calculates the number of ways to color the squares, modulo given number.
  Args:
      n: size of the grid
      modulo: the module

  Returns:
      result
  """
  result = (4 * pow(6, n - 1, modulo)) % modulo
  return result

# Пример использования:
n = 10_000_000
modulo = 100_000_007
result = solve_squares(n, modulo)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InputN((Ввод n = 10000000))
    InputN --> InputModulo((Ввод modulo = 100000007))
    InputModulo --> CalculateResult((Вычислить result = (4 * pow(6, n-1, modulo)) % modulo))
    CalculateResult --> OutputResult((Вывод result))
    OutputResult --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Ввод n = 10000000:** Задаем значение n.
*  **Ввод modulo = 100000007:** Задаем значение modulo.
*   **Вычислить result = (4 * pow(6, n-1, modulo)) % modulo:** Вычисляем результат по формуле, используя модульное возведение в степень.
*   **Вывод result:** Выводим полученный результат.
