"""
HEX:
=================
Сложность: 7
-----------------
Игра HEX - это логическая игра, в которой два игрока поочередно размещают свои фишки на шестиугольной сетке, стремясь соединить противоположные стороны доски. Цель каждого игрока — создать непрерывную цепь своих фишек, соединяющую их противоположные стороны доски. Игроки ставят свои фишки на шестиугольные клетки, пока один из них не сможет соединить свои стороны.  В данной версии игра реализована для двух игроков: '1' и '2'
Правила игры:
1. Игроки по очереди ставят свои фишки (символы '1' и '2') на шестиугольную доску.
2. Цель первого игрока (символ '1') - соединить левую и правую стороны доски своими фишками.
3. Цель второго игрока (символ '2') - соединить верхнюю и нижнюю стороны доски своими фишками.
4. Игрок, первым достигший своей цели, выигрывает.
5. Игра продолжается до победы одного из игроков.
-----------------
Алгоритм:
1. Инициализация:
   1.1. Создать пустую игровую доску 11x11 (массив строк).
   1.2. Установить текущего игрока на 1.
2. Основной игровой цикл:
    2.1. Вывести текущее состояние доски.
    2.2. Запросить у текущего игрока координаты (строка, столбец) для размещения фишки.
    2.3. Проверить ввод: если ввод не корректный, вернуться на шаг 2.2.
    2.4. Если выбранная клетка занята, вернуться на шаг 2.2.
    2.5. Поместить фишку текущего игрока на выбранную клетку.
    2.6. Проверить, выиграл ли текущий игрок.
         2.6.1. Если игрок 1 выиграл, вывести сообщение о победе.
         2.6.2. Если игрок 2 выиграл, вывести сообщение о победе.
         2.6.3. Если нет, перейти на шаг 2.7.
    2.7. Сменить текущего игрока.
3. Завершение игры:
    3.1. Вывести сообщение о победе.
    3.2. Конец игры.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["<p align='left'>Инициализация доски:
    <code><b>
    board = empty 11x11 array
    currentPlayer = 1
    </b></code></p>"]
    InitializeBoard --> LoopStart{"Начало цикла: пока нет победителя"}
    LoopStart --> DisplayBoard["Вывести текущее состояние доски"]
    DisplayBoard --> GetInput["Запросить ввод координат от текущего игрока"]
    GetInput --> ValidateInput{"Проверка корректности ввода"}
    ValidateInput -- Некорректный ввод --> GetInput
    ValidateInput -- Корректный ввод --> CheckCellEmpty{"Проверка: <code><b>board[row][col] == ' '?</b></code>"}
    CheckCellEmpty -- Клетка занята --> GetInput
    CheckCellEmpty -- Клетка свободна --> PlaceMove["Поставить фишку игрока в <code><b>board[row][col]</b></code>"]
     PlaceMove --> CheckWin["Проверить, есть ли победитель у <code><b>currentPlayer</b></code>?"]
    CheckWin -- Игрок победил --> OutputWin["Вывод сообщения о победе игрока <code><b>currentPlayer</b></code>"]
    OutputWin --> End["Конец"]
    CheckWin -- Нет победителя --> SwitchPlayer["Сменить текущего игрока: <code><b>currentPlayer = 3 - currentPlayer</b></code>"]
    SwitchPlayer --> LoopStart
    LoopStart -- Нет победителя --> End
```
**Legenda**:
    Start - Начало игры.
    InitializeBoard - Инициализация игровой доски (пустой 11x11 массив) и установка текущего игрока на 1.
    LoopStart - Начало цикла игры, который продолжается, пока не будет выявлен победитель.
    DisplayBoard - Вывод текущего состояния игровой доски на экран.
    GetInput - Запрос у текущего игрока координат (строки и столбца) для размещения фишки.
    ValidateInput - Проверка корректности введенных координат.
    CheckCellEmpty - Проверка, свободна ли выбранная клетка на доске.
    PlaceMove - Размещение фишки текущего игрока на выбранной клетке.
    CheckWin - Проверка, есть ли победитель после размещения фишки.
    OutputWin - Вывод сообщения о победе, если победитель определен.
    SwitchPlayer - Смена текущего игрока на противоположного.
    End - Конец игры.
"""

import sys
def print_board(board):
    """Выводит текущее состояние доски."""
    print("   ", end="")
    for i in range(len(board)):
        print(chr(ord('A') + i), end=" ")
    print()
    for i, row in enumerate(board):
        print(f"{i+1:2d} ", end="")
        for cell in row:
            print(cell, end=" ")
        print()


def get_move(board, player):
     """Запрашивает у игрока координаты для хода."""
     while True:
          try:
              move = input(f"Ход игрока {player}. Введите координаты (например, A1): ").strip().upper()
              if len(move) < 2:
                  raise ValueError
              col = ord(move[0]) - ord('A')
              row = int(move[1:]) - 1
              if 0 <= row < len(board) and 0 <= col < len(board[0]):
                if board[row][col] == ' ':
                    return row, col
                else:
                     print("Эта клетка занята, выберите другую")
              else:
                   print("Неверные координаты, попробуйте еще раз")
          except ValueError:
            print("Неверный формат ввода, попробуйте еще раз (пример A1)")


def check_win(board, player):
    """Проверяет, выиграл ли игрок."""

    def is_valid(row, col):
        return 0 <= row < len(board) and 0 <= col < len(board[0])

    def dfs(row, col, visited, player):
        if not is_valid(row, col) or (row, col) in visited or board[row][col] != player:
           return False
        visited.add((row, col))

        if player == '1':
           if col == len(board[0])-1:
              return True # достиг правой стороны
           directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, 1)]
        elif player == '2':
           if row == len(board)-1:
               return True # достиг нижней стороны
           directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1)]

        for dr, dc in directions:
            if dfs(row + dr, col + dc, visited, player):
               return True

        return False


    if player == '1':
        for i in range(len(board)):
            if board[i][0] == '1': # start from the left
                if dfs(i, 0, set(), '1'):
                   return True
    elif player == '2':
        for j in range(len(board[0])):
            if board[0][j] == '2': # start from the top
                if dfs(0, j, set(), '2'):
                    return True
    return False
    
def play_hex():
    """Основная функция игры."""
    board_size = 11
    board = [[' ' for _ in range(board_size)] for _ in range(board_size)] # создаем пустую доску
    current_player = '1' # начинаем с первого игрока

    while True:
        print_board(board)
        row, col = get_move(board, current_player)
        board[row][col] = current_player # ставим фишку

        if check_win(board, current_player):
              print_board(board)
              print(f"Игрок {current_player} победил!")
              break
        current_player = '2' if current_player == '1' else '1'


if __name__ == "__main__":
    play_hex()

"""
Объяснение кода:
1.  **Импорт модуля `sys`**:
    -   `import sys`: Импортирует модуль `sys`, используемый для выхода из программы.

2. **Функция `print_board(board)`:**
    - Выводит текущее состояние игровой доски в консоль.
    - Сначала печатает буквенные обозначения столбцов (A, B, C, ...), затем переходит к печати строк, где каждая строка начинается с числового обозначения и далее печатаются клетки доски.

3.  **Функция `get_move(board, player)`:**
    - Запрашивает у игрока ввод координат для хода.
     -  Использует цикл while True для обеспечения корректного ввода.
    - Преобразует введенные координаты (например, "A1") в индексы строки и столбца.
    - Проверяет корректность введенных координат, а так же занята ли клетка и если все ок, возвращает координаты в виде кортежа (row,col)

4.  **Функция `check_win(board, player)`:**
    - Проверяет, есть ли победитель на доске.
    - Использует рекурсивную функцию `dfs` (поиск в глубину) для анализа связности фишек игрока.
    - Функция `is_valid` используется для проверки допустимости координат.
    - Для игрока 1, проверка начинается с левой стороны доски и ищется путь до правой, для игрока 2 - сверху вниз.
    - Если путь найден, то возвращает `True`, иначе `False`.

5.  **Функция `play_hex()`:**
    -  Содержит основную логику игры "Гекс".
    -   Создает пустую игровую доску board размером 11x11.
    -   Устанавливает текущего игрока current_player на '1'.
    -   В цикле while True:
        -   Вызывает `print_board()` для отображения доски.
        -   Вызывает `get_move()` для получения хода от игрока.
        -   Размещает фишку игрока на доске.
        -   Вызывает `check_win()`, чтобы проверить, есть ли победитель.
        -   Если победитель есть, выводит сообщение о победе и завершает игру.
        -   Меняет текущего игрока (с '1' на '2' и наоборот) если нет победителя.

6.  **Блок `if __name__ == "__main__":`:**
    -   Гарантирует, что функция `play_hex()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -   Вызывает `play_hex()` для начала игры.
"""
