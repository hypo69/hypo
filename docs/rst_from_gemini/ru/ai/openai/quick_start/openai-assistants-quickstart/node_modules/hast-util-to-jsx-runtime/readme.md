```markdown
# hast-util-to-jsx-runtime

A hast utility to transform a tree to Preact, React, Solid, Svelte, Vue, etc., with an automatic JSX runtime.

[![Build Status][build-badge]][build]
[![Coverage][coverage-badge]][coverage]
[![Downloads][downloads-badge]][downloads]
[![Size][size-badge]][size]
[![Sponsors][sponsors-badge]][collective]
[![Backers][backers-badge]][collective]
[![Chat][chat-badge]][chat]

This package transforms a [hast](https://github.com/syntax-tree/hast) tree into JSX suitable for various frameworks.  It uses an automatic JSX runtime, providing a common interface for different JSX environments.

## Key Features

* **Automatic JSX Runtime:** Handles the differences between various frameworks' JSX implementations.
* **Fragment Support:**  Guarantees handling of fragments consistently.
* **Extra Information (development):** Supports passing extra data in development environments.

## Installation

This package is ESM only.

**Node.js (version 16+)**:

```bash
npm install hast-util-to-jsx-runtime
```

**Deno**:

```typescript
import {toJsxRuntime} from 'https://esm.sh/hast-util-to-jsx-runtime@2'
```

**Browsers**:

```html
<script type="module">
  import {toJsxRuntime} from 'https://esm.sh/hast-util-to-jsx-runtime@2?bundle'
</script>
```

## Usage

```javascript
import { h } from 'hastscript';
import { toJsxRuntime } from 'hast-util-to-jsx-runtime';
import { Fragment, jsx, jsxs } from 'react/jsx-runtime'; // or your framework's JSX runtime
import { renderToString } from 'react-dom/server'; // or your framework's rendering

const tree = h('div', {}, 'Hello, world!');

const jsxOutput = renderToString(toJsxRuntime(tree, {
  Fragment,
  jsx,
  jsxs,
}));

console.log(jsxOutput); // Output: <div>Hello, world!</div>
```

This example shows a basic transformation.  You'll need to import the appropriate JSX runtime (e.g., React's `jsx-runtime`) and a rendering function (e.g., `renderToString`) for your target framework.


## API

This package exports the function `toJsxRuntime`.  Detailed documentation for the options and types is included in the source code's comments.  It is recommended to review the TypeScript definitions for the most up-to-date and complete API information.


## Important Considerations

* **Framework Compatibility:** Ensure you import the correct JSX runtime (`jsx`, `jsxs`, `Fragment`) corresponding to the framework you are using (e.g., React, Preact, Solid, Svelte, Vue).
* **Error Handling:**  The library throws specific errors for common issues, such as missing or incorrect runtime imports, which can help in debugging issues related to framework incompatibility.
* **`elementAttributeNameCase` and `stylePropertyNameCase`:** These options control the attribute and style property casing, respectively.  Select the appropriate casing for your target framework.  For example, Preact requires `html` casing, while React uses `react` casing for attributes.  Solid uses CSS styling, so you will need to select the `css` casing.

## Examples (Specific Frameworks)

See the included example section for more detailed examples demonstrating how to use `hast-util-to-jsx-runtime` with various frameworks (e.g., Preact, Solid, Svelte, Vue).


## Contributing

See the [CONTRIBUTING](https://github.com/syntax-tree/hast-util-to-jsx-runtime/blob/main/CONTRIBUTING.md) file for guidelines.

## License

[MIT](https://github.com/syntax-tree/hast-util-to-jsx-runtime/blob/main/LICENSE) Â© [Titus Wormer](https://wooorm.com)


```
```


**Explanation of Improvements and Rationale:**

* **Clearer Installation Instructions:**  Explicitly differentiates between Node.js, Deno, and browser installations.
* **Comprehensive Example:** The example now includes a more robust example with imports and rendering, making it easier to understand the practical application of `toJsxRuntime`.
* **Error Handling Emphasis:**  Highlights the importance of error handling, and emphasizes the role of the error messages in troubleshooting framework incompatibility.
* **API Guidance:**  Instead of a direct listing of every type and function, guides users to the source code's TypeScript definitions for complete API information.
* **Framework Specific Examples:** Reinforces the need for example code in the original README with framework-specific details.
* **Removed Unnecessary Details:** Removed overly verbose and confusing explanation sections that did not add significant value.
* **Conciseness:**  The entire README is more concise and focused on essential information.

This revised README is more focused, easier to understand, and better suited for users looking to use the package in various frameworks. Remember to always refer to the TypeScript definitions for detailed API information.