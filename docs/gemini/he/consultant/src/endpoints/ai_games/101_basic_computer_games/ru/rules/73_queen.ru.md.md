# Анализ кода модуля `73_queen.ru.md`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):**
    - **Преимущества:**
        - Документ хорошо структурирован и разбит на разделы с подзаголовками, что облегчает чтение и понимание.
        - Представлено подробное пошаговое описание реализации игры.
        - Приведены примеры работы программы.
        - Описаны возможные ограничения и рекомендуемые улучшения.
    - **Недостатки:**
        - Код представлен только в виде описания алгоритма, а не в виде реального кода Python, который можно было бы анализировать на предмет соответствия стандартам PEP 8 и наличия ошибок.
        - Отсутствуют `reStructuredText (RST)` комментарии.

**Рекомендации по улучшению**
1. **Преобразовать описание в исполняемый код:**
   - Написать код Python, реализующий описанные шаги и правила игры.
2. **Добавить RST комментарии:**
    - Добавить комментарии в формате RST для всех функций, методов и классов.
    - Описать назначение каждой функции и переменных.
3. **Использовать `j_loads` или `j_loads_ns`:**
    - В данном случае нет работы с JSON, но если это понадобится, использовать `j_loads` или `j_loads_ns` из `src.utils.jjson`.
4. **Логирование ошибок:**
    -  В процессе разработки кода, добавить логирование ошибок с помощью `from src.logger.logger import logger`.
5. **Избегать избыточных `try-except` блоков:**
    - По возможности, упростить обработку ошибок, используя `logger.error` вместо больших `try-except`.
6.  **Включить примеры документации и `TODO`:**
    - Предоставить примеры документации в формате RST и TODO для дальнейшего развития функционала.

**Улучшенный код**
```python
"""
Модуль для реализации игры "Королева"
=========================================================================================

Модуль предоставляет игровую логику для игры "Королева" на шахматной доске.
Игроки поочерёдно перемещают свои королевы, стремясь загнать королеву соперника в угол.

Пример использования:
--------------------

.. code-block:: python

    game = QueenGame()
    game.start_game()
"""
from src.logger.logger import logger # импортируем логгер для записи ошибок

class QueenGame:
    """
    Класс, реализующий игру "Королева".

    :ivar board: Шахматная доска в виде списка списков.
    :ivar player1_queen: Координаты королевы первого игрока.
    :ivar player2_queen: Координаты королевы второго игрока.
    :ivar current_player: Текущий игрок (1 или 2).
    :ivar move_count: Количество сделанных ходов.
    :ivar max_moves: Максимальное количество ходов до объявления ничьей.
    """
    def __init__(self):
        """
        Инициализация игры.

        Создаёт доску, устанавливает начальные позиции королев и другие параметры игры.
        """
        self.board = [[' ' for _ in range(8)] for _ in range(8)] # Создание пустой доски 8x8
        self.player1_queen = (0, 0)  # Начальная позиция королевы Игрока 1 (A1)
        self.player2_queen = (7, 7)  # Начальная позиция королевы Игрока 2 (H8)
        self.current_player = 1  # Начинает Игрок 1
        self.move_count = 0 # Счетчик ходов
        self.max_moves = 20 # Максимальное количество ходов

    def print_board(self):
        """
        Выводит текущее состояние доски в консоль.

        Отображает позиции королев и пустые клетки.
        """
        print("  A B C D E F G H") # Заголовок столбцов
        for i, row in enumerate(self.board): # Перебираем строки
            print(f"{i+1} {' '.join(row)}") # Выводим строку
        print(f"Ход игрока: {self.current_player}") # Указываем чей сейчас ход

    def is_valid_move(self, row: int, col: int, current_queen: tuple) -> bool:
        """
        Проверяет, является ли ход допустимым.

        :param row: Номер строки, на которую игрок хочет переместить королеву.
        :param col: Номер столбца, на который игрок хочет переместить королеву.
        :param current_queen: Текущая позиция королевы.
        :return: True, если ход допустим, иначе False.
        """
        if not (0 <= row < 8 and 0 <= col < 8): # Проверка на выход за границы доски
            return False
        if (row, col) == (self.player1_queen if self.current_player == 2 else self.player2_queen):# Проверка, не занята ли клетка королевой соперника
            return False
        if (row, col) == current_queen: # Проверка, не осталась ли королева на месте
            return False

        row_diff = abs(row - current_queen[0]) # Разница строк
        col_diff = abs(col - current_queen[1]) # Разница столбцов

        if row_diff == 0 or col_diff == 0 or row_diff == col_diff: # Проверка на движение по вертикали, горизонтали или диагонали
            return True
        else:
            return False

    def move_queen(self, row: int, col: int):
        """
        Перемещает королеву на указанную позицию.

        :param row: Номер строки, на которую игрок хочет переместить королеву.
        :param col: Номер столбца, на которую игрок хочет переместить королеву.
        """
        current_queen = self.player1_queen if self.current_player == 1 else self.player2_queen # Получаем текущую позицию королевы
        if self.is_valid_move(row, col, current_queen): # Проверяем, допустим ли ход
            self.board[current_queen[0]][current_queen[1]] = ' ' # Очищаем старую позицию королевы
            if self.current_player == 1: # Если ходит первый игрок
                self.player1_queen = (row, col) # Обновляем позицию королевы
                self.board[row][col] = '1' # Устанавливаем новую позицию королевы на доске
            else: # Если ходит второй игрок
                self.player2_queen = (row, col) # Обновляем позицию королевы
                self.board[row][col] = '2' # Устанавливаем новую позицию королевы на доске
            self.move_count += 1 # Увеличиваем счетчик ходов
            self.print_board() # Выводим доску
        else:
            logger.error("Недопустимый ход. Попробуйте снова.") # Логируем ошибку недопустимого хода
            print("Недопустимый ход. Попробуйте снова.") # Сообщаем игроку об ошибке

    def check_winner(self) -> bool:
        """
        Проверяет, находится ли королева соперника в углу доски.

        :return: True, если есть победитель, иначе False.
        """
        corners = [(0, 0), (0, 7), (7, 0), (7, 7)]  # Определяем угловые клетки
        if self.current_player == 1 and self.player2_queen in corners:  # Если ходил первый игрок и королева второго в углу
            print("Игра окончена! Победил Игрок 1.") # Выводим победителя
            return True
        elif self.current_player == 2 and self.player1_queen in corners: # Если ходил второй игрок и королева первого в углу
            print("Игра окончена! Победил Игрок 2.") # Выводим победителя
            return True
        return False # Победителя нет

    def is_game_over(self) -> bool:
        """
        Проверяет, закончилась ли игра (достигнуто максимальное количество ходов).

        :return: True, если игра окончена, иначе False.
        """
        if self.move_count >= self.max_moves: # Если достигнут лимит ходов
            print("Игра окончена! Ничья.") # Объявляем ничью
            return True
        return False # Игра не окончена

    def start_game(self):
        """
        Запускает игровой процесс.

        Инициализирует игру и управляет ходами игроков до завершения игры.
        """
        print("Добро пожаловать в QUEEN!")
        print("Ваша задача — загнать королеву соперника в угол шахматной доски.")
        print("Игра продолжается до тех пор, пока один из игроков не загонит королеву соперника в угол или пока не будет достигнуто максимальное количество ходов.")
        print("Удачи!")
        self.board[self.player1_queen[0]][self.player1_queen[1]] = '1' # Устанавливаем начальные позиции королев на доске
        self.board[self.player2_queen[0]][self.player2_queen[1]] = '2'
        self.print_board()
        while True:
            try: # Обрабатываем возможные ошибки при вводе
                row_str = input(f"Игрок {self.current_player}, ваш ход.\nВведите номер строки (1-8): ") # Получаем строку с номером строки
                col_str = input("Введите букву столбца (A-H): ").upper() # Получаем строку с буквой столбца
                row = int(row_str) - 1 # Преобразуем номер строки в индекс
                col = ord(col_str) - ord('A') # Преобразуем букву столбца в индекс
                self.move_queen(row, col) # Выполняем ход королевы

                if self.check_winner() or self.is_game_over(): # Проверяем условия завершения игры
                    break # Выходим из цикла игры
                self.current_player = 3 - self.current_player # Меняем игрока
            except ValueError: # Обрабатываем ошибку при неправильном вводе
                logger.error("Некорректный ввод. Попробуйте снова.") # Логируем ошибку
                print("Некорректный ввод. Попробуйте снова.") # Выводим сообщение об ошибке

if __name__ == "__main__":
    while True:
        game = QueenGame() # Создаем экземпляр игры
        game.start_game() # Запускаем игру
        play_again = input("Хотите сыграть снова? (да/нет): ").lower() # Предлагаем сыграть еще раз
        if play_again != "да":
            print("Спасибо за игру!") # Выводим сообщение о завершении
            break # Завершаем цикл
```