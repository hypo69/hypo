"""
<GOMOKO>:
=================
Сложность: 5
-----------------
Gomoku (также известная как Five in a Row) — это абстрактная стратегическая настольная игра, в которую играют два игрока на доске. Цель игры состоит в том, чтобы первым сформировать непрерывную линию из пяти своих камней по горизонтали, вертикали или диагонали. Игроки по очереди размещают свои камни на пустых пересечениях.
-----------------
Правила игры:
1. Играют два игрока, один ходит крестиками ("X"), другой ноликами ("O").
2. Игра проходит на доске 19х19.
3. Игроки по очереди ставят свои символы (крестики или нолики) на пустые клетки доски.
4. Победителем становится тот, кто первым выстроит пять своих символов в ряд по горизонтали, вертикали или диагонали.
5. Если доска полностью заполнена, а победитель не выявлен, игра заканчивается вничью.
-----------------
Алгоритм:
1. Инициализация:
    - Установить размер доски 19x19.
    - Заполнить доску нулями (пустые клетки).
    - Начать с первого игрока, чей символ крестик ("X").
2. Игровой цикл:
    - Вывести текущее состояние доски.
    - Запросить у текущего игрока ввод координат x и y для его хода.
    - Проверить, что введенные координаты находятся в пределах доски и выбранная клетка пуста. Если проверка не пройдена, повторить ввод.
    - Поместить символ текущего игрока на доску.
    - Проверить, есть ли победитель. Проверять нужно по всем направлениям (горизонталь, вертикаль и диагонали). Если победитель есть, вывести сообщение о победе и завершить игру.
    - Если победителя нет, проверить, не заполнена ли вся доска. Если доска заполнена, объявить ничью и завершить игру.
    - Если ни победителя нет, ни доска не заполнена, передать ход другому игроку.
3. Конец игры.
-----------------
Блок-схема:
```mermaid
graph TD
    Start(Начало) --> Initialize(Инициализация доски, игроков);
    Initialize --> PrintBoard(Вывести доску);
    PrintBoard --> GetMove(Запросить ход игрока);
    GetMove -- Некорректный ход --> PrintBoard;
    GetMove -- Корректный ход --> PlaceMove(Разместить символ на доске);
    PlaceMove --> CheckWin(Проверить победу);
    CheckWin -- Победа есть --> OutputWin(Вывести сообщение о победе)
    OutputWin --> End(Конец игры);
    CheckWin -- Победы нет --> CheckDraw(Проверить ничью);
    CheckDraw -- Ничья --> OutputDraw(Вывести сообщение о ничье);
    OutputDraw --> End;
    CheckDraw -- Ничьи нет --> SwitchPlayer(Переключить игрока);
    SwitchPlayer --> PrintBoard;
    
    
    classDef process fill:#ccf,stroke:#333,stroke-width:2px;
  class Start,Initialize,GetMove,PlaceMove,CheckWin,CheckDraw,SwitchPlayer process;
  class PrintBoard,OutputWin,OutputDraw  fill:#afa,stroke:#333,stroke-width:2px;
    class End fill:#fcc,stroke:#333,stroke-width:2px;
```
"""
import numpy as np

def print_board(board):
    """Выводит текущее состояние доски в консоль.

    Args:
        board (numpy.ndarray): Двумерный массив, представляющий доску.
    """
    print("  " + " ".join(str(i) for i in range(19)))
    for i, row in enumerate(board):
        print(f"{i:2d} " + " ".join(str(cell) if cell != 0 else "." for cell in row))


def get_move(player, board):
    """Запрашивает у игрока ввод координат для хода и проверяет их корректность.

    Args:
        player (str): Символ текущего игрока ('X' или 'O').
        board (numpy.ndarray): Двумерный массив, представляющий доску.

    Returns:
        tuple: Кортеж (row, col) с координатами хода игрока.
    """
    while True:
        try:
            move = input(f"Игрок {player}, введите координаты (строка столбец через пробел): ").split()
            row = int(move[0])
            col = int(move[1])
            if 0 <= row < 19 and 0 <= col < 19 and board[row][col] == 0:
                return row, col
            else:
                print("Некорректный ход. Попробуйте еще раз.")
        except (ValueError, IndexError):
            print("Некорректный ввод. Попробуйте еще раз.")


def place_move(board, row, col, player):
    """Размещает символ игрока на доске.

    Args:
        board (numpy.ndarray): Двумерный массив, представляющий доску.
        row (int): Строка, в которую нужно поставить символ.
        col (int): Столбец, в который нужно поставить символ.
        player (str): Символ текущего игрока ('X' или 'O').
    """
    board[row][col] = player


def check_win(board, row, col, player):
    """Проверяет, есть ли победитель на доске.

        Args:
            board (numpy.ndarray): Двумерный массив, представляющий доску.
            row (int): Строка последнего хода.
            col (int): Столбец последнего хода.
            player (str): Символ текущего игрока ('X' или 'O').

        Returns:
            bool: True, если есть победитель, False в противном случае.
    """
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]  # (dx, dy) - смещение для поиска в разных направлениях
    for dx, dy in directions:
        count = 1
        # Проверяем в прямом направлении
        i = 1
        while 0 <= row + i * dx < 19 and 0 <= col + i * dy < 19 and board[row + i * dx][col + i * dy] == player:
            count += 1
            i += 1
        # Проверяем в обратном направлении
        i = 1
        while 0 <= row - i * dx < 19 and 0 <= col - i * dy < 19 and board[row - i * dx][col - i * dy] == player:
           count += 1
           i += 1
        if count >= 5:
            return True
    return False

def check_draw(board):
    """Проверяет, есть ли ничья.

    Args:
        board (numpy.ndarray): Двумерный массив, представляющий доску.

    Returns:
        bool: True, если ничья, False в противном случае.
    """
    return np.all(board != 0)

def switch_player(player):
    """Переключает текущего игрока.

    Args:
        player (str): Символ текущего игрока ('X' или 'O').

    Returns:
        str: Символ следующего игрока ('X' или 'O').
    """
    return 'O' if player == 'X' else 'X'

def main():
    """Основная функция игры Гомоку."""
    board = np.zeros((19, 19), dtype=str) # Инициализируем игровую доску размером 19x19, заполненную нулями
    current_player = 'X'  # Начинаем с игрока, который играет крестиками
    game_over = False # Устанавливаем флаг, сигнализирующий о конце игры
    while not game_over: # Запускаем игровой цикл
        print_board(board) # Выводим текущее состояние доски в консоль
        row, col = get_move(current_player, board) # Получаем от игрока координаты его хода
        place_move(board, row, col, current_player) # Размещаем символ игрока на доске
        if check_win(board,row,col,current_player): # Проверяем, есть ли победитель
            print_board(board)
            print(f"Игрок {current_player} победил!")  # Выводим сообщение о победе
            game_over = True # Завершаем игровой цикл
        elif check_draw(board): # Проверяем, не закончилась ли игра ничьей
             print_board(board)
             print("Ничья!") # Выводим сообщение о ничьей
             game_over = True # Завершаем игровой цикл
        else:
            current_player = switch_player(current_player)  # Переключаем текущего игрока

if __name__ == "__main__":
    main()
"""
Пояснения:
1. `import numpy as np`: Импортируем библиотеку NumPy для работы с массивами (для представления доски).
2. `print_board(board)`: Функция для вывода доски на экран. Использует `numpy` для удобной работы с двумерным массивом.
3. `get_move(player, board)`: Функция для запроса координат хода игрока. Проверяет корректность ввода и наличие пустой клетки.
4. `place_move(board, row, col, player)`: Функция для размещения символа игрока на доске.
5.  `check_win(board, row, col, player)`: Функция для проверки победы. Проверяет наличие 5 символов подряд в любом направлении.
6.  `check_draw(board)`: Функция для проверки ничьей (нет пустых клеток).
7. `switch_player(player)`: Функция для переключения игроков.
8. `main()`: Основная функция, реализующая игровой цикл. Инициализирует доску, запрашивает ходы, проверяет победу/ничью и переключает игроков.
9. `if __name__ == "__main__":`: Гарантирует, что код в блоке `main()` запустится, только если файл запущен напрямую, а не импортирован как модуль.
licence:MIT(../licence)
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
```