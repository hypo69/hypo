# Модуль `utils` для работы с шифрованием и кодированием Mega

## Обзор

Модуль `utils` содержит набор функций для шифрования, дешифрования, кодирования и декодирования данных, используемых в Mega. Он включает функции для преобразования данных между различными форматами, такими как целые числа, строки, массивы 32-битных целых чисел и base64url.

## Подробней

Этот модуль предоставляет инструменты для работы с криптографическими операциями, необходимыми для взаимодействия с API Mega. Он обеспечивает функциональность для шифрования и дешифрования данных с использованием AES в режиме CBC, а также для кодирования и декодирования данных с использованием base64url.

## Функции

### `a32_to_str`

```python
def a32_to_str(a: list) -> str:
    """Преобразует массив 32-битных целых чисел в строку.

    Args:
        a (list): Массив 32-битных целых чисел.

    Returns:
        str: Строка, полученная из массива целых чисел.

    Example:
        >>> a32_to_str([1, 2, 3])
        b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03'
    """
    ...
```

**Как работает функция**:
Функция принимает массив 32-битных целых чисел и упаковывает их в строку, используя формат `>%dI`, где `%d` - длина массива.

### `aes_cbc_encrypt`

```python
def aes_cbc_encrypt(data: bytes, key: bytes) -> bytes:
    """Шифрует данные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для шифрования.
        key (bytes): Ключ шифрования.

    Returns:
        bytes: Зашифрованные данные.

    Example:
        >>> key = b'\\x00' * 16
        >>> data = b'test data'
        >>> aes_cbc_encrypt(data, key)
        b'\\x19\\xc6\\x8f\\xad\\xe1\\x9d\\xe5\\xba\\x14\\xc1\\xfa\\xde\\xaf\\xfa\\x1e\\xc6'
    """
    ...
```

**Как работает функция**:

1.  Создает объект шифрования AES с использованием предоставленного ключа и режима CBC. Вектор инициализации (IV) устанавливается как 16 нулевых байтов.
2.  Выполняет шифрование предоставленных данных с использованием созданного объекта шифрования.

### `aes_cbc_encrypt_a32`

```python
def aes_cbc_encrypt_a32(data: list, key: list) -> tuple:
    """Шифрует данные (представленные в виде массива 32-битных целых чисел) с использованием AES в режиме CBC.

    Args:
        data (list): Данные для шифрования в виде массива 32-битных целых чисел.
        key (list): Ключ шифрования в виде массива 32-битных целых чисел.

    Returns:
        tuple: Зашифрованные данные в виде массива 32-битных целых чисел.

    Example:
        >>> key = [0] * 4
        >>> data = [1, 2, 3]
        >>> aes_cbc_encrypt_a32(data, key)
        (435410593, 3059842601, 3449158870)
    """
    ...
```

**Как работает функция**:

1.  Преобразует входные данные и ключ из массивов 32-битных целых чисел в строки с помощью функций `a32_to_str`.
2.  Вызывает функцию `aes_cbc_encrypt` для шифрования преобразованной строки данных с использованием преобразованного ключа.
3.  Преобразует зашифрованную строку обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.

### `str_to_a32`

```python
def str_to_a32(b: str | bytes) -> tuple:
    """Преобразует строку в массив 32-битных целых чисел.

    Args:
        b (str | bytes): Строка для преобразования.

    Returns:
        tuple: Массив 32-битных целых чисел, полученный из строки.

    Raises:
        TypeError: Если входные данные не являются строкой или байтами.

    Example:
        >>> str_to_a32(b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02')
        (1, 2)
    """
    ...
```

**Как работает функция**:

1.  Проверяет, делится ли длина входной строки на 4. Если нет, добавляет необходимое количество нулевых байтов для дополнения строки до длины, кратной 4.
2.  Преобразует входную строку в байты, если она представлена в виде обычной строки.
3.  Определяет формат для упаковки байтов в 32-битные целые числа, используя модуль `struct`.
4.  Распаковывает байты в массив 32-битных целых чисел и возвращает его.

### `mpi2int`

```python
def mpi2int(s: bytes) -> int:
    """Преобразует строку, представляющую целое число MPI (Multi-Precision Integer), в целое число Python.

    Args:
        s (bytes): Строка, представляющая целое число MPI.

    Returns:
        int: Целое число, полученное из строки MPI.

    Example:
        >>> mpi2int(b'\\x00\\x02\\x12\\x34')
        4660
    """
    ...
```

**Как работает функция**:
Функция принимает строку, представляющую целое число MPI, и преобразует ее в целое число Python. Она пропускает первые два байта строки и преобразует оставшуюся часть строки из шестнадцатеричного представления в целое число.

### `aes_cbc_decrypt`

```python
def aes_cbc_decrypt(data: bytes, key: bytes) -> bytes:
    """Расшифровывает данные, зашифрованные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для расшифровки.
        key (bytes): Ключ расшифровки.

    Returns:
        bytes: Расшифрованные данные.

    Example:
        >>> key = b'\\x00' * 16
        >>> data = b'\\x19\\xc6\\x8f\\xad\\xe1\\x9d\\xe5\\xba\\x14\\xc1\\xfa\\xde\\xaf\\xfa\\x1e\\xc6'
        >>> aes_cbc_decrypt(data, key)
        b'test data\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b'
    """
    ...
```

**Как работает функция**:

1.  Создает объект дешифрования AES с использованием предоставленного ключа и режима CBC. Вектор инициализации (IV) устанавливается как 16 нулевых байтов.
2.  Выполняет дешифрование предоставленных данных с использованием созданного объекта дешифрования.

### `aes_cbc_decrypt_a32`

```python
def aes_cbc_decrypt_a32(data: list, key: list) -> tuple:
    """Расшифровывает данные (представленные в виде массива 32-битных целых чисел) с использованием AES в режиме CBC.

    Args:
        data (list): Данные для расшифровки в виде массива 32-битных целых чисел.
        key (list): Ключ расшифровки в виде массива 32-битных целых чисел.

    Returns:
        tuple: Расшифрованные данные в виде массива 32-битных целых чисел.

    Example:
        >>> key = [0] * 4
        >>> data = [435410593, 3059842601, 3449158870]
        >>> aes_cbc_decrypt_a32(data, key)
        (1, 2, 3, 0, 0)
    """
    ...
```

**Как работает функция**:

1.  Преобразует входные данные и ключ из массивов 32-битных целых чисел в строки с помощью функций `a32_to_str`.
2.  Вызывает функцию `aes_cbc_decrypt` для дешифрования преобразованной строки данных с использованием преобразованного ключа.
3.  Преобразует дешифрованную строку обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.

### `base64urldecode`

```python
def base64urldecode(data: str) -> bytes:
    """Декодирует строку base64url.

    Args:
        data (str): Строка для декодирования.

    Returns:
        bytes: Декодированные данные.

    Example:
        >>> base64urldecode('YSBzaW1wbGUgc3RyaW5n')
        b'a simple string'
    """
    ...
```

**Как работает функция**:

1.  Добавляет необходимое количество символов `=` для дополнения строки до длины, кратной 4.
2.  Заменяет символы `-`, `_` и `,` на `+`, `/` и `` соответственно.
3.  Декодирует строку с использованием base64.

### `base64_to_a32`

```python
def base64_to_a32(s: str) -> tuple:
    """Декодирует строку base64url в массив 32-битных целых чисел.

    Args:
        s (str): Строка для декодирования.

    Returns:
        tuple: Массив 32-битных целых чисел, полученный из строки base64url.

    Example:
        >>> base64_to_a32('AQIDBAUGBwgJCgsMDQ4PEA')
        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    """
    ...
```

**Как работает функция**:

1.  Декодирует входную строку base64url с помощью функции `base64urldecode`.
2.  Преобразует декодированную строку в массив 32-битных целых чисел с помощью функции `str_to_a32`.

### `base64urlencode`

```python
def base64urlencode(data: bytes) -> str:
    """Кодирует байты в строку base64url.

    Args:
        data (bytes): Данные для кодирования.

    Returns:
        str: Строка base64url, полученная из данных.

    Example:
        >>> base64urlencode(b'a simple string')
        'YSBzaW1wbGUgc3RyaW5n'
    """
    ...
```

**Как работает функция**:

1.  Кодирует входные байты с использованием base64.
2.  Декодирует полученную строку из байтов в обычную строку, используя кодировку UTF-8.
3.  Заменяет символы `+`, `/` и `=` на `-`, `_` и `` соответственно.

### `a32_to_base64`

```python
def a32_to_base64(a: list) -> str:
    """Кодирует массив 32-битных целых чисел в строку base64url.

    Args:
        a (list): Массив 32-битных целых чисел для кодирования.

    Returns:
        str: Строка base64url, полученная из массива целых чисел.

    Example:
        >>> a32_to_base64([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        'AQIDBAUGBwgJCgsMDQ4PEA'
    """
    ...
```

**Как работает функция**:

1.  Преобразует входной массив 32-битных целых чисел в строку с помощью функции `a32_to_str`.
2.  Кодирует полученную строку в base64url с помощью функции `base64urlencode`.

### `get_chunks`

```python
def get_chunks(size: int) -> dict:
    """Разбивает размер файла на чанки для параллельной загрузки.

    Args:
        size (int): Размер файла в байтах.

    Returns:
        dict: Словарь, где ключи - начальные позиции чанков, а значения - размеры чанков.

    Example:
        >>> get_chunks(1048576)
        {0: 131072, 131072: 131072, 262144: 131072, 393216: 131072, 524288: 131072, 655360: 131072, 786432: 131072, 917504: 131072}
    """
    ...
```

**Как работает функция**:

1.  Инициализирует пустой словарь `chunks` для хранения информации о чанках.
2.  Устанавливает начальные значения для переменных `p` (текущая позиция), `pp` (предыдущая позиция) и `i` (счетчик).
3.  В цикле `while` создает чанки размером `i * 0x20000` (где `i` увеличивается с каждой итерацией), пока `i` меньше или равно 8 и текущая позиция `p` меньше, чем `size - i * 0x20000`.
    *   Добавляет чанк в словарь `chunks` с ключом `p` и значением `i * 0x20000`.
    *   Обновляет `pp` и `p`.
    *   Увеличивает `i`.
4.  В цикле `while` создает чанки размером `0x100000` (1 МБ), пока текущая позиция `p` меньше размера файла `size`.
    *   Добавляет чанк в словарь `chunks` с ключом `p` и значением `0x100000`.
    *   Обновляет `pp` и `p`.
5.  Создает последний чанк, размер которого равен оставшейся части файла (`size - pp`).
    *   Добавляет чанк в словарь `chunks` с ключом `pp` и значением `size - pp`.
6.  Если размер последнего чанка равен 0, удаляет его из словаря `chunks`.
7.  Возвращает словарь `chunks`.