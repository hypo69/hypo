"""
CHECKR:
=================
Сложность: 5
-----------------
Игра "Шашки" представляет собой упрощенную текстовую версию игры в шашки, где два игрока по очереди перемещают свои фигуры по доске, стараясь захватить фигуры противника. Игра заканчивается, когда один из игроков теряет все свои фигуры.

Правила игры:
1. Доска представлена в виде одномерного массива, где каждый элемент соответствует позиции на доске.
2. На доске есть два типа фигур, которые обозначаются символами "1" и "2".
3. Игроки по очереди вводят номера позиций, откуда и куда они хотят переместить свою фигуру.
4. Перемещение возможно только на соседние свободные позиции.
5. При захвате фигуры противника, фигура противника удаляется с доски, а перемещение продолжается.
6. Игра заканчивается, когда у одного из игроков не остается фигур.

Алгоритм:
1. Инициализация доски, где устанавливаются начальные позиции фигур.
2. Начать цикл "пока игра не закончена":
    2.1 Вывести текущее состояние доски.
    2.2 Запросить ввод хода от текущего игрока (номер фигуры и новое положение).
    2.3 Проверить корректность хода (существование фигуры, допустимость перемещения, возможность захвата).
    2.4 Если ход корректен, выполнить перемещение и захват (если есть).
    2.5 Проверить, не закончилась ли игра (один из игроков проиграл).
    2.6 Переключиться на следующего игрока.
3. Вывести сообщение о победе.
4. Конец игры.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["<p align='left'>Инициализация доски:
    <code><b>
    board = [1, 1, 1, 0, 0, 2, 2, 2]
    currentPlayer = 1
    </b></code></p>"]
    InitializeBoard --> LoopStart{"Начало цикла: пока игра не закончена"}
    LoopStart -- Да --> OutputBoard["Вывод текущего состояния доски"]
    OutputBoard --> InputMove["Ввод хода игроком: <code><b>piecePosition, newPosition</b></code>"]
    InputMove --> ValidateMove["Проверка корректности хода"]
    ValidateMove -- Ход корректен --> MovePiece["Перемещение фигуры и захват (если возможно)"]
    MovePiece --> CheckWin{"Проверка: <code><b>Есть ли победитель?</b></code>"}
     CheckWin -- Да --> OutputWin["Вывод сообщения о победе"]
    OutputWin --> End["Конец"]
    CheckWin -- Нет --> SwitchPlayer["<code><b>currentPlayer = 3 - currentPlayer</b></code>"]
    SwitchPlayer --> LoopStart
    ValidateMove -- Ход не корректен --> OutputError["Вывод сообщения об ошибке"]
     OutputError --> LoopStart
    LoopStart -- Нет --> End
```

Legenda:
    Start - Начало программы.
    InitializeBoard - Инициализация доски и начальных переменных.
        `board` - одномерный массив, представляющий доску.
        `currentPlayer` - номер текущего игрока (1 или 2).
    LoopStart - Начало основного цикла игры, продолжающегося пока не будет победителя.
    OutputBoard - Вывод текущего состояния доски.
    InputMove - Запрос у текущего игрока номера фигуры и нового положения.
    ValidateMove - Проверка корректности хода.
         Проверяются условия: существование фигуры, допустимость перемещения, возможность захвата.
    MovePiece - Перемещение фигуры на новую позицию.
        Включает захват фигуры противника, если это возможно.
    CheckWin - Проверка, есть ли победитель. 
        Игра заканчивается, если у одного из игроков не остается фигур.
     OutputWin - Вывод сообщения о победе.
    End - Конец программы.
    SwitchPlayer - Переключение на следующего игрока.
        Используется выражение `currentPlayer = 3 - currentPlayer` для переключения между игроками 1 и 2.
    OutputError - Вывод сообщения об ошибке, если ход не корректен
"""
__author__ = 'hypo69 (hypo69@davidka.net)'

import copy

# Инициализация доски
board = [1, 1, 1, 0, 0, 2, 2, 2]
# Текущий игрок (1 или 2)
current_player = 1
# Флаг конца игры
game_over = False
def print_board(board):
    """
        Выводит текущее состояние доски.
        
        Аргументы:
        board (list): Список, представляющий доску.
    """
    print("Текущая доска:")
    for i, piece in enumerate(board):
      print(f"{piece} ", end="")
      if (i + 1) % 4 == 0:
        print()

def get_player_pieces(board, player):
    """
    Возвращает список индексов фигур игрока.
    
    Аргументы:
        board (list): Список, представляющий доску.
        player (int): Номер игрока (1 или 2).

    Возвращает:
        list: Список индексов фигур игрока.
    """
    return [i for i, piece in enumerate(board) if piece == player]

def is_valid_move(board, piece_position, new_position, player):
    """
        Проверяет, является ли ход корректным.

    Аргументы:
         board (list): Список, представляющий доску.
         piece_position (int): Позиция фигуры, которую нужно переместить.
         new_position (int): Новая позиция фигуры.
         player (int): Номер текущего игрока (1 или 2).

        Возвращает:
           bool: True, если ход корректен, False в противном случае.
    """
    # Проверка, что позиция фигуры находится в пределах доски
    if piece_position < 0 or piece_position >= len(board):
       return False
    # Проверка, что новая позиция находится в пределах доски
    if new_position < 0 or new_position >= len(board):
       return False
    # Проверка, что в выбранной позиции есть фигура текущего игрока
    if board[piece_position] != player:
       return False
    # Проверка, что новая позиция свободна
    if board[new_position] != 0:
        return False
    # Проверка, что новая позиция находится рядом с текущей
    if abs(new_position - piece_position) != 1:
        return False
   
    return True

def make_move(board, piece_position, new_position):
    """
    Выполняет перемещение фигуры и захват (если есть).

    Аргументы:
        board (list): Список, представляющий доску.
        piece_position (int): Позиция фигуры, которую нужно переместить.
        new_position (int): Новая позиция фигуры.

    Возвращает:
        list: Обновленный список доски.
    """
    # Создаем копию доски, чтобы не изменять исходную
    new_board = copy.copy(board)
    # Перемещаем фигуру на новую позицию
    new_board[new_position] = new_board[piece_position]
    # Освобождаем старую позицию
    new_board[piece_position] = 0
    return new_board

def check_game_over(board, current_player):
    """
        Проверяет, закончилась ли игра.
        
        Аргументы:
         board (list): Список, представляющий доску.
         current_player (int): Номер текущего игрока (1 или 2).

        Возвращает:
            bool: True, если игра закончилась, False в противном случае.
    """
    # Получаем индексы фигур текущего игрока
    player_pieces = get_player_pieces(board, current_player)
    if len(player_pieces) == 0:
       return True
    # Проверяем наличие возможных ходов
    for piece_position in player_pieces:
       for new_position in range(len(board)):
            if is_valid_move(board, piece_position, new_position, current_player):
                 return False # Есть доступный ход
    return True # Нет доступных ходов
  
# Основной игровой цикл
while not game_over:
    # Выводим текущее состояние доски
    print_board(board)
    print(f"Ход игрока {current_player}")
    # Запрашиваем ввод хода
    try:
        piece_position = int(input("Выберите позицию фигуры: "))
        new_position = int(input("Выберите новую позицию: "))
    except ValueError:
        print("Неверный ввод. Введите целые числа.")
        continue
    # Проверяем корректность хода
    if is_valid_move(board, piece_position, new_position, current_player):
        # Выполняем перемещение
        board = make_move(board, piece_position, new_position)
         # Проверяем, не закончилась ли игра
        if check_game_over(board, current_player):
            game_over = True
            winner = 3 - current_player
            print_board(board)
            print(f"Победил игрок {winner}!")
        else:
            # Переключаем игрока
            current_player = 3 - current_player
    else:
        print("Некорректный ход. Попробуйте снова.")

"""
Пояснения:
1. **Инициализация игры**:
   - `board = [1, 1, 1, 0, 0, 2, 2, 2]`: Инициализирует доску, где 1 - это фигуры первого игрока, 2 - фигуры второго игрока, а 0 - пустые клетки.
   - `current_player = 1`: Устанавливает текущего игрока на первого игрока (1).
   - `game_over = False`: Инициализирует флаг конца игры в значение `False`.
2. **Функция `print_board(board)`**:
   - Выводит текущее состояние доски в консоль.
   - Проходит по каждой ячейке доски и выводит её содержимое, добавляя новую строку после каждой четвертой ячейки для наглядности.
3. **Функция `get_player_pieces(board, player)`**:
   - Принимает доску и номер игрока.
   - Возвращает список индексов всех фигур текущего игрока на доске.
4. **Функция `is_valid_move(board, piece_position, new_position, player)`**:
   - Проверяет, является ли ход корректным.
    -   Проверяет, что `piece_position` и `new_position` находятся в пределах доски.
    -   Проверяет, что в `piece_position` есть фигура текущего игрока.
    -   Проверяет, что `new_position` свободна.
    -   Проверяет, что новая позиция находится рядом с текущей.
   - Возвращает `True`, если ход корректен, и `False`, если нет.
5. **Функция `make_move(board, piece_position, new_position)`**:
   - Выполняет перемещение фигуры и захват (если есть).
    - Создает копию доски, чтобы не изменять исходную.
    - Перемещает фигуру на новую позицию.
    - Освобождает старую позицию.
   - Возвращает обновленный список доски.
6.  **Функция `check_game_over(board, current_player)`**:
    - Проверяет, закончилась ли игра.
    - Игра заканчивается, если у текущего игрока не осталось фигур на доске или нет доступных ходов.
    - Возвращает `True`, если игра закончилась, и `False` в противном случае.
7. **Основной игровой цикл `while not game_over:`**:
   - Выводит текущее состояние доски.
   - Запрашивает у пользователя позицию фигуры и новую позицию для хода.
   - Проверяет корректность ввода и самого хода (с помощью `is_valid_move`).
   - Если ход корректен:
     - Выполняет перемещение фигуры на доске (с помощью `make_move`).
     - Проверяет, закончилась ли игра (с помощью `check_game_over`).
     - Если игра закончилась, устанавливает `game_over = True`, определяет победителя и выводит сообщение о победе.
     - Если игра не закончилась, переключает текущего игрока.
   - Если ход некорректен, выводит сообщение об ошибке.
8. **Обработка исключений `try...except ValueError:`**:
    -   Блок try-except обрабатывает возможные ошибки ввода. Если пользователь введет не целое число, то будет выведено сообщение об ошибке.
"""
```