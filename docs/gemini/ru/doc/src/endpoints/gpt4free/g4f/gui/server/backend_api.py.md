# Модуль backend_api.py

## Обзор

Модуль `backend_api.py` является частью проекта `hypotez` и содержит класс `Backend_Api`, который обрабатывает различные API endpoints для серверных операций Flask-приложения. Этот модуль предоставляет функциональность для взаимодействия с моделями, провайдерами, обработки разговоров, управления версиями и обработки ошибок.

## Подробнее

Этот модуль реализует API для различных операций, таких как получение списка моделей, провайдеров, обработка запросов на разговор, управление файлами и куки, а также синтез речи. Он использует Flask для определения endpoints и обработки HTTP-запросов.

## Классы

### `Backend_Api`

**Описание**:
Класс `Backend_Api` обрабатывает различные endpoints в Flask-приложении для серверных операций. Он предоставляет методы для взаимодействия с моделями, провайдерами, обработки разговоров, обработки ошибок и управления версиями.

**Принцип работы**:

1.  **Инициализация**: При инициализации класса `Backend_Api` создается экземпляр Flask-приложения и определяются маршруты для различных API endpoints.
2.  **Обработка запросов**: Для каждого endpoint определена соответствующая функция, которая обрабатывает HTTP-запросы, взаимодействует с моделями и провайдерами, и возвращает результаты в формате JSON или в виде потока данных.
3.  **Взаимодействие с моделями и провайдерами**: Класс использует другие модули проекта, такие как `ChatCompletion`, `models`, и `convert_to_provider`, для взаимодействия с различными AI-моделями и провайдерами.
4.  **Управление файлами и куки**: Класс предоставляет endpoints для загрузки и управления файлами и куки, используя функции из модулей `files`, `copy_images`, и `cookies`.
5.  **Синтез речи**: Класс также предоставляет функциональность для синтеза речи, используя методы провайдеров.

**Методы**:

-   `__init__(self, app: Flask) -> None`: Инициализирует API backend с заданным Flask-приложением.
-   `handle_synthesize(self, provider: str)`: Обрабатывает запросы на синтез речи для указанного провайдера.
-   `get_provider_models(self, provider: str)`: Получает список моделей для указанного провайдера.
-   `_format_json(self, response_type: str, content=None, **kwargs) -> str`: Форматирует и возвращает JSON-ответ.

**Параметры**:

-   `app` (Flask): Экземпляр Flask-приложения.
-   `routes` (dict): Словарь, сопоставляющий API endpoints с их обработчиками.

**Примеры**:

```python
from flask import Flask

app = Flask(__name__)
backend_api = Backend_Api(app)

# Пример использования одного из endpoints (предположим, что `get_version` определен в классе `Backend_Api`)
with app.test_request_context('/backend-api/v2/version'):
    version_info = backend_api.get_version()
    print(version_info)
```

## Функции

### `safe_iter_generator`

```python
def safe_iter_generator(generator: Generator) -> Generator:
    """
    Оборачивает генератор, чтобы гарантировать, что он выдает хотя бы одно значение.

    Args:
        generator (Generator): Исходный генератор.

    Returns:
        Generator: Новый генератор, который сначала выдает первое значение из исходного генератора, а затем все остальные.

    Как работает функция:
    1. Извлекает первое значение из исходного генератора.
    2. Определяет внутреннюю функцию iter_generator, которая сначала выдает сохраненное первое значение, а затем все остальные значения из исходного генератора.
    3. Возвращает новую функцию iter_generator как генератор.

    Внутри функции происходят следующие действия и преобразования:
    Первое значение генератора --> Сохранение первого значения
    |
    -- Создание нового генератора с первым значением и остальными значениями из исходного генератора
    |
    Возврат нового генератора

    Примеры:
        >>> def number_generator(n):
        ...     for i in range(n):
        ...         yield i
        >>> gen = number_generator(3)
        >>> safe_gen = safe_iter_generator(gen)
        >>> list(safe_gen)
        [0, 1, 2]

        >>> def empty_generator():
        ...     return
        >>> safe_gen = safe_iter_generator(empty_generator()) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            ...
        StopIteration
    """
    ...
```

### `home`

```python
@app.route('/', methods=['GET'])
def home():
    """
    Отображает главную страницу.

    В зависимости от режима (демонстрационный или обычный) отображает разные шаблоны.

    Returns:
        str: HTML-код главной страницы.

    Как работает функция:
    1. Проверяет, находится ли приложение в демонстрационном режиме (app.demo).
    2. Если в демонстрационном режиме, загружает переменные окружения OAUTH_CLIENT_ID и G4F_BACKEND_URL.
    3. Возвращает шаблон demo.html с соответствующими переменными, если в демонстрационном режиме, или шаблон home.html в противном случае.

    Внутри функции происходят следующие действия и преобразования:
    Демонстрационный режим? --> Загрузка переменных окружения
    |
    -- Возврат соответствующего HTML-шаблона
    |
    Возврат HTML-кода

    Примеры:
        Предположим, что приложение находится в демонстрационном режиме и переменные окружения установлены.
        В этом случае функция вернет шаблон demo.html с соответствующими значениями.
        Если приложение не в демонстрационном режиме, будет возвращен шаблон home.html.
    """
    ...
```

### `qrcode`

```python
@app.route('/qrcode', methods=['GET'])
@app.route('/qrcode/<conversation_id>', methods=['GET'])
def qrcode(conversation_id: str = ""):
    """
    Отображает QR-код для заданной conversation_id.

    Args:
        conversation_id (str, optional): Идентификатор разговора. По умолчанию "".

    Returns:
        str: HTML-код страницы QR-кода.

    Как работает функция:
    1. Загружает переменную окружения G4F_SHARE_URL.
    2. Возвращает шаблон qrcode.html с conversation_id и share_url.

    Внутри функции происходят следующие действия и преобразования:
    Загрузка переменной окружения G4F_SHARE_URL
    |
    -- Возврат HTML-шаблона qrcode.html с conversation_id и share_url
    |
    Возврат HTML-кода

    Примеры:
        >>> # Предположим, что переменная окружения G4F_SHARE_URL установлена.
        >>> # Функция вернет шаблон qrcode.html с соответствующими значениями.
        >>> qrcode(conversation_id="123")
        # Вернет HTML-страницу с QR-кодом для conversation_id "123"
    """
    ...
```

### `jsonify_models`

```python
@app.route('/backend-api/v2/models', methods=['GET'])
def jsonify_models(**kwargs):
    """
    Возвращает JSON-ответ со списком моделей.

    Args:
        **kwargs: Дополнительные аргументы.

    Returns:
        flask.Response: JSON-ответ со списком моделей.

    Как работает функция:
    1. Проверяет, находится ли приложение в демонстрационном режиме (app.demo).
    2. Если в демонстрационном режиме, вызывает функцию get_demo_models().
    3. Если не в демонстрационном режиме, вызывает метод self.get_models(**kwargs).
    4. Проверяет, является ли ответ списком.
    5. Если ответ является списком, возвращает его в формате JSON.
    6. Если ответ не является списком, возвращает его как есть.

    Внутри функции происходят следующие действия и преобразования:
    Демонстрационный режим? --> Вызов get_demo_models()
    |
    -- Вызов self.get_models(**kwargs)
    |
    Является ли ответ списком? --> Возврат JSON-ответа
    |
    Возврат ответа как есть

    Примеры:
        >>> # Предположим, что приложение находится в демонстрационном режиме и get_demo_models() возвращает список моделей.
        >>> # Функция вернет JSON-ответ с этим списком.
        >>> jsonify_models()
        # Вернет JSON-ответ со списком моделей
    """
    ...
```

### `jsonify_provider_models`

```python
@app.route('/backend-api/v2/models/<provider>', methods=['GET'])
def jsonify_provider_models(**kwargs):
    """
    Возвращает JSON-ответ со списком моделей для указанного провайдера.

    Args:
        **kwargs: Дополнительные аргументы.

    Returns:
        flask.Response: JSON-ответ со списком моделей.

    Как работает функция:
    1. Вызывает метод self.get_provider_models(**kwargs).
    2. Проверяет, является ли ответ списком.
    3. Если ответ является списком, возвращает его в формате JSON.
    4. Если ответ не является списком, возвращает его как есть.

    Внутри функции происходят следующие действия и преобразования:
    Вызов self.get_provider_models(**kwargs)
    |
    -- Является ли ответ списком? --> Возврат JSON-ответа
    |
    Возврат ответа как есть

    Примеры:
        >>> # Предположим, что self.get_provider_models() возвращает список моделей для провайдера "example".
        >>> # Функция вернет JSON-ответ с этим списком.
        >>> jsonify_provider_models(provider="example")
        # Вернет JSON-ответ со списком моделей для провайдера "example"
    """
    ...
```

### `jsonify_providers`

```python
@app.route('/backend-api/v2/providers', methods=['GET'])
def jsonify_providers(**kwargs):
    """
    Возвращает JSON-ответ со списком провайдеров.

    Args:
        **kwargs: Дополнительные аргументы.

    Returns:
        flask.Response: JSON-ответ со списком провайдеров.

    Как работает функция:
    1. Вызывает метод self.get_providers(**kwargs).
    2. Проверяет, является ли ответ списком.
    3. Если ответ является списком, возвращает его в формате JSON.
    4. Если ответ не является списком, возвращает его как есть.

    Внутри функции происходят следующие действия и преобразования:
    Вызов self.get_providers(**kwargs)
    |
    -- Является ли ответ списком? --> Возврат JSON-ответа
    |
    Возврат ответа как есть

    Примеры:
        >>> # Предположим, что self.get_providers() возвращает список провайдеров.
        >>> # Функция вернет JSON-ответ с этим списком.
        >>> jsonify_providers()
        # Вернет JSON-ответ со списком провайдеров
    """
    ...
```

### `get_demo_models`

```python
def get_demo_models():
    """
    Возвращает список демонстрационных моделей с информацией об их поддержке изображений, vision и провайдерах.

    Returns:
        list: Список словарей, каждый из которых содержит информацию о демонстрационной модели.
              Каждый словарь содержит ключи: "name" (имя модели), "image" (поддерживает ли модель изображения),
              "vision" (поддерживает ли модель vision), "providers" (список провайдеров, поддерживающих модель),
              "demo" (является ли модель демонстрационной).

    Как работает функция:
    1. Итерирует по словарю `models.demo_models`, который содержит модели и список их провайдеров.
    2. Для каждой модели создает словарь с информацией о модели и ее провайдерах.
    3. Возвращает список этих словарей.

    Внутри функции происходят следующие действия и преобразования:
    Итерация по моделям и провайдерам
    |
    -- Создание словаря с информацией о модели
    |
    Возврат списка словарей

    Примеры:
        >>> # Предположим, что models.demo_models содержит две модели: model1 и model2.
        >>> # Функция вернет список словарей с информацией об этих моделях.
        >>> get_demo_models()
        # Вернет список словарей с информацией о model1 и model2
    """
    ...
```

### `handle_conversation`

```python
def handle_conversation():
    """
    Обрабатывает запросы на разговор и передает потоковые ответы обратно.

    Returns:
        Response: Flask-объект ответа для потоковой передачи.

    Как работает функция:
    1. Извлекает данные JSON из формы запроса или тела запроса.
    2. Если в запросе есть файлы, добавляет их в данные JSON.
    3. Если приложение находится в демонстрационном режиме и не указан провайдер, выбирает случайного провайдера из списка демонстрационных провайдеров.
    4. Подготавливает аргументы для разговора с помощью метода `_prepare_conversation_kwargs`.
    5. Создает потоковый ответ с помощью метода `_create_response_stream`.
    6. Возвращает Flask-объект ответа для потоковой передачи.

    Внутри функции происходят следующие действия и преобразования:
    Извлечение данных JSON --> Добавление файлов (если есть) --> Выбор провайдера (если необходимо)
    |
    -- Подготовка аргументов для разговора --> Создание потокового ответа
    |
    Возврат Flask-объекта ответа для потоковой передачи

    Примеры:
        >>> # Пример вызова функции с данными JSON и файлами.
        >>> # Функция вернет Flask-объект ответа для потоковой передачи.
        handle_conversation()
        # Вернет Flask-объект ответа для потоковой передачи
    """
    ...
```

### `_handle_conversation`

```python
@app.route('/backend-api/v2/conversation', methods=['POST'])
def _handle_conversation():
    """
    Обработчик маршрута для `/backend-api/v2/conversation`.

    Вызывает функцию `handle_conversation` для обработки запроса.

    Returns:
        Response: Результат выполнения функции `handle_conversation`.
    """
    ...
```

### `add_usage`

```python
@app.route('/backend-api/v2/usage', methods=['POST'])
def add_usage():
    """
    Добавляет данные об использовании в лог-файл.

    Создает директорию `.usage` в директории cookies (если она не существует) и записывает JSON-данные из запроса в файл `.jsonl`,
    имя которого соответствует текущей дате.

    Returns:
        dict: Пустой словарь `{}`.

    Как работает функция:
    1. Определяет директорию для хранения логов использования.
    2. Создает директорию, если она не существует.
    3. Определяет имя файла для хранения логов использования на текущую дату.
    4. Открывает файл для записи (создает, если не существует, или добавляет в конец, если существует).
    5. Записывает JSON-данные из запроса в файл в формате JSON Lines.
    6. Возвращает пустой словарь.

    Внутри функции происходят следующие действия и преобразования:
    Определение директории и файла --> Создание директории (если необходимо)
    |
    -- Открытие файла для записи --> Запись данных в файл
    |
    Возврат пустого словаря

    Примеры:
        >>> # Пример вызова функции с данными в запросе.
        >>> # Функция вернет пустой словарь и запишет данные в лог-файл.
        add_usage()
        # Вернет {}
    """
    ...
```

### `add_log`

```python
@app.route('/backend-api/v2/log', methods=['POST'])
def add_log():
    """
    Добавляет логи в лог-файл.

    Создает директорию `.logging` в директории cookies (если она не существует) и записывает JSON-данные из запроса в файл `.jsonl`,
    имя которого соответствует текущей дате.

    Returns:
        dict: Пустой словарь `{}`.

    Как работает функция:
    1. Определяет директорию для хранения логов.
    2. Создает директорию, если она не существует.
    3. Определяет имя файла для хранения логов на текущую дату.
    4. Открывает файл для записи (создает, если не существует, или добавляет в конец, если существует).
    5. Добавляет в данные информацию об источнике запроса (origin).
    6. Записывает JSON-данные из запроса (с добавленной информацией об источнике) в файл в формате JSON Lines.
    7. Возвращает пустой словарь.

    Внутри функции происходят следующие действия и преобразования:
    Определение директории и файла --> Создание директории (если необходимо)
    |
    -- Открытие файла для записи --> Добавление информации об источнике --> Запись данных в файл
    |
    Возврат пустого словаря

    Примеры:
        >>> # Пример вызова функции с данными в запросе.
        >>> # Функция вернет пустой словарь и запишет данные в лог-файл.
        add_log()
        # Вернет {}
    """
    ...
```

### `add_memory`

```python
@app.route('/backend-api/v2/memory/<user_id>', methods=['POST'])
def add_memory(user_id: str):
    """
    Добавляет элементы в память пользователя с использованием MemoryClient.

    Args:
        user_id (str): Идентификатор пользователя.

    Returns:
        dict: Словарь, содержащий количество добавленных элементов.

    Как работает функция:
    1. Получает API-ключ из заголовка запроса `x_api_key`.
    2. Извлекает JSON-данные из тела запроса.
    3. Инициализирует MemoryClient с использованием полученного API-ключа.
    4. Добавляет элементы в память пользователя, используя MemoryClient.add().
    5. Возвращает словарь с количеством добавленных элементов.

    Внутри функции происходят следующие действия и преобразования:
    Получение API-ключа и данных из запроса --> Инициализация MemoryClient
    |
    -- Добавление элементов в память пользователя --> Возврат словаря с количеством добавленных элементов
    |
    Возврат словаря с количеством добавленных элементов

    Примеры:
        >>> # Пример вызова функции с user_id и данными в запросе.
        >>> # Функция вернет словарь с количеством добавленных элементов.
        add_memory(user_id="123")
        # Вернет {"count": N}, где N - количество добавленных элементов
    """
    ...
```

### `read_memory`

```python
@app.route('/backend-api/v2/memory/<user_id>', methods=['GET'])
def read_memory(user_id: str):
    """
    Получает данные из памяти пользователя с использованием MemoryClient.

    Args:
        user_id (str): Идентификатор пользователя.

    Returns:
        dict | list: Результат поиска или список всех элементов памяти пользователя.

    Как работает функция:
    1. Получает API-ключ из заголовка запроса `x_api_key`.
    2. Инициализирует MemoryClient с использованием полученного API-ключа.
    3. Если в параметрах запроса есть `search`, выполняет поиск по памяти пользователя с использованием MemoryClient.search().
    4. Если в параметрах запроса нет `search`, получает все элементы памяти пользователя с использованием MemoryClient.get_all().
    5. Возвращает результат поиска или список всех элементов памяти пользователя.

    Внутри функции происходят следующие действия и преобразования:
    Получение API-ключа --> Инициализация MemoryClient --> Проверка наличия параметра `search`
    |
    -- Выполнение поиска (если `search` есть) или получение всех элементов (если `search` нет)
    |
    Возврат результата поиска или списка всех элементов

    Примеры:
        >>> # Пример вызова функции с user_id и параметром search.
        >>> # Функция вернет результат поиска в памяти пользователя.
        read_memory(user_id="123", search="keyword")
        # Вернет результат поиска

        >>> # Пример вызова функции с user_id без параметра search.
        >>> # Функция вернет список всех элементов памяти пользователя.
        read_memory(user_id="123")
        # Вернет список всех элементов
    """
    ...
```

### `create`

```python
@app.route('/backend-api/v2/create', methods=['GET', 'POST'])
def create():
    """
    Создает ответ с использованием модели чата, выполняя поиск в интернете и фильтрацию Markdown.

    Returns:
        Response: Ответ Flask с текстом в формате text/plain.

    Raises:
        Exception: Если во время обработки запроса произошла ошибка.

    Как работает функция:
    1. Определяет список инструментов (`tool_calls`), которые будут использоваться для обработки запроса.
       В список добавляется инструмент `bucket_tool`.
    2. Проверяет, передан ли параметр `web_search` в запросе. Если да, добавляет инструмент `search_tool` в список `tool_calls`.
    3. Получает значения параметров из запроса (`filter_markdown`, `cache`, `model`, `prompt`, `provider`, `stream`).
    4. Формирует словарь `parameters` с параметрами для вызова `ChatCompletion.create`.
    5. Если передан параметр `cache`, создает идентификатор кэша на основе параметров запроса и пытается получить ответ из кэша.
       Если ответ в кэше не найден, выполняет запрос к `ChatCompletion.create`, сохраняет результат в кэше и возвращает его.
    6. Если параметр `cache` не передан, выполняет запрос к `ChatCompletion.create` и возвращает результат.
    7. Если передан параметр `filter_markdown`, фильтрует результат с помощью `filter_markdown` и возвращает его.
    8. Обрабатывает возможные исключения и возвращает JSON-ответ с информацией об ошибке.

    Внутри функции происходят следующие действия и преобразования:
    Определение инструментов --> Получение параметров из запроса --> Формирование словаря параметров
    |
    -- Проверка наличия кэша --> Получение ответа из кэша или выполнение запроса к ChatCompletion.create
    |
    Фильтрация Markdown (если необходимо) --> Возврат ответа или информации об ошибке

    Примеры:
        >>> # Пример вызова функции с параметрами web_search и filter_markdown.
        >>> # Функция выполнит поиск в интернете, получит ответ от модели чата, отфильтрует Markdown и вернет результат.
        create(web_search="example", filter_markdown="true")
        # Вернет отфильтрованный ответ от модели чата

        >>> # Пример вызова функции с параметром cache.
        >>> # Функция попытается получить ответ из кэша. Если ответ в кэше не найден, выполнит запрос к модели чата,
        >>> # сохранит результат в кэше и вернет его.
        create(cache="cache_id", prompt="example prompt")
        # Вернет ответ от модели чата (из кэша или после выполнения запроса)
    """
    ...
```

### `manage_files`

```python
@app.route('/backend-api/v2/files/<bucket_id>', methods=['GET', 'DELETE'])
def manage_files(bucket_id: str):
    """
    Управляет файлами в указанном bucket (удаляет bucket или возвращает содержимое).

    Args:
        bucket_id (str): Идентификатор bucket.

    Returns:
        Response: Ответ Flask с содержимым bucket или информацией об удалении.

    Raises:
        Exception: Если произошла ошибка при удалении bucket.

    Как работает функция:
    1. Sanitize `bucket_id` с помощью `secure_filename`.
    2. Получает путь к директории bucket с помощью `get_bucket_dir`.
    3. Проверяет, существует ли директория bucket. Если нет, возвращает JSON-ответ с информацией об ошибке.
    4. Если метод запроса `DELETE`, пытается удалить директорию bucket и возвращает JSON-ответ с информацией об успехе или ошибке.
    5. Если метод запроса `GET`, получает параметры `delete_files`, `refine_chunks_with_spacy` и `event_stream` из запроса.
    6. Возвращает содержимое bucket с помощью `get_streaming` и устанавливает соответствующий mimetype.

    Внутри функции происходят следующие действия и преобразования:
    Sanitize bucket_id --> Получение пути к директории bucket --> Проверка существования директории bucket
    |
    -- Если метод DELETE: попытка удаления директории bucket --> Возврат JSON-ответа с информацией об успехе или ошибке
    |
    -- Если метод GET: получение параметров из запроса --> Получение содержимого bucket с помощью get_streaming
    |
    Возврат содержимого bucket или информации об удалении
    """
    ...
```

### `upload_files`

```python
@self.app.route('/backend-api/v2/files/<bucket_id>', methods=['POST'])
def upload_files(bucket_id: str):
    """
    Загружает файлы в указанный bucket.

    Args:
        bucket_id (str): Идентификатор bucket.

    Returns:
        dict: Словарь с информацией о загруженных файлах (bucket_id, files, media).

    Как работает функция:
    1. Sanitize `bucket_id` с помощью `secure_filename`.
    2. Получает путь к директории bucket с помощью `get_bucket_dir`.
    3. Создает директории bucket и media (если необходимо).
    4. Итерирует по файлам, переданным в запросе.
    5. Sanitize имя каждого файла с помощью `secure_filename`.
    6. Проверяет расширение файла с помощью `is_allowed_extension` или `supports_filename`.
    7. Сохраняет файл в соответствующей директории (media или bucket).
    8. Записывает список загруженных файлов в файл `files.txt` в директории bucket.
    9. Возвращает словарь с информацией о загруженных файлах.

    Внутри функции происходят следующие действия и преобразования:
    Sanitize bucket_id --> Получение пути к директории bucket --> Создание директорий
    |
    -- Итерация по файлам в запросе --> Sanitize имя файла --> Проверка расширения файла
    |
    -- Сохранение файла в соответствующей директории --> Запись списка файлов в файл files.txt
    |
    Возврат словаря с информацией о загруженных файлах
    """
    ...
```

### `get_media`

```python
@app.route('/files/<bucket_id>/media/<filename>', methods=['GET'])
def get_media(bucket_id, filename, dirname: str = None):
    """
    Возвращает медиафайл из указанного bucket.

    Args:
        bucket_id (str): Идентификатор bucket.
        filename (str): Имя файла.
        dirname (str, optional): Имя директории. По умолчанию `None`.

    Returns:
        Response: Ответ Flask с медиафайлом.

    Raises:
        NotFound: Если файл не найден и `source_url` отсутствует.

    Как работает функция:
    1. Получает путь к директории media с помощью `get_bucket_dir`.
    2. Пытается вернуть файл из директории media с помощью `send_from_directory`.
    3. Если файл не найден, пытается получить `source_url` из параметров запроса.
    4. Если `source_url` получен, выполняет редирект на `source_url`.
    5. Если `source_url` отсутствует, выбрасывает исключение `NotFound`.

    Внутри функции происходят следующие действия и преобразования:
    Получение пути к директории media --> Попытка возврата файла с помощью send_from_directory
    |
    -- Если файл не найден: попытка получения source_url из параметров запроса
    |
    -- Если source_url получен: редирект на source_url
    |
    Выбрасывание исключения NotFound (если source_url отсутствует)
    """
    ...
```

### `find_media`

```python
@app.route('/search/<search>', methods=['GET'])
def find_media(search: str):
    """
    Выполняет поиск медиафайлов по тегам.

    Args:
        search (str): Строка поиска (теги, разделенные знаком "+").

    Returns:
        Response: Перенаправление на найденный медиафайл или JSON-ответ с ошибкой, если ничего не найдено.

    Raises:
        NotFound: Если файлы не найдены.

    Как работает функция:
    1. Подготавливает поисковые теги, разделяя строку поиска на отдельные теги и приводя их к нижнему регистру.
    2. Проверяет доступность директории с изображениями. Если директория недоступна, возвращает JSON-ответ с ошибкой.
    3. Выполняет поиск файлов в директории с изображениями, проверяя соответствие тегам.
    4. Формирует список файлов, соответствующих поисковым тегам.
    5. Если найден хотя бы один файл, выполняет перенаправление на случайный или первый файл из списка (в зависимости от параметров запроса).
    6. Если файлы не найдены или параметр `skip` указывает на несуществующий индекс, возвращает JSON-ответ с ошибкой.

    Внутри функции происходят следующие действия и преобразования:
    Подготовка поисковых тегов --> Проверка доступности директории с изображениями --> Поиск файлов в директории
    |
    -- Формирование списка файлов, соответствующих поисковым тегам --> Перенаправление на найденный файл или возврат JSON-ответа с ошибкой
    |
    Возврат перенаправления или JSON-ответа с ошибкой
    """
    ...
```

### `upload_cookies`

```python
@app.route('/backend-api/v2/upload_cookies', methods=['POST'])
def upload_cookies():
    """
    Загружает файл с cookies на сервер.

    Returns:
        str: Сообщение об успехе или ошибке загрузки.
        int: HTTP-код ответа (200 в случае успеха, 400 в случае ошибки).

    Как работает функция:
    1. Проверяет, был ли передан файл в запросе.
    2. Проверяет имя файла на соответствие разрешенным расширениям (.json или .har).
    3. Sanitize имя файла с помощью `secure_filename`.
    4. Сохраняет файл в директории с cookies.
    5. Возвращает сообщение об успехе или ошибке и соответствующий HTTP-код.

    Внутри функции происходят следующие действия и преобразования:
    Проверка наличия файла в запросе --> Проверка расширения файла --> Sanitize имя файла
    |
    -- Сохранение файла в директории с cookies --> Возврат сообщения об успехе или ошибке и HTTP-кода
    |
    Возврат сообщения и HTTP-кода
    """
    ...
```

### `get_chat`

```python
@self.app.route('/backend-api/v2/chat/<share_id>', methods=['GET'])
def get_chat(share_id: str) -> str:
    """
    Получает данные чата по `share_id`.

    Args:
        share_id (str): Идентификатор чата.

    Returns:
        str: JSON-ответ с данными чата или сообщение об ошибке.

    Raises:
        NotFound: Если чат с указанным `share_id` не найден.

    Как работает функция:
    1. Sanitize `share_id` с помощью `secure_filename`.
    2. Проверяет, не был ли чат уже получен с текущей версией (сравнивает `if-none-match` с кэшем).
    3. Если чат не был модифицирован, возвращает код 304 (Not Modified).
    4. Получает путь к файлу чата.
    5. Проверяет, существует ли файл чата. Если нет, возвращает код 404 (Not Found).
    6. Загружает данные чата из файла.
    7. Проверяет, не был ли чат модифицирован с момента последнего получения (сравнивает `updated` с `if-none-match`).
    8. Если чат не был модифицирован, возвращает код 304 (Not Modified).
    9. Обновляет кэш с новым значением `updated`.
    10. Возвращает данные чата в формате JSON.

    Внутри функции происходят следующие действия и преобразования:
    Sanitize share_id --> Проверка наличия в кэше --> Проверка существования файла
    |
    -- Загрузка данных из файла --> Проверка `updated` --> Обновление кэша
    |
    Возврат данных в формате JSON или кода 304/404
    """
    ...
```

### `upload_chat`

```python
@self.app.route('/backend-api/v2/chat/<share_id>', methods=['POST'])
def upload_chat(share_id: str) -> dict:
    """
    Загружает данные чата по `share_id`.

    Args:
        share_id (str): Идентификатор чата.

    Returns:
        dict: Словарь с `share_id`.

    Как работает функция:
    1. Получает данные чата из запроса.
    2. Проверяет, не была ли версия чата уже загружена (сравнивает `updated` с кэшем).
    3. Если версия чата совпадает с кэшем, возвращает код 400 (Bad Request).
    4. Sanitize `share_id` с помощью `secure_filename`.
    5. Получает путь к директории bucket.
    6. Создает директорию bucket (если она не существует).
    7. Сохраняет данные чата в файл `chat.json`.
    8. Обновляет кэш с новым значением `updated`.
    9. Возвращает словарь с `share_id`.

    Внутри функции происходят следующие действия и преобразования:
    Получение данных из запроса --> Проверка версии чата --> Sanitize share_id
    |
    -- Получение пути к директории bucket --> Создание директории --> Сохранение данных в файл
    |
    Обнов