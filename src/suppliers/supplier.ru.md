# Анализ кода `hypotez/src/suppliers/supplier.py`

## <алгоритм>

1.  **Инициализация `Supplier`**:
    *   При создании экземпляра `Supplier` вызывается `__init__`.
    *   Инициализируются атрибуты класса, такие как `supplier_id`, `supplier_prefix`, `locale`, `price_rule`, `related_modules`, `scenario_files`, `current_scenario`, `locators` и `driver`.
    *   Вызывается метод `_payload()` для загрузки настроек.
    *   Если `_payload()` возвращает `False`, выбрасывается исключение `DefaultSettingsException`.

    **Пример**:
    ```python
    supplier = Supplier(supplier_prefix="test_supplier")
    ```

2.  **Загрузка настроек (`_payload`)**:
    *   Логируется начало загрузки настроек для текущего поставщика.
    *   Динамически импортируется модуль, связанный с поставщиком (например, `src.suppliers.test_supplier`). Если модуль не найден, возвращается `False` и логируется ошибка.
    *   Формируется путь к файлу настроек поставщика (например, `src/suppliers/test_supplier_settings.json`).
    *   Из файла настроек загружаются данные с помощью `j_loads_ns` (предполагается загрузка в `SimpleNamespace`). Если файл не найден или не содержит данных, возвращается `False` и логируется ошибка.
    *   Загруженные данные (правило расчета цен, локаль, файлы сценариев и локаторы) устанавливаются в качестве атрибутов объекта `Supplier`. Если в файле настроек отсутствуют данные, то используются значения по умолчанию.
    *   Логируется успешная загрузка настроек, возвращается `True`.
    *   Если возникает исключение, возвращается `False` и логируется ошибка.

    **Пример**:
    Предположим, что файл `test_supplier_settings.json` содержит:
    ```json
    {
        "price_rule": "custom_rule",
        "locale": "ru",
        "scenario_files": ["scenario1.json", "scenario2.json"],
        "locators": {
            "login_button": "#login_button"
         }
    }
    ```

    В этом случае:
        * `self.price_rule` будет установлен в "custom_rule"
        * `self.locale` будет установлен в "ru"
        * `self.scenario_files` будет установлен в `["scenario1.json", "scenario2.json"]`
        * `self.locators` будет установлен в `{"login_button": "#login_button"}`
    
3.  **Вход в систему (`login`)**:
    *   Вызывается метод `login` из динамически загруженного модуля поставщика (например, `src.suppliers.test_supplier.login`).
    *   Метод `login` модуля поставщика получает экземпляр класса `Supplier` в качестве аргумента, выполняет вход на сайт поставщика и возвращает `True` или `False`.

    **Пример**:
    ```python
    supplier.login()  # Вызовет src.suppliers.test_supplier.login(supplier)
    ```
4.  **Запуск файлов сценариев (`run_scenario_files`)**:
    *   Вызывается функция `run_scenario_files` из `src.scenario`.
    *   Функция получает экземпляр `Supplier` и список файлов сценариев для выполнения.
    *   Если `scenario_files` не указан, берется список файлов из атрибута `self.scenario_files`.
    *   Возвращает `True`, если все сценарии успешно выполнены, иначе `False`.

    **Пример**:
    ```python
    supplier.run_scenario_files() # Выполнит сценарии из self.scenario_files
    supplier.run_scenario_files(["new_scenario.json"]) # выполнит сценарии из списка
    ```

5.  **Запуск сценариев (`run_scenarios`)**:
    *   Вызывается функция `run_scenarios` из `src.scenario`.
    *   Функция получает экземпляр `Supplier` и сценарий (словарь) или список сценариев для выполнения.
    *   Возвращает `True`, если сценарий(и) успешно выполнен(ы), иначе `False`.
    
    **Пример**:
    ```python
    supplier.run_scenarios({"step1": "do_something"}) # выполнит сценарий
    supplier.run_scenarios([{"step1": "do_something"}, {"step2": "do_another_thing"}]) # выполнит список сценариев
    **Блок-схема**:

```mermaid
graph TD
    Start[Создание экземпляра Supplier] --> Init[Инициализация Supplier]
    Init --> LoadSettings{Загрузка настроек _payload()}
    LoadSettings -- Успех --> LoadJSON[Загрузка настроек из JSON]
    LoadJSON --> SetAttributes[Установка атрибутов Supplier]
    SetAttributes --> Success{Возврат True}
    LoadSettings -- Ошибка --> RaiseException[Выброс исключения DefaultSettingsException]
    Success --> Login[Вход на сайт login()]
    Login --> CallLogin[Вызов related_modules.login()]
    Start --> RunScenarioFiles[Запуск файлов сценариев run_scenario_files()]
    RunScenarioFiles --> CallScenarioFiles[Вызов run_scenario_files из src.scenario]
    Start --> RunScenarios[Запуск сценариев run_scenarios()]
    RunScenarios --> CallScenarios[Вызов run_scenarios из src.scenario]

    style Start fill:#f9f,stroke:#333,stroke-width:2px
    style LoadSettings fill:#ccf,stroke:#333,stroke-width:2px
    style LoadJSON fill:#ccf,stroke:#333,stroke-width:2px
    style SetAttributes fill:#ccf,stroke:#333,stroke-width:2px
```

     - ### Легенда:

    1. **Start[Создание экземпляра Supplier]**: Начало процесса, создание экземпляра класса `Supplier`.
    2. **Init[Инициализация Supplier]**: Вызов метода инициализации класса `__init__`.
    3. **LoadSettings{Загрузка настроек _payload()}**: Вызов метода `_payload()` для загрузки настроек.
       - **Успех**: Успешная загрузка настроек, переход к загрузке и установке атрибутов.
       - **Ошибка**: Возникновение ошибки во время загрузки настроек.
    4. **LoadJSON[Загрузка настроек из JSON]**: Загрузка настроек поставщика из JSON-файла.
    5. **SetAttributes[Установка атрибутов Supplier]**: Установка атрибутов экземпляра класса `Supplier` из загруженных настроек.
    6. **Success{Возврат True}**: Возврат `True` из метода `_payload()` после успешной загрузки настроек.
    7. **RaiseException[Выброс исключения DefaultSettingsException]**: Выбрасывание исключения `DefaultSettingsException`, если загрузка настроек не удалась.
    8. **Login[Вход на сайт login()]**: Вызов метода `login()` для входа на сайт поставщика.
    9. **CallLogin[Вызов related_modules.login()]**: Вызов метода `login` из модуля, специфичного для поставщика.
    10. **RunScenarioFiles[Запуск файлов сценариев run_scenario_files()]**: Вызов метода `run_scenario_files` для выполнения сценариев из файлов.
    11. **CallScenarioFiles[Вызов run_scenario_files из src.scenario]**: Вызов внешней функции `run_scenario_files` из модуля `src.scenario` для запуска сценариев.
    12. **RunScenarios[Запуск сценариев run_scenarios()]**: Вызов метода `run_scenarios` для выполнения сценариев.
    13. **CallScenarios[Вызов run_scenarios из src.scenario]**: Вызов внешней функции `run_scenarios` из модуля `src.scenario` для запуска сценариев.

### Зависимости:

*   **importlib**: Используется для динамической загрузки модулей поставщиков. Это позволяет гибко добавлять и настраивать поставщиков без изменения основного кода класса `Supplier`.
*  **typing**: Используется для статической типизации, что делает код более читаемым и понятным. `List`, `Optional`, `Dict`, `Any` для аннотации типов.
*   **types**: Используется для работы с модулями и простыми пространствами имен (`ModuleType`, `SimpleNamespace`).
*   **pydantic**: Используется для валидации данных и управления моделями (`BaseModel`, `Field`, `validator`). Обеспечивает проверку типа и корректности данных, поступающих в модель `Supplier`.
*   **header**:  Предположительно, это пользовательский модуль, возможно, содержащий общие определения или конфигурацию. Неявно используется для работы с зависимостями проекта (возможно, используется для определения констант или путей).
*   **src.gs**: `gs` используется для доступа к глобальным настройкам проекта, в частности `gs.path.src` для построения пути к файлам конфигурации поставщиков.
*   **src.utils.jjson**: `j_loads_ns` используется для загрузки данных из JSON-файлов в виде `SimpleNamespace`. Обеспечивает удобный доступ к данным из конфигурационных файлов.
*   **src.webdriver.driver**: `Driver` - класс, представляющий веб-драйвер.
*   **src.scenario**:  Содержит функции для запуска сценариев `run_scenarios` и `run_scenario_files`.
*   **src.logger.logger**: Используется для логирования событий и ошибок.
*   **src.logger.exceptions**: `DefaultSettingsException` используется для обработки ошибок при инициализации поставщика.

## <объяснение>

### Импорты:

*   `import importlib`: Позволяет динамически импортировать модули во время выполнения программы. В данном случае используется для загрузки модулей, связанных с конкретными поставщиками.
*   `from typing import List, Optional, Dict, Any`:  Используется для статической типизации, что делает код более читаемым и понятным.
    *   `List`: Тип для списков.
    *   `Optional`: Тип для переменных, которые могут быть либо заданного типа, либо `None`.
    *   `Dict`: Тип для словарей.
    *  `Any`: Тип для переменных любого типа.
*  `from types import ModuleType, SimpleNamespace`:
    *   `ModuleType`: Тип для модулей Python, используется для аннотации типа `related_modules`.
    *   `SimpleNamespace`: Простой класс для создания объектов с атрибутами, используемый для хранения загруженных настроек.
*   `from pydantic import BaseModel, Field, validator`:  `pydantic` используется для валидации данных и управления моделями.
    *   `BaseModel`: Базовый класс для создания моделей данных.
    *   `Field`: Используется для определения полей модели.
    *   `validator`: Используется для определения пользовательских валидаторов.
*   `import header`: Предположительно, это пользовательский модуль, возможно, содержащий общие определения или конфигурацию.
*   `from src import gs`:  `gs` используется для доступа к глобальным настройкам проекта, в частности, `gs.path.src`.
*   `from src.utils.jjson import j_loads_ns`:  `j_loads_ns` используется для загрузки данных из JSON-файлов в виде `SimpleNamespace`.
*   `from src.webdriver.driver import Driver`:  Импортирует класс веб-драйвера `Driver`.
*   `from src.scenario import run_scenarios, run_scenario_files`:  Импортирует функции для запуска сценариев.
*   `from src.logger.logger import logger`:  Используется для логирования событий и ошибок.
*   `from src.logger.exceptions import DefaultSettingsException`:  Исключение, используемое для обработки ошибок при инициализации поставщика.

### Классы:

*   `class Supplier(BaseModel)`:
    *   **Роль**: Базовый класс для представления поставщиков. Этот класс управляет загрузкой конфигурации, выполнением сценариев и входом на сайты поставщиков.
    *   **Атрибуты**:
        *   `supplier_id`: Идентификатор поставщика (может быть `None`).
        *   `supplier_prefix`: Префикс поставщика (строка, обязательное поле).
        *   `locale`: Код локали поставщика (по умолчанию `'en'`).
        *   `price_rule`: Правило расчета цен (может быть `None`).
        *   `related_modules`: Модуль, содержащий специфические функции для поставщика (может быть `None`).
        *   `scenario_files`: Список файлов сценариев для поставщика.
        *   `current_scenario`: Текущий исполняемый сценарий (словарь).
        *   `locators`: Локаторы для элементов страницы.
        *   `driver`: Экземпляр веб-драйвера.
    *   **Методы**:
        *   `__init__(self, **data)`: Инициализирует объект поставщика, загружает настройки через метод `_payload()`.
        *   `_payload(self)`: Загружает настройки поставщика из JSON-файла, используя `j_loads_ns` и динамически импортирует модуль, связанный с поставщиком.
        *   `login(self)`: Выполняет вход на сайт поставщика, вызывая метод `login` из модуля, связанного с поставщиком.
        *   `run_scenario_files(self, scenario_files)`: Выполняет сценарии, указанные в файлах.
        *   `run_scenarios(self, scenarios)`: Выполняет сценарии, переданные как словарь или список словарей.
        *    `check_supplier_prefix(cls, value)`: Валидатор для проверки, что `supplier_prefix` не пустая строка.
    *   **Взаимодействие**:
        *   Использует `pydantic` для валидации и управления данными.
        *   Динамически загружает модули поставщиков через `importlib`.
        *   Использует `j_loads_ns` для загрузки настроек из JSON-файлов.
        *   Использует функции из модуля `src.scenario` для выполнения сценариев.
        *   Использует `src.logger` для логирования.
        *   Использует `src.webdriver.driver` для управления веб-драйвером.
    *    `Config`: Настройки модели, `arbitrary_types_allowed = True` разрешает использовать произвольные типы данных.

### Функции:
* `_payload(self)`: Метод загружает настройки поставщика из JSON-файла, используя `j_loads_ns`.
    * **Аргументы**: `self` - экземпляр класса `Supplier`.
    * **Возвращаемое значение**: `True` в случае успеха, `False` в случае ошибки.
    * **Назначение**: Загружает конфигурационные данные поставщика (правила цен, локаль, файлы сценариев, локаторы) и сохраняет их в атрибуты объекта поставщика.
*  `login(self)`: Метод выполняет вход на сайт поставщика.
     * **Аргументы**: `self` - экземпляр класса `Supplier`.
     * **Возвращаемое значение**: `True` в случае успеха, `False` в случае ошибки.
     * **Назначение**: Вызывает метод `login` из динамически загруженного модуля поставщика.
* `run_scenario_files(self, scenario_files: Optional[str | List[str]] = None)`: Выполняет один или несколько файлов сценариев.
    * **Аргументы**:
        * `self`: экземпляр класса `Supplier`.
        * `scenario_files`: Опциональный список файлов сценариев или путь к одному файлу. Если не указан, использует `self.scenario_files`.
    * **Возвращаемое значение**: `True` в случае успеха, `False` в случае ошибки.
    * **Назначение**: Вызывает функцию `run_scenario_files` из модуля `src.scenario` для выполнения сценариев.
* `run_scenarios(self, scenarios: dict | List[dict])`: Выполняет один или несколько сценариев.
    * **Аргументы**:
        * `self`: экземпляр класса `Supplier`.
        * `scenarios`: Словарь или список словарей, представляющих сценарии.
    * **Возвращаемое значение**: `True` в случае успеха, `False` в случае ошибки.
    * **Назначение**: Вызывает функцию `run_scenarios` из модуля `src.scenario` для выполнения сценариев.

### Переменные:
*   `MODE = 'dev'`: Глобальная переменная, определяющая режим работы (например, разработка). Влияние переменной в этом конкретном файле не наблюдается.
*   `settings_path`: Локальная переменная, представляющая путь к файлу настроек поставщика.
*   `settings`: Локальная переменная, представляющая настройки поставщика, загруженные из JSON-файла в виде `SimpleNamespace`.
*   `ex`: Локальная переменная, используемая для хранения информации об исключениях.
*   `value`: Локальная переменная, используемая в валидаторе `check_supplier_prefix` для хранения значения `supplier_prefix`.
*   `related_module`: Локальная переменная, представляющая динамически загруженный модуль поставщика.
*   `scenario_files`: Аргумент функции `run_scenario_files`, может быть как строкой (путь к файлу) так и списком строк.

### Потенциальные ошибки и области для улучшения:

1.  **Обработка ошибок**:
    *   Хотя используется try-except блоки, обработка ошибок может быть более детальной.
    *   В блоке `except Exception as ex:` логируется общее исключение, но было бы полезно логировать конкретный тип ошибки для более легкой отладки.
2.  **Зависимости**:
    *   Файл `header` не определен, поэтому его назначение неясно.
    *   В зависимости от сложности проекта может потребоваться более гибкое управление зависимостями.
3.  **Улучшение валидации:**
    *   Можно добавить дополнительные валидаторы для других полей.

### Цепочка взаимосвязей с другими частями проекта:

1.  **`src.suppliers.*`**: Данный файл служит базой для всех поставщиков (например, `src.suppliers.test_supplier`). Каждый конкретный поставщик может реализовывать методы `login`, специфичные для этого поставщика.
2.  **`src.scenario`**: Класс `Supplier` использует `run_scenarios` и `run_scenario_files` для выполнения сценариев, что обеспечивает единый механизм выполнения сценариев для всех поставщиков.
3.  **`src.webdriver.driver`**:  Класс `Supplier` может использовать `Driver` для управления веб-драйвером.
4.  **`src.utils.jjson`**: `j_loads_ns` используется для загрузки настроек поставщика, обеспечивая единый механизм работы с JSON-конфигурациями.
5. **`src.logger`**: Используется для логирования событий, позволяя отслеживать состояние и работу `Supplier` и связанных процессов.
6.  **`src.gs`**: `gs.path` используется для построения путей к конфигурационным файлам, обеспечивая доступ к глобальным параметрам проекта.
7.  **`header`**:  Ожидается, что данный модуль используется для общих настроек или конфигурации, но это неявно.
8.  **`pydantic`**: Используется для валидации данных, обеспечивая корректность работы класса `Supplier`.
9.  **`types`**: Используется для работы с типами, что делает код более читаемым и понятным.
10. **`importlib`**: Используется для динамического импорта модулей, что обеспечивает гибкость и расширяемость системы.