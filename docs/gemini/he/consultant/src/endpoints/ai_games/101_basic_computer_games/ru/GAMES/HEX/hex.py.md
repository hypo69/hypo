## Анализ кода модуля hex.py

**Качество кода**
-   **Соответствие требованиям к формату кода (1-10):**

    -   **Преимущества:**
        -   Код в целом хорошо структурирован и понятен.
        -   Функции разделены логически и выполняют определенные задачи.
        -   Используются информативные имена переменных и функций.
        -   Наличие  документации к модулю, функциям и алгоритму игры.
        -  Присутствует блок-схема игры в формате mermaid.
    -   **Недостатки:**
        -   Отсутствует обработка ошибок и логирование.
        -   Ввод пользователя не защищен от неправильных данных.
        -   Не используются константы для размеров доски.
        -   Функция `check_win` содержит сложный рекурсивный алгоритм, который может быть улучшен в плане производительности и читаемости.
        -   Нет явной обработки случая ничьей.
        -  Не используется `src.utils.jjson`.
        -  Не все docstring оформлены в RST.

**Рекомендации по улучшению**
1.  **Обработка ошибок и логирование**:
    -   Добавить обработку исключений в функции `get_move` для предотвращения сбоев программы при некорректном вводе.
    -   Использовать `from src.logger.logger import logger` для логирования ошибок и отладочной информации.

2.  **Валидация ввода**:
    -   Усилить проверку ввода в функции `get_move` для предотвращения ошибок при некорректном вводе пользователя.

3.  **Константы**:
    -   Вынести размер доски в константу, чтобы облегчить изменение размера доски.

4. **Упрощение алгоритма `check_win`**:
     -  Рассмотреть возможность использования итеративного алгоритма вместо рекурсивного в функции `dfs` для повышения производительности.

5.  **Обработка ничьей**:
    -   Добавить проверку на ничью, если все клетки заняты, а победитель не определен.

6.  **Форматирование кода**:
    -   Привести документацию в формат RST, который поддерживается Sphinx.
    -   Добавить docstring для всех функций и модулей.
    -   Соблюдать правила именования переменных и функций, принятые в проекте.

7. **Использование `j_loads` или `j_loads_ns`**:
    -   Заменить `json.load` из стандартной библиотеки на `j_loads` или `j_loads_ns` из `src.utils.jjson`, если это предусмотрено правилами проекта.

**Улучшенный код**
```python
"""
Модуль для игры HEX.
=========================================================================================

Модуль реализует игру HEX для двух игроков на доске 11x11.
Игроки по очереди размещают свои фишки, стремясь соединить противоположные стороны доски.
Первый игрок (символ '1') соединяет левую и правую стороны, второй игрок (символ '2') - верхнюю и нижнюю.

:author: hypo69 (hypo69@davidka.net)
"""
import sys
from src.logger.logger import logger # импорт logger
# from src.utils.jjson import j_loads, j_loads_ns # TODO: добавить, если нужно
BOARD_SIZE = 11 # константа для размера доски


def print_board(board: list[list[str]]) -> None:
    """
    Выводит текущее состояние доски в консоль.

    :param board: Двумерный список, представляющий игровое поле.
    """
    print("   ", end="")
    for i in range(len(board)):
        print(chr(ord('A') + i), end=" ")
    print()
    for i, row in enumerate(board):
        print(f"{i + 1:2d} ", end="")
        for cell in row:
            print(cell, end=" ")
        print()


def get_move(board: list[list[str]], player: str) -> tuple[int, int]:
    """
    Запрашивает у игрока координаты для хода.

    :param board: Двумерный список, представляющий игровое поле.
    :param player: Символ текущего игрока ('1' или '2').
    :raises ValueError: Если ввод некорректный или координаты невалидны.
    :return: Кортеж (row, col) с координатами хода.
    """
    while True:
        try:
            move = input(f"Ход игрока {player}. Введите координаты (например, A1): ").strip().upper()
            if len(move) < 2:
                raise ValueError("Неверный формат ввода") #  ошибка ввода
            col = ord(move[0]) - ord('A')
            row = int(move[1:]) - 1
            if 0 <= row < len(board) and 0 <= col < len(board[0]):
                if board[row][col] == ' ':
                    return row, col
                else:
                   print("Эта клетка занята, выберите другую")
            else:
                 print("Неверные координаты, попробуйте еще раз")
        except ValueError as e:
            logger.error(f"Ошибка ввода: {e}", exc_info=True) #  логирование ошибки
            print("Неверный формат ввода, попробуйте еще раз (пример A1)")


def check_win(board: list[list[str]], player: str) -> bool:
    """
    Проверяет, выиграл ли игрок.

    :param board: Двумерный список, представляющий игровое поле.
    :param player: Символ текущего игрока ('1' или '2').
    :return: True, если игрок выиграл, иначе False.
    """

    def is_valid(row: int, col: int) -> bool:
         """
         Проверяет, являются ли координаты допустимыми.
         :param row: Индекс строки.
         :param col: Индекс столбца.
         :return: True, если координаты валидны, иначе False.
         """
         return 0 <= row < len(board) and 0 <= col < len(board[0])


    def dfs(row: int, col: int, visited: set, player: str) -> bool:
        """
        Рекурсивная функция для поиска в глубину.

        :param row: Индекс строки текущей ячейки.
        :param col: Индекс столбца текущей ячейки.
        :param visited: Множество посещенных ячеек.
        :param player: Символ текущего игрока ('1' или '2').
        :return: True, если достигнута победа, иначе False.
        """
        if not is_valid(row, col) or (row, col) in visited or board[row][col] != player:
           return False
        visited.add((row, col))

        if player == '1':
           if col == len(board[0])-1:
              return True # достиг правой стороны
           directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, 1)]
        elif player == '2':
           if row == len(board)-1:
               return True # достиг нижней стороны
           directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1)]

        for dr, dc in directions:
            if dfs(row + dr, col + dc, visited, player):
               return True

        return False


    if player == '1':
        for i in range(len(board)):
            if board[i][0] == '1': # начинаем с левой стороны
                if dfs(i, 0, set(), '1'):
                   return True
    elif player == '2':
        for j in range(len(board[0])):
            if board[0][j] == '2': # начинаем сверху
                if dfs(0, j, set(), '2'):
                    return True
    return False


def play_hex() -> None:
    """
    Основная функция игры HEX.
    """
    board = [[' ' for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)] # создаем пустую доску
    current_player = '1' # начинаем с первого игрока

    while True:
        print_board(board)
        row, col = get_move(board, current_player)
        board[row][col] = current_player # ставим фишку

        if check_win(board, current_player):
              print_board(board)
              print(f"Игрок {current_player} победил!")
              break
        #  смена игрока
        current_player = '2' if current_player == '1' else '1'

        #  проверка на ничью
        if all(all(cell != ' ' for cell in row) for row in board):
              print_board(board)
              print("Ничья!")
              break


if __name__ == "__main__":
    play_hex()
"""
Объяснение кода:
1.  **Импорт модуля `sys`**::
    -   `import sys`: Импортирует модуль `sys`, используемый для выхода из программы.
    -   `from src.logger.logger import logger`:  Импортирует логер для записи ошибок и отладочной информации.
    -   `from src.utils.jjson import j_loads, j_loads_ns`: TODO:  раскомментировать  если нужно
2. **Константа `BOARD_SIZE`:**
    -   `BOARD_SIZE = 11`: Определяет размер игровой доски.

3. **Функция `print_board(board)`:**
    -   Выводит текущее состояние игровой доски в консоль.
    -   Сначала печатает буквенные обозначения столбцов (A, B, C, ...), затем переходит к печати строк, где каждая строка начинается с числового обозначения и далее печатаются клетки доски.

4.  **Функция `get_move(board, player)`:**
    -   Запрашивает у игрока ввод координат для хода.
    -   Использует цикл while True для обеспечения корректного ввода.
    -   Преобразует введенные координаты (например, "A1") в индексы строки и столбца.
    -   Проверяет корректность введенных координат, а так же занята ли клетка и если все ок, возвращает координаты в виде кортежа (row,col)
    -   Обрабатывает исключения `ValueError` при неверном формате ввода, записывая ошибки в лог.

5.  **Функция `check_win(board, player)`:**
    -   Проверяет, есть ли победитель на доске.
    -   Использует рекурсивную функцию `dfs` (поиск в глубину) для анализа связности фишек игрока.
    -   Функция `is_valid` используется для проверки допустимости координат.
    -   Для игрока 1, проверка начинается с левой стороны доски и ищется путь до правой, для игрока 2 - сверху вниз.
    -   Если путь найден, то возвращает `True`, иначе `False`.

6.  **Функция `play_hex()`:**
    -   Содержит основную логику игры "Гекс".
    -   Создает пустую игровую доску board размером 11x11.
    -   Устанавливает текущего игрока current_player на '1'.
    -   В цикле while True:
        -   Вызывает `print_board()` для отображения доски.
        -   Вызывает `get_move()` для получения хода от игрока.
        -   Размещает фишку игрока на доске.
        -   Вызывает `check_win()`, чтобы проверить, есть ли победитель.
        -   Если победитель есть, выводит сообщение о победе и завершает игру.
        -   Меняет текущего игрока (с '1' на '2' и наоборот) если нет победителя.
        -   Добавлена проверка на ничью, если все клетки заняты, а победитель не определен.

7.  **Блок `if __name__ == "__main__":`:**
    -   Гарантирует, что функция `play_hex()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -   Вызывает `play_hex()` для начала игры.
"""