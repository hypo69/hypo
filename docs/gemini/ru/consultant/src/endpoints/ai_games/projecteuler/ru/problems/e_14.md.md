# Анализ кода модуля `e_14.md`

**Качество кода**
1/10
- Плюсы
    - Присутствует описание задачи.
- Минусы
    - Код отсутствует.
    - Не выполнены требования по форматированию.
    - Нет импортов.
    - Не используется `j_loads` или `j_loads_ns`.
    - Нет RST документации.
    - Отсутствуют комментарии к коду.
    - Не используется логгер.
    - Нет обработки исключений.

**Рекомендации по улучшению**

1.  Добавить импорт необходимых модулей.
2.  Использовать `j_loads` или `j_loads_ns` для чтения файлов.
3.  Написать функцию для вычисления последовательности Коллатца.
4.  Написать функцию для поиска начального числа, порождающего самую длинную последовательность.
5.  Добавить RST документацию для функций.
6.  Использовать логгер для обработки ошибок.
7.  Избегать избыточного использования стандартных блоков `try-except`, предпочитая обработку ошибок с помощью `logger.error`.
8.  Добавить комментарии к коду.
9.  Весь код должен быть оформлен в соответствии с требованиями к оформлению.
10. Проверить и исправить ошибки.

**Оптимизированный код**

```python
"""
Модуль для решения задачи №14 Project Euler.
=========================================================================================

Задача: Найти начальное число, меньшее миллиона, которое порождает самую длинную последовательность Коллатца.

Последовательность Коллатца определяется следующим образом:
n -> n/2 (если n четное)
n -> 3n + 1 (если n нечетное)

"""
from src.utils.jjson import j_loads, j_loads_ns
from src.logger.logger import logger


def collatz_sequence_length(n: int) -> int:
    """
    Вычисляет длину последовательности Коллатца для заданного числа.

    :param n: Начальное число последовательности.
    :return: Длина последовательности.
    """
    length = 1  # Инициализация длины последовательности
    try:
         # Проверка аргумента на целочисленность
         if not isinstance(n, int):
              logger.error(f'Аргумент {n} должен быть целым числом.')
              return 0
         # Проверка аргумента на положительность
         if n <= 0:
               logger.error(f'Аргумент {n} должен быть положительным числом.')
               return 0
         while n != 1:  # Цикл продолжается пока n не станет равным 1
              if n % 2 == 0: # Проверяет, является ли n четным числом
                  n = n // 2  # Если n четное, делим его на 2
              else:
                  n = 3 * n + 1 # Если n нечетное, вычисляем 3n + 1
              length += 1  # Увеличиваем длину последовательности на 1
         return length # Возвращает длину последовательности
    except Exception as ex:
         logger.error(f'Ошибка при вычислении последовательности Коллатца для n = {n}.', exc_info=ex)
         return 0


def find_longest_collatz_sequence(limit: int) -> int:
    """
    Находит начальное число, меньшее заданного лимита, которое порождает самую длинную последовательность Коллатца.

    :param limit: Верхний предел для поиска начального числа.
    :return: Начальное число, порождающее самую длинную последовательность.
    """
    longest_sequence = 0  # Инициализация длины самой длинной последовательности
    start_number = 0   # Инициализация начального числа для самой длинной последовательности
    try:
        # Проверка аргумента на целочисленность
        if not isinstance(limit, int):
            logger.error(f'Аргумент {limit} должен быть целым числом.')
            return 0
        # Проверка аргумента на положительность
        if limit <= 0:
             logger.error(f'Аргумент {limit} должен быть положительным числом.')
             return 0

        for i in range(1, limit):  # Цикл перебирает все числа от 1 до limit
            sequence_length = collatz_sequence_length(i) # Вычисляет длину последовательности для текущего числа i
            if sequence_length > longest_sequence:  # Проверяет, больше ли текущая длина, чем предыдущая самая длинная
                longest_sequence = sequence_length  # Если да, обновляем самую длинную длину
                start_number = i  # Обновляем начальное число самой длинной последовательности
        return start_number  # Возвращает начальное число самой длинной последовательности
    except Exception as ex:
        logger.error(f'Ошибка при поиске самой длинной последовательности Коллатца до {limit}.', exc_info=ex)
        return 0


if __name__ == '__main__':
    # Установка предела в 1 миллион
    limit = 1000000
    # Поиск начального числа, которое порождает самую длинную последовательность Коллатца
    result = find_longest_collatz_sequence(limit)
    # Вывод результата
    print(f'Начальное число, порождающее самую длинную последовательность Коллатца до {limit}: {result}')
```