# Анализ кода модуля `gomoko.py`

**Качество кода**

*   **Соответствие требованиям к формату кода (1-10)**:
    *   **Преимущества**:
        *   Код хорошо структурирован и логически разделен на этапы инициализации, обработки ходов игроков и проверки результатов.
        *   Функции имеют четкое назначение и легко читаются, что улучшает общую поддерживаемость кода.
        *   Используется внятная логика для определения победителя и ничьей.
        *   Есть базовые комментарии, описывающие логику основных блоков кода.
    *   **Недостатки**:
        *   Отсутствуют docstring для модулей и функций, что затрудняет понимание назначения отдельных элементов кода.
        *   Не используется `j_loads` или `j_loads_ns` для чтения файлов, так как нет необходимости в этом, но это стоит учесть в будущем.
        *   Обработка ошибок ввода пользователя не очень информативна и не использует логирование.
        *   Не все части кода имеют подробные комментарии, особенно внутри функций.
        *   Стиль комментариев не соответствует reStructuredText.
        *   Нет импорта логгера, что не позволяет отслеживать ошибки.
        *   Использование f-strings не везде последовательно.

**Рекомендации по улучшению**

1.  **Документирование кода**:
    *   Добавить docstring в формате RST для модуля, функций, методов и переменных, чтобы улучшить читаемость и понимание кода.
2.  **Обработка ошибок**:
    *   Использовать `src.logger.logger` для регистрации ошибок вместо стандартных `try-except`.
    *   Улучшить обработку ошибок ввода пользователя, предоставив более информативные сообщения.
3.  **Импорты**:
    *   Добавить необходимые импорты, например `from src.logger.logger import logger`.
4.  **Форматирование**:
    *   Привести комментарии к формату RST.
    *   Обеспечить последовательное использование f-strings.
5.  **Улучшение читаемости**:
    *   Добавить комментарии внутри функций, объясняющие логику отдельных блоков.

**Улучшенный код**

```python
"""
Модуль реализует игру "Гомоку" (пять в ряд).
=========================================================================================

Модуль позволяет двум игрокам играть в "Гомоку" на доске 15x15.
Игроки по очереди ставят свои фишки, стремясь выстроить линию из пяти своих фишек.
Игра продолжается до победы одного из игроков или до заполнения всей доски.

Пример использования
--------------------

.. code-block:: python

    # Запуск игры происходит при прямом запуске модуля
    # python gomoko.py

"""
__author__ = 'hypo69 (hypo69@davidka.net)'

import random
from src.logger.logger import logger # Импортируем логгер для записи ошибок и отладочной информации

# 1. Инициализация:
# 1.1. Создаем пустую доску 15x15
board = [[' ' for _ in range(15)] for _ in range(15)] # Создание доски 15x15, заполненной пробелами
# 1.2. Устанавливаем флаг начала игры G = 1
game_on = True # Флаг, определяющий, продолжается ли игра
# 1.3. Устанавливаем флаг игрока, P = 1 (игрок 1 ходит первым)
current_player = 1 # Переменная для отслеживания текущего игрока

def print_board(board):
    """
    Выводит текущее состояние игровой доски в консоль.

    :param board: Двумерный массив, представляющий игровую доску.
    """
    print("   ", end="")
    for i in range(15):
        print(f"{i:2}", end=" ")
    print()
    print("  " + "----" * 15)
    for i, row in enumerate(board):
        print(f"{i:2}|", end=" ")
        for cell in row:
            print(f"{cell:2}", end=" ")
        print()
    print()


def check_winner(board, player):
    """
    Проверяет, есть ли победитель на игровой доске.

    :param board: Двумерный массив, представляющий игровую доску.
    :param player: Номер игрока (1 или 2), для которого проверяется победа.
    :return: True, если есть победитель, иначе False.
    """
    symbol = 'X' if player == 1 else 'O' # Определяем символ игрока в зависимости от номера
    # Проверка горизонтальных линий
    for row in board:
        for i in range(len(row) - 4):
            if row[i] == row[i + 1] == row[i + 2] == row[i + 3] == row[i + 4] == symbol:
                return True
    # Проверка вертикальных линий
    for col in range(15):
        for i in range(15 - 4):
            if board[i][col] == board[i + 1][col] == board[i + 2][col] == board[i + 3][col] == board[i + 4][col] == symbol:
                return True
    # Проверка диагоналей (сверху-слева направо-вниз)
    for row in range(15 - 4):
        for col in range(15 - 4):
            if board[row][col] == board[row + 1][col + 1] == board[row + 2][col + 2] == board[row + 3][col + 3] == board[row + 4][col + 4] == symbol:
                return True
    # Проверка диагоналей (сверху-справа налево-вниз)
    for row in range(15 - 4):
        for col in range(4, 15):
            if board[row][col] == board[row + 1][col - 1] == board[row + 2][col - 2] == board[row + 3][col - 3] == board[row + 4][col - 4] == symbol:
                return True
    return False


def check_full_board(board):
    """
    Проверяет, заполнена ли игровая доска.

    :param board: Двумерный массив, представляющий игровую доску.
    :return: True, если доска заполнена, иначе False.
    """
    for row in board:
        for cell in row:
            if cell == ' ':
                return False  # Если есть хотя бы одна свободная ячейка, возвращаем False
    return True  # Если нет пустых ячеек, возвращаем True


# 2. Основной игровой цикл
while game_on:
    # 2.1. Выводим текущее состояние доски
    print_board(board)

    # 2.2. Ход игрока (P = 1)
    if current_player == 1:
        while True:
            try:
                # 2.2.1. Запрашиваем координаты хода X, Y
                x = int(input("Игрок 1 (X) введите x (0-14): ")) # Запрос на ввод координаты x
                y = int(input("Игрок 1 (X) введите y (0-14): ")) # Запрос на ввод координаты y

                # 2.2.2. Проверяем допустимость хода:
                if 0 <= x < 15 and 0 <= y < 15 and board[x][y] == ' ': # Проверка, что введенные координаты находятся в пределах доски и ячейка пуста
                    # 2.2.3. Ставим на доску символ хода текущего игрока (X)
                    board[x][y] = 'X' # Установка символа игрока в выбранную ячейку
                    break
                else:
                    print("Недопустимый ход. Попробуйте еще раз.") # Вывод сообщения об ошибке при недопустимом ходе
            except ValueError as e:
                 logger.error(f'Некорректный ввод координат: {e}') # Логируем ошибку некорректного ввода
                 print("Некорректный ввод. Пожалуйста, введите целые числа") # Сообщение пользователю об ошибке
        # 2.2.4. Меняем флаг игрока
        current_player = 2 # Переключение хода на следующего игрока
    # 2.3. Ход компьютера (P = 2)
    else:
        print("Ход компьютера:")
        while True:
            # 2.3.1. Компьютер выбирает случайный ход
            x = random.randint(0, 14) # Компьютер выбирает случайную координату x
            y = random.randint(0, 14) # Компьютер выбирает случайную координату y
            if board[x][y] == ' ': # Проверка, что выбранная ячейка пуста
                # 2.3.2. Ставим на доску символ хода текущего игрока (O)
                board[x][y] = 'O' # Установка символа компьютера в выбранную ячейку
                break
        # 2.3.3. Меняем флаг игрока
        current_player = 1 # Переключение хода на следующего игрока

    # 2.4. Проверка на победителя или ничью
    if check_winner(board, 1 if current_player == 2 else 2): # Проверка на победителя
        print_board(board)
        print(f"Победил игрок {'1 (X)' if current_player == 2 else '2 (O)'}!") # Вывод сообщения о победе
        game_on = False  # Завершаем игру
    elif check_full_board(board): # Проверка на ничью
        print_board(board)
        print("Ничья!") # Вывод сообщения о ничьей
        game_on = False  # Завершаем игру
"""
Объяснение кода:
===================
1.  **Инициализация**:
    -   `board = [[' ' for _ in range(15)] for _ in range(15)]`: Создаёт игровое поле 15x15, заполненное пробелами (пустые ячейки).
    -   `game_on = True`: Устанавливает флаг, сигнализирующий, что игра продолжается.
    -   `current_player = 1`: Устанавливает текущего игрока на первого (игрок 1).

2.  **Функция `print_board(board)`**:
    -   Выводит текущее состояние игрового поля в консоль. Нумерация строк и столбцов для удобства.

3.  **Функция `check_winner(board, player)`**:
    -   Проверяет, есть ли победитель.
    -   Символ текущего игрока ('X' для игрока 1, 'O' для игрока 2).
    -   Проверяет горизонтальные, вертикальные и обе диагональные линии на наличие пяти подряд идущих символов.
    -   Возвращает `True`, если победитель найден, иначе `False`.

4.  **Функция `check_full_board(board)`**:
    -   Проверяет, заполнено ли игровое поле.
    -   Возвращает `True`, если нет пустых клеток, иначе `False`.

5.  **Основной цикл игры `while game_on:`**:
    -   Продолжается, пока `game_on` равно `True`.
    -   Выводит текущую доску.
    -   **Ход игрока**:
        -   Если `current_player` равен 1, то это ход первого игрока.
        -   Запрашивает ввод координат x и y.
        -   Проверяет, что координаты в допустимых пределах и ячейка пуста. Если нет, повторяет запрос.
        -   Устанавливает символ 'X' в выбранную ячейку.
        -   Переключает текущего игрока на второго (`current_player = 2`).
    -   **Ход компьютера**:
        -   Если `current_player` равен 2, то это ход компьютера.
        -   Компьютер выбирает случайные координаты x и y.
        -   Проверяет, что ячейка не занята.
        -   Устанавливает символ 'O' в выбранную ячейку.
        -   Переключает текущего игрока на первого (`current_player = 1`).
    -   **Проверка на победу или ничью**:
        -   Вызывает `check_winner()` для проверки наличия победителя, и если он есть выводит на консоль сообщение о победе, и устанавливает `game_on` в `False`.
        -   Вызывает `check_full_board()` для проверки, заполнено ли поле. Если поле заполнено, то выводит сообщение о ничьей и завершает игру.
"""