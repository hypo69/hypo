## Ответ на Задачу No 117: Красные, зеленые и синие плитки

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Нам нужно найти количество способов разместить плитки размером 2x1, 3x1 и 4x1 на полоске длиной 50 единиц.
*   Плитки 1x1 можно представить как пустую позицию, где нет ни какой плитки 2x1, 3x1, 4x1.
*   По сути нам надо найти количество комбинаций, где сумма длин всех плиток будет 50.
*   Можно использовать рекурсию или динамическое программирование. Динамическое программирование подходит лучше, так как позволяет избежать пересчета одних и тех же подзадач.

**Решение:**

1.  **Определение базовых случаев:**
    *   Если длина полоски равна 0, то существует 1 способ (не использовать плитки).
    *   Если длина полоски отрицательная, то способов нет.
2.  **Определение рекуррентной формулы:**
    *   Для полоски длиной `n`, количество способов можно найти, просуммировав количество способов для полосок длиной `n-1`, `n-2`, `n-3`, `n-4`, где `n-1` это размещение 1х1,  `n-2` это размещение 2х1, `n-3` это размещение 3х1, и `n-4` это размещение 4х1. То есть мы учитываем что можно добавить либо пустую позицию, либо плитку.
    *   `ways[n] = ways[n-1] + ways[n-2] + ways[n-3] + ways[n-4]`
3.  **Динамическое программирование:**
    *   Создадим массив `ways` для хранения количества способов для каждой длины полоски от 0 до 50.
    *   Заполним массив с использованием рекуррентной формулы, начиная с базовых случаев.

### 2. Алгоритм решения

1.  Начать.
2.  Инициализировать массив `ways` размером 51 (от 0 до 50) нулями.
3.  Установить `ways[0]` равным 1 (базовый случай: для длины 0 есть 1 способ).
4.  Для каждой длины полоски `i` от 1 до 50:
    *   Если `i-1` >= 0,  `ways[i] = ways[i] + ways[i-1]`
    *   Если `i-2` >= 0, `ways[i] = ways[i] + ways[i-2]`
    *   Если `i-3` >= 0, `ways[i] = ways[i] + ways[i-3]`
    *   Если `i-4` >= 0, `ways[i] = ways[i] + ways[i-4]`
5.  Вернуть `ways[50]` (количество способов для полоски длиной 50).
6.  Конец.

### 3. Реализация на Python 3.12
```python
def count_tile_arrangements(length):
    """
    Calculates the number of ways to arrange tiles of sizes 2x1, 3x1, and 4x1 on a strip of a given length.

    Args:
        length: The length of the strip.

    Returns:
        The number of ways to arrange the tiles.
    """
    ways = [0] * (length + 1)
    ways[0] = 1

    for i in range(1, length + 1):
        if i - 1 >= 0:
            ways[i] += ways[i - 1]
        if i - 2 >= 0:
            ways[i] += ways[i - 2]
        if i - 3 >= 0:
            ways[i] += ways[i - 3]
        if i - 4 >= 0:
             ways[i] += ways[i - 4]

    return ways[length]

# Пример использования:
strip_length = 50
result = count_tile_arrangements(strip_length)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeWays((Инициализировать массив ways[0...50] нулями))
    InitializeWays --> SetWays0((Установить ways[0] = 1))
    SetWays0 --> LoopStart((Начать цикл: i от 1 до 50))
    LoopStart --> Check_i_minus_1((i-1 >= 0?))
    Check_i_minus_1 -- Да --> UpdateWays_i_1((ways[i] = ways[i] + ways[i-1]))
    UpdateWays_i_1 --> Check_i_minus_2((i-2 >= 0?))
    Check_i_minus_1 -- Нет --> Check_i_minus_2
    Check_i_minus_2 -- Да --> UpdateWays_i_2((ways[i] = ways[i] + ways[i-2]))
    UpdateWays_i_2 --> Check_i_minus_3((i-3 >= 0?))
    Check_i_minus_2 -- Нет --> Check_i_minus_3
    Check_i_minus_3 -- Да --> UpdateWays_i_3((ways[i] = ways[i] + ways[i-3]))
    UpdateWays_i_3 --> Check_i_minus_4((i-4 >= 0?))
    Check_i_minus_3 -- Нет --> Check_i_minus_4
    Check_i_minus_4 -- Да --> UpdateWays_i_4((ways[i] = ways[i] + ways[i-4]))
    UpdateWays_i_4 --> LoopStart_end
    Check_i_minus_4 -- Нет --> LoopStart_end
    LoopStart_end --> LoopStart
    LoopStart --> EndLoop((Конец цикла))
    EndLoop --> ReturnResult((Вернуть ways[50]))
    ReturnResult --> End((Конец))
```
**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать массив ways[0...50] нулями:** Создаем массив для хранения количества способов и инициализируем его нулями.
*   **Установить ways[0] = 1:** Задаем базовое значение для полоски длинной 0.
*   **Начать цикл, Конец цикла:** Определяют начало и конец цикла перебора длин полоски от 1 до 50.
*   **i-1 >= 0, i-2 >= 0, i-3 >= 0, i-4 >= 0?:** Проверяем можем ли использовать плитки длинной 1,2,3 и 4.
*   **ways[i] = ways[i] + ways[i-1],  ways[i] = ways[i] + ways[i-2], ways[i] = ways[i] + ways[i-3], ways[i] = ways[i] + ways[i-4]:** Обновление значения в массиве `ways` для текущей длинны, добавляя предыдущие значения.
*   **Вернуть ways[50]:** Возвращаем конечное значение количества комбинаций.
