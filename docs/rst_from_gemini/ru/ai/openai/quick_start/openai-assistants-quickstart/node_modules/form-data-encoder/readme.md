```markdown
# form-data-encoder

Encode `FormData` content into the `multipart/form-data` format.

[![Code Coverage](https://codecov.io/github/octet-stream/form-data-encoder/coverage.svg?branch=master)](https://codecov.io/github/octet-stream/form-data-encoder?branch=master)
[![CI](https://github.com/octet-stream/form-data-encoder/workflows/CI/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/ci.yml)
[![ESLint](https://github.com/octet-stream/form-data-encoder/workflows/ESLint/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/eslint.yml)

## Installation

```bash
npm install form-data-encoder
# or
yarn add form-data-encoder
# or
pnpm add form-data-encoder
```

## ESM/CJS Support

This package supports both ESM and CJS for backwards compatibility.  CJS support will be removed in a future major release as Node.js v12 reaches its end-of-life.


## Usage

This library provides a `FormDataEncoder` class to easily encode `FormData` objects.  It's designed to work with various `FormData` implementations, including `formdata-node` and `formdata-polyfill`.

**1. Encoding with `formdata-node`:**

```javascript
import { FormData, File } from 'formdata-node';
import { FormDataEncoder } from 'form-data-encoder';
import fetch from 'node-fetch';
import { Readable } from 'stream';

const form = new FormData();
form.set('greeting', 'Hello, World!');
form.set('file', new File(['On Soviet Moon landscape see binoculars through YOU'], 'file.txt'));

const encoder = new FormDataEncoder(form);

const options = {
  method: 'POST',
  headers: encoder.headers,
  body: Readable.from(encoder) // or use encoder directly if the client supports async iteration
};

const response = await fetch('https://httpbin.org/post', options);
console.log(await response.json());
```

**2. Encoding with `formdata-polyfill` (and `fetch-blob`):**

```javascript
import { FormData } from 'formdata-polyfill';
import { File } from 'fetch-blob'; // Use the correct import for fetch-blob
import { FormDataEncoder } from 'form-data-encoder';
import fetch from 'node-fetch';
// ... (rest of the example)
```

**3. Encoding to Blob (using async iteration):**

```javascript
import { FormDataEncoder } from 'form-data-encoder';
import { FormData } from 'formdata-node';
import Blob from 'fetch-blob'; // Or a similar library

async function formDataToBlob(form) {
  const encoder = new FormDataEncoder(form);
  const chunks = [];
  for await (const chunk of encoder) {
    chunks.push(chunk);
  }
  return new Blob(chunks, { type: encoder.contentType });
}
// ... (rest of the example)
```

**4. Encoding to Blob (using `ReadableStream`):**

```javascript
// ... (imports)

function formDataToReadableStream(encoder) {
  return new ReadableStream({
    async pull(controller) {
       // ... (handle iteration)
    }
  });
}

// ... (rest of the example)
```


**Important Considerations:**

* **`fetch` Support:** Some `fetch` implementations (like `node-fetch`) may not support directly using the encoder object as the request body. In these cases, you'll need to use `Readable.from(encoder)`.
* **File Handling:**  Ensure you're using a compatible library for handling files (like `formdata-node` or `fetch-blob`) with your chosen `FormData` implementation.
* **Error Handling:** Add robust error handling (e.g., `try...catch` blocks) to gracefully manage potential issues during file reading or encoding.
* **`form-data-encoder` vs. Native `FormData`:**  If the HTTP client supports direct use of the `FormData` object as the request body, using native `FormData` may be more efficient.  `form-data-encoder` is useful when the client doesn't support that directly or you need more control over the encoding process.

**Detailed API (reduced to essential points):**

```javascript
import { FormDataEncoder } from 'form-data-encoder';

const encoder = new FormDataEncoder(form);

// Properties
console.log(encoder.boundary); // Boundary string
console.log(encoder.contentType); // Content-Type header
console.log(encoder.headers); // Headers object

// Iterators
for (const part of encoder) {
  // ... process each part
}

async function* encodeAsync() {
  for await (const part of encoder) {
    yield part;
  }
}


```


```