# Модуль stubs

## Обзор

Модуль `stubs` содержит заглушки (stubs) для работы с моделями данных, используемыми в g4f (gpt4free) клиенте. Он определяет структуры данных, такие как `UsageModel`, `ChatCompletion`, `ImagesResponse` и другие, которые используются для представления различных типов ответов от моделей GPT.
Этот модуль необходим для обеспечения согласованности данных между различными частями приложения и для упрощения работы с данными, возвращаемыми от API.

## Подробней

Модуль определяет структуры данных, необходимые для работы с g4f клиентом. Он содержит классы, представляющие различные типы ответов от моделей GPT, а также вспомогательные функции для обработки этих данных.
Этот модуль обеспечивает типизацию и валидацию данных, что помогает избежать ошибок и упрощает разработку.

## Классы

### `BaseModel`

**Описание**: Базовый класс для моделей данных, используемый для представления различных типов ответов от моделей GPT.

**Принцип работы**:

Класс `BaseModel` является основой для всех остальных классов моделей в этом модуле. Он обеспечивает базовую функциональность для создания и инициализации объектов моделей. Если библиотека `pydantic` недоступна, создается упрощенная реализация `BaseModel` с методом `model_construct`.

**Методы**:
- `model_construct(**data)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных. Если `pydantic` установлен, используется его реализация `model_construct`.

### `TokenDetails`

**Описание**: Класс для хранения информации о количестве использованных токенов.

**Атрибуты**:
- `cached_tokens` (int): Количество токенов, взятых из кэша.

### `UsageModel`

**Описание**: Класс для хранения информации об использовании токенов в запросе и ответе.

**Атрибуты**:
- `prompt_tokens` (int): Количество токенов в запросе.
- `completion_tokens` (int): Количество токенов в ответе.
- `total_tokens` (int): Общее количество токенов.
- `prompt_tokens_details` (TokenDetails): Детализация токенов в запросе.
- `completion_tokens_details` (TokenDetails): Детализация токенов в ответе.

**Методы**:
- `model_construct(prompt_tokens=0, completion_tokens=0, total_tokens=0, prompt_tokens_details=None, completion_tokens_details=None, **kwargs)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных. Если детализация токенов не передана, создает экземпляры `TokenDetails` с `cached_tokens=0`.

### `ToolFunctionModel`

**Описание**: Класс для хранения информации о функции, вызываемой инструментом (tool).

**Атрибуты**:
- `name` (str): Название функции.
- `arguments` (str): Аргументы функции.

### `ToolCallModel`

**Описание**: Класс для хранения информации о вызове инструмента.

**Атрибуты**:
- `id` (str): Идентификатор вызова инструмента.
- `type` (str): Тип вызова инструмента.
- `function` (ToolFunctionModel): Информация о функции.

**Методы**:
- `model_construct(function=None, **kwargs)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных. Если информация о функции не передана, создает экземпляр `ToolFunctionModel` с пустыми значениями.

### `ChatCompletionChunk`

**Описание**: Класс для представления частичного ответа чат-модели (chunk).

**Атрибуты**:
- `id` (str): Идентификатор чанка.
- `object` (str): Тип объекта (всегда "chat.completion.cunk").
- `created` (int): Время создания чанка (timestamp).
- `model` (str): Использованная модель.
- `provider` (Optional[str]): Провайдер модели.
- `choices` (List[ChatCompletionDeltaChoice]): Список вариантов выбора.
- `usage` (UsageModel): Информация об использовании токенов.

**Методы**:
- `model_construct(content: str, finish_reason: str, completion_id: str = None, created: int = None, usage: UsageModel = None)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `ChatCompletionMessage`

**Описание**: Класс для представления сообщения в чате.

**Атрибуты**:
- `role` (str): Роль отправителя сообщения (например, "assistant").
- `content` (str): Содержимое сообщения.
- `tool_calls` (list[ToolCallModel]): Список вызовов инструментов.

**Методы**:
- `model_construct(content: str, tool_calls: list = None)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.
- `save(self, filepath: str, allowd_types = None)`: Сохраняет содержимое сообщения в файл. Если содержимое является URI данных или начинается с "data:", извлекает и сохраняет данные в файл. В противном случае, фильтрует содержимое с помощью `filter_markdown` и сохраняет отфильтрованный результат.

### `ChatCompletionChoice`

**Описание**: Класс для представления варианта выбора в ответе чат-модели.

**Атрибуты**:
- `index` (int): Индекс варианта выбора (всегда 0).
- `message` (ChatCompletionMessage): Сообщение.
- `finish_reason` (str): Причина завершения генерации.

**Методы**:
- `model_construct(message: ChatCompletionMessage, finish_reason: str)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `ChatCompletion`

**Описание**: Класс для представления ответа чат-модели.

**Атрибуты**:
- `id` (str): Идентификатор ответа.
- `object` (str): Тип объекта (всегда "chat.completion").
- `created` (int): Время создания ответа (timestamp).
- `model` (str): Использованная модель.
- `provider` (Optional[str]): Провайдер модели.
- `choices` (list[ChatCompletionChoice]): Список вариантов выбора.
- `usage` (UsageModel): Информация об использовании токенов.
- `conversation` (dict): Словарь с историей диалога.

**Методы**:
- `model_construct(content: str, finish_reason: str, completion_id: str = None, created: int = None, tool_calls: list[ToolCallModel] = None, usage: UsageModel = None, conversation: dict = None)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `ChatCompletionDelta`

**Описание**: Класс для представления изменения (delta) в ответе чат-модели.

**Атрибуты**:
- `role` (str): Роль (всегда "assistant").
- `content` (str): Содержимое изменения.

**Методы**:
- `model_construct(cls, content: Optional[str])`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `ChatCompletionDeltaChoice`

**Описание**: Класс для представления варианта выбора изменения (delta) в ответе чат-модели.

**Атрибуты**:
- `index` (int): Индекс варианта выбора (всегда 0).
- `delta` (ChatCompletionDelta): Изменение.
- `finish_reason` (Optional[str]): Причина завершения генерации.

**Методы**:
- `model_construct(cls, delta: ChatCompletionDelta, finish_reason: Optional[str])`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `Image`

**Описание**: Класс для представления изображения.

**Атрибуты**:
- `url` (Optional[str]): URL изображения.
- `b64_json` (Optional[str]): Изображение в формате base64.
- `revised_prompt` (Optional[str]): Уточненный запрос.

**Методы**:
- `model_construct(url: str = None, b64_json: str = None, revised_prompt: str = None)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных.

### `ImagesResponse`

**Описание**: Класс для представления ответа с изображениями.

**Атрибуты**:
- `data` (List[Image]): Список изображений.
- `model` (str): Использованная модель.
- `provider` (str): Провайдер модели.
- `created` (int): Время создания ответа (timestamp).

**Методы**:
- `model_construct(data: List[Image], created: int = None, model: str = None, provider: str = None)`: Создает экземпляр класса, устанавливая атрибуты на основе переданных данных. Если время создания не передано, устанавливает текущее время.

## Функции

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением None.

    Args:
        **kwargs: Произвольные ключевые аргументы.

    Returns:
        dict: Словарь без элементов со значением None.
    """
    ...
```

**Назначение**: Функция `filter_none` принимает произвольные ключевые аргументы и возвращает новый словарь, содержащий только те элементы из входного словаря, значения которых не равны `None`.

**Как работает функция**:

1.  **Инициализация:** Создается пустой словарь `result`.
2.  **Итерация по аргументам:** Функция перебирает все переданные ключевые аргументы и их значения.
3.  **Проверка на `None`:** Для каждого значения проверяется, равно ли оно `None`.
4.  **Добавление в результат:** Если значение не равно `None`, то соответствующая пара ключ-значение добавляется в словарь `result`.
5.  **Возврат результата:** Функция возвращает словарь `result`, содержащий только элементы с не-`None` значениями.

**Примеры**:

```python
>>> filter_none(a=1, b=None, c="hello")
{'a': 1, 'c': 'hello'}

>>> filter_none(x=None, y=None)
{}
```
### `extract_data_uri`

```python
def extract_data_uri(data_uri: str) -> bytes:
    """
    Извлекает данные из data URI.

    Args:
        data_uri (str): Строка, содержащая data URI.

    Returns:
        bytes: Байтовое представление данных.
    """
    ...
```

**Назначение**: Функция `extract_data_uri` извлекает данные из строки, содержащей data URI. Data URI - это схема URI, которая позволяет включать данные (например, изображения) непосредственно в строку, вместо ссылки на внешний ресурс.

**Как работает функция**:

1.  **Разделение строки:** Функция разделяет входную строку `data_uri` на две части по разделителю `,`. Это делается для отделения метаданных от самих данных.
2.  **Декодирование Base64:** Полученная часть с данными декодируется из формата Base64 в байтовое представление.
3.  **Возврат данных:** Функция возвращает байтовое представление данных.

**Примеры**:

```python
>>> data_uri = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w+gYQjEkYABSgAABWgRABg=="
>>> extract_data_uri(data_uri)[:10]
b'\x89PNG\r\n\x1a\n\x00\x00'
```
### `filter_markdown`

```python
def filter_markdown(markdown: str, allowd_types = None) -> str | None:
    """
    Фильтрует markdown содержимое, заменяя ссылки на изображения на локальные пути.

    Args:
        markdown (str): Строка с markdown содержимым.
        allowd_types: Разрешенные типы файлов.

    Returns:
        str | None: Отфильтрованная строка или None, если markdown пустой.
    """
    ...
```

**Назначение**: Функция `filter_markdown` фильтрует markdown-содержимое, заменяя ссылки на изображения на локальные пути. Это полезно, когда необходимо сохранить markdown-контент локально и обеспечить корректное отображение изображений.

**Как работает функция**:

1.  **Проверка на пустоту:** Функция проверяет, является ли входная строка `markdown` пустой. Если да, возвращает `None`.
2.  **Поиск ссылок на изображения:** Использует регулярное выражение для поиска всех ссылок на изображения в markdown-содержимом.
3.  **Замена ссылок на локальные пути:** Для каждой найденной ссылки на изображение, функция генерирует локальный путь и заменяет оригинальную ссылку на этот путь.
4.  **Возврат отфильтрованного контента:** Функция возвращает отфильтрованное markdown-содержимое с замененными ссылками на изображения.

**Примеры**:

```python
>>> markdown = "![alt text](https://example.com/image.png)"
>>> filter_markdown(markdown)
'![alt text](/media/image.png)'
```
```
A: markdown_content
    │
    ├──> B: is_markdown_empty?
    │       │
    │       ├──> True: return None
    │       │
    │       └──> False: continue
    │
    ↓
C: find_image_links
    │
    ↓
D: replace_links_with_local_paths
    │
    ↓
E: return filtered_markdown
```
## Подробней о том, как этот код используется в проекте `hypotez`

Этот код используется в проекте `hypotez` для работы с gpt4free (g4f) клиентом. Он определяет структуры данных, которые используются для представления различных типов ответов от моделей GPT, таких как ответы чат-моделей, изображения и информация об использовании токенов.

Функции `filter_none`, `extract_data_uri` и `filter_markdown` используются для обработки и фильтрации данных, полученных от моделей GPT. Например, `filter_markdown` используется для замены ссылок на изображения в markdown-содержимом на локальные пути, что позволяет сохранить markdown-контент локально и обеспечить корректное отображение изображений.