# Модуль ChatGpt

## Обзор

Модуль `ChatGpt` предоставляет класс `ChatGpt`, который является провайдером для взаимодействия с API ChatGPT. Он позволяет отправлять запросы к различным моделям ChatGPT и получать ответы. Модуль поддерживает сохранение истории сообщений, системные сообщения и потоковую передачу данных.

## Подробней

Модуль предназначен для интеграции с другими частями проекта `hypotez`, чтобы обеспечить возможность использования ChatGPT в качестве одного из доступных провайдеров для генерации текста. Он использует библиотеки `requests` для выполнения HTTP-запросов и `uuid` для генерации уникальных идентификаторов.

## Классы

### `ChatGpt`

**Описание**: Класс `ChatGpt` является провайдером для взаимодействия с API ChatGPT. Он наследует `AbstractProvider` и `ProviderModelMixin`.

**Наследует**:
- `AbstractProvider`: Абстрактный базовый класс для провайдеров.
- `ProviderModelMixin`: Миксин для работы с моделями провайдера.

**Аттрибуты**:
- `label` (str): Метка провайдера ("ChatGpt").
- `url` (str): URL ChatGPT ("https://chatgpt.com").
- `working` (bool): Флаг, указывающий, работает ли провайдер (False).
- `supports_message_history` (bool): Поддержка истории сообщений (True).
- `supports_system_message` (bool): Поддержка системных сообщений (True).
- `supports_stream` (bool): Поддержка потоковой передачи (True).
- `default_model` (str): Модель по умолчанию ('auto').
- `models` (list): Список поддерживаемых моделей.
- `model_aliases` (dict): Словарь псевдонимов моделей.

**Методы**:
- `get_model(model: str) -> str`: Возвращает имя модели на основе псевдонима или модель по умолчанию.
- `create_completion(model: str, messages: Messages, stream: bool, **kwargs) -> CreateResult`: Создает запрос на завершение текста и возвращает результат.

### `ChatGpt.get_model`

```python
    @classmethod
    def get_model(cls, model: str) -> str:
        """Возвращает имя модели на основе псевдонима или модель по умолчанию.

        Args:
            model (str): Имя модели.

        Returns:
            str: Имя модели или модель по умолчанию.
        """
```

**Назначение**:
Метод `get_model` класса `ChatGpt` предназначен для определения и возврата имени модели, которая будет использоваться для генерации текста. Если предоставленное имя модели содержится в списке поддерживаемых моделей, оно возвращается напрямую. Если же имя модели является псевдонимом, то возвращается соответствующее ему имя из словаря `model_aliases`. В случае, когда модель не найдена ни в списке поддерживаемых, ни в словаре псевдонимов, возвращается модель, используемая по умолчанию.

**Параметры**:
- `model` (str): Имя модели, которое необходимо проверить и, возможно, преобразовать.

**Возвращает**:
- `str`: Имя модели, которое будет использоваться для запроса к API.

**Как работает функция**:
1. Проверяет, содержится ли предоставленное имя модели в списке поддерживаемых моделей (`cls.models`).
2. Если модель найдена в списке, возвращает её имя.
3. Если модель не найдена в списке, проверяет, есть ли она в словаре псевдонимов (`cls.model_aliases`).
4. Если модель есть в словаре псевдонимов, возвращает соответствующее ей значение (настоящее имя модели).
5. Если модель не найдена ни в списке, ни в словаре, возвращает имя модели по умолчанию (`cls.default_model`).

```
Проверка наличия модели в списке -> Если найдена: Возврат имени модели
|
Нет
V
Проверка наличия модели в словаре псевдонимов -> Если найдена: Возврат псевдонима модели
|
Нет
V
Возврат имени модели по умолчанию
```

**Примеры**:

```python
# Пример 1: Использование поддерживаемой модели
model_name = ChatGpt.get_model("gpt-3.5-turbo")
print(model_name)  # Вывод: gpt-3.5-turbo

# Пример 2: Использование псевдонима модели
model_name = ChatGpt.get_model("gpt-4o")
print(model_name)  # Вывод: chatgpt-4o-latest

# Пример 3: Использование неподдерживаемой модели
model_name = ChatGpt.get_model("unknown-model")
print(model_name)  # Вывод: auto
```

### `ChatGpt.create_completion`

```python
    @classmethod
    def create_completion(
        cls,
        model: str,
        messages: Messages,
        stream: bool,
        **kwargs
    ) -> CreateResult:
        """Создает запрос на завершение текста и возвращает результат.

        Args:
            model (str): Имя модели.
            messages (Messages): Список сообщений для отправки.
            stream (bool): Флаг, указывающий, использовать ли потоковую передачу.
            **kwargs: Дополнительные аргументы.

        Returns:
            CreateResult: Результат создания завершения.

        Raises:
            ValueError: Если указанная модель недоступна.
        """
```

**Назначение**:
Метод `create_completion` класса `ChatGpt` предназначен для создания запроса к API ChatGPT на генерацию текста на основе предоставленных сообщений. Он выполняет ряд действий, включая подготовку сессии, получение токенов безопасности, форматирование сообщений и отправку запроса. Метод поддерживает потоковую передачу данных и возвращает результат в виде генератора.

**Параметры**:
- `model` (str): Имя модели, которую необходимо использовать для генерации текста.
- `messages` (Messages): Список сообщений, представляющих собой историю разговора.
- `stream` (bool): Флаг, указывающий, следует ли использовать потоковую передачу данных.
- `**kwargs`: Дополнительные параметры, которые могут быть переданы в API.

**Возвращает**:
- `CreateResult`: Результат создания завершения, который может быть как генератором (в случае потоковой передачи), так и полным текстом ответа.

**Вызывает исключения**:
- `ValueError`: Если указанная модель не найдена в списке доступных моделей.

**Как работает функция**:

1. **Определение модели**:
   - Сначала метод `get_model` используется для получения корректного имени модели на основе предоставленного значения.

2. **Проверка доступности модели**:
   - Затем проверяется, является ли полученное имя модели допустимым (содержится ли оно в списке `cls.models`).
   - Если модель не найдена, вызывается исключение `ValueError` с сообщением о недоступности модели и списком доступных моделей.

3. **Инициализация сессии**:
   - Создается сессия с использованием `init_session` и UserAgent.

4. **Получение конфигурации и токенов безопасности**:
   - Запрашиваются токены безопасности.

5. **Формирование заголовков**:
   - Формируются заголовки запроса, включая токены безопасности.

6. **Подготовка данных для запроса**:
   - Сообщения форматируются с использованием функции `format_conversation`.
   - Формируется JSON-данные для отправки запроса.

7. **Отправка запроса и обработка ответа**:
   - Отправляется POST-запрос к API.
   - В случае успеха, если включена потоковая передача (`stream=True`):
     - Ответ обрабатывается построчно, и извлекаются данные, содержащиеся в JSON-формате.
     - Извлекаются токены из JSON, и генерируются части текста ответа.
     - Возвращается генератор, который выдает части текста.
   - Если произошла ошибка при отправке запроса, вызывается исключение.

```
Определение модели -> Проверка доступности модели -> Инициализация сессии -> Получение конфигурации и токенов безопасности
|
Формирование заголовков -> Подготовка данных для запроса -> Отправка запроса
|
Обработка ответа (потоковая передача) -> Извлечение токенов и генерация текста
```

**Примеры**:

```python
# Пример 1: Создание запроса с потоковой передачей
messages = [{"role": "user", "content": "Напиши короткий рассказ про кота"} ]
result = ChatGpt.create_completion(model="gpt-3.5-turbo", messages=messages, stream=True)
for chunk in result:
    print(chunk, end="")

# Пример 2: Создание запроса без потоковой передачи (не реализовано в коде)
# messages = [{"role": "user", "content": "Напиши короткий рассказ про кота"}]
# result = ChatGpt.create_completion(model="gpt-3.5-turbo", messages=messages, stream=False)
# print(result)
```

## Функции

### `format_conversation`

```python
def format_conversation(messages: list) -> list:
    """Форматирует список сообщений в формат, требуемый API ChatGPT.

    Args:
        messages (list): Список сообщений.

    Returns:
        list: Отформатированный список сообщений.
    """
```

**Назначение**:
Функция `format_conversation` преобразует список сообщений в формат, который соответствует ожиданиям API ChatGPT. Каждое сообщение оборачивается в структуру, содержащую уникальный идентификатор, информацию об авторе, типе контента и метаданные.

**Параметры**:
- `messages` (list): Список сообщений, где каждое сообщение представляет собой словарь с ключами `'role'` (роль отправителя) и `'content'` (текст сообщения).

**Возвращает**:
- `list`: Список отформатированных сообщений, готовых для отправки в API ChatGPT.

**Как работает функция**:
1. Инициализирует пустой список `conversation` для хранения отформатированных сообщений.
2. Проходит по каждому сообщению в списке `messages`.
3. Для каждого сообщения создает словарь, содержащий следующие ключи:
   - `'id'`: Уникальный идентификатор сообщения, сгенерированный с помощью `uuid.uuid4()`.
   - `'author'`: Словарь с информацией об авторе сообщения, где `'role'` берется из оригинального сообщения.
   - `'content'`: Словарь с информацией о контенте сообщения, где `'content_type'` установлен в `'text'`, а `'parts'` содержит список с текстом сообщения.
   - `'metadata'`: Словарь с метаданными сообщения, содержащий информацию о смещениях символов.
   - `'create_time'`: Время создания сообщения, округленное до трех знаков после запятой.
4. Добавляет созданный словарь в список `conversation`.
5. Возвращает список `conversation`.

```
Инициализация списка conversation -> Проход по сообщениям в списке messages
|
Создание словаря для каждого сообщения -> Добавление словаря в список conversation
|
Возврат списка conversation
```

**Примеры**:

```python
# Пример 1: Форматирование списка сообщений
messages = [
    {'role': 'user', 'content': 'Привет!'},
    {'role': 'assistant', 'content': 'Здравствуйте!'}
]
formatted_messages = format_conversation(messages)
print(formatted_messages)
# Вывод:
# [
#     {'id': '...', 'author': {'role': 'user'}, 'content': {'content_type': 'text', 'parts': ['Привет!']}, 'metadata': {...}, 'create_time': ...},
#     {'id': '...', 'author': {'role': 'assistant'}, 'content': {'content_type': 'text', 'parts': ['Здравствуйте!']}, 'metadata': {...}, 'create_time': ...}
# ]
```

### `init_session`

```python
def init_session(user_agent: str) -> Session:
    """Инициализирует сессию requests с необходимыми заголовками и куками.

    Args:
        user_agent (str): User-Agent для сессии.

    Returns:
        Session: Инициализированная сессия requests.
    """
```

**Назначение**:
Функция `init_session` создает и инициализирует сессию `requests` с необходимыми заголовками и куками для взаимодействия с API ChatGPT. Она устанавливает User-Agent, добавляет куки и заголовки, которые имитируют поведение браузера.

**Параметры**:
- `user_agent` (str): Строка User-Agent, которая будет использоваться для сессии.

**Возвращает**:
- `Session`: Объект сессии `requests`, настроенный с необходимыми заголовками и куками.

**Как работает функция**:
1. Создает объект сессии `requests.Session()`.
2. Определяет куки `_dd_s`.
3. Определяет заголовки, включая User-Agent, `accept`, `accept-language` и другие.
4. Выполняет GET-запрос к `https://chatgpt.com/` с установленными куками и заголовками.
5. Возвращает инициализированную сессию.

```
Создание сессии -> Определение куки -> Определение заголовков
|
Выполнение GET-запроса -> Возврат сессии
```

**Примеры**:

```python
# Пример 1: Инициализация сессии
user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36'
session = init_session(user_agent)
print(session)
# Вывод: <requests.sessions.Session object at 0x...>
```