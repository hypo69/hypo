# Анализ кода модуля e_107.md

**Качество кода**
8
-  Плюсы
    - Код представляет собой описание задачи Project Euler, включая условия и примеры.
    - Структура документа хорошо организована, с четким разделением на условия задачи, примеры и ожидаемый результат.
-  Минусы
    - Отсутствует код для решения задачи.
    - Не хватает документации в формате reStructuredText (RST).
    - Нет явных импортов или ссылок на внешние функции/библиотеки.

**Рекомендации по улучшению**

1.  **Добавить решение задачи:** Необходимо включить Python код, который решает задачу о минимальном связывающем дереве (MST), например, с использованием алгоритма Прима или Краскала.
2.  **Добавить docstrings:** Добавить подробные описания в формате RST для всех функций, методов и переменных, включая описание алгоритма.
3.  **Использовать `j_loads` или `j_loads_ns`:**  В будущей реализации, для чтения данных из файла, использовать `j_loads` или `j_loads_ns`.
4.  **Обработка ошибок:** В коде решения предусмотреть обработку возможных ошибок с использованием `logger.error` вместо стандартных `try-except`.
5.  **Логирование:** Внедрить логирование для отслеживания процесса вычислений и возможных проблем.
6.  **Комментарии RST:**  Добавить комментарии в формате RST для описания логики кода.
7. **Добавить импорты**: Добавить импорты `j_loads_ns` и `logger`.
8. **Рефакторинг:** Сделать рефакторинг кода, если это необходимо, для улучшения читаемости и производительности.

**Оптимизированный код**

```markdown
# Задача No 107
"""
Модуль для решения задачи 107 Project Euler: Минимальная стоимость соединения.

Этот модуль содержит описание задачи и примеры, а также реализует
алгоритм Прима для нахождения минимального связывающего дерева.

.. code-block:: python

    # Пример использования:
    # from src.utils.jjson import j_loads_ns
    # from src.logger.logger import logger
    #
    # data = j_loads_ns('network.txt')
    # result, total_weight, min_weight = calculate_min_spanning_tree(data)
    #
"""

## Минимальная стоимость соединения
## Условия
Следующая матрица представляет сетевое соединение из 40 вершин и показывает стоимость соединения между вершинами. Обратите внимание, что значение 0 означает отсутствие соединения между двумя вершинами.

```
0, 16, 12, 21, 0, 0, 0, 
16, 0, 0, 17, 20, 0, 0, 
12, 0, 0, 28, 0, 31, 0, 
21, 17, 28, 0, 18, 19, 23, 
0, 20, 0, 18, 0, 0, 11, 
0, 0, 31, 19, 0, 0, 27, 
0, 0, 0, 23, 11, 27, 0
```
Полная стоимость соединения сети составляет сумму всех стоимостей, перечисленных выше. Однако ясно, что некоторые соединения являются избыточными. Например, для сети с 7 вершинами и приведенными выше матричными соединениями:

```
Полная стоимость соединения составляет 85.
```

Было бы возможно снизить стоимость соединения, исключив некоторые соединения, сохраняя при этом связанность всех вершин.

Минимальная стоимость соединения сети, соединяющей все вершины, равна 37. При этом, общая экономия составляет 85 - 37 = 48.

Найдите минимальную стоимость соединения сети, заданной в файле `network.txt`, с 40 вершинами и определите, сколько можно сэкономить по сравнению с полной стоимостью соединения, которую она имеет в настоящее время.

```python
# from src.utils.jjson import j_loads_ns # Импорт функции для загрузки данных из JSON
# from src.logger.logger import logger # Импорт модуля для логирования
# import heapq # импортируем библиотеку для работы с кучей

# def calculate_min_spanning_tree(matrix: list) -> tuple[list, int, int]:
#     """
#     Вычисляет минимальное связывающее дерево (MST) для заданного графа, представленного в виде матрицы смежности.
#
#     :param matrix: Матрица смежности, представляющая граф.
#     :type matrix: list
#     :return: Кортеж, содержащий MST, полную стоимость сети и минимальную стоимость MST.
#     :rtype: tuple[list, int, int]
#     :raises TypeError: Если входные данные не являются списком или если матрица не квадратная.
#     :raises ValueError: Если матрица пустая или содержит нечисловые значения.
#
#     :Example:
#     >>> matrix = [
#     ...    [0, 16, 12, 21, 0, 0, 0],
#     ...    [16, 0, 0, 17, 20, 0, 0],
#     ...    [12, 0, 0, 28, 0, 31, 0],
#     ...    [21, 17, 28, 0, 18, 19, 23],
#     ...    [0, 20, 0, 18, 0, 0, 11],
#     ...    [0, 0, 31, 19, 0, 0, 27],
#     ...    [0, 0, 0, 23, 11, 27, 0]
#     ... ]
#     >>> mst, total_weight, min_weight = calculate_min_spanning_tree(matrix)
#     >>> print(f'MST: {mst}')
#     >>> print(f'Total weight: {total_weight}')
#     >>> print(f'Min weight: {min_weight}')
#
#
#     """
#     # Проверка типа входных данных
#     if not isinstance(matrix, list):
#         logger.error('Входные данные должны быть списком.')
#         raise TypeError('Входные данные должны быть списком.')
#
#     # Проверка на пустую матрицу
#     if not matrix:
#         logger.error('Матрица не должна быть пустой.')
#         raise ValueError('Матрица не должна быть пустой.')
#
#     # Получение количества вершин
#     num_vertices = len(matrix)
#
#     # Проверка, что матрица квадратная
#     for row in matrix:
#          if len(row) != num_vertices:
#              logger.error('Матрица должна быть квадратной.')
#              raise ValueError('Матрица должна быть квадратной.')
#
#
#     # Инициализация переменных для алгоритма Прима
#     visited = [False] * num_vertices # Массив для отслеживания посещенных вершин
#     min_heap = [(0, 0)] # Куча для хранения ребер, начинаем с первой вершины
#     mst = [] # Список для хранения ребер MST
#     total_weight = 0 # Общая стоимость сети
#     min_weight = 0 # Минимальная стоимость MST
#
#     # Вычисление общей стоимости сети
#     for i in range(num_vertices):
#         for j in range(i + 1, num_vertices):
#             total_weight += matrix[i][j]
#
#
#     # Алгоритм Прима
#     while min_heap:
#         weight, vertex = heapq.heappop(min_heap) # извлекаем ребро с минимальным весом
#
#         # Если вершина уже посещена, переходим к следующему ребру
#         if visited[vertex]:
#             continue
#
#         visited[vertex] = True # Помечаем текущую вершину как посещенную
#         min_weight += weight # Добавляем вес ребра к минимальному весу
#
#         # Добавляем ребро в MST, кроме первого
#         if weight != 0:
#             mst.append((weight, vertex))
#
#         # Добавляем ребра из текущей вершины в кучу
#         for next_vertex in range(num_vertices):
#             if matrix[vertex][next_vertex] != 0 and not visited[next_vertex]:
#                 heapq.heappush(min_heap, (matrix[vertex][next_vertex], next_vertex))
#
#     return mst, total_weight, min_weight
#
#
# if __name__ == '__main__':
#     try:
#         # data = j_loads_ns('network.txt') # Загрузка данных из файла
#         # Пример данных
#         data = [
#            [0, 16, 12, 21, 0, 0, 0],
#            [16, 0, 0, 17, 20, 0, 0],
#            [12, 0, 0, 28, 0, 31, 0],
#            [21, 17, 28, 0, 18, 19, 23],
#            [0, 20, 0, 18, 0, 0, 11],
#            [0, 0, 31, 19, 0, 0, 27],
#            [0, 0, 0, 23, 11, 27, 0]
#         ]
#         mst, total_weight, min_weight = calculate_min_spanning_tree(data) # Вызов функции для расчета MST
#
#         print(f'Минимальное связывающее дерево (MST): {mst}') # Вывод MST
#         print(f'Полная стоимость сети: {total_weight}') # Вывод общей стоимости
#         print(f'Минимальная стоимость MST: {min_weight}') # Вывод минимальной стоимости
#         print(f'Экономия: {total_weight - min_weight}') # Вывод экономии
#     except Exception as e:
#         logger.error(f'Произошла ошибка: {e}') # Логирование ошибки
```