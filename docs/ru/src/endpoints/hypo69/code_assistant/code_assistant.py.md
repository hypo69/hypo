# Модуль для работы с ассистентом программиста `CodeAssistant`

## Обзор

Модуль предназначен для обучения модели машинного обучения кодовой базе, составления документации к проекту, примеров кода и тестов.

Модуль содержит класс :class:`CodeAssistant`, который используется для взаимодействия с различными AI-моделями (например, Google Gemini и OpenAI) и выполнения задач обработки кода. Класс читает файлы кода, отправляет код в модель, модель обрабатывает код и возвращает его в класс. Класс сохраняет результат в директории `docs/gemini`. В зависимости от роли файлы сохраняются в разных поддиректориях.

## Подробнее

Модуль предоставляет функциональность для автоматизации задач, связанных с машинным обучением, включая чтение файлов кода, взаимодействие с моделями ИИ (Google Gemini и OpenAI), обработку кода и сохранение результатов.

## Классы

### `Config`

**Описание**: Класс `Config` предназначен для хранения и управления конфигурационными параметрами ассистента кода.

**Как работает класс**:
1.  **Инициализация**: Класс инициализируется с базовыми путями и загружает конфигурацию из файла `code_assistant.json`.
2.  **Чтение инструкции для кода**: Метод `code_instruction` пытается прочитать инструкцию для кода из файла в директории `instructions`. Файл выбирается на основе текущей роли и языка.
3.  **Настройка Gemini**: Параметры для модели Gemini, такие как имя модели и ключ API, устанавливаются из переменных окружения или из конфигурационного файла.

**Переменные класса**:

*   `base_path` (Path): Базовый путь к директории `code_assistant`.
*   `config` (SimpleNamespace): Объект, содержащий конфигурационные параметры, загруженные из `code_assistant.json`.
*   `role` (str): Роль, используемая по умолчанию (`'doc_writer_md'`).
*   `lang` (str): Язык, используемый по умолчанию (`'ru'`).
*   `system_instruction` (str): Инструкция для системы, изначально пустая строка.

**Методы**:

*   `code_instruction`

    ```python
    @property
    def code_instruction(self) -> str | bool:
        """Чтение инструкции для кода."""
    ```

    **Назначение**: Чтение инструкции для кода из файла.

    **Как работает функция**:

    1.  Определяется путь к файлу инструкции на основе текущей роли и языка.
    2.  Пытается прочитать содержимое файла.
    3.  В случае ошибки логирует её и возвращает `...`.

    **Возвращает**:

    *   `str | bool`: Содержимое файла инструкции или `...` в случае ошибки.

    **Вызывает исключения**:

    *   `Exception`: В случае ошибки при чтении файла.

*   `gemini`

    ```python
    gemini: SimpleNamespace = SimpleNamespace(**{
            'model_name': os.getenv('GEMINI_MODEL') if USE_ENV else config.gemini_model_name or None,
            'api_key': os.getenv('GEMINI_API_KEY') if USE_ENV else gs.credentials.gemini.onela or None,
            'response_mime_type': 'text/plain',
        })
    ```

    **Назначение**: Настройка параметров для модели Gemini.

    **Как работает**:
    1.  Извлекает параметры модели, такие как `model_name` и `api_key`, из переменных окружения, если `USE_ENV` установлен, иначе из конфигурационного файла.
    2.  Устанавливает `response_mime_type` в `'text/plain'`.
    3.  Создает объект `SimpleNamespace` с этими параметрами.

### `CodeAssistant`

**Описание**: Класс `CodeAssistant` предназначен для работы с моделями ИИ, такими как Google Gemini и OpenAI, для выполнения различных задач, связанных с обработкой кода.

**Как работает класс**:

1.  **Инициализация**: Класс инициализируется с заданной ролью, языком и списком моделей для использования. Он также загружает системные инструкции из файла, если они предоставлены, или использует инструкции по умолчанию.
2.  **Инициализация моделей**: Метод `_initialize_models` инициализирует указанные модели ИИ (в настоящее время поддерживается только Google Gemini) с использованием предоставленных параметров конфигурации.
3.  **Обработка файлов**: Метод `process_files` выполняет итерацию по файлам в указанных директориях, создает запросы на основе содержимого файлов и отправляет их в модель ИИ. Затем он сохраняет ответы, полученные от модели.
4.  **Создание запросов**: Метод `_create_request` создает запросы, включающие роль, язык, путь к файлу и содержимое файла.
5.  **Генерация файлов**: Метод `_yield_files_content` генерирует пути к файлам и их содержимое на основе указанных шаблонов.
6.  **Сохранение ответов**: Метод `_save_response` сохраняет ответы модели в файлы, добавляя суффикс к имени файла в зависимости от роли.
7.  **Удаление внешних кавычек**: Метод `_remove_outer_quotes` удаляет внешние кавычки из ответа модели.
8.  **Запуск**: Метод `run` запускает процесс обработки файлов.

**Переменные класса**:

*   `role` (str): Роль, которую выполняет ассистент (например, `'doc_writer_md'`).
*   `lang` (str): Язык, используемый ассистентом (например, `'ru'`).
*   `config` (SimpleNamespace): Объект, содержащий конфигурационные параметры, загруженные из `code_assistant.json`.
*   `gemini_model` (GoogleGenerativeAI): Экземпляр модели Google Gemini.
*   `openai_model` (OpenAIModel): Экземпляр модели OpenAI.

**Методы**:

*   `__init__`

    ```python
    def __init__(
        self,
        role: Optional[str] = 'doc_writer_md',
        lang: Optional[str] = 'en',
        models_list: Optional[list[str, str] | str] = ['gemini'],
        system_instruction: Optional[str | Path] = None,
        **kwards,
    ) -> None:
        """
        Инициализация ассистента с заданными параметрами.

        Args:
            role (str): Роль для выполнения задачи.
            lang (str): Язык выполнения.
            models_list (list[str]): Список моделей для инициализации.
            system_instruction (str|Path): Инструкция для системы. Можно отправить текст или путь к файлу.
            **kwards: Дополнительные аргументы для инициализации моделей.
        """
    ```

    **Назначение**: Инициализация экземпляра класса `CodeAssistant` с заданными параметрами.

    **Как работает функция**:

    1.  Устанавливает значения `role` и `lang` из переданных аргументов.
    2.  Если предоставлена инструкция для системы (`system_instruction`):
        *   Если инструкция является строкой, она устанавливается напрямую.
        *   Если инструкция является путем к файлу, содержимое файла считывается и устанавливается как инструкция.
        *   Если инструкция имеет неверный формат, регистрируется ошибка.
    3.  Если инструкция не предоставлена, используется инструкция по умолчанию из файла `CODE_RULES.lang.MD`.
    4.  Вызывает метод `_initialize_models` для инициализации моделей ИИ.

    **Параметры**:

    *   `role` (Optional[str]): Роль для выполнения задачи. По умолчанию `'doc_writer_md'`.
    *   `lang` (Optional[str]): Язык выполнения. По умолчанию `'en'`.
    *   `models_list` (Optional[list[str, str] | str]): Список моделей для инициализации. По умолчанию `['gemini']`.
    *   `system_instruction` (Optional[str | Path]): Инструкция для системы. Может быть строкой или путем к файлу. По умолчанию `None`.
    *   `**kwards`: Дополнительные аргументы для инициализации моделей.

*   `_initialize_models`

    ```python
    def _initialize_models(self, models_list: list, response_mime_type:str = 'text/plain', **kwards) -> bool:
        """
        Инициализация моделей на основе заданных параметров.

        Args:
            models_list (list[str]): Список моделей для инициализации.
            **kwards: Дополнительные аргументы для инициализации моделей.

        Returns:
            bool: Успешность инициализации моделей.

        Raises:
            Exception: Если произошла ошибка при инициализации моделей.
        """
    ```

    **Назначение**: Инициализация моделей ИИ на основе заданных параметров.

    **Как работает функция**:

    1.  Проверяет, есть ли `'gemini'` в списке моделей (`models_list`).
    2.  Если есть, пытается инициализировать модель Google Gemini:
        *   Создает экземпляр `GoogleGenerativeAI` с параметрами, переданными в `kwards`.
        *   Ловит исключения, если происходит ошибка при инициализации, и регистрирует ошибку.

    **Параметры**:

    *   `models_list` (list[str]): Список моделей для инициализации.
    *   `**kwards`: Дополнительные аргументы для инициализации моделей.

    **Возвращает**:

    *   `bool`: `True`, если инициализация прошла успешно, `False` в противном случае.

    **Вызывает исключения**:

    *   `Exception`: Если произошла ошибка при инициализации моделей.

*   `send_file`

    ```python
    def send_file(self, file_path: Path) -> Optional[str | None]:
        """
        Отправка файла в модель.

        Args:
            file_path (Path): Абсолютный путь к файлу, который нужно отправить.
            file_name (Optional[str]): Имя файла для отправки. Если не указано и 'src' отсутствует, используется имя файла без изменений.

        Returns:
            Optional[str | None]: URL файла, если успешно отправлен, иначе None.
        """
    ```

    **Назначение**: Отправка файла в модель Google Gemini.

    **Как работает функция**:

    1.  Пытается отправить файл в модель с помощью метода `upload_file` модели `gemini_model`.
    2.  Если ответ получен, возвращает URL файла, если он присутствует в ответе.

    **Параметры**:

    *   `file_path` (Path): Абсолютный путь к файлу, который нужно отправить.

    **Возвращает**:

    *   `Optional[str | None]`: URL файла, если успешно отправлен, иначе `None`.

    **Вызывает исключения**:

    *   `Exception`: Если произошла ошибка при отправке файла.

*   `process_files`

    ```python
    async def process_files(
        self, start_dirs: str | Path | list[str, str] | list[Path, Path] = None, start_from_file: Optional[int] = 1
    ) -> bool:
        """компиляция, отправка запроса и сохранение результата."""
    ```

    **Назначение**: Компиляция, отправка запроса и сохранение результата обработки файлов.

    **Как работает функция**:

    1.  Определяет стартовые директории для обработки файлов. Если `start_dirs` не указаны, использует значения из конфигурации.
    2.  Итерируется по каждой стартовой директории:
        *   Проверяет, существует ли директория и является ли она директорией. Если нет, переходит к следующей директории.
        *   Итерируется по файлам в директории с использованием метода `_yield_files_content`.
        *   Для каждого файла создает запрос с помощью метода `_create_request`.
        *   Отправляет запрос в модель Google Gemini с использованием метода `ask_async`.
        *   Сохраняет полученный ответ с помощью метода `_save_response`.

    **Параметры**:

    *   `start_dirs` (str | Path | list[str, str] | list[Path, Path]): Список стартовых директорий для обработки файлов.
    *   `start_from_file` (Optional[int]): Номер файла, с которого начинается обработка. По умолчанию `1`.

    **Возвращает**:

    *   `bool`: `True`, если обработка завершена успешно, `False` в противном случае.

*   `_create_request`

    ```python
    def _create_request(self, file_path: str, content: str) -> str:
        """Создание запроса с учетом роли и языка."""
    ```

    **Назначение**: Создание запроса на основе содержимого файла, роли и языка.

    **Как работает функция**:

    1.  Создает словарь `content_request`, содержащий роль, язык, путь к файлу и содержимое файла.
    2.  Возвращает строковое представление запроса.

    **Параметры**:

    *   `file_path` (str): Путь к файлу.
    *   `content` (str): Содержимое файла.

    **Возвращает**:

    *   `str`: Строковое представление запроса.

*   `_yield_files_content`

    ```python
    def _yield_files_content(
        self,
        process_directory: str | Path,
    ) -> Iterator[tuple[Path, str]]:
        """
        Генерирует пути файлов и их содержимое по указанным шаблонам.

        Args:
            process_directory (Path | str): Абсолютный путь к стартовой директории

        Returns:
            bool: Iterator
        """
    ```

    **Назначение**: Генерация путей файлов и их содержимого на основе указанных шаблонов.

    **Как работает функция**:

    1.  Преобразует `process_directory` в объект `Path`, если это строка.
    2.  Компилирует шаблоны исключаемых файлов из конфигурации.
    3.  Итерируется по всем файлам в директории:
        *   Проверяет, соответствует ли имя файла шаблонам включения.
        *   Проверяет, не находится ли файл в исключенной директории.
        *   Проверяет, не соответствует ли имя файла шаблонам исключения.
        *   Проверяет, не находится ли имя файла в списке исключенных файлов.
        *   Если все проверки пройдены, считывает содержимое файла и возвращает путь к файлу и его содержимое.

    **Параметры**:

    *   `process_directory` (str | Path): Абсолютный путь к стартовой директории.

    **Возвращает**:

    *   `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортежи, содержащие путь к файлу и его содержимое.

*   `_save_response`

    ```python
    async def _save_response(self, file_path: Path, response: str, model_name: str) -> bool:
        """
        Сохранение ответа модели в файл с добавлением суффикса.

        Метод сохраняет ответ модели в файл, добавляя к текущему расширению файла
        дополнительный суффикс, определяемый ролью.

        Args:
            file_path (Path): Исходный путь к файлу, в который будет записан ответ.
            response (str): Ответ модели, который необходимо сохранить.
            model_name (str): Имя модели, использованной для генерации ответа.

        Raises:
            OSError: Если не удаётся создать директорию или записать в файл.
        """
    ```

    **Назначение**: Сохранение ответа модели в файл с добавлением суффикса, зависящего от роли.

    **Как работает функция**:

    1.  Определяет директорию для вывода на основе роли.
    2.  Формирует целевую директорию, заменяя `<model>` и `<lang>` на соответствующие значения.
    3.  Заменяет часть пути к файлу на целевую директорию.
    4.  Определяет суффикс для добавления к имени файла на основе роли.
    5.  Создает директорию, если она не существует.
    6.  Записывает ответ модели в файл с добавлением суффикса.

    **Параметры**:

    *   `file_path` (Path): Исходный путь к файлу, в который будет записан ответ.
    *   `response` (str): Ответ модели, который необходимо сохранить.
    *   `model_name` (str): Имя модели, использованной для генерации ответа.

    **Возвращает**:

    *   `bool`: `True`, если сохранение прошло успешно, `False` в противном случае.

    **Вызывает исключения**:

    *   `OSError`: Если не удаётся создать директорию или записать в файл.

*   `_remove_outer_quotes`

    ```python
    def _remove_outer_quotes(self, response: str) -> str:
        """
        Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

        Args:
            response (str): Ответ модели, который необходимо обработать.

        Returns:
            str: Очищенный контент как строка.

        Example:
            >>> _remove_outer_quotes('```md some content ```')
            'some content'
            >>> _remove_outer_quotes('some content')
            'some content'
            >>> _remove_outer_quotes('```python def hello(): print("Hello") ```')
            '```python def hello(): print("Hello") ```'
        """
    ```

    **Назначение**: Удаление внешних кавычек из ответа модели.

    **Как работает функция**:

    1.  Удаляет пробельные символы в начале и конце строки.
    2.  Если строка начинается с `'```python'` или `'```mermaid'`, возвращает её без изменений.
    3.  Удаляет префиксы и суффиксы `'```'` из известных форматов, если они присутствуют.
    4.  Возвращает очищенную строку.

    **Параметры**:

    *   `response` (str): Ответ модели, который необходимо обработать.

    **Возвращает**:

    *   `str`: Очищенный контент как строка.

*   `run`

    ```python
    def run(self, start_from_file: int = 1) -> None:
        """Запуск процесса обработки файлов."""
    ```

    **Назначение**: Запуск процесса обработки файлов.

    **Как работает функция**:

    1.  Устанавливает обработчик сигнала `SIGINT` для прерывания выполнения.
    2.  Запускает асинхронный процесс обработки файлов `process_files`.

    **Параметры**:

    *   `start_from_file` (int): Номер файла, с которого начинается обработка. По умолчанию `1`.

*   `_signal_handler`

    ```python
    def _signal_handler(self, signal, frame) -> None:
        """Обработка прерывания выполнения."""
    ```

    **Назначение**: Обработка прерывания выполнения (например, при нажатии Ctrl+C).

    **Как работает функция**:

    1.  Регистрирует сообщение отладки о прерывании процесса.
    2.  Завершает выполнение программы.

    **Параметры**:

    *   `signal` (int): Номер сигнала.
    *   `frame` (frame): Текущий кадр стека вызовов.

## Функции

### `parse_args`

```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
```

**Назначение**: Разбор аргументов командной строки.

**Как работает функция**:

1.  Создает объект `ArgumentParser` для описания аргументов командной строки.
2.  Определяет аргументы `--role`, `--lang`, `--model`, `--start-dirs` и `--start-file-number`.
3.  Разбирает аргументы командной строки с использованием метода `parse_args`.
4.  Возвращает словарь, содержащий значения аргументов.

**Параметры**:

*   Нет

**Возвращает**:

*   `dict`: Словарь, содержащий значения аргументов командной строки.

### `main`

```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
```

**Назначение**: Запуск процесса обработки файлов в бесконечном цикле с учетом ролей и языков, указанных в конфигурации.

**Как работает функция**:

1.  Загружает конфигурацию из файла `code_assistant.json`.
2.  Входит в бесконечный цикл:
    *   Итерируется по каждому языку и каждой роли, указанным в конфигурации.
    *   Создает экземпляр класса `CodeAssistant` с текущей ролью и языком.
    *   Запускает процесс обработки файлов с использованием метода `process_files`.
    *   Обновляет конфигурацию для учета изменений во время выполнения.

**Параметры**:

*   Нет

**Возвращает**:

*   Нет