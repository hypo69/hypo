## Ответ на Задачу No 134: Пара соседних простых чисел

### 1. Анализ задачи и решение
**Понимание задачи:**
* Найти пары соседних простых чисел `p1` и `p2` в диапазоне `5 ≤ p1 ≤ 1000000`.
* Для каждой пары `p1`, `p2` найти наименьшее кратное `p1`, которое заканчивается на `p2`.
* Суммировать все эти наименьшие кратные.

**Решение:**
1. **Генерация простых чисел:** Сначала необходимо сгенерировать список простых чисел в диапазоне от 5 до 1000000 (включительно). Можно использовать решето Эратосфена для эффективности.
2. **Поиск соседних простых чисел:** Далее нужно пройти по полученному списку простых чисел и найти пары соседних чисел.
3. **Поиск наименьшего кратного:** Для каждой пары `(p1, p2)` нужно найти такое наименьшее целое число `k`, чтобы `k * p1` заканчивалось на цифры `p2`.
4. **Суммирование кратных:** Суммируем все найденные наименьшие кратные.

**Поиск наименьшего кратного с заданными последними цифрами:**
Пусть у нас есть числа `p1` и `p2`. Нам нужно найти `k` такое, чтобы `k * p1 % 10^len(str(p2)) == p2`.
Иными словами, остаток от деления `k * p1` на `10^len(str(p2))` должен быть равен `p2`.

### 2. Алгоритм решения
1. **Начать.**
2. **Сгенерировать простые числа** в диапазоне от 5 до 1000000.
   1.  Создать список `is_prime` размером 1000001, заполненный `True`.
   2.  Установить `is_prime[0]` и `is_prime[1]` в `False`.
   3.  Для каждого числа `p` от 2 до корня из 1000000:
       * Если `is_prime[p]` истинно:
         * Для каждого кратного `i` от `p*p` до 1000000 с шагом `p`:
           * Установить `is_prime[i]` в `False`.
   4. Создать список `primes`, в который добавить все числа `i` от 5 до 1000000, для которых `is_prime[i]` истинно.
3. **Инициализировать** переменную `total_sum` в 0.
4. **Для каждой** пары соседних простых чисел `(p1, p2)` в списке `primes` (до предпоследнего элемента):
    1.  Получить `length_p2` = количество цифр в числе `p2`.
    2.  Вычислить `mod_val = 10 ** length_p2`.
    3.  Найти минимальное `k`, для которого `(k * p1) % mod_val == p2`. 
        1.  Начать `k` с 1
        2. Пока `(k * p1) % mod_val != p2`:
            *   Увеличить `k` на 1.
    4.  Вычислить `least_multiple = k * p1`.
    5.  Прибавить `least_multiple` к `total_sum`.
5. **Вернуть** значение `total_sum`.
6. **Конец.**

### 3. Реализация на Python 3.12
```python
def generate_primes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    for p in range(2, int(limit**0.5) + 1):
        if is_prime[p]:
            for i in range(p * p, limit + 1, p):
                is_prime[i] = False
    primes = [i for i in range(5, limit + 1) if is_prime[i]]
    return primes

def find_least_multiple(p1, p2):
  length_p2 = len(str(p2))
  mod_val = 10 ** length_p2
  k = 1
  while (k * p1) % mod_val != p2:
    k += 1
  return k * p1


def sum_of_least_multiples(limit):
    primes = generate_primes(limit)
    total_sum = 0
    for i in range(len(primes) - 1):
        p1 = primes[i]
        p2 = primes[i+1]
        least_multiple = find_least_multiple(p1, p2)
        total_sum += least_multiple
    return total_sum


limit = 1000000
result = sum_of_least_multiples(limit)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> GeneratePrimes((Сгенерировать простые числа от 5 до 1000000))
    GeneratePrimes --> InitializeSum((Инициализировать total_sum = 0))
    InitializeSum --> LoopStart((Начать цикл: i от 0 до len(primes)-2))
    LoopStart --> GetPrimes((Получить p1 = primes[i], p2 = primes[i+1]))
    GetPrimes --> CalculateModVal((Вычислить mod_val = 10^len(str(p2)) ))
    CalculateModVal --> FindK((Найти наименьшее k, чтобы (k * p1) % mod_val == p2))
    FindK --> CalculateMultiple((least_multiple = k * p1))
    CalculateMultiple --> AddToSum((total_sum += least_multiple))
    AddToSum --> LoopStart
    LoopStart --> OutputSum((Вывести total_sum))
    OutputSum --> End((Конец))
```

**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Сгенерировать простые числа от 5 до 1000000:**  Генерирует список всех простых чисел в заданном диапазоне.
*   **Инициализировать total_sum = 0:**  Создает переменную для хранения суммы наименьших кратных и присваивает ей значение 0.
*   **Начать цикл: i от 0 до len(primes)-2:**  Начинает цикл для перебора всех пар соседних простых чисел.
*   **Получить p1 = primes[i], p2 = primes[i+1]:**  Получает очередную пару соседних простых чисел.
*  **Вычислить mod_val = 10^len(str(p2)):** вычисляет модуль, на который будем брать остаток при поиске k
*  **Найти наименьшее k, чтобы (k \* p1) % mod_val == p2:**  Находит наименьшее целое число `k` такое, что `k * p1` оканчивается на цифры `p2`.
*   **least_multiple = k * p1:** Вычисляет наименьшее кратное
*   **total_sum += least_multiple:**  Добавляет найденное наименьшее кратное к общей сумме.
*   **Вывести total_sum:** Выводит итоговую сумму.
