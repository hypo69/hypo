# Модуль helper.py

## Обзор

Модуль `helper.py` содержит набор вспомогательных функций, используемых для обработки и форматирования текстовых данных, сообщений и других типов данных, необходимых для работы с различными AI-моделями. В частности, он предназначен для предобработки данных перед отправкой запросов к моделям, а также для постобработки ответов от этих моделей.

## Подробней

Модуль предоставляет функции для преобразования данных в строковый формат, форматирования промптов, извлечения системных сообщений, получения последних сообщений от пользователя, а также для генерации случайных строк и шестнадцатеричных значений. Он также включает функции для работы с cookies и фильтрации значений `None`. Эти функции облегчают взаимодействие с AI-моделями, предоставляя удобные инструменты для обработки данных.

## Функции

### `to_string`

```python
def to_string(value) -> str:
    """
    Преобразует значение в строку, обрабатывая различные типы данных.

    Args:
        value: Значение для преобразования. Может быть строкой, словарем или списком.

    Returns:
        str: Строковое представление значения.

    Как работает функция:
    1. **Проверка типа значения**: Функция проверяет тип входного значения.
    2. **Обработка строки**: Если значение уже является строкой, функция возвращает его без изменений.
    3. **Обработка словаря**: Если значение является словарем, функция проверяет наличие определенных ключей:
        - Если есть ключ "name", возвращает пустую строку.
        - Если есть ключ "bucket_id", пытается прочитать содержимое bucket и возвращает его как строку.
        - Если есть ключ "type" со значением "text", возвращает значение ключа "text".
        - В противном случае возвращает пустую строку.
    4. **Обработка списка**: Если значение является списком, функция рекурсивно применяет `to_string` к каждому элементу, у которого "type" равен "text", и объединяет результаты в строку.
    5. **Преобразование в строку**: Если значение не является ни строкой, ни словарем, ни списком, функция преобразует его в строку с помощью `str()`.

    Схема работы функции:

    A (Проверка типа значения)
    |
    B (Строка?) -- Нет --> C (Словарь?) -- Нет --> D (Список?) -- Нет --> E (str(value))
    | Да
    B (return value)
    | Да
    C (Проверка ключей)

    Примеры:
    >>> to_string("hello")
    'hello'
    >>> to_string({"type": "text", "text": "world"})
    'world'
    >>> to_string([{"type": "text", "text": "one"}, {"type": "text", "text": "two"}])
    'onetwo'
    """
    ...
```

### `format_prompt`

```python
def format_prompt(messages: Messages, add_special_tokens: bool = False, do_continue: bool = False, include_system: bool = True) -> str:
    """
    Форматирует список сообщений в единую строку, добавляя специальные токены.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит ключи 'role' и 'content'.
        add_special_tokens (bool): Флаг, указывающий, нужно ли добавлять специальные токены форматирования. По умолчанию `False`.
        do_continue (bool): Флаг, указывающий, нужно ли продолжать форматирование. По умолчанию `False`.
        include_system (bool): Флаг, указывающий, нужно ли включать системные сообщения. По умолчанию `True`.

    Returns:
        str: Отформатированная строка, содержащая все сообщения.

    Как работает функция:
    1. **Проверка add_special_tokens и количества сообщений**: Если `add_special_tokens` равен `False` и количество сообщений не больше 1, функция возвращает строковое представление содержимого первого сообщения.
    2. **Фильтрация и преобразование сообщений**: Функция преобразует список сообщений в список кортежей `(role, content)`, фильтруя системные сообщения, если `include_system` равен `False`.
    3. **Форматирование сообщений**: Функция объединяет сообщения в строку, добавляя роль сообщения и содержимое, разделенные двоеточием.
    4. **Добавление "Assistant:"**: Если `do_continue` равен `False`, функция добавляет "Assistant:" в конце отформатированной строки.

    Схема работы функции:

    A (Проверка add_special_tokens и количества сообщений)
    |
    B (Фильтрация и преобразование сообщений)
    |
    C (Форматирование сообщений)
    |
    D (Добавление "Assistant:")
    |
    E (Возврат отформатированной строки)

    Примеры:
    >>> messages = [{"role": "user", "content": "hello"}, {"role": "assistant", "content": "world"}]
    >>> format_prompt(messages)
    'User: hello\\nAssistant: world\\nAssistant:'
    >>> format_prompt(messages, add_special_tokens=True)
    'User: hello\\nAssistant: world\\nAssistant:'
    """
    ...
```

### `get_system_prompt`

```python
def get_system_prompt(messages: Messages) -> str:
    """
    Извлекает системные сообщения из списка сообщений и объединяет их в одну строку.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит ключи 'role' и 'content'.

    Returns:
        str: Объединенная строка системных сообщений.

    Как работает функция:
    1. **Фильтрация системных сообщений**: Функция фильтрует список сообщений, выбирая только те, у которых роль равна "system".
    2. **Объединение сообщений**: Функция объединяет содержимое всех системных сообщений в одну строку, разделяя их символом новой строки.

    Схема работы функции:

    A (Фильтрация системных сообщений)
    |
    B (Объединение сообщений)
    |
    C (Возврат объединенной строки)

    Примеры:
    >>> messages = [{"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "hello"}]
    >>> get_system_prompt(messages)
    'You are a helpful assistant.'
    """
    ...
```

### `get_last_user_message`

```python
def get_last_user_message(messages: Messages) -> str:
    """
    Извлекает последнее сообщение от пользователя из списка сообщений.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит ключи 'role' и 'content'.

    Returns:
        str: Последнее сообщение от пользователя.

    Как работает функция:
    1. **Копирование списка сообщений**: Функция создает копию списка сообщений, чтобы не изменять исходный список.
    2. **Итерация по сообщениям**: Функция итерируется по списку сообщений в обратном порядке.
    3. **Поиск сообщения от пользователя**: Функция ищет последнее сообщение, у которого роль равна "user".
    4. **Объединение сообщений**: Если найдено несколько сообщений от пользователя подряд, функция объединяет их в одну строку, разделяя символом новой строки.

    Схема работы функции:

    A (Копирование списка сообщений)
    |
    B (Итерация по сообщениям)
    |
    C (Поиск сообщения от пользователя)
    |
    D (Объединение сообщений)
    |
    E (Возврат последнего сообщения)

    Примеры:
    >>> messages = [{"role": "user", "content": "hello"}, {"role": "assistant", "content": "world"}, {"role": "user", "content": "how are you"}]
    >>> get_last_user_message(messages)
    'how are you'
    """
    ...
```

### `format_image_prompt`

```python
def format_image_prompt(messages, prompt: str = None) -> str:
    """
    Форматирует промпт для генерации изображений. Если `prompt` не указан, использует последнее сообщение пользователя.

    Args:
        messages: Список сообщений.
        prompt (str, optional): Промпт для генерации изображения. По умолчанию `None`.

    Returns:
        str: Отформатированный промпт.

    Как работает функция:
    1. **Проверка наличия prompt**: Функция проверяет, был ли передан параметр `prompt`.
    2. **Использование prompt**: Если `prompt` был передан, функция возвращает его без изменений.
    3. **Извлечение последнего сообщения пользователя**: Если `prompt` не был передан, функция вызывает `get_last_user_message` для получения последнего сообщения пользователя и возвращает его.

    Схема работы функции:

    A (Проверка наличия prompt)
    |
    B (Использование prompt) -- Нет --> C (Извлечение последнего сообщения пользователя)
    | Да
    B (Возврат prompt)

    Примеры:
    >>> messages = [{"role": "user", "content": "hello"}, {"role": "assistant", "content": "world"}, {"role": "user", "content": "how are you"}]
    >>> format_image_prompt(messages)
    'how are you'
    >>> format_image_prompt(messages, prompt="generate image of cat")
    'generate image of cat'
    """
    ...
```

### `format_prompt_max_length`

```python
def format_prompt_max_length(messages: Messages, max_lenght: int) -> str:
    """
    Форматирует промпт и обрезает его, если он превышает заданную максимальную длину.

    Args:
        messages (Messages): Список сообщений.
        max_lenght (int): Максимальная длина промпта.

    Returns:
        str: Отформатированный и, возможно, обрезанный промпт.

    Как работает функция:
    1. **Форматирование промпта**: Функция вызывает `format_prompt` для форматирования списка сообщений в промпт.
    2. **Проверка длины промпта**: Функция проверяет, превышает ли длина отформатированного промпта заданную максимальную длину.
    3. **Обрезание промпта**: Если длина промпта превышает максимальную длину, функция пытается обрезать промпт, используя различные стратегии:
        - Если количество сообщений больше 6, функция форматирует только первые 3 и последние 3 сообщения.
        - Если длина промпта все еще превышает максимальную длину, функция форматирует только системные сообщения и последнее сообщение пользователя.
        - Если длина промпта все еще превышает максимальную длину, функция использует только содержимое последнего сообщения пользователя.
    4. **Логирование**: Функция логирует информацию об обрезании промпта.

    Схема работы функции:

    A (Форматирование промпта)
    |
    B (Проверка длины промпта)
    |
    C (Обрезание промпта)
    |
    D (Логирование)
    |
    E (Возврат промпта)

    Примеры:
    >>> messages = [{"role": "user", "content": "hello"}, {"role": "assistant", "content": "world"}, {"role": "user", "content": "how are you"}]
    >>> format_prompt_max_length(messages, 100)
    'User: hello\\nAssistant: world\\nUser: how are you\\nAssistant:'
    """
    ...
```

### `get_random_string`

```python
def get_random_string(length: int = 10) -> str:
    """
    Генерирует случайную строку указанной длины, содержащую строчные буквы и цифры.

    Args:
        length (int, optional): Длина случайной строки. По умолчанию 10.

    Returns:
        str: Случайная строка указанной длины.

    Как работает функция:
    1. **Выбор символов**: Функция выбирает случайные символы из набора строчных букв и цифр.
    2. **Генерация строки**: Функция генерирует строку указанной длины, объединяя выбранные символы.

    Схема работы функции:

    A (Выбор символов)
    |
    B (Генерация строки)
    |
    C (Возврат строки)

    Примеры:
    >>> get_random_string(5)
    'a1b2c'
    """
    ...
```

### `get_random_hex`

```python
def get_random_hex(length: int = 32) -> str:
    """
    Генерирует случайную шестнадцатеричную строку указанной длины.

    Args:
        length (int, optional): Длина случайной строки. По умолчанию 32.

    Returns:
        str: Случайная шестнадцатеричная строка указанной длины.

    Как работает функция:
    1. **Выбор символов**: Функция выбирает случайные символы из набора шестнадцатеричных символов (a-f и 0-9).
    2. **Генерация строки**: Функция генерирует строку указанной длины, объединяя выбранные символы.

    Схема работы функции:

    A (Выбор символов)
    |
    B (Генерация строки)
    |
    C (Возврат строки)

    Примеры:
    >>> get_random_hex(5)
    'a1b2c'
    """
    ...
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением `None`.

    Args:
        **kwargs: Словарь, элементы которого нужно отфильтровать.

    Returns:
        dict: Отфильтрованный словарь.

    Как работает функция:
    1. **Итерация по элементам**: Функция итерируется по элементам словаря.
    2. **Проверка значения**: Для каждого элемента функция проверяет, равно ли его значение `None`.
    3. **Фильтрация элементов**: Функция оставляет только те элементы, значения которых не равны `None`.

    Схема работы функции:

    A (Итерация по элементам)
    |
    B (Проверка значения)
    |
    C (Фильтрация элементов)
    |
    D (Возврат словаря)

    Примеры:
    >>> filter_none(a=1, b=None, c=3)
    {'a': 1, 'c': 3}
    """
    ...
```

### `async_concat_chunks`

```python
async def async_concat_chunks(chunks: AsyncIterator) -> str:
    """
    Асинхронно объединяет чанки в одну строку.

    Args:
        chunks (AsyncIterator): Асинхронный итератор чанков.

    Returns:
        str: Объединенная строка.

    Как работает функция:
    1. **Сбор чанков**: Функция собирает все чанки из асинхронного итератора в список.
    2. **Объединение чанков**: Функция вызывает `concat_chunks` для объединения чанков в одну строку.

    Внутренние функции:
        - `concat_chunks(chunks: Iterator) -> str`:
            Объединяет чанки в одну строку.
            Args:
                chunks (Iterator): Итератор чанков.

            Returns:
                str: Объединенная строка.

            Как работает функция:
            1. **Преобразование в строку**: Функция преобразует каждый чанк в строку.
            2. **Фильтрация чанков**: Функция фильтрует чанки, удаляя пустые чанки и чанки, являющиеся экземплярами исключений.
            3. **Объединение чанков**: Функция объединяет отфильтрованные чанки в одну строку.

            Схема работы функции:
            A (Преобразование в строку)
            |
            B (Фильтрация чанков)
            |
            C (Объединение чанков)
            |
            D (Возврат объединенной строки)

    Схема работы функции async_concat_chunks:

    A (Сбор чанков)
    |
    B (Объединение чанков)
    |
    C (Возврат объединенной строки)

    Примеры:
    >>> async def gen():
    ...     yield "hello"
    ...     yield "world"
    >>> import asyncio
    >>> asyncio.run(async_concat_chunks(gen()))
    'helloworld'
    """
    ...
```

### `concat_chunks`

```python
def concat_chunks(chunks: Iterator) -> str:
    """
    Объединяет чанки в одну строку.

    Args:
        chunks (Iterator): Итератор чанков.

    Returns:
        str: Объединенная строка.

    Как работает функция:
    1. **Преобразование в строку**: Функция преобразует каждый чанк в строку.
    2. **Фильтрация чанков**: Функция фильтрует чанки, удаляя пустые чанки и чанки, являющиеся экземплярами исключений.
    3. **Объединение чанков**: Функция объединяет отфильтрованные чанки в одну строку.

    Схема работы функции:

    A (Преобразование в строку)
    |
    B (Фильтрация чанков)
    |
    C (Объединение чанков)
    |
    D (Возврат объединенной строки)

    Примеры:
    >>> concat_chunks(["hello", "world"])
    'helloworld'
    """
    ...
```

### `format_cookies`

```python
def format_cookies(cookies: Cookies) -> str:
    """
    Форматирует словарь cookies в строку для использования в HTTP-запросах.

    Args:
        cookies (Cookies): Словарь cookies.

    Returns:
        str: Строка cookies.

    Как работает функция:
    1. **Преобразование в строку**: Функция преобразует каждый элемент словаря cookies в строку вида "ключ=значение".
    2. **Объединение cookies**: Функция объединяет строки cookies в одну строку, разделяя их символом "; ".

    Схема работы функции:

    A (Преобразование в строку)
    |
    B (Объединение cookies)
    |
    C (Возврат строки)

    Примеры:
    >>> format_cookies({"name": "value", "name2": "value2"})
    'name=value; name2=value2'
    """
    ...