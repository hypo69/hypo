# Модуль `utils`

## Обзор

Модуль `utils` содержит набор общих утилит и вспомогательных функций, используемых в проекте `tinytroupe`. Он включает в себя функции для работы с вводом и выводом моделей, управления моделями, валидации данных, обработки шаблонов, рендеринга, ввода-вывода и запуска, а также вспомогательные классы для сериализации JSON.

## Подробнее

Этот модуль предоставляет разнообразные инструменты, облегчающие разработку и поддержку проекта `tinytroupe`. Он содержит функции для составления сообщений для языковых моделей (LLM), извлечения JSON и блоков кода из текста, повторного выполнения функций при ошибках, проверки и очистки данных, добавления переменных RAI в шаблоны, инъекции стилей CSS в HTML, разбивки текста на части, форматирования даты и времени, чтения конфигурационных файлов, запуска логгера и сериализации объектов в JSON.

## Функции

### `compose_initial_LLM_messages_with_templates`

```python
def compose_initial_LLM_messages_with_templates(system_template_name: str, user_template_name: str = None, rendering_configs: dict = {}) -> list:
    """
    Составляет начальные сообщения для вызова LLM модели, предполагая, что всегда используется
    системное (общее описание задачи) и необязательное пользовательское сообщение (специфическое описание задачи).
    Эти сообщения составляются с использованием указанных шаблонов и конфигураций рендеринга.

    Args:
        system_template_name (str): Имя файла шаблона системного сообщения.
        user_template_name (str, optional): Имя файла шаблона пользовательского сообщения. По умолчанию `None`.
        rendering_configs (dict, optional): Словарь с конфигурациями для рендеринга шаблонов. По умолчанию `{}`.

    Returns:
        list: Список составленных сообщений для LLM модели.

    Как работает функция:
    1. Определяет пути к файлам шаблонов системного и пользовательского сообщений.
    2. Создает пустой список `messages` для хранения сообщений.
    3. Добавляет системное сообщение, рендерит шаблон с использованием `chevron.render` и добавляет в список `messages`.
    4. Если указано имя пользовательского шаблона, рендерит его и добавляет в список `messages`.
    5. Возвращает список `messages`.

    ASCII flowchart:
    A [Определение путей к шаблонам]
    ↓
    B [Создание списка сообщений]
    ↓
    C [Добавление системного сообщения (рендеринг шаблона)]
    ↓
    D [Проверка наличия пользовательского шаблона]
    |
    ├── E [Добавление пользовательского сообщения (рендеринг шаблона)]
    │   ↓
    └── F [Возврат списка сообщений]

    Примеры:
    >>> compose_initial_LLM_messages_with_templates('system_template.md', 'user_template.md', {'name': 'test'})
    [{'role': 'system', 'content': 'System message content'}, {'role': 'user', 'content': 'User message content'}]

    >>> compose_initial_LLM_messages_with_templates('system_template.md', rendering_configs={'name': 'test'})
    [{'role': 'system', 'content': 'System message content'}]
    """
    ...
```

### `extract_json`

```python
def extract_json(text: str) -> dict:
    """
    Извлекает JSON объект из строки, игнорируя: любой текст перед первой
    открывающей фигурной скобкой; и любые открывающие (```json) или закрывающие (```) теги Markdown.

    Args:
        text (str): Строка, из которой нужно извлечь JSON.

    Returns:
        dict: Извлеченный JSON объект в виде словаря. Возвращает пустой словарь, если извлечение не удалось.

    Как работает функция:
    1. Удаляет любой текст до первой открывающей фигурной или квадратной скобки.
    2. Удаляет любой текст после последней закрывающей фигурной или квадратной скобки.
    3. Удаляет недопустимые escape-последовательности, заменяя `\\\'` на `'`.
    4. Пытается распарсить полученный текст как JSON и возвращает результат.
    5. В случае ошибки возвращает пустой словарь.

    ASCII flowchart:
    A [Удаление текста до первой скобки]
    ↓
    B [Удаление текста после последней скобки]
    ↓
    C [Удаление недопустимых escape-последовательностей]
    ↓
    D [Попытка распарсить JSON]
    |
    ├── E [Возврат JSON объекта]
    │   ↓
    └── F [Возврат пустого словаря (ошибка)]

    Примеры:
    >>> extract_json('text{"key": "value"}')
    {'key': 'value'}

    >>> extract_json('{"key": "value"}text')
    {'key': 'value'}

    >>> extract_json('invalid json')
    {}
    """
    ...
```

### `extract_code_block`

```python
def extract_code_block(text: str) -> str:
    """
    Извлекает блок кода из строки, игнорируя любой текст перед первым
    открывающим тройным обратным апострофом и любой текст после закрывающего тройного обратного апострофа.

    Args:
        text (str): Строка, из которой нужно извлечь блок кода.

    Returns:
        str: Извлеченный блок кода. Возвращает пустую строку, если извлечение не удалось.

    Как работает функция:
    1. Удаляет любой текст до первого открывающего тройного обратного апострофа.
    2. Удаляет любой текст после последнего закрывающего тройного обратного апострофа.
    3. Возвращает полученный блок кода.
    4. В случае ошибки возвращает пустую строку.

    ASCII flowchart:
    A [Удаление текста до первого ```]
    ↓
    B [Удаление текста после последнего ```]
    ↓
    C [Возврат блока кода]

    Примеры:
    >>> extract_code_block('text```code```')
    'code'

    >>> extract_code_block('```code```text')
    'code'

    >>> extract_code_block('no code block')
    ''
    """
    ...
```

### `repeat_on_error`

```python
def repeat_on_error(retries: int, exceptions: list):
    """
    Декоратор, который повторяет вызов указанной функции, если возникает исключение из числа указанных,
    до указанного количества повторных попыток. Если количество повторных попыток превышено,
    исключение поднимается. Если исключение не возникает, функция возвращается нормально.

    Args:
        retries (int): Количество попыток повтора.
        exceptions (list): Список классов исключений, которые нужно перехватывать.
    """
    ...
```

### `check_valid_fields`

```python
def check_valid_fields(obj: dict, valid_fields: list) -> None:
    """
    Проверяет, являются ли поля в указанном словаре допустимыми, в соответствии со списком допустимых полей.
    Если нет, вызывает исключение ValueError.

    Args:
        obj (dict): Словарь, поля которого нужно проверить.
        valid_fields (list): Список допустимых полей.

    Raises:
        ValueError: Если в словаре обнаружено недопустимое поле.

    Как работает функция:
    1. Перебирает все ключи в словаре `obj`.
    2. Для каждого ключа проверяет, присутствует ли он в списке `valid_fields`.
    3. Если ключ отсутствует в списке допустимых полей, вызывается исключение `ValueError` с сообщением об ошибке.

    ASCII flowchart:
    A [Перебор ключей в словаре]
    ↓
    B [Проверка наличия ключа в списке допустимых полей]
    |
    ├── C [Вызов ValueError (недопустимое поле)]
    │   ↓
    └── D [Продолжение перебора]

    Примеры:
    >>> check_valid_fields({'a': 1, 'b': 2}, ['a', 'b'])  # No error

    >>> check_valid_fields({'a': 1, 'b': 2}, ['a'])
    ValueError: Invalid key b in dictionary. Valid keys are: ['a']
    """
    ...
```

### `sanitize_raw_string`

```python
def sanitize_raw_string(value: str) -> str:
    """
    Очищает указанную строку путем:
      - удаления любых недопустимых символов.
      - обеспечения того, чтобы она не была длиннее максимальной длины строки Python.

    Это сделано в целях предосторожности для безопасности, чтобы избежать любых потенциальных проблем со строкой.

    Args:
        value (str): Строка, которую нужно очистить.

    Returns:
        str: Очищенная строка.

    Как работает функция:
    1. Кодирует строку в UTF-8, игнорируя недопустимые символы, и декодирует обратно в UTF-8.
    2. Обрезает строку до максимальной длины строки Python.
    3. Возвращает очищенную строку.

    ASCII flowchart:
    A [Кодирование в UTF-8 с игнорированием ошибок]
    ↓
    B [Декодирование из UTF-8]
    ↓
    C [Обрезание до максимальной длины]
    ↓
    D [Возврат очищенной строки]

    Примеры:
    >>> sanitize_raw_string('invalid\x00string')
    'invalidstring'

    >>> sanitize_raw_string('long string' * 100000)  # Truncates if too long
    'long stringlong string...'
    """
    ...
```

### `sanitize_dict`

```python
def sanitize_dict(value: dict) -> dict:
    """
    Очищает указанный словарь путем:
      - удаления любых недопустимых символов.
      - обеспечения того, чтобы словарь не был слишком глубоко вложенным.

    Args:
        value (dict): Словарь, который нужно очистить.

    Returns:
        dict: Очищенный словарь.

    Как работает функция:
    1. Преобразует словарь в JSON строку, отключая экранирование ASCII символов.
    2. Очищает полученную JSON строку с помощью `sanitize_raw_string`.
    3. Преобразует очищенную JSON строку обратно в словарь.
    4. Возвращает очищенный словарь.

    ASCII flowchart:
    A [Преобразование словаря в JSON строку]
    ↓
    B [Очистка JSON строки]
    ↓
    C [Преобразование JSON строки обратно в словарь]
    ↓
    D [Возврат очищенного словаря]

    Примеры:
    >>> sanitize_dict({'key': 'invalid\x00string'})
    {'key': 'invalidstring'}

    >>> sanitize_dict({'key': {'nested': 'value'}})
    {'key': {'nested': 'value'}}
    """
    ...
```

### `add_rai_template_variables_if_enabled`

```python
def add_rai_template_variables_if_enabled(template_variables: dict) -> dict:
    """
    Добавляет переменные шаблона RAI в указанный словарь, если включены дисклеймеры RAI.
    Они могут быть настроены в файле config.ini. Если включены, переменные будут загружать дисклеймеры RAI из
    соответствующих файлов в каталоге prompts. В противном случае переменные будут установлены в None.

    Args:
        template_variables (dict): Словарь переменных шаблона, в который нужно добавить переменные RAI.

    Returns:
        dict: Обновленный словарь переменных шаблона.

    Как работает функция:
    1. Импортирует модуль `config` для избежания циклического импорта.
    2. Считывает значения `RAI_HARMFUL_CONTENT_PREVENTION` и `RAI_COPYRIGHT_INFRINGEMENT_PREVENTION` из конфигурационного файла.
    3. Открывает файлы с содержимым дисклеймеров RAI.
    4. Добавляет переменные `rai_harmful_content_prevention` и `rai_copyright_infringement_prevention` в словарь `template_variables`,
       устанавливая их в содержимое файлов, если соответствующие настройки включены, или в `None` в противном случае.
    5. Возвращает обновленный словарь `template_variables`.

    ASCII flowchart:
    A [Импорт модуля config]
    ↓
    B [Чтение настроек RAI из конфига]
    ↓
    C [Открытие файлов с дисклеймерами RAI]
    ↓
    D [Добавление переменных RAI в словарь]
    ↓
    E [Возврат обновленного словаря]

    Примеры:
    >>> add_rai_template_variables_if_enabled({})
    {'rai_harmful_content_prevention': '...', 'rai_copyright_infringement_prevention': '...'}

    >>> add_rai_template_variables_if_enabled({'existing_variable': 'value'})
    {'existing_variable': 'value', 'rai_harmful_content_prevention': '...', 'rai_copyright_infringement_prevention': '...'}
    """
    ...
```

### `inject_html_css_style_prefix`

```python
def inject_html_css_style_prefix(html, style_prefix_attributes):
    """
    Вставляет префикс стиля ко всем атрибутам style в данной HTML строке.

    Args:
        html (str): HTML строка, в которую нужно вставить префикс стиля.
        style_prefix_attributes (str): Префикс стиля, который нужно вставить.

    Returns:
        str: HTML строка с вставленным префиксом стиля.

    Как работает функция:
    1. Заменяет все вхождения 'style="' на 'style="{style_prefix_attributes};' в HTML строке.
    2. Возвращает измененную HTML строку.

    ASCII flowchart:
    A [Замена 'style="' на 'style="{style_prefix_attributes};']
    ↓
    B [Возврат измененной HTML строки]

    Примеры:
    >>> inject_html_css_style_prefix('<div style="color: red;">Hello</div>', 'font-size: 20px;')
    '<div style="font-size: 20px;;color: red;">Hello</div>'
    """
    ...
```

### `break_text_at_length`

```python
def break_text_at_length(text: Union[str, dict], max_length: int = None) -> str:
    """
    Разбивает текст (или JSON) на указанной длине, вставляя строку "(...)" в точке разрыва.
    Если максимальная длина равна `None`, содержимое возвращается как есть.

    Args:
        text (Union[str, dict]): Текст или JSON, который нужно разбить.
        max_length (int, optional): Максимальная длина текста. По умолчанию `None`.

    Returns:
        str: Разбитый текст или JSON.

    Как работает функция:
    1. Проверяет, является ли входной текст словарем. Если да, преобразует его в JSON строку с отступами.
    2. Если `max_length` равен `None` или длина текста меньше или равна `max_length`, возвращает текст как есть.
    3. Иначе обрезает текст до `max_length` и добавляет "(...)" в конце.
    4. Возвращает полученный текст.

    ASCII flowchart:
    A [Проверка типа текста (словарь?)]
    |
    ├── B [Преобразование в JSON строку]
    │   ↓
    └── C [Проверка max_length]
        |
        ├── D [Возврат текста как есть]
        │   ↓
        └── E [Обрезание текста и добавление "(...)"]
            ↓
            F [Возврат обрезанного текста]

    Примеры:
    >>> break_text_at_length('long text', 5)
    'long ...'

    >>> break_text_at_length('short text', 20)
    'short text'

    >>> break_text_at_length({'key': 'value'}, 10)
    '{\n    "ke (...)'
    """
    ...
```

### `pretty_datetime`

```python
def pretty_datetime(dt: datetime) -> str:
    """
    Возвращает красивое строковое представление указанного объекта datetime.

    Args:
        dt (datetime): Объект datetime, который нужно отформатировать.

    Returns:
        str: Строковое представление datetime объекта в формате "YYYY-MM-DD HH:MM".

    Как работает функция:
    1. Форматирует объект `datetime` в строку с использованием формата "%Y-%m-%d %H:%M".
    2. Возвращает отформатированную строку.

    ASCII flowchart:
    A [Форматирование datetime объекта]
    ↓
    B [Возврат отформатированной строки]

    Примеры:
    >>> import datetime
    >>> dt = datetime.datetime(2024, 1, 1, 12, 30)
    >>> pretty_datetime(dt)
    '2024-01-01 12:30'
    """
    ...
```

### `dedent`

```python
def dedent(text: str) -> str:
    """
    Удаляет отступы из указанного текста, удаляя любые начальные пробелы и отступы.

    Args:
        text (str): Текст, из которого нужно удалить отступы.

    Returns:
        str: Текст без отступов.

    Как работает функция:
    1. Удаляет общие начальные пробелы из каждой строки текста с помощью `textwrap.dedent`.
    2. Удаляет начальные и конечные пробельные символы из текста с помощью `strip`.
    3. Возвращает обработанный текст.

    ASCII flowchart:
    A [Удаление отступов с помощью textwrap.dedent]
    ↓
    B [Удаление начальных и конечных пробелов]
    ↓
    C [Возврат текста без отступов]

    Примеры:
    >>> dedent('  hello\\n  world')
    'hello\\nworld'

    >>> dedent('   hello')
    'hello'
    """
    ...
```

### `read_config_file`

```python
def read_config_file(use_cache: bool = True, verbose: bool = True) -> configparser.ConfigParser:
    """
    Читает конфигурационный файл.

    Args:
        use_cache (bool, optional): Использовать ли кэшированную конфигурацию, если она есть. По умолчанию `True`.
        verbose (bool, optional): Выводить ли отладочные сообщения. По умолчанию `True`.

    Returns:
        configparser.ConfigParser: Объект конфигурации.

    Raises:
        ValueError: Если не удается найти конфигурационный файл.

    Как работает функция:
    1. Проверяет, нужно ли использовать кэшированную конфигурацию и существует ли она. Если да, возвращает кэшированную конфигурацию.
    2. Иначе создает новый объект `configparser.ConfigParser`.
    3. Определяет путь к конфигурационному файлу по умолчанию в директории модуля.
    4. Пытается прочитать конфигурационный файл по умолчанию. Если файл не найден, вызывает исключение `ValueError`.
    5. Определяет путь к пользовательскому конфигурационному файлу в текущей рабочей директории.
    6. Если пользовательский конфигурационный файл найден, считывает его и перезаписывает значения по умолчанию.
    7. Возвращает объект конфигурации.

    ASCII flowchart:
    A [Проверка использования кэша и наличия конфигурации]
    |
    ├── B [Возврат кэшированной конфигурации]
    │   ↓
    └── C [Создание объекта ConfigParser]
        ↓
        D [Определение пути к файлу конфигурации по умолчанию]
        ↓
        E [Чтение файла конфигурации по умолчанию]
        |
        ├── F [Вызов ValueError (файл не найден)]
        │   ↓
        └── G [Определение пути к пользовательскому файлу конфигурации]
            ↓
            H [Чтение пользовательского файла конфигурации (перезапись значений)]
            ↓
            I [Возврат объекта конфигурации]

    Примеры:
    >>> config = read_config_file()
    >>> type(config)
    <class 'configparser.ConfigParser'>
    """
    ...
```

### `pretty_print_config`

```python
def pretty_print_config(config: configparser.ConfigParser) -> None:
    """
    Выводит текущую конфигурацию TinyTroupe в удобочитаемом формате.

    Args:
        config (configparser.ConfigParser): Объект конфигурации.

    Как работает функция:
    1. Выводит заголовок "Current TinyTroupe configuration".
    2. Перебирает все секции в конфигурации.
    3. Для каждой секции выводит ее имя в квадратных скобках.
    4. Перебирает все элементы в секции и выводит их в формате "ключ = значение".

    ASCII flowchart:
    A [Вывод заголовка]
    ↓
    B [Перебор секций в конфигурации]
    ↓
    C [Вывод имени секции]
    ↓
    D [Перебор элементов в секции]
    ↓
    E [Вывод элемента в формате "ключ = значение"]

    Примеры:
    >>> import configparser
    >>> config = configparser.ConfigParser()
    >>> config['Section1'] = {'key1': 'value1', 'key2': 'value2'}
    >>> pretty_print_config(config)
    =================================
    Current TinyTroupe configuration 
    =================================
    [Section1]
    key1 = value1
    key2 = value2
    """
    ...
```

### `start_logger`

```python
def start_logger(config: configparser.ConfigParser) -> None:
    """
    Инициализирует логгер для TinyTroupe.

    Args:
        config (configparser.ConfigParser): Объект конфигурации.

    Как работает функция:
    1. Получает уровень логирования из конфигурации.
    2. Создает логгер с именем "tinytroupe".
    3. Создает обработчик консоли и устанавливает уровень логирования.
    4. Создает форматтер логирования.
    5. Добавляет форматтер к обработчику консоли.
    6. Добавляет обработчик консоли к логгеру.

    ASCII flowchart:
    A [Получение уровня логирования из конфигурации]
    ↓
    B [Создание логгера]
    ↓
    C [Создание обработчика консоли]
    ↓
    D [Создание форматтера]
    ↓
    E [Добавление форматтера к обработчику]
    ↓
    F [Добавление обработчика к логгеру]

    Примеры:
    >>> import configparser
    >>> config = configparser.ConfigParser()
    >>> config['Logging'] = {'LOGLEVEL': 'DEBUG'}
    >>> start_logger(config)
    """
    ...
```

## Классы

### `JsonSerializableRegistry`

```python
class JsonSerializableRegistry:
    """
    Миксин-класс, который предоставляет JSON сериализацию, десериализацию и регистрацию подклассов.

    Attributes:
        class_mapping (dict): Словарь, сопоставляющий имена классов с классами.
    """

    class_mapping = {}

    def to_json(self, include: list = None, suppress: list = None, file_path: str = None) -> dict:
        """
        Возвращает JSON представление объекта.

        Args:
            include (list, optional): Атрибуты для включения в сериализацию.
            suppress (list, optional): Атрибуты для исключения из сериализации.
            file_path (str, optional): Путь к файлу, куда будет записан JSON.
        """
        ...

    @classmethod
    def from_json(cls, json_dict_or_path, suppress: list = None, post_init_params: dict = None):
        """
        Загружает JSON представление объекта и создает экземпляр класса.

        Args:
            json_dict_or_path (dict or str): JSON словарь, представляющий объект, или путь к файлу для загрузки JSON.
            suppress (list, optional): Атрибуты, которые нужно исключить из загрузки.

        Returns:
            An instance of the class populated with the data from json_dict_or_path.
        """
        ...

    def __init_subclass__(cls, **kwargs):
        """
        Регистрирует подкласс в `class_mapping` и автоматически расширяет атрибуты `serializable_attributes` и `custom_serialization_initializers` из базовых классов.
        """
        ...

    def _post_deserialization_init(self, **kwargs):
        """
        Вызывает метод `_post_init`, если он существует, после десериализации.
        """
        ...
```

## Другие функции

### `post_init`

```python
def post_init(cls):
    """
    Декоратор для принудительного вызова метода post-initialization в классе, если он есть.
    Метод должен называться `_post_init`.
    """
    ...
```

### `name_or_empty`

```python
def name_or_empty(named_entity: AgentOrWorld):
    """
    Возвращает имя указанного агента или среды или пустую строку, если агент равен None.
    """
    ...
```

### `custom_hash`

```python
def custom_hash(obj):
    """
    Возвращает хеш для указанного объекта. Объект сначала преобразуется
    в строку, чтобы сделать его хешируемым. Этот метод является детерминированным,
    в отличие от встроенной функции hash().
    """
    ...
```

### `fresh_id`

```python
def fresh_id():
    """
    Возвращает новый ID для нового объекта. Это полезно для создания уникальных ID для объектов.
    """
    ...