"""
LIFE 2:
=================
Сложность: 5
-----------------
Игра "Жизнь 2" - это упрощенная версия клеточного автомата "Игра Жизнь" Конвея.  В этой версии игрок задает начальное состояние двумерного поля, а затем наблюдает за развитием этого поля в течение нескольких поколений.  Игра демонстрирует простые правила, которые приводят к сложным и непредсказуемым шаблонам.  Целью игры является наблюдение и изучение этих паттернов, а не достижение определенной цели.
Правила игры:
1.  Игровое поле представляет собой двумерную сетку.
2.  Каждая клетка в сетке может находиться в одном из двух состояний: "жива" или "мертва".
3.  Начальное состояние поля задается игроком (в книге оно случайно).
4.  Состояние клетки в следующем поколении определяется по следующим правилам:
    -   Если клетка жива и у нее 2 или 3 живых соседа, она остается жива в следующем поколении.
    -   Если клетка мертва и у нее ровно 3 живых соседа, она оживает в следующем поколении.
    -   В остальных случаях клетка умирает или остается мертвой.
5.  Игра продолжается заданное количество поколений.
-----------------
Алгоритм:
1. Задать размер игрового поля (N = 20).
2. Создать двумерный массив (поле) размером NxN и заполнить его случайными значениями (0 или 1), где 1 - живая клетка, 0 - мертвая.
3. Вывести на экран текущее состояние поля.
4. Начать цикл от 1 до 20 (количество поколений):
    4.1  Создать новый пустой массив (next_field) того же размера.
    4.2  Для каждой клетки поля:
        4.2.1  Посчитать количество живых соседей вокруг текущей клетки.
        4.2.2  Применить правила игры и определить состояние клетки в следующем поколении.
            -  Если клетка жива (поле[i][j] = 1) и имеет 2 или 3 живых соседа, то next_field[i][j] = 1.
            -  Если клетка мертва (поле[i][j] = 0) и имеет 3 живых соседа, то next_field[i][j] = 1.
            -  В противном случае next_field[i][j] = 0.
    4.3  Обновить текущее поле, присвоив ему значения из next_field.
    4.4  Вывести на экран обновленное состояние поля.
5. Конец игры.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeField["<p align='left'>Инициализация поля:
    <code><b>
    fieldSize = 20
    field = random(fieldSize x fieldSize) (0 или 1)
    </b></code></p>"]
    InitializeField --> OutputField["Вывод поля"]
    OutputField --> GenerationLoopStart{"Начало цикла поколений: for generation in range(20)"}
    GenerationLoopStart -- Да --> CreateNextField["<p align='left'>Создание нового поля:
    <code><b>
    nextField = new fieldSize x fieldSize array
    </b></code></p>"]
    CreateNextField --> CellLoopStart{"Начало цикла по клеткам: for i in range(fieldSize) <br> for j in range(fieldSize)"}
    CellLoopStart --> CountNeighbors["<p align='left'>Подсчет живых соседей:
    <code><b>
    neighbors = count_living_neighbors(field, i, j)
    </b></code></p>"]
    CountNeighbors --> ApplyRules{"<p align='left'>Применение правил:
    <code><b>
    if field[i][j] == 1 and (neighbors == 2 or neighbors == 3): <br>
        nextField[i][j] = 1<br>
    else if field[i][j] == 0 and neighbors == 3:<br>
        nextField[i][j] = 1 <br>
    else:<br>
        nextField[i][j] = 0 <br>
    </b></code></p>"}
    ApplyRules --> CellLoopEnd{"Конец цикла по клеткам"}
    CellLoopEnd -- Да --> CellLoopStart
    CellLoopEnd -- Нет --> UpdateField["<p align='left'>Обновление поля:
    <code><b>
    field = nextField
    </b></code></p>"]
     UpdateField --> OutputFieldUpdated["Вывод обновленного поля"]
    OutputFieldUpdated --> GenerationLoopEnd{"Конец цикла поколений"}
     GenerationLoopEnd -- Да -->  GenerationLoopStart
    GenerationLoopEnd -- Нет --> End["Конец"]
```
Legenda:
    Start - Начало программы.
    InitializeField - Инициализация игрового поля: устанавливается размер поля fieldSize = 20, и создается двумерный массив field, заполненный случайными 0 и 1.
    OutputField - Вывод на экран текущего состояния игрового поля.
    GenerationLoopStart - Начало цикла, который выполняется 20 раз (количество поколений).
    CreateNextField - Создание нового пустого двумерного массива nextField для хранения состояния клеток в следующем поколении.
    CellLoopStart - Начало вложенного цикла, проходящего по всем клеткам текущего поля.
    CountNeighbors - Подсчет количества живых соседних клеток для текущей клетки field[i][j].
    ApplyRules - Применение правил игры для определения состояния клетки nextField[i][j] в следующем поколении.
    CellLoopEnd - Конец вложенного цикла, проходящего по всем клеткам текущего поля.
    UpdateField - Обновление текущего поля field данными из nextField.
    OutputFieldUpdated - Вывод на экран обновленного состояния игрового поля.
    GenerationLoopEnd - Конец цикла, проходящего по всем поколениям.
    End - Конец программы.
"""
__author__ = 'hypo69 (hypo69@davidka.net)'

import random
import time

def count_living_neighbors(field, row, col, field_size):
    """
    Считает количество живых соседей для клетки в заданных координатах.

    Args:
        field (list of lists): Двумерный массив, представляющий игровое поле.
        row (int): Индекс строки клетки.
        col (int): Индекс столбца клетки.
        field_size (int): Размер поля.

    Returns:
        int: Количество живых соседей у клетки.
    """
    neighbors = 0
    for i in range(max(0, row - 1), min(field_size, row + 2)):
        for j in range(max(0, col - 1), min(field_size, col + 2)):
            if (i, j) != (row, col): # Исключаем саму клетку из подсчета
                neighbors += field[i][j]
    return neighbors

def print_field(field):
    """Выводит на экран текущее состояние игрового поля."""
    for row in field:
        print(''.join(['*' if cell else '.' for cell in row]))
    print("-" * 20)

def life_game(field_size=20, generations=20):
    """
    Запускает игру "Жизнь" с заданными параметрами.

    Args:
        field_size (int, optional): Размер игрового поля (по умолчанию 20).
        generations (int, optional): Количество поколений для симуляции (по умолчанию 20).
    """
    # Создаем игровое поле и заполняем его случайными значениями (0 или 1)
    field = [[random.randint(0, 1) for _ in range(field_size)] for _ in range(field_size)]

    # Выводим начальное состояние поля
    print("Начальное состояние:")
    print_field(field)
    time.sleep(1)

    # Основной цикл симуляции
    for generation in range(1, generations + 1):
        print(f"Поколение {generation}:")
        next_field = [[0 for _ in range(field_size)] for _ in range(field_size)] #создаем новое поле

        # Проходим по каждой клетке и применяем правила игры
        for i in range(field_size):
            for j in range(field_size):
                neighbors = count_living_neighbors(field, i, j, field_size)
                # Правила игры:
                # 1. Живая клетка с 2 или 3 живыми соседями остается живой
                # 2. Мертвая клетка с 3 живыми соседями оживает
                if (field[i][j] == 1 and (neighbors == 2 or neighbors == 3)) or (field[i][j] == 0 and neighbors == 3):
                     next_field[i][j] = 1

        field = next_field # Обновляем поле новым поколением
        print_field(field)
        time.sleep(1)


if __name__ == "__main__":
    life_game()

"""
Пояснения:
1.  **Импорт модулей**:
    -  `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел.
    - `import time`: Импортирует модуль time, чтобы можно было приостанавливать выполнение программы (для визуализации)
2.  **Функция `count_living_neighbors(field, row, col, field_size)`**:
    -   Принимает на вход текущее игровое поле `field`, координаты клетки (`row`, `col`) и размер поля `field_size`.
    -   Инициализирует счетчик живых соседей `neighbors` нулем.
    -   Проходит циклом по всем соседним клеткам, включая диагональные.
    -  Проверяет, что текущая соседняя клетка не является самой клеткой.
    -  Если клетка жива (значение равно 1), увеличивает счетчик `neighbors` на 1.
    -  Возвращает общее количество живых соседей.
3.  **Функция `print_field(field)`**:
    -   Принимает на вход текущее игровое поле `field`.
    -   Проходит циклом по всем строкам поля.
    -  Выводит каждую строку, заменяя 1 на символ `*`, а 0 на символ `.`.
4.  **Функция `life_game(field_size=20, generations=20)`**:
    -   Принимает на вход размер поля `field_size` (по умолчанию 20) и количество поколений `generations` (по умолчанию 20).
    -   Создает начальное поле `field` размером `field_size x field_size`, заполненное случайными значениями 0 или 1.
    -  Выводит начальное состояние поля.
    -  Запускает основной цикл симуляции `for generation in range(1, generations + 1)`:
         -  Выводит номер текущего поколения.
         -  Создает новое пустое поле `next_field`.
         -  Проходит циклом по всем клеткам текущего поля `field`.
             -  Вызывает функцию `count_living_neighbors` для подсчета живых соседей.
             -  Применяет правила игры "Жизнь":
                 -  Если клетка жива и имеет 2 или 3 живых соседа, она остается живой в новом поколении.
                 -  Если клетка мертва и имеет ровно 3 живых соседа, она оживает в новом поколении.
                 -  В противном случае клетка умирает или остается мертвой.
         -  Обновляет текущее поле `field` новым поколением `next_field`.
         -  Выводит обновленное состояние поля.
         -  `time.sleep(1)` - Задержка в 1 секунду для наглядности.
5.  **Запуск игры**:
    -   `if __name__ == "__main__":`: Этот блок гарантирует, что функция `life_game()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `life_game()`: Вызывает функцию для начала игры.
"""
