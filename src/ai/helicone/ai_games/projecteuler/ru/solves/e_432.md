## Ответ на Задачу No 432: Совершенные тотетные числа

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Необходимо определить, что такое совершенное тотетное число. Это число, сумма последовательных значений тотиентной функции Эйлера которого равна самому числу.
*   Нужно реализовать вычисление тотиентной функции Эйлера φ(n).
*   Необходимо реализовать функцию s(n) для вычисления суммы φ(n) + φ(φ(n)) + ... до тех пор, пока φ не станет равно 1.
*   Необходимо определить все совершенные тотетные числа в заданном диапазоне и просуммировать их.
*   Необходимо оптимизировать вычисления, так как n = 10^8, а значит, наивный перебор может занять много времени.

**Решение:**
1.  **Функция Эйлера (φ(n)):**
    *   Реализуем функцию `phi(n)`, которая вычисляет тотиентную функцию Эйлера для заданного числа n.  Можно использовать формулу с разложением на простые множители `phi(n) = n * (1 - 1/p1) * (1 - 1/p2) * ...`, где `p1`, `p2` - простые делители числа `n`.
2.  **Функция s(n):**
    *   Реализуем функцию `s(n)`, которая последовательно применяет функцию Эйлера к числу n, пока результат не станет равным 1, и возвращает сумму всех полученных значений.
3.  **Проверка на совершенство и суммирование:**
    *   Создаем цикл от 1 до n.
    *   В цикле для каждого числа проверяем, является ли оно совершенным тотетным, вызывая `s(n)`.
    *   Если является, прибавляем его к общей сумме.
4.  **Оптимизации:**
    *   Для ускорения вычислений можно использовать мемоизацию для функции `phi`.
    *   Можно заранее вычислить все тотиентные числа до некоторого значения, которое может быть максимальным значением в вычислениях `s(n)`.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать переменную `total_sum` со значением 0.
3.  Создать функцию `phi(n)` для вычисления тотиентной функции Эйлера.
4.  Создать функцию `s(n)` для вычисления суммы тотиентных значений до 1.
5.  Для каждого числа `i` от 1 до `limit`:
    *   Вычислить `s_value = s(i)`
    *   Если `s_value` равно `i`
        *   Прибавить `i` к `total_sum`.
6.  Вернуть `total_sum`.
7.  Конец.

### 3. Реализация на Python 3.12
```python
import math

def phi(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 1:
        return 1
    result = n
    p = 2
    while p * p <= n:
        if n % p == 0:
            while n % p == 0:
                n //= p
            result -= result // p
        p += 1
    if n > 1:
        result -= result // n
    memo[n] = result
    return result

def s(n, memo={}):
    if n in memo:
        return memo[n]
    total = 0
    current = n
    while current != 1:
        total += phi(current)
        current = phi(current)
    total += 1
    memo[n] = total
    return total


def sum_of_perfect_totient_numbers(limit):
    total_sum = 0
    for num in range(1, limit + 1):
        if s(num) == num:
            total_sum += num
    return total_sum

# Пример использования:
limit = 10**8
result = sum_of_perfect_totient_numbers(limit)
print(result)

```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeSum((Инициализировать total_sum = 0))
    InitializeSum --> DefinePhi((Определить функцию phi(n)))
    DefinePhi --> DefineS((Определить функцию s(n)))
    DefineS --> LoopStart((Начать цикл: i от 1 до limit))
    LoopStart --> ComputeSValue((Вычислить s_value = s(i)))
    ComputeSValue --> CheckPerfectTotient((Проверить: s_value == i?))
    CheckPerfectTotient -- Да --> AddToSum((Добавить i к total_sum))
    AddToSum --> LoopStart
    CheckPerfectTotient -- Нет --> LoopStart
    LoopStart --> End((Конец))
```

**Legenda:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать total_sum:** Создаем переменную для хранения результата и присваиваем ей значение 0.
* **Определить функцию phi(n):** Создание функции `phi(n)` для вычисления тотиентной функции Эйлера.
* **Определить функцию s(n):** Создание функции `s(n)` для вычисления суммы последовательных тотиентных значений.
* **Начать цикл, Конец цикла:** Определяют начало и конец цикла перебора чисел от 1 до `limit`.
* **Вычислить s_value = s(i):** Вычисляем значение функции `s(i)` для текущего числа `i`.
* **Проверить: s_value == i?:** Проверяем, является ли текущее число совершенным тотетным (то есть, `s(i)` равно `i`).
* **Добавить i к total_sum:** Если число является совершенным тотетным, то добавляем его к общей сумме.
