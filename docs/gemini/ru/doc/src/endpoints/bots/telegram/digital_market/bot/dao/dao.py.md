# Модуль для работы с DAO (Data Access Object) пользователей, покупок, категорий и продуктов
=========================================================================================

Модуль содержит классы DAO для взаимодействия с базой данных, включая модели User, Purchase, Category и Product.
Он предоставляет методы для получения статистики покупок пользователей, информации о приобретенных продуктах,
общей статистики пользователей, а также статистики по платежам.

## Оглавление
- [Обзор](#обзор)
- [Подробнее](#подробнее)
- [Классы](#классы)
    - [UserDAO](#userdao)
        - [get_purchase_statistics](#get_purchase_statistics)
        - [get_purchased_products](#get_purchased_products)
        - [get_statistics](#get_statistics)
    - [PurchaseDao](#purchasedao)
        - [get_payment_stats](#get_payment_stats)
        - [get_full_summ](#get_full_summ)
        - [get_next_id](#get_next_id)
    - [CategoryDao](#categorydao)
    - [ProductDao](#productdao)

## Обзор

Модуль предоставляет DAO (Data Access Object) для работы с моделями данных, такими как пользователи, покупки, категории и продукты.
Он включает классы для выполнения операций с базой данных, таких как получение статистики, информации о покупках и общей статистики пользователей.
Также модуль содержит методы для работы с платежами и получения информации о категориях и продуктах.

## Подробнее

Этот модуль является частью проекта `hypotez` и предназначен для упрощения взаимодействия с базой данных.
Он предоставляет удобные методы для выполнения запросов и получения необходимой информации.
Классы DAO инкапсулируют логику доступа к данным и позволяют абстрагироваться от деталей реализации базы данных.
Это облегчает разработку и поддержку приложения, а также повышает его гибкость и масштабируемость.

## Классы

### `UserDAO`

**Описание**:
DAO для работы с моделью User. Предоставляет методы для получения статистики покупок, информации о приобретенных продуктах и общей статистики пользователей.

**Наследует**:
- `BaseDAO[User]`: Базовый класс DAO, предоставляющий общие методы для работы с моделью User.

**Аттрибуты**:
- `model` (User): Модель User, с которой работает данный DAO.

**Методы**:
- `get_purchase_statistics`: Получает статистику покупок пользователя.
- `get_purchased_products`: Получает информацию о приобретенных продуктах пользователя.
- `get_statistics`: Получает общую статистику пользователей.

#### `get_purchase_statistics`

```python
@classmethod
async def get_purchase_statistics(cls, session: AsyncSession, telegram_id: int) -> Optional[Dict[str, int]]:
    """
    Получает статистику покупок пользователя.

    Args:
        session (AsyncSession): Асинхронная сессия базы данных.
        telegram_id (int): Telegram ID пользователя.

    Returns:
        Optional[Dict[str, int]]: Словарь со статистикой покупок пользователя, содержащий общее число покупок и общую сумму.
        Возвращает `None` в случае ошибки или отсутствия данных.

    Raises:
        SQLAlchemyError: При возникновении ошибки при работе с базой данных.

    Example:
        >>> session = AsyncSession()
        >>> telegram_id = 123456789
        >>> stats = await UserDAO.get_purchase_statistics(session, telegram_id)
        >>> if stats:
        ...     print(f"Общее число покупок: {stats['total_purchases']}")
        ...     print(f"Общая сумма покупок: {stats['total_amount']}")
    """
```

**Как работает функция**:

1.  **Формирование запроса**: Функция создает запрос к базе данных для получения общего числа покупок и общей суммы покупок пользователя с указанным `telegram_id`. Используется `func.count` для подсчета количества покупок (`Purchase.id`) и `func.sum` для суммирования цен покупок (`Purchase.price`). Запрос объединяет таблицы `Purchase` и `User` и фильтрует результаты по `telegram_id`.

2.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

3.  **Обработка результата**:
    *   Извлекается первая строка результата запроса (`stats`). Если результат пуст (`stats is None`), функция возвращает `None`.
    *   Если результат не пуст, извлекаются значения общего числа покупок (`total_purchases`) и общей суммы покупок (`total_amount`) из `stats`.
    *   Создается словарь `result_dict` с ключами `'total_purchases'` и `'total_amount'`, содержащий извлеченные значения. Если `total_amount` равен `None`, он заменяется на `0`.
    *   Словарь `result_dict` возвращается как результат работы функции.

4.  **Обработка ошибок**: Если в процессе выполнения запроса или обработки результатов возникает исключение `SQLAlchemyError`, функция перехватывает исключение, выводит сообщение об ошибке в консоль и возвращает `None`.

**ASII flowchart**:

```
Начало
  ↓
  Запрос к БД (общее число покупок, общая сумма) - A
  ↓
  Обработка результата - B
  │
  └──> Результат пуст? - C
      │   └──> Да: Возврат None
      │   └──> Нет: Извлечение данных из результата - D
      │        │
      │        └──> Создание словаря с результатами - E
      │             ↓
      │             Возврат словаря
  ↓
  Обработка ошибки SQLAlchemyError - F
  │
  └──> Вывод сообщения об ошибке
  ↓
  Возврат None
Конец
```

Где:

*   `A`: Формирование и выполнение запроса к базе данных для получения статистики покупок.
*   `B`: Обработка результата запроса.
*   `C`: Проверка, является ли результат запроса пустым.
*   `D`: Извлечение данных (общее число покупок и общая сумма) из результата запроса.
*   `E`: Создание словаря с результатами статистики покупок.
*   `F`: Обработка ошибок, возникающих при работе с базой данных.

**Примеры**:

```python
# Пример 1: Успешное получение статистики покупок
session = AsyncSession()
telegram_id = 123456789
stats = await UserDAO.get_purchase_statistics(session, telegram_id)
if stats:
    print(f"Общее число покупок: {stats['total_purchases']}")
    print(f"Общая сумма покупок: {stats['total_amount']}")

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
telegram_id = 123456789
try:
    stats = await UserDAO.get_purchase_statistics(session, telegram_id)
except SQLAlchemyError as ex:
    print(f"Ошибка при получении статистики покупок: {ex}")
```

#### `get_purchased_products`

```python
    @classmethod
    async def get_purchased_products(cls, session: AsyncSession, telegram_id: int) -> Optional[List[Purchase]]:
        """
        Получает информацию о приобретенных продуктах пользователя.

        Args:
            session (AsyncSession): Асинхронная сессия базы данных.
            telegram_id (int): Telegram ID пользователя.

        Returns:
            Optional[List[Purchase]]: Список покупок пользователя с информацией о продуктах.
            Возвращает `None` в случае ошибки или отсутствия данных.

        Raises:
            SQLAlchemyError: При возникновении ошибки при работе с базой данных.

        Example:
            >>> session = AsyncSession()
            >>> telegram_id = 123456789
            >>> purchases = await UserDAO.get_purchased_products(session, telegram_id)
            >>> if purchases:
            ...     for purchase in purchases:
            ...         print(f"Название продукта: {purchase.product.name}, Цена: {purchase.price}")
        """
```

**Как работает функция**:

1.  **Формирование запроса**: Функция создает запрос к базе данных для получения пользователя с указанным `telegram_id` и его покупок, включая информацию о связанных продуктах. Используется `selectinload` для жадной загрузки связанных данных (покупок и продуктов).

2.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

3.  **Обработка результата**:
    *   Извлекается пользователь из результата запроса (`user`). Если пользователь не найден (`user is None`), функция возвращает `None`.
    *   Если пользователь найден, возвращается список его покупок (`user.purchases`).

4.  **Обработка ошибок**: Если в процессе выполнения запроса или обработки результатов возникает исключение `SQLAlchemyError`, функция перехватывает исключение, выводит сообщение об ошибке в консоль и возвращает `None`.

**ASII flowchart**:

```
Начало
  ↓
  Запрос к БД (пользователь, покупки, продукты) - A
  ↓
  Обработка результата - B
  │
  └──> Пользователь не найден? - C
      │   └──> Да: Возврат None
      │   └──> Нет: Возврат списка покупок пользователя - D
  ↓
  Обработка ошибки SQLAlchemyError - E
  │
  └──> Вывод сообщения об ошибке
  ↓
  Возврат None
Конец
```

Где:

*   `A`: Формирование и выполнение запроса к базе данных для получения пользователя и его покупок.
*   `B`: Обработка результата запроса.
*   `C`: Проверка, найден ли пользователь.
*   `D`: Возврат списка покупок пользователя.
*   `E`: Обработка ошибок, возникающих при работе с базой данных.

**Примеры**:

```python
# Пример 1: Успешное получение информации о покупках пользователя
session = AsyncSession()
telegram_id = 123456789
purchases = await UserDAO.get_purchased_products(session, telegram_id)
if purchases:
    for purchase in purchases:
        print(f"Название продукта: {purchase.product.name}, Цена: {purchase.price}")

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
telegram_id = 123456789
try:
    purchases = await UserDAO.get_purchased_products(session, telegram_id)
except SQLAlchemyError as ex:
    print(f"Ошибка при получении информации о покупках: {ex}")
```

#### `get_statistics`

```python
    @classmethod
    async def get_statistics(cls, session: AsyncSession):
        """
        Получает общую статистику пользователей.

        Args:
            session (AsyncSession): Асинхронная сессия базы данных.

        Returns:
            Dict[str, int]: Словарь со статистикой пользователей, содержащий общее число пользователей,
            число новых пользователей за сегодня, за неделю и за месяц.

        Raises:
            SQLAlchemyError: При возникновении ошибки при работе с базой данных.

        Example:
            >>> session = AsyncSession()
            >>> stats = await UserDAO.get_statistics(session)
            >>> print(f"Общее число пользователей: {stats['total_users']}")
            >>> print(f"Новых пользователей сегодня: {stats['new_today']}")
            >>> print(f"Новых пользователей за неделю: {stats['new_week']}")
            >>> print(f"Новых пользователей за месяц: {stats['new_month']}")
        """
```

**Как работает функция**:

1.  **Определение текущей даты и времени**: Функция определяет текущую дату и время в UTC.

2.  **Формирование запроса**: Функция создает запрос к базе данных для получения общей статистики пользователей, включая общее число пользователей, число новых пользователей за сегодня, за неделю и за месяц. Используется `func.count` для подсчета общего числа пользователей и `func.sum` с использованием `case` для подсчета новых пользователей за определенный период времени.

3.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

4.  **Обработка результата**:
    *   Извлекается строка результата запроса (`stats`).
    *   Создается словарь `statistics` с ключами `'total_users'`, `'new_today'`, `'new_week'` и `'new_month'`, содержащий извлеченные значения.

5.  **Логирование**: Функция логирует информацию об успешно полученной статистике.

6.  **Обработка ошибок**: Если в процессе выполнения запроса или обработки результатов возникает исключение `SQLAlchemyError`, функция перехватывает исключение, логирует сообщение об ошибке и пробрасывает исключение дальше.

**ASII flowchart**:

```
Начало
  ↓
  Определение текущей даты и времени - A
  ↓
  Запрос к БД (общая статистика пользователей) - B
  ↓
  Обработка результата - C
  │
  └──> Извлечение данных из результата - D
  │   └──> Создание словаря со статистикой - E
  │        ↓
  │        Логирование статистики - F
  │        ↓
  │        Возврат словаря
  ↓
  Обработка ошибки SQLAlchemyError - G
  │
  └──> Логирование ошибки
  ↓
  Проброс исключения
Конец
```

Где:

*   `A`: Определение текущей даты и времени.
*   `B`: Формирование и выполнение запроса к базе данных для получения общей статистики пользователей.
*   `C`: Обработка результата запроса.
*   `D`: Извлечение данных (общее число пользователей, новые за сегодня, неделю, месяц) из результата запроса.
*   `E`: Создание словаря со статистикой пользователей.
*   `F`: Логирование информации об успешно полученной статистике.
*   `G`: Обработка ошибок, возникающих при работе с базой данных.

**Примеры**:

```python
# Пример 1: Успешное получение статистики пользователей
session = AsyncSession()
stats = await UserDAO.get_statistics(session)
print(f"Общее число пользователей: {stats['total_users']}")
print(f"Новых пользователей сегодня: {stats['new_today']}")
print(f"Новых пользователей за неделю: {stats['new_week']}")
print(f"Новых пользователей за месяц: {stats['new_month']}")

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
try:
    stats = await UserDAO.get_statistics(session)
except SQLAlchemyError as ex:
    logger.error(f"Ошибка при получении статистики: {ex}", exc_info=True)
```

### `PurchaseDao`

**Описание**:
DAO для работы с моделью Purchase. Предоставляет методы для получения статистики по платежам, общей суммы покупок и следующего свободного ID для новой записи.

**Наследует**:
- `BaseDAO[Purchase]`: Базовый класс DAO, предоставляющий общие методы для работы с моделью Purchase.

**Аттрибуты**:
- `model` (Purchase): Модель Purchase, с которой работает данный DAO.

**Методы**:
- `get_payment_stats`: Получает статистику по типам платежей.
- `get_full_summ`: Получает общую сумму всех покупок.
- `get_next_id`: Получает следующий свободный ID для новой записи.

#### `get_payment_stats`

```python
    @classmethod
    async def get_payment_stats(cls, session: AsyncSession) -> str:
        """
        Получает статистику по типам платежей.

        Args:
            session (AsyncSession): Асинхронная сессия базы данных.

        Returns:
            str: Форматированная строка со статистикой по типам платежей.

        Example:
            >>> session = AsyncSession()
            >>> stats = await PurchaseDao.get_payment_stats(session)
            >>> print(stats)
            💳 Юкасса: 1000.00 ₽
            🤖 Робокасса: 500.00 ₽
            ⭐ STARS: 100
            <BLANKLINE>
            Статистика актуальна на данный момент.
        """
```

**Как работает функция**:

1.  **Формирование запроса**: Функция создает запрос к базе данных для получения статистики по типам платежей. Используется `func.sum` для суммирования цен покупок (`cls.model.price`) для каждого типа платежа (`cls.model.payment_type`). Запрос группирует результаты по типу платежа.

2.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

3.  **Обработка результата**:
    *   Создается словарь `totals` для хранения результатов статистики по типам платежей (yukassa, robocassa, stars).
    *   Результаты запроса итерируются, и для каждого типа платежа и его общей суммы значение сохраняется в словаре `totals`.
    *   Форматируется строка `formatted_stats` с использованием данных из словаря `totals`.

4.  **Возврат результата**: Функция возвращает форматированную строку `formatted_stats` со статистикой по типам платежей.

**ASII flowchart**:

```
Начало
  ↓
  Запрос к БД (статистика по типам платежей) - A
  ↓
  Обработка результата - B
  │
  └──> Создание словаря для хранения результатов - C
  │   ↓
  │   Итерация по результатам запроса - D
  │   │
  │   └──> Сохранение данных в словарь - E
  │        ↓
  │        Форматирование строки с результатами - F
  │        ↓
  │        Возврат форматированной строки
  ↓
Конец
```

Где:

*   `A`: Формирование и выполнение запроса к базе данных для получения статистики по типам платежей.
*   `B`: Обработка результата запроса.
*   `C`: Создание словаря для хранения результатов статистики.
*   `D`: Итерация по результатам запроса.
*   `E`: Сохранение данных (тип платежа и общая сумма) в словарь.
*   `F`: Форматирование строки с использованием данных из словаря.

**Примеры**:

```python
# Пример 1: Успешное получение статистики по типам платежей
session = AsyncSession()
stats = await PurchaseDao.get_payment_stats(session)
print(stats)

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
try:
    stats = await PurchaseDao.get_payment_stats(session)
except SQLAlchemyError as ex:
    print(f"Ошибка при получении статистики по типам платежей: {ex}")
```

#### `get_full_summ`

```python
    @classmethod
    async def get_full_summ(cls, session: AsyncSession) -> int:
        """
        Получает общую сумму всех покупок.

        Args:
            session (AsyncSession): Асинхронная сессия базы данных.

        Returns:
            int: Общая сумма всех покупок.

        Example:
            >>> session = AsyncSession()
            >>> total_sum = await PurchaseDao.get_full_summ(session)
            >>> print(f"Общая сумма всех покупок: {total_sum}")
        """
```

**Как работает функция**:

1.  **Формирование запроса**: Функция создает запрос к базе данных для получения общей суммы всех покупок. Используется `func.sum` для суммирования цен покупок (`cls.model.price`).

2.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

3.  **Обработка результата**:
    *   Извлекается общая сумма из результата запроса (`total_price`).
    *   Если `total_price` равен `None`, он заменяется на `0`.

4.  **Возврат результата**: Функция возвращает общую сумму всех покупок.

**ASII flowchart**:

```
Начало
  ↓
  Запрос к БД (общая сумма всех покупок) - A
  ↓
  Обработка результата - B
  │
  └──> Извлечение общей суммы из результата - C
  │   ↓
  │   Если результат None, то замена на 0 - D
  │   ↓
  │   Возврат общей суммы
  ↓
Конец
```

Где:

*   `A`: Формирование и выполнение запроса к базе данных для получения общей суммы всех покупок.
*   `B`: Обработка результата запроса.
*   `C`: Извлечение общей суммы из результата запроса.
*   `D`: Замена `None` на `0`, если общая сумма равна `None`.

**Примеры**:

```python
# Пример 1: Успешное получение общей суммы всех покупок
session = AsyncSession()
total_sum = await PurchaseDao.get_full_summ(session)
print(f"Общая сумма всех покупок: {total_sum}")

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
try:
    total_sum = await PurchaseDao.get_full_summ(session)
except SQLAlchemyError as ex:
    print(f"Ошибка при получении общей суммы всех покупок: {ex}")
```

#### `get_next_id`

```python
    @classmethod
    async def get_next_id(cls, session: AsyncSession) -> int:
        """
        Возвращает следующий свободный ID для новой записи.

        Args:
            session (AsyncSession): Асинхронная сессия базы данных

        Returns:
            int: Следующий свободный ID

        Example:
            >>> session = AsyncSession()
            >>> next_id = await PurchaseDao.get_next_id(session)
            >>> print(f"Следующий свободный ID: {next_id}")
        """
```

**Как работает функция**:

1.  **Формирование запроса**: Функция создает запрос к базе данных для получения следующего свободного ID для новой записи. Используется `func.max` для получения максимального значения ID (`cls.model.id`) и `func.coalesce` для обработки случая, когда таблица пуста.

2.  **Выполнение запроса**: Сформированный запрос выполняется с использованием асинхронной сессии базы данных (`session`). Результат запроса сохраняется в переменной `result`.

3.  **Обработка результата**:
    *   Извлекается следующий свободный ID из результата запроса (`result.scalar()`).

4.  **Возврат результата**: Функция возвращает следующий свободный ID.

**ASII flowchart**:

```
Начало
  ↓
  Запрос к БД (следующий свободный ID) - A
  ↓
  Обработка результата - B
  │
  └──> Извлечение следующего ID из результата - C
  │   ↓
  │   Возврат следующего ID
  ↓
Конец
```

Где:

*   `A`: Формирование и выполнение запроса к базе данных для получения следующего свободного ID.
*   `B`: Обработка результата запроса.
*   `C`: Извлечение следующего ID из результата запроса.

**Примеры**:

```python
# Пример 1: Успешное получение следующего свободного ID
session = AsyncSession()
next_id = await PurchaseDao.get_next_id(session)
print(f"Следующий свободный ID: {next_id}")

# Пример 2: Ошибка при работе с базой данных
session = AsyncSession()
try:
    next_id = await PurchaseDao.get_next_id(session)
except SQLAlchemyError as ex:
    print(f"Ошибка при получении следующего ID: {ex}")
```

### `CategoryDao`

**Описание**:
DAO для работы с моделью Category.

**Наследует**:
- `BaseDAO[Category]`: Базовый класс DAO, предоставляющий общие методы для работы с моделью Category.

**Аттрибуты**:
- `model` (Category): Модель Category, с которой работает данный DAO.

### `ProductDao`

**Описание**:
DAO для работы с моделью Product.

**Наследует**:
- `BaseDAO[Product]`: Базовый класс DAO, предоставляющий общие методы для работы с моделью Product.

**Аттрибуты**:
- `model` (Product): Модель Product, с которой работает данный DAO.