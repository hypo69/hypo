# Анализ кода модуля `54_hurkle.ru.md`

**Качество кода**

-   **Соответствие требованиям к формату кода (1-10):** 8
    -   **Преимущества:**
        -   Текст хорошо структурирован и понятен.
        -   Разделен на логические разделы.
        -   Присутствует описание игры, пошаговая инструкция, пример работы и ограничения.
    -   **Недостатки:**
        -   Код представлен в виде инструкций, а не в виде исполняемого кода Python.
        -   Отсутствует форматирование в reStructuredText (RST).
        -   Нет docstring для функций и классов, а также нет импортов.
        -   Не используется `j_loads` или `j_loads_ns`.
        -   Не используются `logger` для логирования ошибок.

**Рекомендации по улучшению**

1.  **Формат документации:**
    -   Перевести все комментарии в формат RST, особенно для функций, классов и методов.
2.  **Обработка данных:**
    -   Использовать `j_loads` или `j_loads_ns` для загрузки данных (если это необходимо).
3.  **Структура кода:**
    -   Добавить необходимые импорты.
    -   Создать функции и классы для организации кода.
4.  **Улучшение:**
    -   Добавить docstring для всех функций и классов.
    -   Использовать `logger` для обработки ошибок.
5.  **Примеры кода:**
    -   Включить примеры кода в формате RST.
6.  **Общие замечания:**
    -   Привести все комментарии к стандарту, указанному в задании.
    -   Переписать весь код в Python с учетом указанных требований.

**Улучшенный код**

```python
"""
Модуль для реализации игры "Поиск Хёркла".
=========================================================================================

Этот модуль содержит функции для инициализации и управления игрой "Поиск Хёркла".
Игрок должен угадать местоположение скрытого объекта (Хёркла) на поле, используя подсказки.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    from src.endpoints.ai_games.101_basic_computer_games.ru.rules import hurkle

    hurkle.run_game()
"""

import random # импортируем модуль random для генерации случайных чисел
from src.logger.logger import logger # импортируем logger для логирования ошибок

def initialize_game(field_size: int = 5) -> tuple[list[list[str]], tuple[int, int]]:
    """
    Инициализирует игру: создает игровое поле и размещает на нем Хёркла.

    :param field_size: Размер игрового поля (по умолчанию 5).
    :return: Кортеж, содержащий игровое поле и координаты Хёркла.
    """
    #  функция инициализации игры, создание поля заданного размера и размещения херкла на нем
    try:
        field = [['' for _ in range(field_size)] for _ in range(field_size)] # создаем поле
        hurkle_x = random.randint(0, field_size - 1) # выбираем случайную координату x
        hurkle_y = random.randint(0, field_size - 1) # выбираем случайную координату y
        return field, (hurkle_x, hurkle_y) # возвращаем поле и координаты херкла
    except Exception as e: # обрабатываем исключения
         logger.error(f'Ошибка при инициализации игры: {e}', exc_info=True) # логируем ошибку
         return [], (-1, -1) # возвращаем пустые значения в случае ошибки

def display_field(field: list[list[str]]) -> None:
    """
    Отображает игровое поле в консоли.

    :param field: Игровое поле.
    :return: None
    """
    # функция отображения поля
    try:
        field_size = len(field)  # определяем размер поля
        header = '   ' + '  '.join([chr(65 + i) for i in range(field_size)]) # создаем заголовок
        print(header) # печатаем заголовок
        for i, row in enumerate(field): # перебираем строки поля
             print(f'{i+1} ', end='') # печатаем номер строки
             print('  '.join(row)) # печатаем строку
    except Exception as e: # обрабатываем исключения
         logger.error(f'Ошибка при отображении поля: {e}', exc_info=True) # логируем ошибку

def get_player_guess(field_size: int) -> tuple[int, int]:
    """
    Запрашивает у игрока координаты клетки и возвращает их.

    :param field_size: Размер игрового поля.
    :return: Кортеж с координатами клетки, введенными игроком.
    """
    # функция получения координаты от игрока
    while True: # запускаем цикл для получения ввода пока он не будет корректным
        try:
            guess = input('Введите вашу попытку (например, C3): ').upper()  # запрашиваем ввод координат
            if len(guess) < 2: # проверка на минимальную длину ввода
                 print('Некорректный ввод. Пожалуйста, введите букву и цифру.') # сообщение об ошибке
                 continue # перезапуск цикла

            col = ord(guess[0]) - ord('A') # получаем номер колонки
            row = int(guess[1:]) - 1  # получаем номер строки

            if 0 <= col < field_size and 0 <= row < field_size: # проверка на выход за пределы поля
                 return row, col # возвращаем координаты
            else:
                 print('Некорректный ввод. Пожалуйста, введите координаты в пределах поля.') # сообщение об ошибке
        except ValueError: # обрабатываем исключение при некорректном формате числа
            print('Некорректный ввод. Пожалуйста, введите букву и цифру.') # сообщение об ошибке
        except Exception as e: # обрабатываем исключения
             logger.error(f'Ошибка при получении ввода игрока: {e}', exc_info=True) # логируем ошибку
             return -1, -1 # возвращаем некорректные значения при ошибке

def check_guess(hurkle_coords: tuple[int, int], guess_coords: tuple[int, int]) -> str:
    """
    Проверяет близость предположения игрока к местоположению Хёркла и возвращает подсказку.

    :param hurkle_coords: Координаты Хёркла.
    :param guess_coords: Координаты предположения игрока.
    :return: Подсказку для игрока.
    """
    # функция проверки близости предположения к местоположению херкла и выдачи подсказки
    try:
        hurkle_x, hurkle_y = hurkle_coords # получаем координаты херкла
        guess_x, guess_y = guess_coords # получаем координаты игрока

        if hurkle_x == guess_x and hurkle_y == guess_y: # проверяем совпадение
             return 'Поздравляем! Вы нашли Хёркла!' # возвращаем сообщение о победе
        elif abs(hurkle_x - guess_x) <= 1 and abs(hurkle_y - guess_y) <= 1: # проверяем, что херкл рядом
             return 'Хёркл рядом!' # возвращаем подсказку
        else:
             return 'Хёркл далеко!' # возвращаем подсказку
    except Exception as e: # обрабатываем исключения
         logger.error(f'Ошибка при проверке предположения: {e}', exc_info=True) # логируем ошибку
         return 'Произошла ошибка при проверке предположения' # возвращаем сообщение об ошибке

def play_again() -> bool:
    """
    Запрашивает у игрока, хочет ли он сыграть снова.

    :return: True, если игрок хочет сыграть снова, False в противном случае.
    """
    # функция для проверки хочет ли игрок играть еще
    while True: # запускаем цикл
        try:
            answer = input('Хотите сыграть снова? (да/нет): ').lower() # запрашиваем ответ
            if answer in ['да', 'нет']: # проверка ответа на корректность
                return answer == 'да' # возвращаем результат
            else:
                print('Пожалуйста, введите "да" или "нет".') # если ответ не корректен
        except Exception as e: # обрабатываем исключения
             logger.error(f'Ошибка при запросе игры заново: {e}', exc_info=True) # логируем ошибку
             return False # возвращаем ложь при ошибке

def run_game():
    """
    Запускает основную логику игры.
    """
    #  основная функция запуска игры
    print('Добро пожаловать в игру HURKLE!') # приветствие
    print('Я спрятал объект на поле, и ваша задача — угадать его местоположение.')  # приветствие
    print('Я дам вам подсказки, и с каждым ходом вы будете ближе к цели!\n') # приветствие

    while True: # запускаем игровой цикл
        field, hurkle_coords = initialize_game() # инициализируем игру
        if not field: # если поле не было создано
             print('Не удалось запустить игру.') # сообщение об ошибке
             return # прерываем цикл
        
        display_field(field) # отображаем поле
        moves = 0 # обнуляем счетчик ходов

        while True: # цикл ходов игрока
             moves += 1  # увеличиваем счетчик ходов
             guess_coords = get_player_guess(len(field)) # получаем координаты от игрока
             if guess_coords == (-1, -1): # если произошла ошибка при получении координат
                  break # прерываем цикл
             result = check_guess(hurkle_coords, guess_coords) # проверяем координаты
             print(result) # выводим результат

             if 'Поздравляем' in result: # если игрок выиграл
                print(f'Вы нашли Хёркла за {moves} ходов!') # сообщение о победе
                break # прерываем цикл
             
        if not play_again(): # если игрок не хочет играть снова
              print('Спасибо за игру!') # сообщение о завершении
              break # прерываем цикл
```