# Анализ кода модуля life.py
 
 **Качество кода**
 
 -  **Соответствие требованиям к формату кода (1-10):**
     -  **Преимущества:**
         - Код хорошо структурирован и разбит на логические функции, что облегчает его чтение и понимание.
         - Использованы осмысленные имена переменных и функций, что делает код самодокументируемым.
         - Присутствуют docstring для каждой функции, объясняющие её назначение, параметры и возвращаемые значения.
         - Код соответствует правилам игры "Жизнь" и правильно имитирует эволюцию клеток.
         - В коде есть обработка ошибок ввода пользователя для размеров поля и количества поколений.
         - Присутствует блок-схема алгоритма и подробное описание кода, что помогает понять логику работы программы.
     -  **Недостатки:**
         -   Не используется `j_loads` или `j_loads_ns` для чтения данных, хотя в задании это требовалось (в текущем коде нет чтения данных из файлов).
         -   Нет использования `logger.error` для логирования ошибок, что могло бы улучшить отслеживание проблем.
         -   Не все блоки try-except сопровождаются подробным логированием ошибок.
         -   Не используется reStructuredText (RST) для docstring, как указано в задании.
         -   Отсутствуют импорты из `src.utils.jjson` и `src.logger.logger`.
         -   Много слов, которые надо избегать (например "получает", "делает").
 
 **Рекомендации по улучшению**
 
 1.  **Импорты:**
     - Добавить необходимые импорты для использования `j_loads` и `logger`.
     - Заменить использование `json.load` на `j_loads` или `j_loads_ns`.
 2.  **Формат docstring:**
     - Переписать все docstring в формате RST.
 3.  **Логирование:**
     - Заменить `print` для вывода ошибок на `logger.error`, чтобы обеспечить централизованное логирование.
     - Добавить более информативные сообщения об ошибках, включая подробности исключений.
 4. **Обработка исключений:**
    - Избегать общих блоков `except Exception:` и использовать более конкретные типы исключений, если это возможно.
    - Логировать все ошибки с помощью `logger.error` с подробным описанием исключения.
 5. **Удаление лишних слов:**
    - Избегать слов, которые не несут смысл (например, "выполняет", "получает").
 6. **Стиль кода:**
   - Сохранить все `#` комментарии, как они есть.
   - Добавить комментарии `#` после изменений в коде.
 
 **Улучшенный код**
 ```python
 """
 Модуль для реализации игры "Жизнь"
 ====================================
 
 Модуль содержит функции для создания и управления симуляцией клеточного автомата "Игра Жизнь",
 разработанной Джоном Конвеем. Позволяет пользователю задавать размеры игрового поля,
 количество поколений и начальную конфигурацию клеток.
 
 Функции модуля:
     - :func:`get_grid_size`: Запрашивает у пользователя размеры сетки.
     - :func:`get_generations`: Запрашивает у пользователя количество поколений.
     - :func:`get_initial_config`: Запрашивает начальную конфигурацию или генерирует случайную.
     - :func:`create_grid`: Создает сетку на основе заданных параметров.
     - :func:`print_grid`: Выводит сетку на экран.
     - :func:`count_live_neighbours`: Подсчитывает количество живых соседей.
     - :func:`apply_rules`: Применяет правила игры для определения состояния клетки.
     - :func:`next_generation`: Создает следующее поколение сетки.
     - :func:`play_game_of_life`: Основная функция, управляющая симуляцией.
 
 """
 
 import random
 import time
 from src.logger.logger import logger # Импорт logger для логирования ошибок
 # from src.utils.jjson import j_loads_ns # j_loads не используется
 
 
 def get_grid_size() -> tuple[int, int]:
     """
     Запрашивает у пользователя размеры сетки.
 
     :return: Кортеж (rows, cols) с количеством строк и столбцов.
     :rtype: tuple[int, int]
     :raises ValueError: Если введены некорректные значения.
     """
     while True:
         try:
             rows = int(input("Введите количество строк: "))
             cols = int(input("Введите количество столбцов: "))
             if rows > 0 and cols > 0:
                 return rows, cols
             else:
                 print("Пожалуйста, введите положительные значения для строк и столбцов.")
         except ValueError as e:
             logger.error(f'Некорректный ввод размера сетки: {e}') # Логирование ошибки с помощью logger.error
             print("Пожалуйста, введите целое число.")
 
 
 def get_generations() -> int:
     """
     Запрашивает у пользователя количество поколений.
 
     :return: Количество поколений.
     :rtype: int
     :raises ValueError: Если введено некорректное значение.
     """
     while True:
         try:
             generations = int(input("Введите количество поколений: "))
             if generations > 0:
                 return generations
             else:
                 print("Пожалуйста, введите положительное количество поколений.")
         except ValueError as e:
             logger.error(f'Некорректный ввод количества поколений: {e}') # Логирование ошибки с помощью logger.error
             print("Пожалуйста, введите целое число.")
 
 
 def get_initial_config(rows: int, cols: int) -> list[str]:
     """
     Запрашивает у пользователя ввод начальной конфигурации или использует случайную.
 
     :param rows: Количество строк в сетке.
     :type rows: int
     :param cols: Количество столбцов в сетке.
     :type cols: int
     :return: Список строк, представляющих начальную конфигурацию.
     :rtype: list[str]
     """
     use_random = input("Использовать случайную конфигурацию (y/n)? ").lower()
     if use_random != 'y':
         print("Введите начальную конфигурацию, используя '*' для живых клеток и ' ' для мертвых.")
         print("Введите каждую строку отдельно:")
         initial_config = []
         for _ in range(rows):
             while True:
               row_input = input()
               if len(row_input) == cols and all(cell in ['*', ' '] for cell in row_input):
                   initial_config.append(row_input)
                   break
               else:
                 print(f"Неверный ввод. Введите строку длиной {cols} символов '*' или ' '")
         return initial_config
     else:
         return  [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]
 
 
 def create_grid(rows: int, cols: int, initial_config: list[str] = None) -> list[list[str]]:
     """
     Создает сетку на основе заданных размеров и начальной конфигурации.
 
     :param rows: Количество строк в сетке.
     :type rows: int
     :param cols: Количество столбцов в сетке.
     :type cols: int
     :param initial_config: Начальная конфигурация сетки (необязательный параметр).
     :type initial_config: list[str], optional
     :return: Список списков, представляющий сетку.
     :rtype: list[list[str]]
     """
     if initial_config:
         return [list(row) for row in initial_config]
     else:
         return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]
 
 
 def print_grid(grid: list[list[str]]):
     """
     Выводит сетку на экран.
 
     :param grid: Сетка для вывода.
     :type grid: list[list[str]]
     """
     for row in grid:
         print(''.join(row))
     print("-" * len(grid[0]))
 
 
 def count_live_neighbours(grid: list[list[str]], row: int, col: int) -> int:
     """
     Подсчитывает количество живых соседей для заданной клетки.
 
     :param grid: Игровая сетка.
     :type grid: list[list[str]]
     :param row: Индекс строки клетки.
     :type row: int
     :param col: Индекс столбца клетки.
     :type col: int
     :return: Количество живых соседей.
     :rtype: int
     """
     rows = len(grid)
     cols = len(grid[0])
     count = 0
     for i in range(max(0, row - 1), min(rows, row + 2)):
         for j in range(max(0, col - 1), min(cols, col + 2)):
             if (i, j) != (row, col) and grid[i][j] == '*':
                 count += 1
     return count
 
 
 def apply_rules(grid: list[list[str]], row: int, col: int) -> str:
     """
     Применяет правила игры "Жизнь" для определения состояния клетки в следующем поколении.
 
     :param grid: Игровая сетка.
     :type grid: list[list[str]]
     :param row: Индекс строки клетки.
     :type row: int
     :param col: Индекс столбца клетки.
     :type col: int
     :return: Новое состояние клетки ('*' или ' ').
     :rtype: str
     """
     live_neighbours = count_live_neighbours(grid, row, col)
     if grid[row][col] == '*':
         if live_neighbours < 2 or live_neighbours > 3:
             return ' '  # Клетка умирает
         else:
             return '*'  # Клетка выживает
     else:
         if live_neighbours == 3:
             return '*'  # Клетка оживает
         else:
             return ' '  # Клетка остается мертвой
 
 
 def next_generation(grid: list[list[str]]) -> list[list[str]]:
     """
     Создает следующее поколение сетки.
 
     :param grid: Текущая игровая сетка.
     :type grid: list[list[str]]
     :return: Новая игровая сетка (следующее поколение).
     :rtype: list[list[str]]
     """
     rows = len(grid)
     cols = len(grid[0])
     new_grid = [[' ' for _ in range(cols)] for _ in range(rows)]
     for row in range(rows):
         for col in range(cols):
             new_grid[row][col] = apply_rules(grid, row, col)
     return new_grid
 
 
 def play_game_of_life():
   """
   Основная функция, управляющая симуляцией игры "Жизнь".
 
   """
   rows, cols = get_grid_size() # Запрос размера сетки у пользователя.
   generations = get_generations() # Запрос количества поколений у пользователя.
   initial_config = get_initial_config(rows, cols) # Запрос начальной конфигурации у пользователя
   grid = create_grid(rows, cols, initial_config) # Создание игровой сетки.
 
   for generation in range(generations):
     print(f"Поколение: {generation + 1}")
     print_grid(grid)
     grid = next_generation(grid)
     time.sleep(0.5)
 
   print("Симуляция завершена")
   print("Финальное состояние поля:")
   print_grid(grid)
   
 if __name__ == "__main__":
     play_game_of_life()
 
 """
 Объяснение кода:
 
 1.  **Импорт модулей**:
 
     -   `import random`:  Импортирует модуль `random` для генерации случайных чисел.
     -   `import time`:  Импортирует модуль `time` для добавления задержки между поколениями.
     -   `from src.logger.logger import logger`:  Импортирует модуль `logger` для логирования ошибок.
 2.  **Функция `get_grid_size()`**:
     -   Запрашивает у пользователя размеры сетки (количество строк и столбцов), проверяя корректность ввода.
     -   Возвращает кортеж `rows, cols` целых чисел.
 3.  **Функция `get_generations()`**:
     -   Запрашивает у пользователя количество поколений для симуляции, проверяя корректность ввода.
     -   Возвращает целое число `generations`.
 4.  **Функция `get_initial_config(rows, cols)`**:
     -   Запрашивает у пользователя, использовать ли случайную начальную конфигурацию или ввести свою.
     -   Если пользователь не выбирает случайную конфигурацию, запрашивает начальную конфигурацию, построчно, проверяя корректность ввода.
     -   Если пользователь выбирает случайную, возвращает случайную начальную конфигурацию.
     -   Возвращает список строк (начальная конфигурация).
 5.  **Функция `create_grid(rows, cols, initial_config=None)`**:
     -   Создает и возвращает сетку (список списков) на основе заданных размеров `rows`, `cols` и начальной конфигурации `initial_config`.
     -   Если `initial_config` предоставлена, использует её для создания сетки.
     -   Если `initial_config` не предоставлена, генерирует случайную сетку, где каждая клетка имеет 50% шанс быть живой (`'*'`) или мертвой (`' '`).
 6.  **Функция `print_grid(grid)`**:
     -   Выводит текущую сетку на экран.
     -   Каждая строка сетки выводится на отдельной строке, а также добавляется разделительная линия.
 7.  **Функция `count_live_neighbours(grid, row, col)`**:
     -   Подсчитывает количество живых соседей у клетки с координатами `row` и `col` в сетке `grid`.
     -   Соседями считаются все клетки, прилегающие к данной клетке по горизонтали, вертикали и диагонали.
     -   Возвращает целое число - количество живых соседей.
 8.  **Функция `apply_rules(grid, row, col)`**:
     - Применяет правила игры "Жизнь" для клетки с координатами `row` и `col`.
     - Возвращает `*` если клетка должна быть живой, и `' '` если клетка должна быть мертвой.
     -   Возвращает новое состояние клетки.
 9.  **Функция `next_generation(grid)`**:
     - Создает и возвращает сетку следующего поколения на основе текущей сетки.
     - Применяет функцию `apply_rules` к каждой клетке.
     -   Создает новую сетку (список списков) и применяет правила игры для определения состояния каждой клетки в следующем поколении.
 10. **Функция `play_game_of_life()`**:
     -   Основная функция, управляющая симуляцией игры "Жизнь".
     -   Вызывает функции `get_grid_size()`, `get_generations()` и `create_grid()` для инициализации игры.
     -   В цикле `for` выводит на экран текущее поколение, рассчитывает и выводит следующее поколение.
     -   После цикла `for` выводит на экран финальное состояние поля.
 11. **Запуск игры**:
     -   `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_game_of_life()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
     -   `play_game_of_life()`: Вызывает функцию для начала игры.
 """
 ```