# Модуль для работы с ассистентом программиста

## Обзор

Модуль предназначен для обучения модели машинного обучения на кодовой базе, составления документации к проекту, примеров кода и тестов. Он содержит класс `CodeAssistant`, который читает файлы кода, отправляет код в модели, обрабатывает код и сохраняет результат в директории `docs/gemini` в зависимости от роли.

## Подробней

Этот модуль является частью проекта `hypotez` и предназначен для автоматизации задач, связанных с анализом и улучшением кода. Он использует AI-модели (например, Google Gemini и OpenAI) для выполнения различных задач, таких как проверка кода, создание документации и генерация тестов. Модуль предоставляет гибкие возможности настройки ролей, языков и моделей, что позволяет адаптировать его под различные задачи и требования проекта.

## Классы

### `Config`

**Описание**: Класс, содержащий конфигурационные параметры для работы `CodeAssistant`.

**Как работает класс**:
Класс `Config` содержит параметры конфигурации, такие как базовый путь к модулю, конфигурационный файл, роль, язык и инструкции для системы. Он также определяет параметры для модели Gemini, такие как имя модели и API-ключ.

**Свойства**:
- `base_path` (Path): Базовый путь к модулю.
- `config` (SimpleNamespace): Конфигурация, загруженная из файла `code_assistant.json`.
- `role` (str): Роль для выполнения задачи (по умолчанию `doc_writer_md`).
- `lang` (str): Язык выполнения (по умолчанию `ru`).
- `system_instruction` (str): Инструкция для системы (по умолчанию пустая строка).
- `code_instruction` (str | bool): Чтение инструкции для кода.
- `gemini` (SimpleNamespace): Параметры для модели Gemini.

### `CodeAssistant`

**Описание**: Класс для работы ассистента программиста с моделями ИИ.

**Как работает класс**:
Класс `CodeAssistant` предназначен для взаимодействия с AI-моделями (Google Gemini и OpenAI) и выполнения задач обработки кода. Он позволяет инициализировать модели с заданными параметрами, отправлять файлы в модель, получать ответы и сохранять результаты. Класс поддерживает различные роли (например, `code_checker`, `doc_writer_md`) и языки, что позволяет адаптировать его под различные задачи и требования проекта.

**Методы**:
- `__init__`: Инициализация ассистента с заданными параметрами.
- `_initialize_models`: Инициализация моделей на основе заданных параметров.
- `send_file`: Отправка файла в модель.
- `process_files`: Компиляция, отправка запроса и сохранение результата.
- `_create_request`: Создание запроса с учетом роли и языка.
- `_yield_files_content`: Генерация путей файлов и их содержимого по указанным шаблонам.
- `_save_response`: Сохранение ответа модели в файл с добавлением суффикса.
- `_remove_outer_quotes`: Удаление внешних кавычек в начале и в конце строки, если они присутствуют.
- `run`: Запуск процесса обработки файлов.
- `_signal_handler`: Обработка прерывания выполнения.

#### `__init__`

```python
def __init__(
    self,
    role: Optional[str] = 'doc_writer_md',
    lang: Optional[str] = 'en',
    models_list: Optional[list[str, str] | str] = ['gemini'],
    system_instruction: Optional[str | Path] = None,
    **kwards,
) -> None:
    """
    Инициализация ассистента с заданными параметрами.

    Args:
        role (str): Роль для выполнения задачи.
        lang (str): Язык выполнения.
        models_list (list[str]): Список моделей для инициализации.
        system_instruction (str|Path): Инструкция для системы. Можно отправить текст или путь к файлу.
        **kwards: Дополнительные аргументы для инициализации моделей.
    """
    ...
```

**Назначение**: Инициализирует экземпляр класса `CodeAssistant` с заданными параметрами.

**Параметры**:
- `role` (Optional[str]): Роль для выполнения задачи. По умолчанию `doc_writer_md`.
- `lang` (Optional[str]): Язык выполнения. По умолчанию `en`.
- `models_list` (Optional[list[str, str] | str]): Список моделей для инициализации. По умолчанию `['gemini']`.
- `system_instruction` (Optional[str | Path]): Инструкция для системы. Может быть текстом или путем к файлу. По умолчанию `None`.
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Как работает функция**:

1. **Установка параметров конфигурации**: Функция устанавливает параметры `role` и `lang` в классе `Config`.
2. **Обработка инструкции для системы**:
   - Если `system_instruction` является строкой, она присваивается `Config.system_instruction`.
   - Если `system_instruction` является путем к файлу (`Path`), функция пытается прочитать содержимое файла и присвоить его `Config.system_instruction`. В случае ошибки чтения файла, регистрируется ошибка.
   - Если `system_instruction` имеет неверный формат, регистрируется ошибка.
   - Если `system_instruction` не указана, функция пытается прочитать инструкцию из файла `CODE_RULES.{lang}.MD` и присвоить ее `Config.system_instruction`.
3. **Инициализация моделей**: Вызывается метод `_initialize_models` для инициализации моделей на основе заданных параметров.

#### `_initialize_models`

```python
def _initialize_models(self, models_list: list, response_mime_type:str = 'text/plain', **kwards) -> bool:
    """
    Инициализация моделей на основе заданных параметров.

    Args:
        models_list (list[str]): Список моделей для инициализации.
        **kwards: Дополнительные аргументы для инициализации моделей.

    Returns:
        bool: Успешность инициализации моделей.

    Raises:
        Exception: Если произошла ошибка при инициализации моделей.
    """
    ...
```

**Назначение**: Инициализирует модели (например, Google Gemini) на основе заданных параметров.

**Параметры**:
- `models_list` (list[str]): Список моделей для инициализации.
- `response_mime_type` (str): MIME-тип ответа (по умолчанию `text/plain`).
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Возвращает**:
- `bool`: `True`, если инициализация моделей прошла успешно, `False` в противном случае.

**Как работает функция**:

1. **Проверка наличия 'gemini' в списке моделей**: Функция проверяет, присутствует ли строка 'gemini' в списке `models_list`.
2. **Инициализация модели Gemini**:
   - Функция пытается создать экземпляр модели `GoogleGenerativeAI` с использованием параметров из `kwards` и `Config.gemini`.
   - Фильтрует `kwards` для удаления известных аргументов, таких как `model_name`, `api_key`, `generation_config` и `system_instruction`.
   - Если инициализация прошла успешно, возвращает `True`.
   - В случае ошибки при инициализации, регистрируется ошибка и возвращается `False`.

#### `send_file`

```python
def send_file(self, file_path: Path) -> Optional[str | None]:
    """
    Отправка файла в модель.

    Args:
        file_path (Path): Абсолютный путь к файлу, который нужно отправить.
        file_name (Optional[str]): Имя файла для отправки. Если не указано и 'src' отсутствует, используется имя файла без изменений.

    Returns:
        Optional[str | None]: URL файла, если успешно отправлен, иначе None.
    """
    ...
```

**Назначение**: Отправляет файл в модель Gemini для обработки.

**Параметры**:
- `file_path` (Path): Абсолютный путь к файлу, который нужно отправить.

**Возвращает**:
- `Optional[str | None]`: URL файла, если успешно отправлен, иначе `None`.

**Как работает функция**:

1. **Отправка файла в модель**: Функция вызывает метод `upload_file` модели `gemini_model` для отправки файла.
2. **Обработка ответа**:
   - Если ответ получен и содержит атрибут `url`, функция возвращает значение этого атрибута.
   - В случае ошибки при отправке файла, регистрируется ошибка и возвращается `None`.

#### `process_files`

```python
async def process_files(
    self, start_dirs: str | Path | list[str, str] | list[Path, Path] = None, start_from_file: Optional[int] = 1
) -> bool:
    """компиляция, отправка запроса и сохранение результата."""
    ...
```

**Назначение**: Компилирует, отправляет запрос в модель Gemini и сохраняет результат.

**Параметры**:
- `start_dirs` (str | Path | list[str, str] | list[Path, Path]): Список директорий для обработки.
- `start_from_file` (Optional[int]): Номер файла, с которого начать обработку (по умолчанию 1).

**Возвращает**:
- `bool`: `True`, если обработка файлов прошла успешно, `False` в противном случае.

**Как работает функция**:

1. **Инициализация стартовых директорий**: Функция получает список стартовых директорий из аргумента `start_dirs` или из конфигурации, если `start_dirs` не указан.
2. **Итерация по директориям**: Функция итерируется по каждой директории в списке `start_dirs`.
3. **Проверка существования и типа директории**: Функция проверяет, существует ли директория и является ли она директорией. Если директория не существует или не является директорией, регистрируется ошибка и происходит переход к следующей директории.
4. **Итерация по файлам в директории**: Функция вызывает метод `_yield_files_content` для получения путей файлов и их содержимого.
5. **Обработка каждого файла**:
   - Функция проверяет, не является ли файл одним из исключенных файлов или директорий.
   - Если номер текущего файла меньше `start_from_file`, происходит переход к следующему файлу.
   - Функция создает запрос с использованием метода `_create_request`, отправляет его в модель Gemini и получает ответ.
   - Если ответ получен, функция удаляет внешние кавычки из ответа и сохраняет его с использованием метода `_save_response`.
   - В случае ошибки при получении ответа или сохранении файла, регистрируется ошибка.
6. **Задержка**: После обработки каждого файла функция выполняет задержку в 20 секунд.

#### `_create_request`

```python
def _create_request(self, file_path: str, content: str) -> str:
    """Создание запроса с учетом роли и языка."""
    ...
```

**Назначение**: Создает запрос для отправки в модель Gemini с учетом роли, языка и содержимого файла.

**Параметры**:
- `file_path` (str): Путь к файлу.
- `content` (str): Содержимое файла.

**Возвращает**:
- `str`: Запрос в виде строки.

**Как работает функция**:

1. **Создание словаря с параметрами запроса**: Функция создает словарь `content_request`, содержащий параметры запроса, такие как роль, язык, путь к файлу и содержимое файла.
   - `role`: Роль для выполнения задачи берется из `Config.role`.
   - `output_language`: Язык выполнения берется из `Config.lang`.
   - `file_location_in_project_hypotez`: Относительный путь к файлу в проекте `hypotez` получается с использованием функции `get_relative_path`.
   - `instruction`: Инструкция для модели берется из `Config.code_instruction` или остается пустой, если инструкция не указана.
   - `input_code`: Содержимое файла оборачивается в блок кода ```python.
2. **Преобразование словаря в строку**: Функция преобразует словарь `content_request` в строку с использованием `str()`.
3. **Обработка ошибок**: В случае возникновения ошибки при создании запроса, регистрируется ошибка и возвращается содержимое файла без изменений.

#### `_yield_files_content`

```python
def _yield_files_content(
    self,
    process_directory: str | Path,
) -> Iterator[tuple[Path, str]]:
    """
    Генерирует пути файлов и их содержимое по указанным шаблонам.

    Args:
        process_directory (Path | str): Абсолютный путь к стартовой директории

    Returns:
        bool: Iterator
    """
    ...
```

**Назначение**: Генерирует пути к файлам и их содержимое в указанной директории, исключая файлы и директории, соответствующие заданным шаблонам.

**Параметры**:
- `process_directory` (str | Path): Путь к директории, в которой нужно искать файлы.

**Возвращает**:
- `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортежи, содержащие путь к файлу (`Path`) и его содержимое (`str`).

**Как работает функция**:

1. **Преобразование пути к директории**: Функция преобразует путь к директории в объект `Path`, если он передан в виде строки.
2. **Компиляция шаблонов исключения файлов**: Функция компилирует шаблоны исключения файлов из конфигурации в объекты регулярных выражений.
3. **Итерация по файлам в директории**: Функция итерируется по всем файлам в директории и ее поддиректориях с использованием `rglob('*')`.
4. **Проверка на соответствие шаблонам включения**: Функция проверяет, соответствует ли имя файла хотя бы одному из шаблонов включения. Если файл не соответствует ни одному шаблону включения, он исключается из обработки.
5. **Проверка на исключенные директории**: Функция проверяет, не содержится ли какая-либо из исключенных директорий в пути к файлу. Если файл находится в исключенной директории, он исключается из обработки.
6. **Проверка на исключенные файлы по шаблону**: Функция проверяет, соответствует ли имя файла хотя бы одному из шаблонов исключения. Если файл соответствует хотя бы одному шаблону исключения, он исключается из обработки.
7. **Проверка на конкретные исключенные файлы**: Функция проверяет, не содержится ли имя файла в списке исключенных файлов. Если файл содержится в списке исключенных файлов, он исключается из обработки.
8. **Чтение содержимого файла**: Функция пытается прочитать содержимое файла с использованием кодировки `utf-8`. Если чтение файла прошло успешно, функция возвращает путь к файлу и его содержимое. В случае ошибки при чтении файла, регистрируется ошибка и возвращается `None, None`.

#### `_save_response`

```python
async def _save_response(self, file_path: Path, response: str, model_name: str) -> bool:
    """
    Сохранение ответа модели в файл с добавлением суффикса.

    Метод сохраняет ответ модели в файл, добавляя к текущему расширению файла
    дополнительный суффикс, определяемый ролью.

    Args:
        file_path (Path): Исходный путь к файлу, в который будет записан ответ.
        response (str): Ответ модели, который необходимо сохранить.
        model_name (str): Имя модели, использованной для генерации ответа.

    Raises:
        OSError: Если не удаётся создать директорию или записать в файл.
    """
    ...
```

**Назначение**: Сохраняет ответ модели в файл, добавляя суффикс в зависимости от роли.

**Параметры**:
- `file_path` (Path): Путь к исходному файлу.
- `response` (str): Ответ модели, который нужно сохранить.
- `model_name` (str): Имя модели, сгенерировавшей ответ.

**Возвращает**:
- `bool`: `True`, если файл успешно сохранен, `False` в случае ошибки.

**Как работает функция**:

1. **Определение директории вывода**: Функция определяет директорию вывода на основе роли (`Config.role`) из атрибута `output_directory` конфигурации.
2. **Формирование целевой директории**: Функция формирует путь к целевой директории, заменяя `<model>` на имя модели (`model_name`) и `<lang>` на язык (`Config.lang`).
3. **Замена части пути**: Функция заменяет часть пути к файлу на целевую директорию.
4. **Определение суффикса**: Функция определяет суффикс для добавления к имени файла на основе роли (`Config.role`).
5. **Формирование пути экспорта**: Функция формирует путь к файлу, в который будет сохранен ответ модели, добавляя суффикс к имени файла.
6. **Сохранение ответа в файл**: Функция создает директорию для файла (если она не существует) и сохраняет ответ модели в файл с использованием кодировки `utf-8`.
7. **Обработка ошибок**: В случае ошибки при создании директории или записи в файл, регистрируется ошибка и возвращается `False`.

#### `_remove_outer_quotes`

```python
def _remove_outer_quotes(self, response: str) -> str:
    """
    Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

    Args:
        response (str): Ответ модели, который необходимо обработать.

    Returns:
        str: Очищенный контент как строка.

    Example:
        >>> _remove_outer_quotes('```md some content ```')
        'some content'
        >>> _remove_outer_quotes('some content')
        'some content'
        >>> _remove_outer_quotes('```python def hello(): print("Hello") ```')
        '```python def hello(): print("Hello") ```'
    """
    ...
```

**Назначение**: Удаляет внешние кавычки в начале и конце строки, если они присутствуют.

**Параметры**:
- `response` (str): Ответ модели, который необходимо обработать.

**Возвращает**:
- `str`: Очищенный контент как строка.

**Как работает функция**:

1. **Удаление пробелов**: Функция удаляет пробелы в начале и конце строки.
2. **Проверка на наличие маркеров кода**: Если строка начинается с `\`\`\`python` или `\`\`\`mermaid`, функция возвращает строку без изменений.
3. **Удаление префиксов и суффиксов**: Функция итерируется по списку префиксов из конфигурации и проверяет, начинается ли строка с какого-либо из префиксов (без учета регистра). Если префикс найден, функция удаляет префикс и суффикс `\`\`\`` (если он есть) из строки.
4. **Возврат строки без изменений**: Если ни одно из условий не выполнено, функция возвращает строку без изменений.

#### `run`

```python
def run(self, start_from_file: int = 1) -> None:
    """Запуск процесса обработки файлов."""
    ...
```

**Назначение**: Запускает процесс обработки файлов.

**Параметры**:
- `start_from_file` (int): Номер файла, с которого начать обработку (по умолчанию 1).

**Как работает функция**:

1. **Обработка прерывания**: Функция устанавливает обработчик сигнала `SIGINT` для прерывания выполнения программы (например, при нажатии `Ctrl+C`).
2. **Запуск обработки файлов**: Функция запускает асинхронную обработку файлов с использованием метода `process_files`.

#### `_signal_handler`

```python
def _signal_handler(self, signal, frame) -> None:
    """Обработка прерывания выполнения."""
    ...
```

**Назначение**: Обрабатывает прерывание выполнения программы.

**Параметры**:
- `signal`: Номер сигнала.
- `frame`: Текущий кадр стека вызовов.

**Как работает функция**:

1. **Вывод сообщения**: Функция выводит сообщение о прерывании процесса с использованием `logger.debug`.
2. **Завершение программы**: Функция завершает выполнение программы с кодом 0.

## Функции

### `parse_args`

```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
    ...
```

**Назначение**: Разбирает аргументы командной строки.

**Возвращает**:
- `dict`: Словарь с аргументами командной строки.

**Как работает функция**:

1. **Создание парсера аргументов**: Функция создает объект `ArgumentParser` для разбора аргументов командной строки.
2. **Добавление аргументов**: Функция добавляет аргументы, такие как `role`, `lang`, `model`, `start-dirs` и `start-file-number`, с указанием их типов, значений по умолчанию и описаний.
3. **Разбор аргументов**: Функция разбирает аргументы командной строки с использованием метода `parse_args`.
4. **Возврат аргументов**: Функция возвращает аргументы в виде словаря.

### `main`

```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
    ...
```

**Назначение**: Запускает бесконечный цикл обработки файлов с динамическим обновлением конфигурации.

**Как работает функция**:

1. **Загрузка конфигурации**: Функция загружает конфигурацию из файла `code_assistant.json` с использованием `j_loads_ns`.
2. **Обработка файлов для каждой комбинации языков и ролей**:
   - Функция итерируется по каждому языку в списке `config.languages`.
   - Функция итерируется по каждой роли в списке `config.roles`.
   - Для каждой комбинации языка и роли создается экземпляр класса `CodeAssistant` с заданными параметрами.
   - Функция запускает обработку файлов с использованием метода `process_files`.
   - Конфигурация обновляется после каждой итерации для учета изменений в файле `code_assistant.json`.

## Примеры

Пример использования класса `CodeAssistant`:

```python
assistant = CodeAssistant(role='code_checker', lang='ru', model=['gemini'])
assistant.process_files()
```

Пример использования функции `parse_args`:

```python
args = parse_args()
role = args['role']
lang = args['lang']
model = args['model']
start_dirs = args['start_dirs']
start_file_number = args['start_file_number']
```