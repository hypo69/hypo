# Модуль для работы с Poe (g4f)

## Обзор

Модуль предоставляет класс `Poe`, который является поставщиком (provider) для работы с различными моделями через веб-сайт poe.com. Этот модуль использует Selenium WebDriver для взаимодействия с веб-страницей, ввода запросов и получения ответов от AI моделей.

## Подробнее

Модуль `Poe` предназначен для интеграции с библиотекой `g4f` и предоставляет возможность использовать модели, доступные на платформе Poe, такие как Llama-2, CodeLlama, GPT-3.5 и GPT-4. Для работы требуется аутентификация пользователя на сайте poe.com.

## Классы

### `Poe(AbstractProvider)`

**Описание**: Класс `Poe` реализует взаимодействие с платформой Poe для получения ответов от различных AI моделей.

**Наследует**:

- `AbstractProvider`: Абстрактный базовый класс для поставщиков, предоставляющий общую структуру и интерфейс для работы с разными AI моделями.

**Атрибуты**:

- `url` (str): URL адрес веб-сайта Poe.
- `working` (bool): Флаг, указывающий, работает ли провайдер в данный момент (в данном случае всегда `False`).
- `needs_auth` (bool): Флаг, указывающий, требуется ли аутентификация для работы с провайдером (в данном случае `True`).
- `supports_stream` (bool): Флаг, указывающий, поддерживает ли провайдер потоковую передачу данных (в данном случае `True`).
- `models` (keys): Cписок доступных моделей, которые можно использовать через данного провайдера.

**Методы**:

- `create_completion`: Метод для создания запроса к модели и получения ответа.

## Функции

### `create_completion`

```python
@classmethod
def create_completion(
    cls,
    model: str,
    messages: Messages,
    stream: bool,
    proxy: str = None,
    webdriver: WebDriver = None,
    user_data_dir: str = None,
    headless: bool = True,
    **kwargs
) -> CreateResult:
    """
    Создает запрос к модели на платформе Poe и возвращает результат.

    Args:
        model (str): Название модели для использования.
        messages (Messages): Список сообщений для отправки в модель.
        stream (bool): Флаг, указывающий, нужно ли возвращать ответ в виде потока.
        proxy (str, optional): Адрес прокси-сервера для использования. По умолчанию `None`.
        webdriver (WebDriver, optional): Инстанс WebDriver для управления браузером. По умолчанию `None`.
        user_data_dir (str, optional): Путь к каталогу пользовательских данных браузера. По умолчанию `None`.
        headless (bool, optional): Флаг, указывающий, нужно ли запускать браузер в headless-режиме. По умолчанию `True`.
        **kwargs: Дополнительные аргументы.

    Returns:
        CreateResult: Результат выполнения запроса.

    Raises:
        ValueError: Если указанная модель не поддерживается.
        RuntimeError: Если не удается найти текстовое поле для ввода запроса.

    Внутренние функции:
        Нет
    """
```

**Назначение**: Функция `create_completion` отправляет запрос к указанной модели на платформе Poe и возвращает ответ. Она использует Selenium WebDriver для автоматизации взаимодействия с веб-сайтом poe.com.

**Параметры**:

- `cls`: Ссылка на класс `Poe`.
- `model` (str): Название модели для использования (например, "gpt-3.5-turbo").
- `messages` (Messages): Список сообщений, которые необходимо отправить модели. Обычно это список словарей, где каждый словарь содержит ключи "role" (например, "user" или "assistant") и "content" (текст сообщения).
- `stream` (bool): Флаг, указывающий, следует ли возвращать ответ в режиме потоковой передачи. Если `True`, функция будет возвращать ответ частями по мере их поступления.
- `proxy` (str, optional): Строка, указывающая адрес прокси-сервера, который следует использовать для подключения к Poe.com. Если не указан, прокси-сервер не используется. По умолчанию `None`.
- `webdriver` (WebDriver, optional): Инстанс WebDriver для управления браузером. Если не указан, будет создан новый инстанс. По умолчанию `None`.
- `user_data_dir` (str, optional): Путь к каталогу пользовательских данных браузера. Используется для сохранения сессии пользователя. По умолчанию `None`.
- `headless` (bool, optional): Флаг, указывающий, следует ли запускать браузер в "headless" режиме (без графического интерфейса). По умолчанию `True`.
- `**kwargs`: Дополнительные параметры, которые могут быть переданы.

**Возвращает**:

- `CreateResult`: Генератор, который выдает части ответа модели.

**Вызывает исключения**:

- `ValueError`: Если указанная модель не поддерживается (т.е. отсутствует в словаре `models`).
- `RuntimeError`: Если не удается найти элемент `textarea` на странице, что может свидетельствовать об отсутствии авторизации пользователя.

**Как работает функция**:

1. **Подготовка**:
   - Проверяется, указана ли модель. Если нет, используется модель по умолчанию "gpt-3.5-turbo".
   - Проверяется, поддерживается ли указанная модель. Если нет, выбрасывается исключение `ValueError`.
   - Форматируется запрос из списка сообщений.
2. **Взаимодействие с веб-страницей**:
   - Создается или используется существующая сессия WebDriver для управления браузером.
   - Скрипт внедряется в каждую новую страницу для перехвата и обработки сообщений WebSocket.
   - Открывается страница Poe с выбранной моделью.
   - Ожидается появление элемента `textarea` для ввода текста.
   - Вводится запрос в `textarea` и нажимается кнопка отправки.
3. **Получение ответа**:
   - Скрипт выполняется в цикле для получения частей ответа модели.
   - Ответ возвращается в виде потока (`yield chunk`).
   - Цикл завершается, когда получен полный ответ или возникает ошибка.

**ASCII flowchart**:

```
   Начало
   ↓
   Проверка модели
   ↓
   Форматирование запроса
   ↓
   Создание сессии WebDriver
   ↓
   Внедрение скрипта перехвата сообщений
   ↓
   Открытие страницы Poe
   ↓
   Ожидание элемента textarea
   ↓
   Ввод запроса и отправка
   ↓
   Цикл получения ответа
   ├── Ответ получен? 
   │   └── Да: Выдача части ответа (chunk)
   │   └── Нет: Пауза и повтор
   └── Конец
```

**Примеры**:

```python
# Пример использования с указанием модели и сообщений
messages = [{"role": "user", "content": "Hello, how are you?"}]
result = Poe.create_completion(model="gpt-3.5-turbo", messages=messages, stream=True)
for chunk in result:
    print(chunk, end="")

# Пример использования с headless-режимом и прокси
messages = [{"role": "user", "content": "Tell me a joke."}]
result = Poe.create_completion(model="gpt-4", messages=messages, stream=True, headless=True, proxy="http://your_proxy:8080")
for chunk in result:
    print(chunk, end="")