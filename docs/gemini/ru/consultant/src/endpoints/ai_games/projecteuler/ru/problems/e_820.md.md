# Анализ кода модуля e_820.md

**Качество кода**
7
- Плюсы
    - Код содержит постановку задачи Project Euler.
    - Описаны условия задачи и приведены примеры.
- Минусы
    -  Отсутствует программный код.
    -  Текст требует форматирования под reStructuredText.
    -  Присутствуют ошибки в рассуждениях и вычислениях для `f(2)`.

**Рекомендации по улучшению**

1.  Добавить reStructuredText форматирование.
2.  Уточнить описание задачи.
3.  Добавить программный код для решения задачи.
4.  Исправить ошибки в вычислениях и рассуждениях.

**Оптимизированный код**

```markdown
Задача No 820
=========================================================================================

Конфликтная сетка
-----------------

**Условия**

Дана сетка *n* × *n*, состоящая из целых чисел. Две клетки в сетке называются **конфликтующими**, если они не совпадают и если их соответствующие числа равны.

Пусть *f(n)* будет количеством способов выбрать подмножество ячеек в сетке *n* × *n* таким образом, чтобы никакие две ячейки в выбранном подмножестве не конфликтовали. Например:

*   Если `n = 1` и единственная клетка имеет значение `1`, тогда возможны 2 варианта: либо взять эту клетку, либо не брать. Следовательно, `f(1) = 2`.
*   Если `n = 2` и сетка имеет значения
    ::

        1 2
        3 4

    то каждая клетка имеет уникальное значение, и мы можем выбрать любое подмножество ячеек. Существует 2<sup>4</sup> = 16 таких подмножеств. Следовательно, `f(2) = 16`.
*   Если `n = 2` и сетка имеет значения
    ::

        1 2
        1 2

    тогда клетки (1,1) и (2,1) конфликтуют, а также клетки (1,2) и (2,2). Мы можем выбрать не более одной клетки из каждой пары конфликтующих клеток.
    
    - Для каждой пары конфликтующих клеток есть 3 варианта выбора: не брать ни одну, взять первую или взять вторую. Поскольку есть две пары, `f(2) = 3 * 3 = 9`

Дано, что:

*   если все числа различны, `f(n) = 2^(n*n)`
*   если все числа одинаковы, `f(n) = 2*n*n - 1 + 1`  (или `f(n) = 2 * n**2 - 1 + 1`)
*   если все числа 1 или 2, `f(2) = 9`.

Найдите `f(10)` для следующей сетки:
::

    1  2  3  4  5  6  7  8  9  10
    11 12 13 14 15 16 17 18 19 20
    21 22 23 24 25 26 27 28 29 30
    31 32 33 34 35 36 37 38 39 40
    41 42 43 44 45 46 47 48 49 50
    51 52 53 54 55 56 57 58 59 60
    61 62 63 64 65 66 67 68 69 70
    71 72 73 74 75 76 77 78 79 80
    81 82 83 84 85 86 87 88 89 90
    91 92 93 94 95 96 97 98 99 100

В ответе запишите только последние 9 цифр.

.. code-block:: python

    from collections import defaultdict
    from typing import List

    def solve() -> int:
        """
        Вычисляет количество способов выбрать подмножество ячеек в сетке 10x10 без конфликтов.

        :return: Последние 9 цифр от f(10)
        """
        grid = [
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
            [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
            [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],
            [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],
            [51, 52, 53, 54, 55, 56, 57, 58, 59, 60],
            [61, 62, 63, 64, 65, 66, 67, 68, 69, 70],
            [71, 72, 73, 74, 75, 76, 77, 78, 79, 80],
            [81, 82, 83, 84, 85, 86, 87, 88, 89, 90],
            [91, 92, 93, 94, 95, 96, 97, 98, 99, 100],
        ]

        conflicts = defaultdict(list)
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                conflicts[val].append((r, c))
        
        total_ways = 1
        for val, cells in conflicts.items():
            total_ways = (total_ways * (len(cells) + 1)) % 1_000_000_000

        return total_ways

    if __name__ == "__main__":
        result = solve()
        print(result)
```