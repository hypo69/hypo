# Множества (наборы) в python

## סקירה כללית

במדעי המחשב ובמתמטיקה, קבוצות הן דרך להציג אוספים של אלמנטים ייחודיים. חשוב להבין ש:

*   **ייחודיות:** כל אלמנט בתוך קבוצה חייב להיות ייחודי. כפילויות אינן מותרות.
*   **אי סדר:** הסדר של האלמנטים בתוך קבוצה אינו חשוב.

## תוכן עניינים

*   [מבוא: מהן קבוצות?](#מבוא-מהן-קבוצות)
*   [קבוצות ופירות](#קבוצות-ופירות)
*   [מדוע קבוצות דורשות ייחודיות של אלמנטים?](#מדוע-קבוצות-דורשות-ייחודיות-של-אלמנטים)
*   [פעולות על קבוצות (סלסלות פירות):](#פעולות-על-קבוצות-סלסלות-פירות)
    *   [איחוד (Union): "אוספים את כל הפירות לתוך קבוצה אחת"](#איחוד-union-אוספים-את-כל-הפירות-לתוך-קבוצה-אחת)
    *   [חיתוך (Intersection): "מוצאים פירות משותפים"](#חיתוך-intersection-מוצאים-פירות-משותפים)
    *   [הפרש (Difference): "פירות שקיימים בקבוצה אחת אך לא בשנייה"](#הפרש-difference-פירות-שקיימים-בקבוצה-אחת-אך-לא-בשנייה)
    *   [הפרש סימטרי (Symmetric Difference): "פירות שקיימים רק באחת מהקבוצות"](#הפרש-סימטרי-symmetric-difference-פירות-שקיימים-רק-באחת-מהקבוצות)
    *   [תת-קבוצה (Subset): "האם כל הפירות מקבוצה אחת נמצאים בקבוצה השנייה?"](#תת-קבוצה-subset-האם-כל-הפירות-מקבוצה-אחת-נמצאים-בקבוצה-השנייה)
    *   [קבוצה מכילה (Superset): "האם קבוצה אחת מכילה את כל הפירות מקבוצה אחרת?"](#קבוצה-מכילה-superset-האם-קבוצה-אחת-מכילה-את-כל-הפירות-מקבוצה-אחרת)
*   [קוד לדוגמה:](#קוד-לדוגמה)
*   [משימות לתרגול:](#משימות-לתרגול)

## מבוא: מהן קבוצות?

במדעי המחשב ובמתמטיקה, קבוצות הן דרך להציג אוספים של אלמנטים ייחודיים. חשוב להבין ש:

*   **ייחודיות:** כל אלמנט בתוך קבוצה חייב להיות ייחודי. כפילויות אינן מותרות.
*   **אי סדר:** הסדר של האלמנטים בתוך קבוצה אינו חשוב.

## קבוצות ופירות

אנו נדמיין שיש לנו רק את הפירות הבאים:

*   🍎 (תפוח)
*   🍐 (אגס)
*   🍉 (אבטיח)
*   🧺 (סל)

חשוב לשים לב ש:

1.  **בתוך קבוצה *אין* פירות זהים:** אם יש תפוח בקבוצה, לא יהיה שם תפוח נוסף זהה. כל פרי הוא ייחודי בתוך הקבוצה שלו.
2.  **סדר הפירות אינו חשוב:** אם בקבוצה יש תפוח ואגס, זה זהה למצב שבו היו אגס ותפוח. הסדר אינו משנה.

לדוגמה, `{🍎, 🍐, 🍉}` היא קבוצה שבה יש תפוח, אגס ואבטיח.

## מדוע קבוצות דורשות ייחודיות של אלמנטים?

*   קבוצות נועדו לעקוב אחר *נוכחות* של אלמנטים, ולא אחר *הכמות* שלהם.
*   ייחודיות של אלמנטים מפשטת את ביצוע הפעולות על קבוצות.
*   קבוצות משמשות להסרת יתירות בנתונים.

## פעולות על קבוצות (סלסלות פירות):

1.  ### איחוד (Union): "אוספים את כל הפירות לתוך קבוצה אחת"

    *   אני מאחד שתי קבוצות פירות, אוסף את כל הפירות לקבוצה חדשה. אם יש פירות זהים בשתי הקבוצות, בקבוצה החדשה יהיה רק פרי אחד כזה.
    *   אם בקבוצה A יש {🍎, 🍐}, ובקבוצה B יש {🍐, 🍉}, אז בקבוצה A ∪ B יהיו {🍎, 🍐, 🍉}.
2.  ### חיתוך (Intersection): "מוצאים פירות משותפים"

    *   אני מחפש *רק* את הפירות שקיימים גם בקבוצה A וגם בקבוצה B.
    *   אם בקבוצה A יש {🍎, 🍐}, ובקבוצה B יש {🍐, 🍉}, אז בקבוצה A ∩ B יהיה רק {🍐}.
3.  ### הפרש (Difference): "פירות שקיימים בקבוצה אחת אך לא בשנייה"

    *   אני מחפש *רק* את הפירות שקיימים בקבוצה A, אך לא קיימים בקבוצה B.
    *   אם בקבוצה A יש {🍎, 🍐}, ובקבוצה B יש {🍐, 🍉}, אז בקבוצה A - B יהיה {🍎}, ובקבוצה B - A יהיה {🍉}.
4.  ### הפרש סימטרי (Symmetric Difference): "פירות שקיימים רק באחת מהקבוצות"

    *   אני מחפש *את כל* הפירות שקיימים או בקבוצה A, או בקבוצה B, אך לא בשתיהן בו זמנית.
    *   אם בקבוצה A יש {🍎, 🍐}, ובקבוצה B יש {🍐, 🍉}, אז בקבוצה A ^ B יהיו {🍎, 🍉}.
5.  ### תת-קבוצה (Subset): "האם כל הפירות מקבוצה אחת נמצאים בקבוצה השנייה?"

    *   אני בודק האם קבוצה A היא תת-קבוצה של קבוצה B. זה אומר שכל הפירות מקבוצה A קיימים גם בקבוצה B.
    *   **דוגמה:** אם בקבוצה A יש {🍎, 🍐}, ובקבוצה B יש {🍎, 🍐, 🍉}, אז A <= B.
6.  ### קבוצה מכילה (Superset): "האם קבוצה אחת מכילה את כל הפירות מקבוצה אחרת?"

    *   אני בודק האם קבוצה A היא קבוצה מכילה של קבוצה B. זה אומר שכל הפירות מקבוצה B קיימים גם בקבוצה A.
    *   אם בקבוצה A יש {🍎, 🍐, 🍉}, ובקבוצה B יש {🍎, 🍐}, אז A >= B.

## קוד לדוגמה:

```python
from typing import Set

def create_fruit_set(fruit_string: str) -> Set[str]:
    """
    Args:
        fruit_string (str): מחרוזת עם פירות (🍎, 🍐, 🍉, 🧺).

    Returns:
        Set[str]: קבוצה של פירות ייחודיים.

    Raises:
        ValueError: אם המחרוזת מכילה תווים שאינם 🍎, 🍐, 🍉, 🧺.
    """
    if not all(fruit in ["🍎", "🍐", "🍉", "🧺"] for fruit in fruit_string):
        raise ValueError("Строка может содержать только символы 🍎, 🍐, 🍉, 🧺")
    return set(fruit_string)  # Используем set() для создания множества

def display_set(fruit_set: Set[str]) -> str:
  """
  Args:
        fruit_set (Set[str]): קבוצה של פירות.

    Returns:
        str: מחרוזת לתצוגה.
  """
  return "{" + ", ".join(fruit_set) + "}"


# Создаем множества фруктов
fruits_set_A = create_fruit_set("🍎🍐")  # Множество A: {🍎, 🍐}
fruits_set_B = create_fruit_set("🍐🍉")  # Множество B: {🍐, 🍉}
fruits_set_C = create_fruit_set("🍎🍐🍉")  # Множество C: {🍎, 🍐, 🍉}
fruits_set_D = create_fruit_set("🧺")  # Множество D: {🧺}

# Выводим множества
print(f"Множество A: {display_set(fruits_set_A)}")
print(f"Множество B: {display_set(fruits_set_B)}")
print(f"Множество C: {display_set(fruits_set_C)}")
print(f"Множество D: {display_set(fruits_set_D)}")

# Объединение множеств (Union)
union_result = fruits_set_A | fruits_set_B
print(f"A ∪ B: {display_set(union_result)}")  # Результат: {🍎, 🍐, 🍉}

# Пересечение множеств (Intersection)
intersection_result = fruits_set_A & fruits_set_B
print(f"A ∩ B: {display_set(intersection_result)}")  # Результат: {🍐}

# Разность множеств (Difference)
difference_result_AB = fruits_set_A - fruits_set_B
print(f"A - B: {display_set(difference_result_AB)}")  # Результат: {🍎}
difference_result_BA = fruits_set_B - fruits_set_A
print(f"B - A: {display_set(difference_result_BA)}")  # Результат: {🍉}

# Симметричная разность множеств (Symmetric Difference)
symmetric_difference_result = fruits_set_A ^ fruits_set_B
print(f"A ^ B: {display_set(symmetric_difference_result)}")  # Результат: {🍎, 🍉}

# Подмножество (Subset)
subset_result1 = fruits_set_A <= fruits_set_C
print(f"A <= C: {subset_result1}")  # Результат: True (A подмножество C)
subset_result2 = fruits_set_A <= fruits_set_B
print(f"A <= B: {subset_result2}") # Результат: False (A не подмножество B)

# Надмножество (Superset)
superset_result1 = fruits_set_C >= fruits_set_A
print(f"C >= A: {superset_result1}")  # Результат: True (C надмножество A)
superset_result2 = fruits_set_B >= fruits_set_A
print(f"B >= A: {superset_result2}")  # Результат: False (B не надмножество A)

# Проверка на наличие элемента
print(f"🍎 in A: {'🍎' in fruits_set_A}")  # Результат: True
print(f"🍉 in A: {'🍉' in fruits_set_A}")  # Результат: False
```

### `create_fruit_set`
**Description**: הפונקציה יוצרת קבוצת פירות ממחרוזת.
**Parameters**:
- `fruit_string` (str): מחרוזת המכילה את הפירות (🍎, 🍐, 🍉, 🧺).

**Returns**:
- `Set[str]`: קבוצה של פירות ייחודיים.

**Raises**:
- `ValueError`: אם המחרוזת מכילה תווים שאינם 🍎, 🍐, 🍉, 🧺.

### `display_set`
**Description**: הפונקציה ממירה קבוצת פירות למחרוזת שניתן להציג.
**Parameters**:
- `fruit_set` (Set[str]): קבוצה של פירות.

**Returns**:
- `str`: מחרוזת מוכנה לתצוגה.

*   **`create_fruit_set(fruit_string)`:** פונקציה זו יוצרת קבוצה ממחרוזת פירות.
    *   `set(fruit_string)` הופכת את המחרוזת לקבוצה, מסירה כפילויות והופכת את סדר האלמנטים ללא רלוונטי.
    *   אנו בודקים שהמחרוזת מכילה רק סמלי יוניקוד מורשים.
*   **`display_set(fruit_set)`:** פונקציה זו משמשת להמרת קבוצה למחרוזת קריאה להצגה.
*   **דוגמאות:** אנו יוצרים כמה קבוצות ומיישמים עליהן פעולות שונות. התוצאות של כל פעולה מוצגות על המסך.

## משימות לתרגול:

1.  צרו קבוצות פירות משלכם ונסו עליהן את כל הפעולות.
2.  ממשו פונקציה `is_disjoint(set1, set2)`, שתבדוק אם שתי קבוצות אינן נחתכות (חיתוך = קבוצה ריקה).
3.  ממשו פונקציה `power_set(fruit_set)`, שתחזיר קבוצה של כל תתי הקבוצות של הקבוצה הנתונה.
4.  נסו ליישם קבוצות לפתרון בעיה אמיתית. לדוגמה, יש לכם שתי רשימות אורחים למסיבה, מצאו את האורחים שנמצאים בשתי הרשימות, את האורחים שנמצאים רק ברשימה הראשונה וכדומה.