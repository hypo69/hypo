# Модуль для работы с JSON (`jjson.py`)

## Обзор

Модуль `jjson.py` предоставляет набор функций для работы с данными в формате JSON. Он включает функции для загрузки JSON из файлов, строк и объектов, а также для сохранения JSON в файлы. Модуль также поддерживает работу с `SimpleNamespace` объектами, обеспечивая удобный способ доступа к данным.

## Подробней

Этот модуль предоставляет удобные инструменты для обработки JSON-данных, включая чтение, запись и преобразование. Он облегчает работу с конфигурационными файлами, данными API и другими источниками JSON-информации. Модуль также включает функции для обработки ошибок и ведения журнала, что упрощает отладку и обслуживание.

## Классы

### `Config`

**Описание**: Класс `Config` определяет константы, представляющие режимы открытия файлов для записи и добавления данных.

**Атрибуты**:
- `MODE_WRITE` (str): Режим открытия файла для записи (`"w"`).
- `MODE_APPEND_START` (str): Режим открытия файла для добавления данных в начало файла (`"a+"`).
- `MODE_APPEND_END` (str): Режим открытия файла для добавления данных в конец файла (`"+a"`).

## Функции

### `_convert_to_dict`

```python
def _convert_to_dict(value: Any) -> Any:
    """ Функция преобразует SimpleNamespace и списки в словари.
    Args:
        value (Any): Значение для преобразования.

    Returns:
        Any: Преобразованное значение в виде словаря.
    """
```

**Назначение**: Функция рекурсивно преобразует объекты `SimpleNamespace` и списки в словари. Это необходимо для совместимости с функциями, работающими с JSON, которые обычно ожидают данные в формате словарей.

**Параметры**:
- `value` (Any): Значение, которое необходимо преобразовать. Это может быть объект `SimpleNamespace`, словарь, список или любой другой тип данных.

**Возвращает**:
- `Any`: Преобразованное значение в виде словаря. Если входное значение не является объектом `SimpleNamespace` или списком, возвращается исходное значение.

**Как работает функция**:

1.  **Проверка типа**: Функция проверяет, является ли входное значение экземпляром `SimpleNamespace`, словарем или списком.
2.  **Преобразование `SimpleNamespace`**: Если `value` является экземпляром `SimpleNamespace`, функция итерируется по его атрибутам и рекурсивно преобразует каждый атрибут в словарь.
3.  **Преобразование словаря**: Если `value` является словарем, функция итерируется по его элементам и рекурсивно преобразует каждое значение в словаре.
4.  **Преобразование списка**: Если `value` является списком, функция итерируется по его элементам и рекурсивно преобразует каждый элемент в словаре.
5.  **Возврат значения**: Если `value` не является ни `SimpleNamespace`, ни словарем, ни списком, функция возвращает `value` без изменений.

```
A (Проверка типа value)
|
├─── SimpleNamespace? ─── B (Преобразование SimpleNamespace)
|   │                       │
|   └─── Да ───────────── Рекурсивное преобразование атрибутов
|
├─── Словарь? ─────────── C (Преобразование словаря)
|   │                       │
|   └─── Да ───────────── Рекурсивное преобразование значений
|
├─── Список? ──────────── D (Преобразование списка)
|   │                       │
|   └─── Да ───────────── Рекурсивное преобразование элементов
|
└─── Нет ──────────────── E (Возврат значения без изменений)
```

**Примеры**:

```python
from types import SimpleNamespace

data_ns = SimpleNamespace(name='John', age=30)
result = _convert_to_dict(data_ns)
print(result)  # Вывод: {'name': 'John', 'age': 30}

data_list = [SimpleNamespace(name='John'), SimpleNamespace(name='Jane')]
result = _convert_to_dict(data_list)
print(result)  # Вывод: [{'name': 'John'}, {'name': 'Jane'}]

data_dict = {'name': SimpleNamespace(first='John', last='Doe')}
result = _convert_to_dict(data_dict)
print(result)  # Вывод: {'name': {'first': 'John', 'last': 'Doe'}}
```

### `_read_existing_data`

```python
def _read_existing_data(path: Path, exc_info: bool = True) -> dict:
    """Считывает существующие JSON-данные из файла."""
```

**Назначение**: Функция считывает существующие JSON-данные из файла, указанного в параметре `path`. Она обрабатывает исключения, которые могут возникнуть при чтении или декодировании JSON, и возвращает пустой словарь в случае ошибки.

**Параметры**:
- `path` (Path): Путь к файлу, из которого необходимо считать JSON-данные.
- `exc_info` (bool, optional): Флаг, указывающий, нужно ли логировать исключения с трассировкой. По умолчанию `True`.

**Возвращает**:
- `dict`: Словарь, содержащий JSON-данные, считанные из файла. Если происходит ошибка при чтении или декодировании JSON, возвращается пустой словарь.

**Вызывает исключения**:
- `json.JSONDecodeError`: Если JSON-данные в файле не могут быть декодированы.
- `Exception`: Если возникает любая другая ошибка при чтении файла.

**Как работает функция**:

1.  **Чтение данных**: Функция пытается прочитать текст из файла, указанного в `path`, используя кодировку UTF-8.
2.  **Декодирование JSON**: Если чтение выполнено успешно, функция пытается декодировать JSON-данные из прочитанного текста с помощью `json.loads()`.
3.  **Обработка ошибок**: Если при декодировании JSON возникает исключение `json.JSONDecodeError`, функция логирует ошибку с помощью `logger.error()` и возвращает пустой словарь.
4.  **Обработка общих исключений**: Если возникает любое другое исключение, функция логирует ошибку и также возвращает пустой словарь.
5.  **Возврат данных**: Если чтение и декодирование JSON выполнены успешно, функция возвращает полученный словарь.

```
A (Попытка чтения данных из файла)
|
├─── Успешно ──────── B (Попытка декодирования JSON)
|   │                   │
|   └─── JSONDecodeError ─── C (Логирование ошибки и возврат {})
|   │
|   └─── Exception ─────── D (Логирование ошибки и возврат {})
|   │
|   └─── Успешно ──────── E (Возврат JSON-данных)
|
└─── Ошибка ────────── F (Логирование ошибки и возврат {})
```

**Примеры**:

```python
from pathlib import Path
from src.logger.logger import logger
import json

# Создание временного файла с JSON-данными
temp_file = Path("temp.json")
with open(temp_file, "w", encoding="utf-8") as f:
    json.dump({"name": "John", "age": 30}, f)

# Чтение данных из файла
data = _read_existing_data(temp_file)
print(data)  # Вывод: {'name': 'John', 'age': 30}

# Удаление временного файла
temp_file.unlink()

# Создание временного файла с некорректными JSON-данными
temp_file = Path("temp.json")
with open(temp_file, "w", encoding="utf-8") as f:
    f.write("not a json")

# Чтение данных из файла с некорректными JSON-данными
data = _read_existing_data(temp_file)
print(data)  # Вывод: {}

# Удаление временного файла
temp_file.unlink()
```

### `_merge_data`

```python
def _merge_data(
    data: Dict, existing_data: Dict, mode: str
) -> Dict:
    """Объединяет новые данные с существующими данными в зависимости от режима."""
```

**Назначение**: Функция объединяет новые данные (`data`) с существующими данными (`existing_data`) в зависимости от указанного режима (`mode`). Поддерживаются режимы добавления в начало и в конец.

**Параметры**:
- `data` (Dict): Новые данные для объединения.
- `existing_data` (Dict): Существующие данные, с которыми нужно объединить новые данные.
- `mode` (str): Режим объединения данных. Возможные значения: `Config.MODE_APPEND_START` (добавить в начало) и `Config.MODE_APPEND_END` (добавить в конец).

**Возвращает**:
- `Dict`: Объединенные данные в виде словаря. В случае ошибки возвращается пустой словарь.

**Как работает функция**:

1.  **Проверка режима**: Функция проверяет, соответствует ли указанный режим одному из поддерживаемых значений (`Config.MODE_APPEND_START` или `Config.MODE_APPEND_END`).
2.  **Добавление в начало**: Если режим `Config.MODE_APPEND_START`, функция выполняет следующие действия:
    - Если `data` и `existing_data` являются списками, функция объединяет их, добавляя `data` в начало `existing_data`.
    - Если `data` и `existing_data` являются словарями, функция обновляет `existing_data` данными из `data`.
    - Возвращает обновленные `existing_data`.
3.  **Добавление в конец**: Если режим `Config.MODE_APPEND_END`, функция выполняет следующие действия:
    - Если `data` и `existing_data` являются списками, функция объединяет их, добавляя `data` в конец `existing_data`.
    - Если `data` и `existing_data` являются словарями, функция обновляет `data` данными из `existing_data`.
    - Возвращает обновленные `data`.
4.  **Режим по умолчанию**: Если режим не соответствует ни одному из поддерживаемых значений, функция возвращает `data` без изменений.
5.  **Обработка ошибок**: Если в процессе объединения данных возникает исключение, функция логирует ошибку и возвращает пустой словарь.

```
A (Проверка режима)
|
├─── MODE_APPEND_START ─── B (Добавление в начало)
|   │                       │
|   ├─── Списки? ─────── Объединение списков (data + existing_data)
|   │
|   └─── Словари? ─────── Обновление словаря (existing_data.update(data))
|   │
|   └─── Возврат existing_data
|
├─── MODE_APPEND_END ───── C (Добавление в конец)
|   │                       │
|   ├─── Списки? ─────── Объединение списков (existing_data + data)
|   │
|   └─── Словари? ─────── Обновление словаря (data.update(existing_data))
|   │
|   └─── Возврат data
|
└─── Режим по умолчанию ─── D (Возврат data без изменений)
```

**Примеры**:

```python
from src.utils.jjson import Config
from src.logger.logger import logger

# Пример с добавлением в начало (списки)
data = [1, 2, 3]
existing_data = [4, 5, 6]
mode = Config.MODE_APPEND_START
result = _merge_data(data, existing_data, mode)
print(result)  # Вывод: [1, 2, 3, 4, 5, 6]

# Пример с добавлением в конец (словари)
data = {"a": 1, "b": 2}
existing_data = {"c": 3, "d": 4}
mode = Config.MODE_APPEND_END
result = _merge_data(data, existing_data, mode)
print(result)  # Вывод: {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# Пример с режимом по умолчанию
data = {"a": 1, "b": 2}
existing_data = {"c": 3, "d": 4}
mode = "unknown"
result = _merge_data(data, existing_data, mode)
print(result)  # Вывод: {'a': 1, 'b': 2}
```

### `j_dumps`

```python
def j_dumps(
    data: Union[Dict, SimpleNamespace, List[Dict], List[SimpleNamespace]],
    file_path: Optional[Path] = None,
    ensure_ascii: bool = False,
    mode: str = Config.MODE_WRITE,
    exc_info: bool = True,
) -> Optional[Dict]:
    """
    Сохраняет JSON-данные в файл или возвращает JSON-данные в виде словаря.

    Args:
        data (Dict | SimpleNamespace | List[Dict] | List[SimpleNamespace]): JSON-совместимые данные или объекты SimpleNamespace для сохранения.
        file_path (Optional[Path], optional): Путь к выходному файлу. Если None, возвращает JSON в виде словаря. По умолчанию None.
        ensure_ascii (bool, optional): Если True, экранирует символы, не входящие в ASCII, в выходных данных. По умолчанию True.
        mode (str, optional): Режим открытия файла ('w', 'a+', '+a'). По умолчанию 'w'.
        exc_info (bool, optional): Если True, логирует исключения с трассировкой. По умолчанию True.

    Returns:
        Optional[Dict]: JSON-данные в виде словаря в случае успеха или None в случае ошибки.

    Raises:
        ValueError: Если режим файла не поддерживается.
    """
```

**Назначение**: Функция `j_dumps` преобразует данные в формат JSON и сохраняет их в файл или возвращает в виде словаря. Поддерживаются различные типы входных данных, включая словари, объекты `SimpleNamespace` и списки.

**Параметры**:
- `data` (Dict | SimpleNamespace | List[Dict] | List[SimpleNamespace]): Данные для сохранения в формате JSON.
- `file_path` (Optional[Path], optional): Путь к файлу для сохранения данных. Если `None`, функция возвращает JSON в виде словаря. По умолчанию `None`.
- `ensure_ascii` (bool, optional): Если `True`, не ASCII символы будут экранированы. По умолчанию `False`.
- `mode` (str, optional): Режим открытия файла (`'w'`, `'a+'`, `'+a'`). По умолчанию `'w'`.
- `exc_info` (bool, optional): Если `True`, исключения будут логироваться с трассировкой. По умолчанию `True`.

**Возвращает**:
- `Optional[Dict]`: JSON-данные в виде словаря при успехе или `None` при возникновении ошибки. Если `file_path` указан, функция возвращает `data`

**Вызывает исключения**:
- `ValueError`: Если указан неподдерживаемый режим файла.

**Как работает функция**:

1.  **Преобразование `file_path` в `Path`**: Если `file_path` является строкой или объектом `Path`, он преобразуется в объект `Path`.
2.  **Обработка строковых данных**: Если `data` является строкой, функция пытается исправить JSON-синтаксис с помощью `repair_json`.
3.  **Преобразование данных в словарь**: Функция преобразует входные данные в словарь с помощью `_convert_to_dict`.
4.  **Выбор режима файла**: Если `mode` не является одним из допустимых значений (`'w'`, `'a+'`, `'+a'`), устанавливается режим по умолчанию `'w'`.
5.  **Чтение существующих данных**: Если указан `file_path` и режим является `'a+'` или `'+a'`, функция пытается прочитать существующие данные из файла с помощью `_read_existing_data`.
6.  **Объединение данных**: Функция объединяет новые данные с существующими данными с помощью `_merge_data`.
7.  **Запись данных в файл**: Если указан `file_path`, функция пытается создать директорию для файла (если она не существует) и записывает JSON-данные в файл с использованием `json.dump`.
8.  **Логирование ошибок**: Если при записи данных в файл возникает исключение, функция логирует ошибку с помощью `logger.error`.
9.  **Возврат данных**: Если запись в файл прошла успешно или `file_path` не указан, функция возвращает JSON-данные в виде словаря.

```
A (Преобразование file_path в Path)
|
B (Обработка строковых данных)
|
C (Преобразование данных в словарь)
|
D (Выбор режима файла)
|
E (Чтение существующих данных, если необходимо)
|
F (Объединение данных)
|
G (Запись данных в файл, если file_path указан)
|
H (Логирование ошибок)
|
I (Возврат данных)
```

**Примеры**:

```python
from pathlib import Path
from types import SimpleNamespace

# Пример сохранения данных в файл
data = {"name": "John", "age": 30}
file_path = Path("output.json")
result = j_dumps(data, file_path=file_path)
print(result)  # Вывод: {'name': 'John', 'age': 30}

# Пример возврата JSON в виде словаря
data = SimpleNamespace(name="John", age=30)
result = j_dumps(data)
print(result)  # Вывод: {'name': 'John', 'age': 30}

# Пример с ensure_ascii=True
data = {"name": "Иван", "age": 30}
result = j_dumps(data, ensure_ascii=True)
print(result)  # Вывод: {'name': '\\u0418\\u0432\\u0430\\u043d', 'age': 30}
```

### `_decode_strings`

```python
def _decode_strings(data: Any) -> Any:
    """Рекурсивно декодирует строки в структуре данных."""
```

**Назначение**: Функция рекурсивно декодирует строки в заданной структуре данных, используя кодировку `unicode_escape`. Это полезно для обработки JSON-данных, содержащих экранированные символы Unicode.

**Параметры**:
- `data` (Any): Структура данных (строка, список или словарь) для декодирования.

**Возвращает**:
- `Any`: Декодированная структура данных.

**Как работает функция**:

1.  **Проверка типа**: Функция проверяет тип входных данных (`data`).
2.  **Декодирование строки**: Если `data` является строкой, функция пытается декодировать ее с использованием кодировки `unicode_escape`. Если декодирование не удается, возвращается исходная строка.
3.  **Декодирование списка**: Если `data` является списком, функция рекурсивно применяет `_decode_strings` к каждому элементу списка.
4.  **Декодирование словаря**: Если `data` является словарем, функция рекурсивно применяет `_decode_strings` к каждому ключу и значению в словаре.
5.  **Возврат данных**: Если `data` не является строкой, списком или словарем, функция возвращает `data` без изменений.

```
A (Проверка типа данных)
|
├─── Строка ────── B (Попытка декодирования unicode_escape)
|   │              │
|   └─── Успешно ── Возврат декодированной строки
|   │
|   └─── Ошибка ──── Возврат исходной строки
|
├─── Список ────── C (Рекурсивное декодирование элементов списка)
|
├─── Словарь ───── D (Рекурсивное декодирование ключей и значений словаря)
|
└─── Другое ──── E (Возврат данных без изменений)
```

**Примеры**:

```python
# Пример декодирования строки
encoded_string = "Hello \\u041c\\u0438\\u0440!"
decoded_string = _decode_strings(encoded_string)
print(decoded_string)  # Вывод: Hello Мир!

# Пример декодирования списка
encoded_list = ["\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442"]
decoded_list = _decode_strings(encoded_list)
print(decoded_list)  # Вывод: ['Привет']

# Пример декодирования словаря
encoded_dict = {"name": "\\u0410\\u043d\\u043d\\u0430"}
decoded_dict = _decode_strings(encoded_dict)
print(decoded_dict)  # Вывод: {'name': 'Анна'}
```

### `_string_to_dict`

```python
def _string_to_dict(json_string: str) -> dict:
    """Удаляет markdown кавычки и парсит JSON строку."""
```

**Назначение**: Функция `_string_to_dict` преобразует JSON-строку в словарь, предварительно удалив обрамляющие markdown-кавычки (если они есть).

**Параметры**:
- `json_string` (str): JSON-строка для преобразования.

**Возвращает**:
- `dict`: Словарь, полученный из JSON-строки. В случае ошибки парсинга возвращается пустой словарь.

**Как работает функция**:

1.  **Удаление markdown-кавычек**: Функция проверяет, начинается ли строка с `"```"` или `"```json"` и заканчивается ли на `"```"` или `"```\\n"`. Если это так, она удаляет эти кавычки и префикс `"json"` (если он есть).
2.  **Парсинг JSON**: Функция пытается распарсить строку с помощью `json.loads()`.
3.  **Обработка ошибок**: Если при парсинге возникает ошибка `json.JSONDecodeError`, функция логирует ошибку и возвращает пустой словарь.
4.  **Возврат результата**: Если парсинг прошел успешно, функция возвращает полученный словарь.

```
A (Проверка на наличие markdown-кавычек)
|
├─── Есть кавычки ── B (Удаление кавычек и префикса "json")
|
└─── Нет кавычек ── C (Парсинг JSON)
|
D (Обработка ошибок парсинга)
|
E (Возврат результата)
```

**Примеры**:

```python
# Пример с markdown-кавычками
json_string = "```json\n{\"name\": \"John\"}\n```"
result = _string_to_dict(json_string)
print(result)  # Вывод: {'name': 'John'}

# Пример без markdown-кавычек
json_string = "{\"name\": \"Jane\"}"
result = _string_to_dict(json_string)
print(result)  # Вывод: {'name': 'Jane'}

# Пример с ошибкой парсинга
json_string = "{\"name\": \"Jane\""  # Некорректный JSON
result = _string_to_dict(json_string)
print(result)  # Вывод: {}
```

### `j_loads`

```python
def j_loads(
    jjson: Union[dict, SimpleNamespace, str, Path, list], ordered: bool = True
) -> Union[dict, list]:
    """
    Загружает JSON или CSV данные из файла, каталога, строки или объекта.

    Args:
        jjson (dict | SimpleNamespace | str | Path | list): Путь к файлу/каталогу, JSON строка или JSON объект.
        ordered (bool, optional): Использовать OrderedDict для сохранения порядка элементов. По умолчанию True.

    Returns:
        dict | list: Обработанные данные (словарь или список словарей).

    Raises:
        FileNotFoundError: Если указанный файл не найден.
        json.JSONDecodeError: Если JSON данные не могут быть распарсены.
    """
```

**Назначение**: Функция `j_loads` загружает JSON-данные из различных источников, таких как файлы, каталоги, строки или объекты, и преобразует их в словари или списки словарей.

**Параметры**:
- `jjson` (dict | SimpleNamespace | str | Path | list): Источник JSON-данных. Может быть путем к файлу или каталогу, JSON-строкой или JSON-объектом.
- `ordered` (bool, optional): Указывает, следует ли использовать `OrderedDict` для сохранения порядка элементов. По умолчанию `True`.

**Возвращает**:
- `dict | list`: Обработанные данные в виде словаря или списка словарей.

**Вызывает исключения**:
- `FileNotFoundError`: Если указанный файл не найден.
- `json.JSONDecodeError`: Если JSON-данные не могут быть распарсены.

**Как работает функция**:

1.  **Обработка `SimpleNamespace`**: Если `jjson` является объектом `SimpleNamespace`, он преобразуется в словарь.
2.  **Обработка `Path`**: Если `jjson` является объектом `Path`, функция проверяет, является ли это файлом или каталогом:
    - Если это каталог, функция рекурсивно загружает все JSON-файлы из этого каталога.
    - Если это файл, функция считывает содержимое файла и парсит его как JSON.
3.  **Обработка строки**: Если `jjson` является строкой, функция преобразует её в словарь с помощью `_string_to_dict`.
4.  **Обработка списка**: Если `jjson` является списком, функция рекурсивно декодирует строки в списке с помощью `_decode_strings`.
5.  **Обработка словаря**: Если `jjson` является словарем, функция рекурсивно декодирует строки в словаре с помощью `_decode_strings`.
6.  **Обработка ошибок**: Функция обрабатывает исключения, такие как `FileNotFoundError` и `json.JSONDecodeError`, и логирует ошибки с помощью `logger.error`.
7.  **Возврат результата**: Функция возвращает обработанные данные в виде словаря или списка словарей.

```
A (Проверка типа jjson)
|
├─── SimpleNamespace ── B (Преобразование в словарь)
|
├─── Path ────────── C (Проверка, файл или каталог)
|   │
|   ├─── Каталог ── Рекурсивная загрузка JSON-файлов из каталога
|   │
|   └─── Файл ──── Чтение содержимого файла и парсинг JSON
|
├─── Строка ──────── D (Преобразование строки в словарь)
|
├─── Список ──────── E (Декодирование строк в списке)
|
├─── Словарь ─────── F (Декодирование строк в словаре)
|
└─── Обработка ошибок и возврат результата
```

**Примеры**:

```python
from pathlib import Path
from types import SimpleNamespace

# Пример загрузки из строки
json_string = '{"name": "John", "age": 30}'
data = j_loads(json_string)
print(data)  # Вывод: {'name': 'John', 'age': 30}

# Пример загрузки из файла
file_path = Path("data.json")
with open(file_path, "w") as f:
    f.write('{"name": "Jane", "age": 25}')
data = j_loads(file_path)
print(data)  # Вывод: {'name': 'Jane', 'age': 25}
file_path.unlink()

# Пример загрузки из SimpleNamespace
ns_object = SimpleNamespace(name="Tom", age=40)
data = j_loads(ns_object)
print(data)  # Вывод: {'name': 'Tom', 'age': 40}
```

### `j_loads_ns`

```python
def j_loads_ns(
    jjson: Union[Path, SimpleNamespace, Dict, str], ordered: bool = True
) -> Union[SimpleNamespace, List[SimpleNamespace], Dict]:
    """Загружает JSON/CSV данные и преобразует в SimpleNamespace."""
```

**Назначение**: Функция `j_loads_ns` загружает JSON-данные из различных источников (файла, объекта `SimpleNamespace`, словаря или строки) и преобразует их в объекты `SimpleNamespace`.

**Параметры**:
- `jjson` (Union[Path, SimpleNamespace, Dict, str]): Источник JSON-данных.
- `ordered` (bool, optional): Указывает, следует ли использовать упорядоченные словари. По умолчанию `True`.

**Возвращает**:
- `Union[SimpleNamespace, List[SimpleNamespace], Dict]`: Данные, преобразованные в объекты `SimpleNamespace` или список объектов `SimpleNamespace`.

**Как работает функция**:

1.  **Загрузка данных**: Функция вызывает `j_loads` для загрузки JSON-данных из указанного источника.
2.  **Преобразование в `SimpleNamespace`**: Если данные успешно загружены, функция преобразует их в объекты `SimpleNamespace`:
    - Если данные являются списком, каждый элемент списка преобразуется в объект `SimpleNamespace`.
    - Если данные являются словарем, словарь преобразуется в объект `SimpleNamespace`.
3.  **Обработка ошибок**: Если при загрузке данных возникает ошибка, функция возвращает пустой словарь.

```
A (Загрузка данных с помощью j_loads)
|
B (Проверка, успешно ли загружены данные)
|
├─── Данные загружены ── C (Преобразование в SimpleNamespace)
|   │                   │
|   ├─── Список ────── Преобразование каждого элемента в SimpleNamespace
|   │
|   └─── Словарь ──── Преобразование словаря в SimpleNamespace
|
└─── Ошибка ────────── Возврат пустого словаря
```

**Примеры**:

```python
from pathlib import Path
from types import SimpleNamespace

# Пример загрузки из строки
json_string = '{"name": "John", "age": 30}'
data = j_loads_ns(json_string)
print(data.name)  # Вывод: John
print(data.age)   # Вывод: 30

# Пример загрузки из файла
file_path = Path("data.json")
with open(file_path, "w") as f:
    f.write('{"name": "Jane", "age": 25}')
data = j_loads_ns(file_path)
print(data.name)  # Вывод: Jane
print(data.age)   # Вывод: 25
file_path.unlink()

# Пример загрузки из SimpleNamespace
ns_object = SimpleNamespace(name="Tom", age=40)
data = j_loads_ns(ns_object)
print(data.name)  # Вывод: Tom
print(data.age)   # Вывод: 40