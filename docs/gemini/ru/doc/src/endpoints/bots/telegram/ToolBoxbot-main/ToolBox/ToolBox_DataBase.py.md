# Модуль для работы с базой данных Telegram Bot ToolBox
=========================================================

Модуль содержит класс `DataBase`, который используется для создания, обновления и загрузки данных из базы данных SQLite.

## Обзор

Этот модуль предоставляет класс `DataBase`, предназначенный для упрощения взаимодействия с базой данных SQLite. Он позволяет создавать таблицы, вставлять и обновлять данные, а также загружать данные в формате словаря. Модуль также содержит функции для преобразования типов данных, хранящихся в базе данных.

## Подробнее

Модуль `ToolBox_DataBase.py` предоставляет класс `DataBase`, который облегчает работу с базами данных SQLite. Он включает методы для создания базы данных, вставки и обновления данных, а также загрузки данных в виде словаря. Этот модуль полезен для хранения и управления данными, используемыми в боте Telegram ToolBox.

## Классы

### `DataBase`

**Описание**: Класс для управления базой данных SQLite.

**Принцип работы**:
Класс `DataBase` инициализируется с именем базы данных, именем таблицы и словарем, определяющим структуру таблицы (названия столбцов и типы данных). Он предоставляет методы для создания таблицы, вставки/обновления данных и загрузки данных в виде словаря. Класс также содержит словарь типов данных для преобразования значений, полученных из базы данных, в соответствующие типы Python.

**Атрибуты**:
- `db_name` (str): Имя файла базы данных.
- `table_name` (str): Имя таблицы в базе данных.
- `titles` (dict[str, str]): Словарь, определяющий структуру таблицы (названия столбцов и типы данных).
- `types` (dict[str, function]): Словарь функций для преобразования типов данных.

**Методы**:
- `create()`: Создает таблицу в базе данных, если она не существует.
- `insert_or_update_data(record_id: str, values: dict[str, list[bool|int]|bool|int|str])`: Вставляет новую запись или обновляет существующую в таблице.
- `load_data_from_db() -> dict[str, dict[str, list[bool|int]|bool|int|str]]`: Загружает данные из таблицы в словарь.

### `DataBase.__init__`

```python
    def __init__(self, db_name: str, table_name: str, titles: dict[str, str]) -> None:
        """Инициализирует объект DataBase.

        Args:
            db_name (str): Имя файла базы данных.
            table_name (str): Имя таблицы в базе данных.
            titles (dict[str, str]): Словарь, определяющий структуру таблицы (названия столбцов и типы данных).

        """
```

### `DataBase.create`

```python
    def create(self) -> None:
        """Создает таблицу в базе данных, если она не существует.
        """
```

**Как работает функция**:

1.  Устанавливает соединение с базой данных SQLite, используя имя базы данных, переданное при инициализации класса (`self.db_name`).
2.  Создает объект `cursor`, который используется для выполнения SQL-запросов.
3.  Выполняет SQL-запрос для создания таблицы, если она не существует. SQL-запрос формируется на основе имени таблицы (`self.table_name`) и структуры таблицы, определенной в словаре `self.titles`.
4.  Закрывает соединение с базой данных.

```
    Установить соединение с БД  -->  Создать курсор  -->  Выполнить SQL-запрос для создания таблицы  -->  Закрыть соединение с БД
```

### `DataBase.insert_or_update_data`

```python
    def insert_or_update_data(self, record_id: str, values: dict[str, list[bool|int]|bool|int|str]) -> None:
        """Вставляет новую запись или обновляет существующую в таблице.

        Args:
            record_id (str): Идентификатор записи.
            values (dict[str, list[bool|int]|bool|int|str]): Словарь значений для вставки или обновления.
        """
```

**Как работает функция**:

1.  Устанавливает соединение с базой данных SQLite, используя имя базы данных, переданное при инициализации класса (`self.db_name`).
2.  Создает объект `cursor`, который используется для выполнения SQL-запросов.
3.  Формирует строку с плейсхолдерами (`?`) для каждого значения, которое будет вставлено или обновлено.
4.  Формирует SQL-запрос `REPLACE INTO`, который вставляет новую запись, если записи с указанным `record_id` не существует, или обновляет существующую запись.
5.  Выполняет SQL-запрос с использованием `cursor.execute()`. В качестве параметров передаются SQL-запрос и список значений для вставки или обновления.
    *   Для значений типа `list` выполняется преобразование элементов в строку, при этом элементы типа `dict` преобразуются в JSON-строку с помощью `json.dumps()`.
    *   Для остальных значений выполняется приведение к типу `int`
6.  Сохраняет изменения в базе данных с помощью `conn.commit()`.
7.  Закрывает соединение с базой данных.

```
    Установить соединение с БД  -->  Создать курсор  -->  Сформировать строку с плейсхолдерами  -->  Сформировать SQL-запрос REPLACE INTO  -->  Преобразовать значения (list -> str, dict -> json)  -->  Выполнить SQL-запрос  -->  Сохранить изменения  -->  Закрыть соединение с БД
```

### `DataBase.load_data_from_db`

```python
    def load_data_from_db(self) -> dict[str, dict[str, list[bool|int]|bool|int|str]]:
        """Загружает данные из таблицы в словарь.

        Returns:
            dict[str, dict[str, list[bool|int]|bool|int|str]]: Словарь, содержащий данные из таблицы.
        """
```

**Как работает функция**:

1.  Создает пустой словарь `loaded_data`, который будет содержать загруженные данные.
2.  Устанавливает соединение с базой данных SQLite, используя имя базы данных, переданное при инициализации класса (`self.db_name`).
3.  Создает объект `cursor`, который используется для выполнения SQL-запросов.
4.  Выполняет SQL-запрос `SELECT`, который выбирает все столбцы из таблицы (`self.table_name`).
5.  Получает все строки из результата запроса с помощью `cursor.fetchall()`.
6.  Итерируется по каждой строке в `rows`.
    *   Извлекает идентификатор записи (`id`) из первого столбца строки.
    *   Создает пустой словарь `loaded_data[id]`, который будет содержать данные для данной записи.
    *   Итерируется по остальным столбцам строки, начиная со второго столбца (индекс 1).
    *   Для каждого столбца извлекает ключ и значение типа данных из словаря `self.titles`.
    *   Преобразует значение столбца с использованием функции преобразования типа данных, соответствующей типу данных столбца. Функция преобразования типа данных извлекается из словаря `self.types`.
    *   Сохраняет преобразованное значение в словаре `loaded_data[id]` под соответствующим ключом.
7.  Закрывает соединение с базой данных.
8.  Возвращает словарь `loaded_data`, содержащий загруженные данные.

```
    Создать пустой словарь loaded_data  -->  Установить соединение с БД  -->  Создать курсор  -->  Выполнить SQL-запрос SELECT  -->  Получить все строки  -->  Для каждой строки: Извлечь id, создать пустой словарь для записи, для каждого столбца: Извлечь ключ и значение типа данных, преобразовать значение, сохранить значение в словаре записи  -->  Закрыть соединение с БД  -->  Вернуть словарь loaded_data
```

## Функции

### `__main__`

```python
if __name__ == "__main__":
    base = DataBase(db_name="UsersData.db", table_name="users_data_table", titles={"id": "TEXT PRIMARY KEY", "text": "INTEGER[]",
                        "sessions_messages": "TEXT[]", "some": "BOOLEAN",
                        "images": "CHAR", "free" : "BOOLEAN", "basic" : "BOOLEAN",
                        "pro" : "BOOLEAN", "incoming_tokens": "INTEGER", "outgoing_tokens" : "INTEGER",
                        "free_requests" : "INTEGER", "datetime_sub": "DATETIME", "promocode": "BOOLEAN", "ref": "TEXT"})
    base.create(); db = base.load_data_from_db(); N = 8
    uid = input()
    if uid != '':
        if "pro" in uid:
            db[uid.split()[0]] = {"text": [0]*N, "sessions_messages": [], "some": False, "images": "", "free": False, "basic": True, "pro": True, "incoming_tokens": 1.7*10**5, "outgoing_tokens": 5*10**5, "free_requests": 10, "datetime_sub": datetime.now().replace(microsecond=0)+relativedelta(months=1), "promocode": False, "ref": ""}
        elif 'admin' in uid:
            db[uid.split()[0]] = {"text": [0]*N, "sessions_messages": [], "some": False, "images": "", "free": False, "basic": True, "pro": True, "incoming_tokens": 100*10**5, "outgoing_tokens": 100*10**5, "free_requests": 1000, "datetime_sub": datetime.now().replace(microsecond=0)+relativedelta(years=5), "promocode": False, "ref": ""}
        else:
            db[uid] = {"text": [0]*N, "sessions_messages": [], "some": False, "images": "", "free": False, "basic": False, "pro": False, "incoming_tokens": 0, "outgoing_tokens": 0, "free_requests": 10, "datetime_sub": datetime.now().replace(microsecond=0)+relativedelta(days=1), "promocode": False, "ref": ""}
        base.insert_or_update_data(uid.split()[0], db[uid.split()[0]])
```

**Назначение**: Демонстрация работы с классом `DataBase`.

**Как работает функция**:

1.  Создает экземпляр класса `DataBase` с именем базы данных "UsersData.db", именем таблицы "users_data_table" и структурой таблицы, определенной в словаре `titles`.
2.  Вызывает метод `create()` для создания таблицы в базе данных, если она не существует.
3.  Вызывает метод `load_data_from_db()` для загрузки данных из таблицы в словарь `db`.
4.  Запрашивает ввод данных от пользователя с помощью `input()`.
5.  Если введенные данные не пустые, выполняет следующие действия:
    *   Проверяет, содержит ли введенная строка подстроку "pro". Если да, то создает новую запись в словаре `db` с данными для пользователя с подпиской "pro".
    *   Если введенная строка содержит подстроку "admin", то создает новую запись в словаре `db` с данными для администратора.
    *   В противном случае создает новую запись в словаре `db` с данными для обычного пользователя.
    *   Вызывает метод `insert_or_update_data()` для вставки или обновления записи в таблице базы данных.

```
    Создать экземпляр DataBase  -->  Создать таблицу  -->  Загрузить данные из таблицы  -->  Запросить ввод данных от пользователя  -->  Если введенные данные не пустые: Проверить наличие "pro" или "admin", создать новую запись в словаре db, вставить или обновить запись в таблице БД
```

## Примеры

### Создание экземпляра класса `DataBase`

```python
base = DataBase(db_name="UsersData.db", table_name="users_data_table", titles={"id": "TEXT PRIMARY KEY", "text": "INTEGER[]",
                    "sessions_messages": "TEXT[]", "some": "BOOLEAN",
                    "images": "CHAR", "free" : "BOOLEAN", "basic" : "BOOLEAN",
                    "pro" : "BOOLEAN", "incoming_tokens": "INTEGER", "outgoing_tokens" : "INTEGER",
                    "free_requests" : "INTEGER", "datetime_sub": "DATETIME", "promocode": "BOOLEAN", "ref": "TEXT"})
```

### Создание таблицы в базе данных

```python
base.create()
```

### Вставка или обновление данных в таблице

```python
uid = "12345"
data = {"text": [0]*8, "sessions_messages": [], "some": False, "images": "", "free": False, "basic": False, "pro": False, "incoming_tokens": 0, "outgoing_tokens": 0, "free_requests": 10, "datetime_sub": datetime.now().replace(microsecond=0)+relativedelta(days=1), "promocode": False, "ref": ""}
base.insert_or_update_data(uid, data)
```

### Загрузка данных из таблицы в словарь

```python
db = base.load_data_from_db()
print(db)