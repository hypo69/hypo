# Модуль `src.utils.file`

## Обзор

Модуль предоставляет набор утилит для работы с файлами, включая сохранение, чтение и поиск файлов. Он поддерживает работу с большими файлами, используя генераторы для экономии памяти. Модуль содержит функции для чтения и записи текстовых файлов, поиска файлов в директориях (рекурсивно), удаления BOM (Byte Order Mark) и другие полезные функции для работы с файловой системой.

## Подробней

Этот модуль предназначен для упрощения операций с файлами в проекте `hypotez`. Он предоставляет удобные функции для чтения и записи файлов, а также для поиска файлов по заданным критериям. Использование генераторов при чтении больших файлов позволяет снизить потребление памяти, что особенно важно при работе с большими объемами данных.

## Функции

### `save_text_file`

```python
def save_text_file(
    file_path: str | Path,
    data: str | list[str] | dict,
    mode: str = 'w'
) -> bool:
```

**Описание**: Сохраняет данные в текстовый файл. Данные могут быть строкой, списком строк или словарем.

**Как работает функция**: Функция принимает путь к файлу, данные для записи и режим записи (по умолчанию 'w' для записи, 'a' для добавления). Она создает родительские директории, если они не существуют, и записывает данные в файл в указанном режиме. Если данные представлены в виде списка, каждая строка записывается в файл с новой строки. Если данные - словарь, они записываются в формате JSON с отступами.

**Параметры**:
- `file_path` (str | Path): Путь к файлу для сохранения.
- `data` (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.
- `mode` (str, optional): Режим записи файла ('w' для записи, 'a' для добавления). По умолчанию 'w'.

**Возвращает**:
- `bool`: `True`, если файл успешно сохранен, `False` в противном случае.

**Вызывает исключения**:
- `Exception`: При возникновении ошибки при записи в файл.

**Примеры**:

```python
>>> from pathlib import Path
>>> file_path = Path('example.txt')
>>> data = 'Пример текста'
>>> result = save_text_file(file_path, data)
>>> print(result)
True
```

### `read_text_file_generator`

```python
def read_text_file_generator(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    chunk_size: int = 8192,
    recursive: bool = False,
    patterns: Optional[str | list[str]] = None,
) -> Generator[str, None, None] | str | list[str] | None:
```

**Описание**: Читает содержимое файла(ов) или директории. Возвращает генератор строк, строку или список строк в зависимости от входных параметров.

**Как работает функция**: Функция принимает путь к файлу или директории, флаг `as_list` для определения формата возвращаемых данных, список расширений для фильтрации файлов при чтении директории, размер чанка для чтения файла и флаг `recursive` для рекурсивного поиска файлов в директории. В зависимости от входных параметров функция возвращает либо генератор строк, либо объединенную строку, либо список строк. Если путь не является файлом или директорией, возвращается `None`.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк или список строк, в зависимости от типа вывода. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах. По умолчанию 8192.
- `recursive` (bool, optional): Если `True`, поиск файлов выполняется рекурсивно. По умолчанию `False`.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске. По умолчанию `None`.

**Возвращает**:
- `Generator[str, None, None] | str | list[str] | None`:
  - Если `as_list` is `True` и `file_path` является файлом, возвращает генератор строк.
  - Если `as_list` is `True` и `file_path` является директорией и `recursive` is `True`, возвращает список строк.
  - Если `as_list` is `False` и `file_path` является файлом, возвращает строку.
  - Если `as_list` is `False` и `file_path` является директорией, возвращает объединенную строку.
  - Возвращает `None` в случае ошибки.

**Вызывает исключения**:
- `Exception`: При возникновении ошибки при чтении файла.

**Примеры**:

```python
>>> from pathlib import Path
>>> file_path = Path('example.txt')
>>> content = read_text_file(file_path)
>>> if content:
...    print(f'File content: {content[:100]}...')
File content: Пример текста...
```

### `read_text_file`

```python
def read_text_file(
    file_path: Union[str, Path],
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    exc_info: bool = True,
) -> str | list[str] | None:
```

**Описание**: Читает содержимое файла и возвращает его в виде строки или списка строк.

**Как работает функция**: Функция принимает путь к файлу, флаг `as_list` для определения формата возвращаемых данных, список расширений для фильтрации файлов при чтении директории и флаг `exc_info` для логирования информации об исключении. Если `as_list` равен `True`, функция возвращает содержимое файла в виде списка строк. В противном случае, функция возвращает содержимое файла в виде строки. Если путь не является файлом или директорией, возвращается `None`.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает содержимое как список строк. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `exc_info` (bool, optional): Если `True`, логирует traceback при ошибке. По умолчанию `True`.

**Возвращает**:
- `str | list[str] | None`: Содержимое файла в виде строки или списка строк, или `None`, если произошла ошибка.

**Вызывает исключения**:
- Отсутствуют явные исключения, но функция может вызвать исключения при работе с файловой системой.

**Примеры**:
```python
# Чтение файла как строки
file_content = read_text_file("example.txt")

# Чтение файла как списка строк
file_lines = read_text_file("example.txt", as_list=True)
```

### `yield_text_from_files`

```python
def yield_text_from_files(
    file_path: str | Path,
    as_list: bool = False,
    chunk_size: int = 8192
) -> Generator[str, None, None] | str | None:
```

**Описание**: Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

**Как работает функция**: Функция принимает путь к файлу, флаг `as_list` для определения формата возвращаемых данных и размер чанка для чтения файла. Если `as_list` равен `True`, функция возвращает генератор строк. В противном случае, функция возвращает содержимое файла в виде строки. Если путь не является файлом, возвращается `None`.

**Параметры**:
- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. По умолчанию `False`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах.

**Возвращает**:
- `Generator[str, None, None] | str | None`: Генератор строк, объединенная строка или `None` в случае ошибки.

**Yields**:
- `str`: Строки из файла, если `as_list` is `True`.

**Примеры**:

```python
>>> from pathlib import Path
>>> file_path = Path('example.txt')
>>> for line in yield_text_from_files(file_path, as_list=True):
...     print(line)
Первая строка файла
Вторая строка файла
```

### `_read_file_content`

```python
def _read_file_content(file_path: Path, chunk_size: int) -> str:
```

**Описание**: Читает содержимое файла по чанкам и возвращает как строку.

**Как работает функция**: Функция открывает файл по указанному пути и читает его содержимое по частям (чанкам) заданного размера, накапливая прочитанные чанки в строку. Чтение продолжается до тех пор, пока не будет достигнут конец файла.

**Параметры**:
- `file_path` (Path): Путь к файлу для чтения.
- `chunk_size` (int): Размер чанка для чтения файла в байтах.

**Возвращает**:
- `str`: Содержимое файла в виде строки.

**Вызывает исключения**:
- `Exception`: При возникновении ошибки при чтении файла.

**Примеры**:
```python
# Не предполагается прямое использование вне модуля.
```

### `_read_file_lines_generator`

```python
def _read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]:
```

**Описание**: Читает файл по строкам с помощью генератора.

**Как работает функция**: Функция открывает файл по указанному пути и читает его содержимое по частям (чанкам) заданного размера. Затем она разбивает каждый чанк на строки и возвращает их с помощью генератора. Если чанк не заканчивается полной строкой, последняя строка добавляется к следующему чанку.

**Параметры**:
- `file_path` (Path): Путь к файлу для чтения.
- `chunk_size` (int): Размер чанка для чтения файла в байтах.

**Yields**:
- `str`: Строки из файла.

**Вызывает исключения**:
- `Exception`: При возникновении ошибки при чтении файла.

**Примеры**:
```python
# Не предполагается прямое использование вне модуля.
```

### `get_filenames_from_directory`

```python
def get_filenames_from_directory(
    directory: str | Path, ext: str | list[str] = '*'
) -> list[str]:
```

**Описание**: Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.

**Как работает функция**: Функция принимает путь к директории и список расширений файлов для фильтрации. Если расширения не указаны, возвращаются все файлы в директории. Функция возвращает список имен файлов, найденных в директории.

**Параметры**:
- `directory` (str | Path): Путь к директории для поиска.
- `ext` (str | list[str], optional): Расширения для фильтрации. По умолчанию '*'.

**Возвращает**:
- `list[str]`: Список имен файлов, найденных в директории.

**Примеры**:

```python
>>> from pathlib import Path
>>> directory = Path('.')
>>> get_filenames_from_directory(directory, ['.txt', '.md'])
['example.txt', 'readme.md']
```

### `recursively_yield_file_path`

```python
def recursively_yield_file_path(
    root_dir: str | Path, patterns: str | list[str] = '*'
) -> Generator[Path, None, None]:
```

**Описание**: Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

**Как работает функция**: Функция принимает корневую директорию и список шаблонов для фильтрации файлов. Она рекурсивно обходит все поддиректории и возвращает пути ко всем файлам, соответствующим заданным шаблонам, с использованием генератора.

**Параметры**:
- `root_dir` (str | Path): Корневая директория для поиска.
- `patterns` (str | list[str]): Шаблоны для фильтрации файлов. По умолчанию '*'.

**Yields**:
- `Path`: Путь к файлу, соответствующему шаблону.

**Примеры**:

```python
>>> from pathlib import Path
>>> root_dir = Path('.')
>>> for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
...    print(path)
./example.txt
./readme.md
```

### `recursively_get_file_path`

```python
def recursively_get_file_path(
    root_dir: str | Path,
    patterns: str | list[str] = '*'
) -> list[Path]:
```

**Описание**: Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

**Как работает функция**: Функция принимает корневую директорию и список шаблонов для фильтрации файлов. Она рекурсивно обходит все поддиректории и возвращает список путей ко всем файлам, соответствующим заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория для поиска.
- `patterns` (str | list[str]): Шаблоны для фильтрации файлов. По умолчанию '*'.

**Возвращает**:
- `list[Path]`: Список путей к файлам, соответствующим шаблонам.

**Примеры**:

```python
>>> from pathlib import Path
>>> root_dir = Path('.')
>>> paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
>>> print(paths)
[Path('./example.txt'), Path('./readme.md')]
```

### `recursively_read_text_files`

```python
def recursively_read_text_files(
    root_dir: str | Path,
    patterns: str | list[str],
    as_list: bool = False
) -> list[str]:
```

**Описание**: Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.

**Как работает функция**: Функция принимает корневую директорию, список шаблонов для фильтрации файлов и флаг `as_list` для определения формата возвращаемых данных. Она рекурсивно обходит все поддиректории и читает текстовые файлы, соответствующие заданным шаблонам. Если `as_list` равен `True`, функция возвращает список строк. В противном случае, функция возвращает список содержимого файлов.

**Параметры**:
- `root_dir` (str | Path): Путь к корневой директории для поиска.
- `patterns` (str | list[str]): Шаблон(ы) имени файла для фильтрации. Может быть как одиночным шаблоном (например, '*.txt'), так и списком.
- `as_list` (bool, optional): Если `True`, то возвращает содержимое файла как список строк. По умолчанию `False`.

**Возвращает**:
- `list[str]`: Список содержимого файлов (или список строк, если `as_list=True`), соответствующих заданным шаблонам.

**Примеры**:

```python
>>> from pathlib import Path
>>> root_dir = Path('.')
>>> contents = recursively_read_text_files(root_dir, ['*.txt', '*.md'], as_list=True)
>>> for line in contents:
...     print(line)
Содержимое example.txt
Первая строка readme.md
Вторая строка readme.md
```

### `get_directory_names`

```python
def get_directory_names(directory: str | Path) -> list[str]:
```

**Описание**: Возвращает список имен директорий из указанной директории.

**Как работает функция**: Функция принимает путь к директории и возвращает список имен поддиректорий, найденных в указанной директории.

**Параметры**:
- `directory` (str | Path): Путь к директории, из которой нужно получить имена.

**Возвращает**:
- `list[str]`: Список имен директорий, найденных в указанной директории.

**Примеры**:

```python
>>> from pathlib import Path
>>> directory = Path('.')
>>> get_directory_names(directory)
['dir1', 'dir2']
```

### `remove_bom`

```python
def remove_bom(path: str | Path) -> None:
```

**Описание**: Удаляет BOM (Byte Order Mark) из текстового файла или из всех файлов Python в директории.

**Как работает функция**: Функция принимает путь к файлу или директории. Если путь указывает на файл, функция пытается удалить BOM из файла. Если путь указывает на директорию, функция рекурсивно обходит все поддиректории и пытается удалить BOM из всех файлов Python.

**Параметры**:
- `path` (str | Path): Путь к файлу или директории.

**Примеры**:

```python
>>> from pathlib import Path
>>> file_path = Path('example.txt')
>>> with open(file_path, 'w', encoding='utf-8') as f:
...     f.write('\ufeffПример текста с BOM')
>>> remove_bom(file_path)
>>> with open(file_path, 'r', encoding='utf-8') as f:
...     print(f.read())
Пример текста с BOM
```

### `main`

```python
def main() -> None:
```

**Описание**: Entry point для удаления BOM в Python файлах.

**Как работает функция**: Функция определяет корневую директорию (`..\src`) и вызывает функцию `remove_bom` для удаления BOM из всех Python файлов в этой директории.

**Параметры**:
- Отсутствуют.

**Возвращает**:
- `None`

**Примеры**:
```python
# Функция вызывается при запуске скрипта напрямую.