# Анализ кода модуля HOCKEY

**Качество кода**
1.  **Соответствие требованиям к формату кода (1-10):**
    - 3/10. Код не соответствует требованиям к документированию.

-   **Преимущества:**
    -   Код достаточно простой и понятный, легко читается.
    -   Реализует базовую логику игры в хоккей.
    -   Есть обработка ошибок ввода данных.
    -   Логика игры проста и понятна из кода.

-   **Недостатки:**
    -   Отсутствует документация в формате reStructuredText (RST).
    -   Не используются `j_loads` или `j_loads_ns` для чтения файлов.
    -   Отсутствуют импорты.
    -   Не используются логгирование.
    -   Избыточное использование `try-except` блоков.
    -   Код не соответствует стилю, используемому в других модулях.

**Рекомендации по улучшению**

1.  Добавить документацию в формате reStructuredText (RST) к модулю, всем функциям, методам и переменным.
2.  Использовать `j_loads` или `j_loads_ns` для чтения файлов, если это необходимо.
3.  Удалить избыточные `try-except` блоки, использовать `logger.error` для логирования ошибок.
4.  Добавить импорты необходимые для корректной работы.
5.  Использовать константы для определения действий игроков (1, 2, 3).
6.  Добавить логгирование хода игры и результатов.
7.  Переименовать переменные и функции, согласно стандартам.

**Улучшенный код**

```python
"""
Модуль для игры в хоккей.
=========================

Модуль реализует простую игру в хоккей между двумя игроками.
Игра состоит из нескольких раундов, в которых игроки по очереди
выбирают одно из трех действий: бросок (1), защита (2) или пас (3).
Действия игроков сравниваются, и в зависимости от их комбинации
начисляются очки.

Игра продолжается, пока один из игроков не наберет 10 очков.

Пример использования
---------------------
.. code-block:: python

    python hockey.py
"""

from src.logger.logger import logger # импорт логгера
from src.utils.jjson import j_loads, j_loads_ns # импорт функций для работы с json


# Константы для действий игроков
SHOT = 1  # бросок
SAVE = 2  # защита
PASS = 3  # пас


def play_hockey_game() -> None:
    """
    Запускает игру в хоккей и управляет игровым процессом.

    :return: None
    """
    player1_score = 0 # счет первого игрока
    player2_score = 0 # счет второго игрока

    logger.info('Начало игры в хоккей') # логгирование начала игры

    while player1_score < 10 and player2_score < 10:
        # Получение хода первого игрока
        player1_move = get_player_move(1) # получение хода первого игрока
        if player1_move is None:
            continue
        # Получение хода второго игрока
        player2_move = get_player_move(2) # получение хода второго игрока
        if player2_move is None:
            continue

        # Определение очков
        player1_score, player2_score = calculate_scores(player1_move, player2_move, player1_score, player2_score) # подсчет очков

        # Вывод текущего счета
        logger.info(f"Счет: Игрок 1 - {player1_score}, Игрок 2 - {player2_score}") # логгирование счета


    # Определение победителя и вывод сообщения
    if player1_score >= 10: # проверка победителя
        logger.info("ПЕРВЫЙ ИГРОК ПОБЕДИЛ") # логгирование победителя
    else:
        logger.info("ВТОРОЙ ИГРОК ПОБЕДИЛ") # логгирование победителя

def get_player_move(player_number: int) -> int | None:
    """
    Запрашивает и возвращает ход игрока.

    :param player_number: Номер игрока (1 или 2).
    :return: Ход игрока (1, 2 или 3), или None в случае ошибки ввода.
    """
    while True:
        try:
            move = int(input(f"Ход игрока {player_number} (1-бросок, 2-защита, 3-пас): ")) # запрос хода игрока
            if move < 1 or move > 3:
                logger.error("Неверный ввод! Введите число от 1 до 3") # логгирование ошибки ввода
                print("Неверный ввод! Введите число от 1 до 3")
                continue
            return move
        except ValueError:
            logger.error("Неверный ввод! Введите число от 1 до 3")  # логгирование ошибки ввода
            print("Неверный ввод! Введите число от 1 до 3")
            continue


def calculate_scores(player1_move: int, player2_move: int, player1_score: int, player2_score: int) -> tuple[int, int]:
    """
    Определяет и начисляет очки в зависимости от ходов игроков.

    :param player1_move: Ход первого игрока.
    :param player2_move: Ход второго игрока.
    :param player1_score: Текущий счет первого игрока.
    :param player2_score: Текущий счет второго игрока.
    :return: Обновленный счет обоих игроков.
    """
    if player1_move == SHOT and player2_move == SAVE: # проверка условия для начисления очков
        player2_score += 1
    elif player1_move == SHOT and player2_move == PASS: # проверка условия для начисления очков
        player1_score += 2
    elif player1_move == SAVE and player2_move == SHOT: # проверка условия для начисления очков
        player1_score += 1
    elif player1_move == SAVE and player2_move == PASS: # проверка условия для начисления очков
        player1_score += 1
    elif player1_move == PASS and player2_move == SHOT: # проверка условия для начисления очков
        player2_score += 2
    elif player1_move == PASS and player2_move == SAVE: # проверка условия для начисления очков
        player2_score += 1

    return player1_score, player2_score


if __name__ == "__main__":
    play_hockey_game() # запуск игры

"""
Объяснение кода:
1. **Инициализация переменных**:
   - `player1_score = 0`: Инициализирует счет первого игрока нулем.
   - `player2_score = 0`: Инициализирует счет второго игрока нулем.
2. **Основной игровой цикл `while player1_score < 10 and player2_score < 10:`**:
   - Цикл продолжается до тех пор, пока счет хотя бы одного из игроков не достигнет 10.
   - **Ввод ходов игроков**:
     - Запрашивает ввод хода у первого игрока (1 - бросок, 2 - защита, 3 - пас) и сохраняет его в `player1_move`.
     - Запрашивает ввод хода у второго игрока (1 - бросок, 2 - защита, 3 - пас) и сохраняет его в `player2_move`.
     - **Обработка исключений**:
     - Блоки `try-except` обрабатывают возможные ошибки ввода. Если пользователь введет не целое число, то будет выведено сообщение об ошибке.
   - **Проверка и начисление очков**:
     - `if player1_move == 1 and player2_move == 2`: Если первый игрок бросает, а второй защищается, то счет второго игрока увеличивается на 1.
     - `elif player1_move == 1 and player2_move == 3`: Если первый игрок бросает, а второй пасует, то счет первого игрока увеличивается на 2.
     - `elif player1_move == 2 and player2_move == 1`: Если первый игрок защищается, а второй бросает, то счет первого игрока увеличивается на 1.
     - `elif player1_move == 2 and player2_move == 3`: Если первый игрок защищается, а второй пасует, то счет первого игрока увеличивается на 1.
     - `elif player1_move == 3 and player2_move == 1`: Если первый игрок пасует, а второй бросает, то счет второго игрока увеличивается на 2.
     - `elif player1_move == 3 and player2_move == 2`: Если первый игрок пасует, а второй защищается, то счет второго игрока увеличивается на 1.
   - **Вывод текущего счета**:
     - `print(f"Счет: Игрок 1 - {player1_score}, Игрок 2 - {player2_score}")`: Выводит текущий счет игроков.
3. **Определение победителя**:
   - `if player1_score >= 10`: Проверяет, достиг ли счет первого игрока 10 или более.
     - `print("ПЕРВЫЙ ИГРОК ПОБЕДИЛ")`: Выводит сообщение о победе первого игрока.
   - `else`: Если условие выше не выполнено, значит, победил второй игрок.
     - `print("ВТОРОЙ ИГРОК ПОБЕДИЛ")`: Выводит сообщение о победе второго игрока.
"""
```