## Ответ на Задачу No 171: Суммы квадратов цифр

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Необходимо найти сумму всех чисел `n` (0 < n < 10<sup>20</sup>), таких что сумма квадратов их цифр `f(n)` является точным квадратом.
*   Задача подразумевает проверку огромного количества чисел. Прямой перебор всех чисел невозможен из-за ограничений по времени.
*   Необходимо найти закономерности или свойства, которые помогут нам ограничить поиск или оптимизировать вычисления.

**Решение:**

1.  **Ограничение диапазона:** Сумма квадратов цифр растет медленнее, чем само число. Максимальное значение f(n) для 20-значного числа, каждая цифра которого 9, равно 20 * 9<sup>2</sup> = 1620.  Это означает, что нам нужно проверить только, является ли одно из чисел до 1620 точным квадратом.
2.  **Перебор чисел:** Мы можем перебрать все числа в допустимом диапазоне (0 < n < 10<sup>20</sup>), но это займет неприемлемое время.
3.  **Обратный подход:** Вместо перебора всех чисел n, мы переберем все возможные суммы квадратов цифр (точные квадраты) и проверим, существуют ли числа n, у которых f(n) равно этим квадратам.
4.  **Ограничение суммы квадратов:** Максимальная сумма квадратов цифр для 20-значного числа это 20*9<sup>2</sup> = 1620. Значит, мы можем перебрать все квадраты меньше 1620.  Например, 1<sup>2</sup>, 2<sup>2</sup>, 3<sup>2</sup>.... 40<sup>2</sup> = 1600.
5.  **Поиск чисел с заданной суммой квадратов цифр:** Для каждого точного квадрата (от 1 до 1600) нужно найти все числа, у которых сумма квадратов цифр равна этому квадрату. Это можно сделать с помощью рекурсивной функции. Мы будем генерировать все возможные числа, у которых сумма квадратов цифр равна нашему точного квадрату.
6.  **Оптимизация поиска:** У нас есть рекурсивный поиск, для которого нужно сделать оптимизацию - не считать рекурсию если текущая сумма квадратов цифр больше необходимого точного квадрата. И также если текущая глубина рекурсии больше 20 - также выходим из рекурсии.
7.  **Суммирование результатов:** При нахождении каждого числа, удовлетворяющего условию, добавляем его к общей сумме.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать переменную `total_sum` со значением 0.
3.  Перебрать все точные квадраты `square` от 1 до 40^2 включительно:
    *  Инициализировать рекурсивную функцию `find_numbers` со следующими параметрами:
        *   `current_sum` = 0 (текущая сумма квадратов цифр)
        *   `current_number` = 0 (текущее число)
        *   `target_sum` = `square` (искомая сумма квадратов цифр)
    * Внутри рекурсивной функции `find_numbers`:
        1.  Если  `current_sum` > `target_sum` или глубина рекурсии больше 20, то выйти из рекурсии
        2.  Если `current_sum` == `target_sum` и `current_number` > 0,  то добавить `current_number` к `total_sum`.
        3.  Для каждой цифры от 0 до 9:
            *   Рекурсивно вызвать функцию `find_numbers` с обновленными параметрами:
                *   `current_sum` + квадрат текущей цифры
                *   `current_number` \* 10 + текущая цифра
                *   `target_sum`
4.  Вернуть `total_sum`
5.  Конец

### 3. Реализация на Python 3.12
```python
def find_numbers(current_sum, current_number, target_sum, total_sum_holder):
    if current_sum > target_sum or len(str(current_number)) > 20:
        return

    if current_sum == target_sum and current_number > 0:
        total_sum_holder[0] += current_number
        return

    for digit in range(10):
        find_numbers(current_sum + digit**2, current_number * 10 + digit, target_sum, total_sum_holder)

def sum_numbers_with_square_digit_sum():
    total_sum = [0]
    for i in range(1, 41):
        square = i**2
        find_numbers(0, 0, square, total_sum)
    return total_sum[0]


result = sum_numbers_with_square_digit_sum()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeTotalSum((Инициализировать total_sum = 0))
    InitializeTotalSum --> LoopSquaresStart((Начать цикл: square от 1 до 1600))
    LoopSquaresStart --> CallFindNumbers((Вызвать find_numbers(0, 0, square, total_sum)))
    
    subgraph find_numbers
    A((Начало find_numbers)) --> CheckBaseCase((Проверить: current_sum > target_sum ИЛИ глубина > 20))
    CheckBaseCase -- Да --> B((Вернуться))
    CheckBaseCase -- Нет --> CheckSumMatch((Проверить: current_sum == target_sum и current_number > 0))
    CheckSumMatch -- Да --> AddNumberToSum((total_sum += current_number))
    AddNumberToSum --> B
    CheckSumMatch -- Нет --> LoopDigitsStart((Начать цикл: digit от 0 до 9))
    LoopDigitsStart --> RecursiveCall((Вызвать find_numbers(current_sum + digit^2, current_number*10 + digit, target_sum, total_sum)))
    RecursiveCall --> LoopDigitsStart
    LoopDigitsStart --> B
    end
    
    CallFindNumbers --> LoopSquaresStart
    LoopSquaresStart --> End((Конец))
    End --> ReturnTotalSum((Вернуть total_sum))
```

**Legenda:**

*   **Начало, Конец:** Начало и конец основной программы.
*   **Инициализировать total\_sum:**  Создание переменной для хранения суммы всех подходящих чисел и присваивание ей начального значения 0.
*   **Начать цикл: square от 1 до 1600:**  Цикл перебирает все квадраты от 1 до 1600 (максимальной суммы квадратов цифр для 20-значного числа).
*   **Вызвать find\_numbers(0, 0, square, total\_sum):**  Вызов рекурсивной функции для поиска чисел, у которых сумма квадратов цифр равна текущему `square`.
*   **Начало find\_numbers:** Начало рекурсивной функции.
*    **Проверить: current_sum > target_sum ИЛИ глубина > 20:**  Проверяет условия выхода из рекурсии.
*    **Вернуться:** Выход из рекурсии.
*    **Проверить: current_sum == target_sum и current_number > 0:** Проверка соответствия суммы квадратов цифр итоговой сумме.
*    **total_sum += current_number:** Добавление найденного числа к общей сумме.
*   **Начать цикл: digit от 0 до 9:** Цикл перебирает все цифры от 0 до 9 для генерации новых чисел в рекурсии.
*   **Вызвать find\_numbers(current\_sum + digit^2, current\_number\*10 + digit, target\_sum, total\_sum):** Рекурсивный вызов функции с обновленной суммой квадратов цифр и новым числом.
*    **Вернуть total\_sum:** Возврат общей суммы всех найденных чисел.
