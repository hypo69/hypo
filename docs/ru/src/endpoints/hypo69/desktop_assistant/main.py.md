# Модуль `main.py`

## Обзор

Модуль `main.py` представляет собой основной файл FastAPI-приложения, которое выполняет роль десктопного ассистента. Он включает в себя настройку CORS, определение моделей запросов, интеграцию с Google Generative AI для обработки чата, обслуживание статических файлов (HTML, JSON) и запуск локального сервера.

## Подробней

Этот модуль является отправной точкой для запуска десктопного ассистента. Он обрабатывает HTTP-запросы, взаимодействует с AI-моделями для генерации ответов и предоставляет интерфейс для взаимодействия с пользователем через веб-интерфейс.
Код разбит на несколько логических блоков:
1. **Импорт необходимых библиотек и модулей**:  Импортируются библиотеки, такие как `fastapi`, `uvicorn`, `pydantic`, а также пользовательские модули `src.gs`, `src.logger` и `src.ai`.
2. **Определение путей**:  Определяются пути к каталогам с шаблонами (`templates`) и файлами локализации (`locales`).
3. **Настройка FastAPI**:  Создается экземпляр FastAPI-приложения и настраивается CORS для разрешения запросов с любых источников.
4. **Определение модели запроса `ChatRequest`**:  Определяется класс `ChatRequest` для валидации входящих запросов чата.
5. **Определение глобальных переменных**:  Определяются глобальные переменные, такие как `model` (экземпляр AI-модели), `api_key` и `system_instruction`.
6. **Определение маршрутов**:  Определяются маршруты для обработки корневого запроса (`/`), запросов чата (`/api/chat`) и запросов локализации (`/locales/{lang}.json`).
7. **Запуск локального сервера**:  При запуске скрипта напрямую запускается локальный сервер Uvicorn.

## Классы

### `ChatRequest`

**Описание**:
Класс `ChatRequest` является моделью данных Pydantic, используемой для валидации входящих запросов в конечной точке `/api/chat`. Он содержит поле `message`, которое представляет собой сообщение от пользователя.

**Как работает класс**:
Класс `ChatRequest` наследуется от `BaseModel` из библиотеки `pydantic` и определяет структуру данных для запросов чата. Он содержит одно поле `message` типа `str`, которое обязательно должно присутствовать в запросе. Pydantic автоматически валидирует входящие данные на соответствие этой структуре.

**Параметры**:
- `message` (str): Сообщение от пользователя.

**Примеры**:

```python
from pydantic import BaseModel

class ChatRequest(BaseModel):
    message: str

# Пример создания экземпляра класса
request = ChatRequest(message="Привет, как дела?")
print(request.message) # Вывод: Привет, как дела?
```

## Функции

### `root`

```python
@app.get("/", response_class=HTMLResponse)
async def root():
    """
    Возвращает содержимое файла `index.html` в качестве ответа.

    Args:
        None

    Returns:
        HTMLResponse: HTML-контент из файла `index.html`.

    Raises:
        HTTPException: Если файл `index.html` не найден или произошла ошибка при чтении файла.

    Example:
        Чтобы получить HTML-контент главной страницы, выполните GET-запрос к корневому пути ("/").
    """
```

**Как работает функция**:
Функция `root` обрабатывает GET-запросы к корневому пути ("/"). Она пытается прочитать содержимое файла `index.html` из каталога `templates_path` и вернуть его в качестве HTML-ответа. Если файл не найден или возникает ошибка при чтении, функция генерирует исключение `HTTPException` с кодом состояния 500.

Внутри функции происходят следующие действия и преобразования:

1. **Определение пути к файлу `index.html`**: Определяется путь к файлу `index.html` с использованием `templates_path`.
2. **Проверка существования файла**: Проверяется, существует ли файл `index.html` по указанному пути. Если файл не существует, генерируется исключение `FileNotFoundError`.
3. **Чтение содержимого файла**: Если файл существует, его содержимое считывается в кодировке UTF-8.
4. **Возврат HTML-ответа**: Содержимое файла возвращается в виде HTML-ответа с использованием класса `HTMLResponse`.
5. **Обработка исключений**: Если в процессе чтения файла или проверки его существования возникают исключения, они перехватываются, логируются с использованием `logger.error`, и генерируется исключение `HTTPException` с кодом состояния 500 и детальным описанием ошибки.

### `chat`

```python
@app.post("/api/chat")
async def chat(request: ChatRequest):
    """
    Обрабатывает POST-запросы к эндпоинту `/api/chat`, взаимодействуя с AI-моделью для генерации ответа на сообщение пользователя.

    Args:
        request (ChatRequest): Объект `ChatRequest`, содержащий сообщение пользователя.

    Returns:
        dict: Словарь, содержащий сгенерированный AI-моделью ответ.

    Raises:
        HTTPException: Если AI-модель не инициализирована или произошла ошибка при взаимодействии с ней.

    Example:
        Чтобы отправить сообщение и получить ответ от AI-модели, выполните POST-запрос к эндпоинту `/api/chat` с JSON-телом, содержащим сообщение пользователя:
        {"message": "Hello, AI!"}
    """
```

**Как работает функция**:
Функция `chat` обрабатывает POST-запросы к эндпоинту `/api/chat`. Она принимает объект `ChatRequest`, содержащий сообщение пользователя, и использует AI-модель для генерации ответа на это сообщение. Если AI-модель еще не инициализирована, функция создает экземпляр класса `GoogleGenerativeAI` с использованием API-ключа и имени модели. Затем функция вызывает метод `chat` AI-модели для получения ответа и возвращает его в виде JSON-словаря. Если в процессе обработки запроса возникают ошибки, функция логирует их и генерирует исключение `HTTPException` с кодом состояния 500.

Внутри функции происходят следующие действия и преобразования:

1. **Проверка инициализации AI-модели**: Проверяется, инициализирована ли глобальная переменная `model`. Если `model` равна `None`, это означает, что AI-модель еще не была создана.
2. **Инициализация AI-модели**: Если `model` не инициализирована, создается экземпляр класса `GoogleGenerativeAI` с использованием API-ключа `api_key` и имени модели `gemini-2.0-flash-exp`.
3. **Получение ответа от AI-модели**: Вызывается метод `chat` AI-модели с сообщением пользователя, содержащимся в объекте `request`. Результат вызова сохраняется в переменной `response`.
4. **Возврат ответа**: Ответ от AI-модели возвращается в виде JSON-словаря с ключом `"response"`.
5. **Обработка исключений**: Если в процессе инициализации AI-модели или получения ответа возникают исключения, они перехватываются, логируются с использованием `logger.error`, и генерируется исключение `HTTPException` с кодом состояния 500 и детальным описанием ошибки.

### `get_locale_file`

```python
def get_locale_file(lang: str):
    """
    Загружает файл локализации для указанного языка.

    Args:
        lang (str): Код языка (например, "en", "ru").

    Returns:
        dict: Словарь с данными локализации из JSON-файла.

    Raises:
        HTTPException: Если файл локализации не найден, содержит ошибки JSON или произошла другая ошибка при чтении файла.

    Example:
        Чтобы получить словарь локализации для русского языка, вызовите функцию следующим образом:
        get_locale_file("ru")
    """
```

**Как работает функция**:
Функция `get_locale_file` загружает файл локализации для указанного языка. Она принимает код языка в качестве аргумента, формирует путь к файлу локализации на основе этого кода и пытается прочитать содержимое файла. Если файл успешно прочитан и содержит валидный JSON, функция возвращает словарь с данными локализации. Если файл не найден, содержит ошибки JSON или произошла другая ошибка при чтении файла, функция генерирует исключение `HTTPException` с соответствующим кодом состояния и детальным описанием ошибки.

Внутри функции происходят следующие действия и преобразования:

1. **Формирование пути к файлу локализации**: Формируется путь к файлу локализации на основе кода языка, используя `locales_path`.
2. **Чтение файла локализации**: Файл локализации открывается в режиме чтения с кодировкой UTF-8, и его содержимое считывается с использованием `json.load`.
3. **Возврат данных локализации**: Если файл успешно прочитан и содержит валидный JSON, словарь с данными локализации возвращается.
4. **Обработка исключений**: Если в процессе чтения файла или разбора JSON возникают исключения, они перехватываются, логируются с использованием `logger.error`, и генерируется исключение `HTTPException` с соответствующим кодом состояния и детальным описанием ошибки.

### `locales`

```python
@app.get("/locales/{lang}.json")
async def locales(lang: str):
    """
    Обрабатывает GET-запросы к эндпоинту `/locales/{lang}.json`, возвращая файл локализации для указанного языка.

    Args:
        lang (str): Код языка (например, "en", "ru").

    Returns:
        dict: Словарь с данными локализации из JSON-файла.

    Raises:
        HTTPException: Если файл локализации не найден, содержит ошибки JSON или произошла другая ошибка при чтении файла.

    Example:
        Чтобы получить файл локализации для русского языка, выполните GET-запрос к эндпоинту `/locales/ru.json`.
    """
```

**Как работает функция**:
Функция `locales` обрабатывает GET-запросы к эндпоинту `/locales/{lang}.json`. Она принимает код языка в качестве аргумента и вызывает функцию `get_locale_file` для получения файла локализации для этого языка. Результат вызова функции `get_locale_file` возвращается в качестве ответа на запрос. Если в процессе получения файла локализации возникают ошибки, функция `get_locale_file` генерирует исключение `HTTPException`, которое перехватывается FastAPI и возвращается клиенту в виде HTTP-ответа с соответствующим кодом состояния и детальным описанием ошибки.

Внутри функции происходят следующие действия и преобразования:

1. **Вызов функции `get_locale_file`**: Вызывается функция `get_locale_file` с кодом языка, полученным из URL-параметра `{lang}`.
2. **Возврат данных локализации**: Результат вызова функции `get_locale_file` (словарь с данными локализации) возвращается в качестве ответа на запрос.

## Запуск локального сервера

```python
if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)
```

**Описание**:
Этот блок кода запускает локальный сервер Uvicorn, если скрипт запускается напрямую (а не импортируется как модуль).

**Как работает**:
1.  `if __name__ == "__main__":`: Эта строка проверяет, является ли текущий файл точкой входа в программу. Если это так, то выполняется код внутри блока.
2.  `uvicorn.run(app, host="127.0.0.1", port=8000)`: Эта строка запускает сервер Uvicorn.
    *   `app`: Это экземпляр FastAPI-приложения, который будет обслуживаться сервером.
    *   `host="127.0.0.1"`: Это IP-адрес, на котором будет прослушивать сервер. `127.0.0.1` - это адрес локального хоста, то есть сервер будет доступен только на этом компьютере.
    *   `port=8000`: Это номер порта, на котором будет прослушивать сервер.

Таким образом, этот код запускает FastAPI-приложение на локальном сервере Uvicorn, который будет доступен по адресу `http://127.0.0.1:8000`.