from aiogram import Router, F
from aiogram.enums import ContentType
from aiogram.types import Message, CallbackQuery, LabeledPrice, PreCheckoutQuery
from sqlalchemy.ext.asyncio import AsyncSession
from bot.app.utils import generate_payment_link
from bot.config import bot, settings
from bot.dao.dao import UserDAO, CategoryDao, ProductDao, PurchaseDao
from bot.user.kbs import catalog_kb, product_kb, get_product_buy_youkassa, \
    get_product_buy_stars, get_product_buy_robocassa
from bot.user.schemas import TelegramIDModel, ProductCategoryIDModel, PaymentData
from bot.user.utils import successful_payment_logic

catalog_router = Router()


@catalog_router.callback_query(F.data == "catalog")
async def page_catalog(call: CallbackQuery, session_without_commit: AsyncSession):
    await call.answer("–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞...")
    try:
        await call.message.delete()
    except Exception as e:
        pass
    catalog_data = await CategoryDao.find_all(session=session_without_commit)

    await call.message.answer(
        text="–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ç–æ–≤–∞—Ä–æ–≤:",
        reply_markup=catalog_kb(catalog_data)
    )


@catalog_router.callback_query(F.data.startswith("category_"))
async def page_catalog_products(call: CallbackQuery, session_without_commit: AsyncSession):
    category_id = int(call.data.split("_")[-1])
    products_category = await ProductDao.find_all(session=session_without_commit,
                                                  filters=ProductCategoryIDModel(category_id=category_id))
    count_products = len(products_category)
    if count_products:
        await call.answer(f"–í –¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {count_products} —Ç–æ–≤–∞—Ä–æ–≤.")
        for product in products_category:
            product_text = (
                f"üì¶ <b>–ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:</b> {product.name}\n\n"
                f"üí∞ <b>–¶–µ–Ω–∞:</b> {product.price} —Ä—É–±.\n\n"
                f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n<i>{product.description}</i>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            )
            await call.message.answer(
                product_text,
                reply_markup=product_kb(product.id, product.price, 1)
            )
    else:
        await call.answer("–í –¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")


@catalog_router.callback_query(F.data.startswith('buy_'))
async def process_about(call: CallbackQuery, session_without_commit: AsyncSession):
    user_info = await UserDAO.find_one_or_none(
        session=session_without_commit,
        filters=TelegramIDModel(telegram_id=call.from_user.id)
    )
    _, payment_type, product_id, price = call.data.split('_')

    if payment_type == 'yukassa':
        await send_yukassa_invoice(call, user_info, product_id, price)
    elif payment_type == 'stars':
        await send_stars_invoice(call, user_info, product_id, 10)
    elif payment_type == 'robocassa':
        await send_robocassa_invoice(call, user_info, product_id, price, session_without_commit)

    await call.message.delete()


async def send_yukassa_invoice(call, user_info, product_id, price):
    await bot.send_invoice(
        chat_id=call.from_user.id,
        title=f'–û–ø–ª–∞—Ç–∞ üëâ {price}‚ÇΩ',
        description=f'–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –≤ —Ä–∞–∑–º–µ—Ä–µ {price}‚ÇΩ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–æ—Å—Ç—É–ø –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ç–æ–≤–∞—Ä—É.',
        payload=f"yukassa_{user_info.id}_{product_id}",
        provider_token=settings.PROVIDER_TOKEN,
        currency='rub',
        prices=[LabeledPrice(
            label=f'–û–ø–ª–∞—Ç–∞ {price}',
            amount=int(price) * 100
        )],
        reply_markup=get_product_buy_youkassa(price)
    )


async def send_robocassa_invoice(call, user_info, product_id, price, session: AsyncSession):
    pay_id = await PurchaseDao.get_next_id(session=session)
    text = f'–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –≤ —Ä–∞–∑–º–µ—Ä–µ {price}‚ÇΩ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–æ—Å—Ç—É–ø –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ç–æ–≤–∞—Ä—É.'
    description = f"–û–ø–ª–∞—Ç–∞ –∑–∞ —Ç–æ–≤–∞—Ä: ID {user_info.id} ({price}‚ÇΩ)"
    payment_link = generate_payment_link(cost=float(price), number=pay_id, description=description,
                                         user_id=user_info.id, user_telegram_id=call.from_user.id,
                                         product_id=product_id)
    kb = get_product_buy_robocassa(price, payment_link)
    await call.message.answer(text, reply_markup=kb)


async def send_stars_invoice(call, user_info, product_id, stars_price):
    await bot.send_invoice(
        chat_id=call.from_user.id,
        title=f'–û–ø–ª–∞—Ç–∞ üëâ {stars_price} ‚≠ê',
        description=f'–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –≤ —Ä–∞–∑–º–µ—Ä–µ {stars_price} –∑–≤–µ–∑–¥, '
                    f'—á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–æ—Å—Ç—É–ø –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ç–æ–≤–∞—Ä—É.',
        payload=f"stars_{user_info.id}_{product_id}",
        provider_token="",
        currency='XTR',
        prices=[LabeledPrice(
            label=f'–û–ø–ª–∞—Ç–∞ {stars_price} ‚≠ê',
            amount=int(stars_price)
        )],
        reply_markup=get_product_buy_stars(stars_price)
    )


@catalog_router.pre_checkout_query(lambda query: True)
async def pre_checkout_query(pre_checkout_q: PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_q.id, ok=True)


@catalog_router.message(F.content_type == ContentType.SUCCESSFUL_PAYMENT)
async def successful_payment(message: Message, session_with_commit: AsyncSession):
    payment_info = message.successful_payment
    payment_type, user_id, product_id = payment_info.invoice_payload.split('_')

    if payment_type == 'stars':
        price = payment_info.total_amount
        currency = '‚≠ê'
    else:
        price = payment_info.total_amount / 100
        currency = '‚ÇΩ'

    payment_data = {
        'user_id': int(user_id),
        'payment_id': payment_info.telegram_payment_charge_id,
        'price': price,
        'product_id': int(product_id),
        'payment_type': payment_type
    }

    await successful_payment_logic(session=session_with_commit,
                                   payment_data=payment_data, currency=currency,
                                   user_tg_id=message.from_user.id, bot=bot)