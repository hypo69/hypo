# Анализ кода модуля orbit.py

**Качество кода**
6
- Плюсы
    - Код хорошо структурирован, с разделением на функции для моделирования и игрового процесса.
    - Используются константы для параметров симуляции, что облегчает настройку и понимание кода.
    - Есть обработка исключений для пользовательского ввода, что предотвращает сбои при некорректном вводе.
    - Код в целом соответствует заявленной логике игры.

- Минусы
    - Отсутствует документация в формате reStructuredText (RST).
    - Не используются `j_loads` или `j_loads_ns` для чтения файлов (хотя в данном случае чтения файлов и нет, требование должно соблюдаться).
    - Не используется логирование ошибок через `src.logger.logger`.
    - Код можно улучшить, добавив более подробные комментарии, особенно в функции симуляции.
    - Некоторые проверки в симуляции можно сделать более гибкими и понятными (например, условие стабильной орбиты).
    - Отсутствие проверки на выход за границы при рассчете расстояния (используется x и y напрямую, не учитывая дистанцию).

**Рекомендации по улучшению**

1.  **Документация**:
    - Добавить docstring в формате RST для всех функций, классов и модуля.
    - Включить подробное описание параметров и возвращаемых значений.
2.  **Импорты**:
    - Добавить необходимые импорты (например, `from src.logger.logger import logger` ).
    - Убедиться, что все импорты соответствуют ранее обработанным файлам.
3.  **Обработка ошибок**:
    - Использовать `logger.error` для логирования ошибок вместо стандартных `print` и `try-except` блоков, где это уместно.
4.  **Рефакторинг**:
    -  Уточнить условие стабильной орбиты.
    -  Улучшить читаемость и гибкость кода.
5.  **Комментарии**:
    - Добавить более подробные комментарии, объясняющие логику работы каждого блока кода.
6. **Формат кода**:
    - Переписать все комментарии в формате reStructuredText (RST).

**Оптимизированный код**

```python
"""
Модуль для симуляции орбиты космического корабля.
==================================================

Этот модуль содержит функции для моделирования движения космического корабля
вокруг планеты и реализации текстовой игры, в которой игрок пытается вывести
корабль на стабильную орбиту, вводя начальную скорость и угол.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

   if __name__ == "__main__":
        play_orbit_game()
"""
import math
from src.logger.logger import logger

# Константы для симуляции
INITIAL_X = 100  #: Начальная координата X
INITIAL_Y = 0   #: Начальная координата Y
TIME_STEP = 0.1   #: Шаг времени для симуляции
ORBIT_TOLERANCE = 10  #: Допустимое отклонение для определения стабильной орбиты
MAX_STEPS = 1000  #: Максимальное количество шагов симуляции
MAX_TRIES = 10  #: Максимальное количество попыток

def simulate_orbit(initial_velocity: float, initial_angle: float) -> bool:
    """
    Моделирует орбиту космического корабля вокруг планеты.

    :param initial_velocity: Начальная скорость корабля.
    :type initial_velocity: float
    :param initial_angle: Начальный угол направления корабля в градусах.
    :type initial_angle: float
    :return: True, если орбита установлена; False в противном случае.
    :rtype: bool
    """
    # Преобразуем угол из градусов в радианы
    angle_in_radians = math.radians(initial_angle)

    # Вычисляем компоненты начальной скорости
    velocity_x = initial_velocity * math.cos(angle_in_radians)
    velocity_y = initial_velocity * math.sin(angle_in_radians)

    # Начальные координаты
    x = INITIAL_X
    y = INITIAL_Y
    
    # Переменные для проверки стабильной орбиты
    last_distance = 0
    orbit_count = 0
    
    # Моделирование движения
    for step in range(MAX_STEPS):
        # Рассчитываем расстояние до планеты
        distance = math.sqrt(x * x + y * y)

        # Рассчитываем ускорение (гравитация)
        acceleration_x = -x / (distance ** 3)
        acceleration_y = -y / (distance ** 3)

        # Обновляем скорость
        velocity_x += acceleration_x * TIME_STEP
        velocity_y += acceleration_y * TIME_STEP

        # Обновляем позицию
        x += velocity_x * TIME_STEP
        y += velocity_y * TIME_STEP

        # Проверяем стабильность орбиты.
        if abs(distance - last_distance) < ORBIT_TOLERANCE:
           orbit_count += 1
        else:
           orbit_count = 0
        
        if orbit_count > 50: # Проверяем, что у нас 50 раз подряд расстояние не меняется.
            return True # Орбита стабильна

        last_distance = distance
        
        # Проверка выхода за рамки
        if abs(x) > 500 or abs(y) > 500:
            return False
    
    return False # Не удалось установить орбиту
   
def play_orbit_game():
    """
    Запускает игру по моделированию орбиты.
    """
    
    number_of_tries = 0

    while number_of_tries < MAX_TRIES:
        number_of_tries += 1
        
        try:
            # Запрашиваем у пользователя начальную скорость и угол
            initial_velocity = float(input("Введите начальную скорость (например, 5): "))
            initial_angle = float(input("Введите начальный угол в градусах (например, 45): "))
        except ValueError as e:
            # Логируем ошибку ввода
            logger.error(f"Некорректный ввод: {e}", exc_info=True)
            print("Пожалуйста, введите корректные числовые значения.")
            continue

        # Запускаем моделирование
        orbit_established = simulate_orbit(initial_velocity, initial_angle)

        if orbit_established:
            print("ORBIT ESTABLISHED")
            return  # Завершаем игру
        else:
             print("FAILED")
    print("GAME OVER")


# Запускаем игру, только если скрипт исполняется напрямую.
if __name__ == "__main__":
    play_orbit_game()

"""
Объяснение кода:

1. **Импорт модуля `math` и `logger`**::
   - `import math`: Импортирует модуль `math`, который используется для математических операций, таких как `cos`, `sin`, `sqrt` и `radians`.
   - `from src.logger.logger import logger`: Импортирует логгер для записи ошибок.

2. **Константы**:
    - `INITIAL_X`, `INITIAL_Y`: Начальные координаты космического корабля.
    - `TIME_STEP`: Шаг времени для симуляции движения.
    - `ORBIT_TOLERANCE`: Допустимое отклонение в расстоянии для определения стабильной орбиты.
    - `MAX_STEPS`: Максимальное количество шагов симуляции, для предотвращения бесконечного цикла.
    - `MAX_TRIES`: Максимальное количество попыток для пользователя вывести корабль на орбиту.
    
3. **Функция `simulate_orbit(initial_velocity, initial_angle)`**:
    -   `angle_in_radians = math.radians(initial_angle)`: Преобразует угол из градусов в радианы, так как тригонометрические функции в Python работают с радианами.
    -   `velocity_x = initial_velocity * math.cos(angle_in_radians)`: Вычисляет начальную компоненту скорости по оси X.
    -   `velocity_y = initial_velocity * math.sin(angle_in_radians)`: Вычисляет начальную компоненту скорости по оси Y.
    -   `x = INITIAL_X`, `y = INITIAL_Y`: Устанавливает начальные координаты корабля.
    -   **Цикл симуляции**:
        -   `for step in range(MAX_STEPS)`:  Цикл, который моделирует движение космического корабля в течение `MAX_STEPS` шагов.
        -   `distance = math.sqrt(x * x + y * y)`: Вычисляет расстояние от корабля до центра планеты.
        -   `acceleration_x = -x / (distance ** 3)`: Вычисляет ускорение по оси X (гравитационное притяжение).
        -   `acceleration_y = -y / (distance ** 3)`: Вычисляет ускорение по оси Y (гравитационное притяжение).
        -   `velocity_x += acceleration_x * TIME_STEP`: Обновляет скорость по оси X.
        -   `velocity_y += acceleration_y * TIME_STEP`: Обновляет скорость по оси Y.
        -   `x += velocity_x * TIME_STEP`: Обновляет координату X.
        -   `y += velocity_y * TIME_STEP`: Обновляет координату Y.
        -   **Проверка стабильной орбиты**:
            -   `if abs(distance - last_distance) < ORBIT_TOLERANCE:`: Проверяет, изменилось ли расстояние до центра планеты на допустимое значение.
            -   `orbit_count += 1` увеличиваем счетчик если расстояние в пределах допуска.
            -   `else: orbit_count = 0`: сбрасываем счетчик, если расстояние меняется.
            -   `if orbit_count > 50`: Проверяет, что у нас 50 раз подряд расстояние не меняется.
            -   `return True`: Возвращает `True`, если корабль вышел на стабильную орбиту.
        -   `last_distance = distance`: запоминаем последнее значение расстояния.
        -   **Проверка выхода за рамки**:
            -   `if abs(x) > 500 or abs(y) > 500`: Проверяет, не вышел ли корабль за рамки моделирования.
            -   `return False`: Возвращаем `False`, если корабль вышел за рамки.
    -  `return False`:  Возвращает `False`, если орбита не была установлена за `MAX_STEPS` шагов.

4.  **Функция `play_orbit_game()`**:
    -   `number_of_tries = 0`: Инициализирует счетчик попыток пользователя.
    -   **Цикл `while number_of_tries < MAX_TRIES`**: Цикл, который продолжается, пока число попыток не достигнет `MAX_TRIES`.
    -   `number_of_tries += 1`: Увеличивает счетчик попыток.
    -   `try...except ValueError`: Обработка исключений, если пользователь ввел некорректное значение.
    -   `initial_velocity = float(input("Введите начальную скорость (например, 5): "))`: Запрашивает у пользователя ввод начальной скорости.
    -   `initial_angle = float(input("Введите начальный угол в градусах (например, 45): "))`: Запрашивает у пользователя ввод начального угла в градусах.
    -   `orbit_established = simulate_orbit(initial_velocity, initial_angle)`: Вызывает функцию `simulate_orbit` для моделирования орбиты.
    -   `if orbit_established: print("ORBIT ESTABLISHED"); return`: Если орбита установлена, выводится сообщение и игра заканчивается.
    -   `else: print("FAILED")`: Если орбита не установлена, выводится сообщение о неудаче.
    -   `print("GAME OVER")`: Выводится в конце игры, если не удалось вывести на орбиту за `MAX_TRIES` попыток.

5.  **Запуск игры**:
    -   `if __name__ == "__main__":`: Проверяет, запущен ли скрипт напрямую.
    -   `play_orbit_game()`: Вызывает функцию `play_orbit_game` для начала игры.
"""
```