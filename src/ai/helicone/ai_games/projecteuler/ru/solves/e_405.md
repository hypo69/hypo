## Ответ на Задачу No 405: A Rectangular tiling

### 1. Анализ задачи и решение
**Понимание задачи:**
* Задача требует найти количество способов замощения прямоугольника размером 2n x n плитками 1x2 и 2x1.
*  Нам нужно найти T(10^12) по модулю 10^10, где T(n) — количество способов замощения прямоугольника 2n x n.
*  Для маленьких n, можно найти T(n), но для больших значений это неэффективно.
*  Необходимо найти рекуррентное соотношение для T(n) и использовать матричное возведение в степень для вычисления T(10^12).

**Решение:**

1.  **Рекуррентное соотношение:**
    Известно, что T(n) удовлетворяет рекуррентному соотношению:
    `T(n) = 4 * T(n-1) - T(n-2)` для `n >= 2`, при этом  `T(0) = 1, T(1) = 1`
    Можно также выразить через начальные значения T(1) = 1, T(2) = 3
2.  **Матричное представление:**
    Представим рекуррентное соотношение в матричном виде. Пусть `V(n) = [T(n), T(n-1)]`. Тогда:
    `V(n) = M * V(n-1)`, где `M = [[4, -1], [1, 0]]`.
    Для перехода от `V(1)` к `V(n)` необходимо возвести матрицу `M` в степень `n-1`.
    `V(n) = M^(n-1) * V(1)`, где `V(1) = [T(1), T(0)] = [1, 1]`.
3.  **Матричное возведение в степень:**
    Используем алгоритм бинарного возведения в степень для матрицы M. Это позволяет вычислить M^(n-1) за логарифмическое время.
4.  **Вычисление T(10^12):**
     Находим M^(10^12-1) и умножаем на V(1) для получения V(10^12)
    Извлекаем T(10^12) из V(10^12) и берем остаток по модулю 10^10.
### 2. Алгоритм решения
1. Начать
2. Инициализировать матрицу `M = [[4, -1], [1, 0]]` и вектор `V = [1, 1]`.
3. Определить функцию `matrix_multiply(A, B)` для умножения двух матриц.
4. Определить функцию `matrix_power(matrix, power)` для возведения матрицы в степень.
  * Если степень равна 0, вернуть единичную матрицу.
  * Если степень четная, рекурсивно возвести матрицу в степень `power / 2`, а затем умножить результат на себя.
  * Если степень нечетная, рекурсивно возвести матрицу в степень `power - 1`, а затем умножить результат на исходную матрицу.
5. Вычислить матрицу `M_powered = matrix_power(M, 10^12 - 1)`.
6. Вычислить вектор `V_result = matrix_multiply(M_powered, V)`
7. Извлечь  T(10^12) из  `V_result[0]`
8. Взять остаток от деления  `T(10^12)` на 10^10.
9. Вывести  `T(10^12) % 10^10`.
10. Конец

### 3. Реализация на Python 3.12
```python
def matrix_multiply(A, B, mod):
    """Умножение двух матриц."""
    rows_A = len(A)
    cols_A = len(A[0])
    cols_B = len(B[0])
    C = [[0 for _ in range(cols_B)] for _ in range(rows_A)]
    for i in range(rows_A):
        for j in range(cols_B):
            for k in range(cols_A):
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod
    return C

def matrix_power(matrix, power, mod):
    """Возведение матрицы в степень."""
    if power == 0:
        return [[1, 0], [0, 1]]
    if power % 2 == 0:
        half_power = matrix_power(matrix, power // 2, mod)
        return matrix_multiply(half_power, half_power, mod)
    else:
         half_power = matrix_power(matrix, power - 1, mod)
         return matrix_multiply(matrix, half_power, mod)


def solve():
    """Вычисляет последние 10 цифр T(10^12)."""
    mod = 10**10
    matrix_base = [[4, -1], [1, 0]]
    initial_vector = [[1], [1]]
    
    matrix_powered = matrix_power(matrix_base, 10**12 - 1, mod)
    result_vector = matrix_multiply(matrix_powered, initial_vector, mod)

    return result_vector[0][0]


result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitMatrixAndVector((Инициализировать матрицу M и вектор V))
    InitMatrixAndVector --> DefineMultiply((Определить функцию matrix_multiply))
    DefineMultiply --> DefinePower((Определить функцию matrix_power))
    DefinePower --> ComputeMatrixPower((Вычислить M^(10^12 - 1)))
    ComputeMatrixPower --> ComputeResultVector((Вычислить V_result = M^(10^12 - 1) * V))
    ComputeResultVector --> GetTFromVector((Извлечь T(10^12) из V_result))
    GetTFromVector --> ModuloOperation((Вычислить T(10^12) % 10^10))
    ModuloOperation --> OutputResult((Вывести T(10^12) % 10^10))
    OutputResult --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать матрицу M и вектор V:** Создаем матрицу `M` и вектор `V` с начальными значениями.
* **Определить функцию matrix_multiply:** Функция для умножения двух матриц.
* **Определить функцию matrix_power:** Функция для возведения матрицы в степень.
* **Вычислить M^(10^12 - 1):** Вычисляем матрицу M в степени 10^12 - 1, используя функцию matrix_power.
* **Вычислить V_result = M^(10^12 - 1) * V:** Вычисляем результирующий вектор, умножая матрицу M^(10^12 - 1) на вектор V, используя функцию matrix_multiply.
* **Извлечь T(10^12) из V_result:** Извлекаем значение T(10^12) из результирующего вектора.
* **Вычислить T(10^12) % 10^10:** Вычисляем остаток от деления T(10^12) на 10^10.
*  **Вывести T(10^12) % 10^10:** Выводим результат.
