# Анализ кода модуля `27_checkr.ru.md`

**Качество кода**
- Соответствие требованиям к формату кода (1-10):
  -   **Плюсы:**
    - Документ представляет собой Markdown, что соответствует заявленному формату `.md`.
    -  Текст написан на русском языке, как и требуется.
    -   Представлено подробное описание игры, инструкция по реализации, пример работы и возможные ограничения.
  -   **Минусы:**
    -  В коде отсутствует какой-либо программный код.  Файл представляет собой текстовое описание игры.
    -  Не используется reStructuredText (RST) для документации.
    -   Отсутствуют блоки кода на Python, что делает невозможным выполнение инструкций по работе с кодом.

**Рекомендации по улучшению**
1.  **Добавление кода:**  Необходимо добавить реализацию игры на Python, используя объектно-ориентированный подход.
2.  **Форматирование кода:**  Использовать reStructuredText для описания функций, методов и классов, когда будет добавлен код.
3.  **Логирование:** Добавить логирование с использованием `from src.logger.logger import logger` для отслеживания ошибок.
4.  **Обработка ошибок:**  Избегать общих блоков `try-except` и использовать `logger.error` для обработки ошибок.
5. **Адаптация к предыдущим файлам:** Учесть структуру кода из предыдущих файлов.
6. **Файл должен представлять собой не только описание, а и код:** Файл должен содержать код на Python, который реализует игру, а не только описание.

**Улучшенный код**
```markdown
### Название игры: **CHECKR** (Шашки)
# Модуль, описывающий логику игры в шашки.
# =========================================================================================
#
# Этот модуль содержит описание основных правил и структуры игры в шашки.
#
# Пример использования
# --------------------
#
# Пример использования описания:
#
# ```python
# # TODO:  Добавить пример использования после реализации.
# ```
#

#### Описание
**CHECKR** — это классическая игра в шашки, где игрок и компьютер поочередно делают ходы. Игрок управляет фигурами, которые обозначены "O", в то время как фигуры компьютера обозначены "X". Игра проходит на стандартной доске 8x8, где фигуры могут двигаться по диагонали. Цель игры — захватить все фигуры противника или заблокировать их так, чтобы они не могли двигаться.

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - В начале игры на доске размещаются фигуры:
     - Игрок управляет фигурами "O".
     - Компьютер управляет фигурами "X".
   - Игрок и компьютер делают ходы поочередно. Игрок начинает первым.

#### 2. **Основной цикл игры**
   - **Ход игрока:**
     1. Игрок вводит координаты фигуры, которую он хочет переместить, например, (3, 5).
     2. Затем игрок вводит координаты целевой клетки для перемещения, например, (4, 6).
     3. Программа проверяет, возможно ли выполнение хода. Если ход невозможен (например, если клетка занята), программа попросит игрока выбрать другой ход.
   
   - **Ход компьютера:**
     1. Компьютер делает свой ход по аналогии с игроком. Программа анализирует доску и выбирает оптимальное движение для своей фигуры.

   - **Победа:**
     - Игра продолжается до тех пор, пока один из игроков не останется без фигур или не заблокирует все фигуры противника.
     - Когда игрок или компьютер выигрывает, программа выводит сообщение о победе:
       ```
       ПОБЕДА! ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!
       ```

#### 3. **Подсчёт победителя**
   - Победителем становится тот, кто первым уничтожит все фигуры противника или заблокирует их так, что они не смогут двигаться.

#### 4. **Завершение игры**
   - После завершения игры программа предложит начать новую партию:
     ```
     Хотите сыграть снова? (да/нет)
     ```

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в игру Шашки!
   Вы играете за "O", компьютер за "X".
   Ваш ход.
   Введите координаты фигуры для перемещения (X,Y): 3,5
   Введите целевую клетку для перемещения (X,Y): 4,6
   ```

2. **После хода игрока:**
   ```
   Ход игрока: перемещена фигура с (3,5) на (4,6).
   Ход компьютера.
   ```

3. **Завершение игры:**
   ```
   ПОБЕДА! ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!
   Хотите сыграть снова? (да/нет)
   > нет
   Спасибо за игру!
   ```

---

### Возможные ограничения
- Компьютер не позволяет делать нелегальные ходы, такие как перескок через свою фигуру.
- Программа не поддерживает сложные варианты, такие как «двойные» или «тройные» прыжки, и может потерять фигуру, если игрок попытается выполнить такой ход.

---

### Реализация
Игра реализована с использованием базовых операций для перемещения фигур по доске и проверки валидности хода.

```python
from src.logger.logger import logger  # Добавлен импорт logger #
from typing import List, Tuple, Optional, Any  # Добавлен импорт typing

class Checkers:
    """
    Класс, реализующий игру в шашки.
    """
    def __init__(self):
        """
        Инициализирует доску и начальное положение фигур.
        """
        self.board = self._init_board() # Инициализация доски
        self.player_turn = True  # Начинает игрок
        self.player_pieces = 'O'  # Фигуры игрока
        self.computer_pieces = 'X'  # Фигуры компьютера

    def _init_board(self) -> List[List[Optional[str]]]:
         """
         Инициализирует доску для игры в шашки.

         :return: Игровое поле в виде списка списков, где None означает пустую клетку, 'O' - фигура игрока, 'X' - фигура компьютера
         """
         board = [[None for _ in range(8)] for _ in range(8)]
         for i in range(3):
             for j in range(8):
                if (i + j) % 2 != 0:
                    board[i][j] = 'X'
         for i in range(5,8):
             for j in range(8):
                 if (i + j) % 2 != 0:
                     board[i][j] = 'O'
         return board

    def print_board(self) -> None:
        """
        Выводит текущее состояние доски в консоль.
        """
        print("  0 1 2 3 4 5 6 7") # Вывод номеров колонок
        for i, row in enumerate(self.board): # итерация по строкам и индексам
            print(f"{i} {' '.join(str(piece) if piece else '_' for piece in row)}") # Вывод строки доски с форматированием

    def is_valid_move(self, start: Tuple[int, int], end: Tuple[int, int]) -> bool:
        """
        Проверяет, является ли ход допустимым.

        :param start: Координаты начальной позиции фигуры (строка, столбец).
        :param end: Координаты конечной позиции фигуры (строка, столбец).
        :return: True, если ход допустимый, иначе False.
        """
        start_row, start_col = start # Распаковка кортежа стартовой позиции
        end_row, end_col = end # Распаковка кортежа конечной позиции

        if not (0 <= start_row < 8 and 0 <= start_col < 8 and 0 <= end_row < 8 and 0 <= end_col < 8): # Проверка нахождения в пределах доски
            logger.error(f'Неверные координаты. Начальная позиция: {start}, конечная позиция: {end}.') # Запись ошибки в лог
            return False

        piece = self.board[start_row][start_col] # Получение фигуры
        if not piece: # Проверка наличия фигуры в стартовой позиции
             logger.error(f'Нет фигуры по координатам {start}.') # Запись ошибки в лог
             return False

        if self.player_turn and piece != self.player_pieces: # Проверка хода игрока
            logger.error(f'Нельзя переместить фигуру компьютера {piece} ходит игрок.')  # Запись ошибки в лог
            return False

        if not self.player_turn and piece != self.computer_pieces: # Проверка хода компьютера
            logger.error(f'Нельзя переместить фигуру игрока {piece} ходит компьютер.') # Запись ошибки в лог
            return False

        if self.board[end_row][end_col]: # Проверка занятости конечной позиции
            logger.error(f'Конечная позиция {end} занята.') # Запись ошибки в лог
            return False

        row_diff = abs(end_row - start_row) # Вычисление разницы по строкам
        col_diff = abs(end_col - start_col) # Вычисление разницы по столбцам

        if row_diff != 1 or col_diff != 1: # Проверка на перемещение по диагонали на одну клетку
            logger.error(f'Недопустимый ход. Движение должно быть по диагонали на одну клетку. Начальная позиция {start}, конечная {end}') # Запись ошибки в лог
            return False

        return True # Если все проверки пройдены, возвращается True

    def move_piece(self, start: Tuple[int, int], end: Tuple[int, int]) -> None:
        """
        Перемещает фигуру с начальной позиции на конечную.

        :param start: Координаты начальной позиции фигуры (строка, столбец).
        :param end: Координаты конечной позиции фигуры (строка, столбец).
        """
        start_row, start_col = start # Распаковка кортежа стартовой позиции
        end_row, end_col = end # Распаковка кортежа конечной позиции

        piece = self.board[start_row][start_col] # Получение фигуры
        self.board[start_row][start_col] = None # Очистка стартовой позиции
        self.board[end_row][end_col] = piece # Перемещение фигуры

    def make_computer_move(self) -> bool:
        """
        Определяет и выполняет ход компьютера.

        :return: True, если ход был сделан, иначе False.
        """
        for i in range(8):  # Цикл по строкам
            for j in range(8):  # Цикл по столбцам
                if self.board[i][j] == self.computer_pieces:  # Проверка наличия фигуры компьютера
                    for row_dir in [-1, 1]: # Цикл по возможным направлениям движения
                        for col_dir in [-1, 1]: # Цикл по возможным направлениям движения
                            new_row, new_col = i + row_dir, j + col_dir
                            if self.is_valid_move((i,j), (new_row, new_col)):  # Проверка допустимости хода
                                self.move_piece((i,j), (new_row, new_col)) # Выполнение хода
                                return True
        return False # Если нет допустимых ходов, возвращается False

    def check_winner(self) -> Optional[str]:
        """
         Проверяет, есть ли победитель.

         :return: 'O' если победил игрок, 'X' если победил компьютер, None если игра продолжается.
        """
        player_pieces_count = 0  # Инициализация счетчика фигур игрока
        computer_pieces_count = 0 # Инициализация счетчика фигур компьютера

        for row in self.board:  # Цикл по строкам
            for piece in row: # Цикл по фигурам
                if piece == self.player_pieces: # Проверка на фигуру игрока
                    player_pieces_count += 1  # Увеличение счетчика
                elif piece == self.computer_pieces:  # Проверка на фигуру компьютера
                    computer_pieces_count += 1 # Увеличение счетчика

        if player_pieces_count == 0: # Проверка на отсутствие фигур у игрока
            return 'X' # Возврат победителя компьютер
        if computer_pieces_count == 0: # Проверка на отсутствие фигур у компьютера
            return 'O' # Возврат победителя игрок

        if not self._can_player_move() and player_pieces_count > 0: # Проверка на отсутствие допустимых ходов у игрока
            return 'X' # Возврат победителя компьютер
        if not self._can_computer_move() and computer_pieces_count > 0: # Проверка на отсутствие допустимых ходов у компьютера
            return 'O' # Возврат победителя игрок

        return None # Игра продолжается

    def _can_player_move(self) -> bool:
        """
         Проверяет, есть ли допустимые ходы у игрока.

        :return: True, если есть хотя бы один допустимый ход, иначе False.
        """
        for i in range(8):  # Цикл по строкам
            for j in range(8):  # Цикл по столбцам
                if self.board[i][j] == self.player_pieces:  # Проверка наличия фигуры игрока
                    for row_dir in [-1, 1]: # Цикл по возможным направлениям движения
                        for col_dir in [-1, 1]: # Цикл по возможным направлениям движения
                             new_row, new_col = i + row_dir, j + col_dir
                             if self.is_valid_move((i, j), (new_row, new_col)):  # Проверка допустимости хода
                                 return True # Ход найден, возвращается True
        return False  # Нет допустимых ходов, возвращается False

    def _can_computer_move(self) -> bool:
        """
         Проверяет, есть ли допустимые ходы у компьютера.

        :return: True, если есть хотя бы один допустимый ход, иначе False.
        """
        for i in range(8):  # Цикл по строкам
            for j in range(8):  # Цикл по столбцам
                if self.board[i][j] == self.computer_pieces:  # Проверка наличия фигуры компьютера
                     for row_dir in [-1, 1]: # Цикл по возможным направлениям движения
                         for col_dir in [-1, 1]: # Цикл по возможным направлениям движения
                             new_row, new_col = i + row_dir, j + col_dir
                             if self.is_valid_move((i, j), (new_row, new_col)): # Проверка допустимости хода
                                return True # Ход найден, возвращается True
        return False # Нет допустимых ходов, возвращается False


    def play(self) -> None:
        """
        Запускает игровой процесс.
        """
        while True:
            self.print_board() # Вывод доски в консоль
            winner = self.check_winner() # Проверка победителя

            if winner: # Проверка наличия победителя
                if winner == 'O': # Проверка победителя игрок
                   print("ПОБЕДА! ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!")
                else: # Победил компьютер
                   print("ПОБЕДА! КОМПЬЮТЕР ЗАХВАТИЛ ВСЕ ФИГУРЫ!")
                break

            if self.player_turn:  # Ход игрока
                while True: # Цикл пока не сделан верный ход
                    try: # Защита от ошибок
                        start_str = input("Введите координаты фигуры для перемещения (X,Y): ") # Запрос координат
                        start_row, start_col = map(int, start_str.split(',')) # Преобразование ввода в int
                        end_str = input("Введите целевую клетку для перемещения (X,Y): ") # Запрос координат
                        end_row, end_col = map(int, end_str.split(',')) # Преобразование ввода в int
                        if self.is_valid_move((start_row,start_col), (end_row, end_col)): # Проверка валидности хода
                            self.move_piece((start_row, start_col), (end_row, end_col)) # Выполнение хода
                            break # Выход из цикла
                        else:
                           print("Недопустимый ход") # Вывод ошибки
                    except ValueError:
                        print("Неверный формат ввода") # Вывод ошибки
                    except Exception as ex:  # Обработка других исключений
                        logger.error(f'Ошибка при ходе игрока {ex=}') # Запись ошибки в лог
            else: # Ход компьютера
                print('Ход компьютера') # Сообщение о ходе
                if not self.make_computer_move(): # Выполнение хода компьютера
                    print("Компьютер не может сделать ход") # Сообщение если не может сделать ход
            self.player_turn = not self.player_turn # Смена хода

        while True:
            play_again = input("Хотите сыграть снова? (да/нет): ").lower()  # Запрос на новую игру
            if play_again in ['да', 'нет']:  # Проверка ввода
               break
            else:
              print('Неверный ввод') # Вывод ошибки

        if play_again == 'да':  # Запуск новой игры
            self.__init__()
            self.play()
        else:
            print('Спасибо за игру!') # Благодарность за игру

if __name__ == '__main__':
    game = Checkers()
    game.play()
```