# Модуль для реализации троттлинга сообщений в Telegram боте
=============================================================

Модуль содержит класс `ThrottlingMiddleware`, который используется для ограничения частоты отправки сообщений пользователями в Telegram боте.
Он предотвращает злоупотребления и обеспечивает более стабильную работу бота.

## Обзор

Этот модуль реализует механизм троттлинга (ограничения частоты) для входящих сообщений в Telegram-боте. 
Он использует `aiogram` для обработки сообщений и `cachetools` для хранения информации об ограничениях.

## Подробнее

Модуль предназначен для защиты Telegram-бота от злоупотреблений, таких как спам или флуд. Класс `ThrottlingMiddleware` перехватывает каждое входящее сообщение и проверяет, не превысил ли пользователь установленный лимит по частоте отправки сообщений. Если пользователь отправляет сообщения слишком часто, middleware не передает сообщение дальше на обработку, тем самым предотвращая нежелательные нагрузки на бот.

## Классы

### `ThrottlingMiddleware`

**Описание**: Middleware для ограничения частоты отправки сообщений в Telegram боте.

**Принцип работы**:
1.  При инициализации класса создается кэш `TTLCache`, который хранит информацию о том, когда пользователь отправил последнее сообщение.
2.  При получении нового сообщения, middleware проверяет, есть ли идентификатор чата пользователя в кэше.
3.  Если идентификатора нет в кэше, он добавляется, и сообщение передается дальше на обработку.
4.  Если идентификатор уже есть в кэше, это означает, что пользователь отправил сообщение слишком быстро, и сообщение не передается дальше.

**Атрибуты**:

*   `limit` (TTLCache): Кэш для хранения информации об ограничениях, где ключом является идентификатор чата, а значением - `None`.

**Методы**:

*   `__init__(time_limit: int = 2) -> None`: Инициализирует middleware с заданным временным лимитом.
*   `__call__(handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]], event: Message, data: Dict[str, Any]) -> Any`: Асинхронный метод, который вызывается для каждого входящего сообщения.

## Функции

### `__init__`

```python
def __init__(self, time_limit: int = 2) -> None:
    """
    Инициализирует middleware с заданным временным лимитом.

    Args:
        time_limit (int, optional): Временной лимит в секундах, в течение которого сообщения от одного и того же пользователя будут затроттлены. По умолчанию `2`.

    Returns:
        None

    """
```

**Назначение**: Инициализирует экземпляр класса `ThrottlingMiddleware` с заданным временным лимитом.

**Параметры**:

*   `time_limit` (int): Временной лимит в секундах, в течение которого сообщения от одного и того же пользователя будут затроттлены. По умолчанию равен 2 секундам.

**Возвращает**:
- `None`

**Как работает функция**:

1.  Создается экземпляр класса `TTLCache` из модуля `cachetools`.
2.  `TTLCache` инициализируется с максимальным размером 10000 элементов и временем жизни (TTL), равным `time_limit`.

**Примеры**:

```python
middleware = ThrottlingMiddleware(time_limit=3)
```

### `__call__`

```python
async def __call__(
        self,
        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
        event: Message,
        data: Dict[str, Any]
) -> Any:
    """
    Асинхронный метод, который вызывается для каждого входящего сообщения.

    Args:
        handler (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Функция-обработчик сообщения.
        event (Message): Объект сообщения от Telegram.
        data (Dict[str, Any]): Словарь с дополнительными данными.

    Returns:
        Any: Результат обработки сообщения обработчиком, если сообщение не затроттлено, иначе `None`.

    """
```

**Назначение**: Метод вызывается для каждого входящего сообщения и определяет, следует ли его обработать или затроттлить.

**Параметры**:

*   `handler` (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Функция-обработчик сообщения.
*   `event` (Message): Объект сообщения от Telegram.
*   `data` (Dict[str, Any]): Словарь с дополнительными данными.

**Возвращает**:

*   `Any`: Результат обработки сообщения обработчиком, если сообщение не затроттлено, иначе `None`.

**Как работает функция**:

1.  Проверяет, есть ли идентификатор чата (`event.chat.id`) в кэше `self.limit`.
2.  Если идентификатор чата уже есть в кэше, это означает, что пользователь отправил сообщение слишком быстро, и функция возвращает `None`, предотвращая дальнейшую обработку сообщения.
3.  Если идентификатора чата нет в кэше, он добавляется, и функция вызывает обработчик `handler` с аргументами `event` и `data`.

**Примеры**:

```python
async def my_handler(event: Message, data: Dict[str, Any]) -> None:
    print(f"Received message: {event.text}")

middleware = ThrottlingMiddleware(time_limit=2)
# Предположим, что event и data уже определены
result = await middleware(my_handler, event, data)
```
```
Проверка наличия ID чата в кэше
       │
       ├───> ID чата есть в кэше?
       │    │
       │    └───> Да: Возврат None (троттлинг)
       │
       └───> Нет: Добавление ID чата в кэш
            │
            └───> Вызов обработчика handler(event, data)