# Модуль `src.utils.file`

## Обзор

Модуль `src.utils.file` предоставляет набор утилит для работы с файлами, включая функции для сохранения, чтения и поиска текстовых файлов. Он поддерживает обработку больших файлов с использованием генераторов для экономии памяти.

## Подробнее

Этот модуль предназначен для упрощения операций с файлами в проекте `hypotez`. Он предоставляет удобные функции для чтения и записи текстовых данных, а также для поиска файлов по заданным критериям. Модуль использует стандартные библиотеки Python, такие как `os`, `json`, `fnmatch` и `pathlib`, а также модуль логирования `src.logger.logger` для записи информации об ошибках и событиях.

## Функции

### `save_text_file`

```python
def save_text_file(
    file_path: str | Path,
    data: str | list[str] | dict,
    mode: str = 'w'
) -> bool:
    """
    Сохраняет данные в текстовый файл.

    Args:
        file_path (str | Path): Путь к файлу для сохранения.
        data (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.
        mode (str, optional): Режим записи файла ('w' для записи, 'a' для добавления).
    Returns:
        bool: `True`, если файл успешно сохранен, `False` в противном случае.
    Raises:
        Exception: При возникновении ошибки при записи в файл.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> data = 'Пример текста'
        >>> result = save_text_file(file_path, data)
        >>> print(result)
        True
    """
```

**Назначение**: Сохраняет строковые данные, список строк или словарь в текстовый файл. Поддерживает указание режима записи (перезапись или добавление).

**Параметры**:
- `file_path` (str | Path): Путь к файлу, в который нужно сохранить данные.
- `data` (str | list[str] | dict): Данные для записи. Может быть строкой, списком строк или словарем. Если передан словарь, он будет сохранен в формате JSON.
- `mode` (str, optional): Режим открытия файла. По умолчанию `'w'` (запись). Можно указать `'a'` для добавления данных в конец файла.

**Возвращает**:
- `bool`: `True`, если данные успешно сохранены в файл, `False` в случае ошибки.

**Вызывает исключения**:
- `Exception`: Возникает при ошибках записи в файл, например, при отсутствии прав доступа или неверном пути.

**Как работает функция**:

1.  Преобразует `file_path` в объект `Path` для удобной работы с путями.
2.  Создает родительские директории, если они не существуют.
3.  Открывает файл в указанном режиме (`mode`) и кодировке (`utf-8`).
4.  В зависимости от типа данных (`data`):
    -   Если это список, записывает каждую строку из списка в файл с добавлением символа новой строки.
    -   Если это словарь, записывает его в файл в формате JSON с отступами для читаемости.
    -   Если это строка, записывает строку в файл.
5.  Возвращает `True` в случае успешной записи, `False` при возникновении ошибки.

**ASCII Flowchart**:

```
    Начало
    ↓
    Преобразование file_path в Path
    ↓
    Создание родительских директорий (если отсутствуют)
    ↓
    Открытие файла в заданном режиме и кодировке
    ↓
    Проверка типа данных: строка, список или словарь
    ├── Строка → Запись строки в файл
    ├── Список → Запись каждой строки списка в файл с новой строки
    └── Словарь → Запись словаря в файл в формате JSON
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример записи строки в файл
file_path = Path('example.txt')
data = 'Пример текста'
result = save_text_file(file_path, data)
print(result)  # Вывод: True

# Пример записи списка строк в файл
file_path = Path('example.txt')
data = ['Строка 1', 'Строка 2', 'Строка 3']
result = save_text_file(file_path, data)
print(result)  # Вывод: True

# Пример записи словаря в файл
file_path = Path('example.json')
data = {'ключ1': 'значение1', 'ключ2': 'значение2'}
result = save_text_file(file_path, data)
print(result)  # Вывод: True
```

### `read_text_file_generator`

```python
def read_text_file_generator(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    chunk_size: int = 8192,
    recursive: bool = False,
    patterns: Optional[str | list[str]] = None,
) -> Generator[str, None, None] | str | list[str] | None:
    """
    Читает содержимое файла(ов) или директории.

        Args:
            file_path (str | Path): Путь к файлу или директории.
            as_list (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода.
            extensions (list[str], optional): Список расширений файлов для включения при чтении директории.
            chunk_size (int, optional): Размер чанка для чтения файла в байтах.
            recursive (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно.
            patterns (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.

        Returns:
            Generator[str, None, None] | str | list[str] | None:
            - Если `as_list` is True и `file_path` является файлом, возвращает генератор строк.
            - Если `as_list` is True и `file_path` является директорией и `recursive` is True, возвращает список строк.
            - Если `as_list` is False и `file_path` является файлом, возвращает строку.
            - Если `as_list` is False и `file_path` является директорией, возвращает объединенную строку.
            - Возвращает `None` в случае ошибки.
        Raises:
            Exception: При возникновении ошибки при чтении файла.

        Example:
            >>> from pathlib import Path
            >>> file_path = Path('example.txt')
            >>> content = read_text_file(file_path)
            >>> if content:
            ...    print(f'File content: {content[:100]}...')
            File content: Пример текста...
    Функция read_text_file может возвращать несколько разных типов данных в зависимости от входных параметров:

    Возвращаемые значения:
    ----------------------

    - Generator[str, None, None] (Генератор строк):\
        Генератор при итерации выдаёт строки из файла(ов) по одной. Эффективно для работы с большими файлами, так как они не загружаются полностью в память.\
        - Когда:\
            file_path – это файл и as_list равен True.\
            file_path – это директория, recursive равен True и as_list равен True. При этом в генератор попадают строки из всех найденных файлов.\
            file_path – это директория, recursive равен False и as_list равен True. При этом в генератор попадают строки из всех найденных файлов в текущей директории.\
        
    - str (Строка):\
        Содержимое файла или объединенное содержимое всех файлов в виде одной строки.\
        - Когда:\
            file_path – это файл и as_list равен False.\
            file_path – это директория, recursive равен False и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории, разделенных символами новой строки (\\n).\
            file_path – это директория, recursive равен True и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории и её поддиректориях, разделенных символами новой строки (\\n).\
 \
    - list[str] (Список строк):\
        Этот тип явно не возвращается функцией, однако когда file_path – это директория, recursive равен True и as_list равен True - функция возвращает генератор, который можно преобразовать в список при помощи list()\
        - Когда:\
            file_path – не является ни файлом, ни директорией.\
            Произошла ошибка при чтении файла или директории (например, файл не найден, ошибка доступа и т.п.).\
    Note:\
        Если вы хотите прочитать содержимое файла построчно (особенно для больших файлов) используйте as_list = True. В этом случае вы получите генератор строк.\
        Если вы хотите получить всё содержимое файла в виде одной строки используйте as_list = False.\
        Если вы работаете с директорией, recursive = True будет обходить все поддиректории.\
        extensions и patterns позволят вам фильтровать файлы при работе с директорией.\
        chunk_size позволяет оптимизировать работу с большими файлами при чтении их по частям.\
        None будет возвращён в случае ошибок.\
\
    Важно помнить:\
        В случае чтения директории, если as_list=False, функция объединяет все содержимое найденных файлов в одну строку. Это может потребовать много памяти, если файлов много или они большие.\
        Функция полагается на другие функции-помощники (_read_file_lines_generator, _read_file_content, recursively_get_file_path, yield_text_from_files), которые здесь не определены и их поведение влияет на результат read_text_file.\
\

    """
```

**Назначение**: Читает содержимое одного или нескольких файлов, или директории, возвращая данные в виде генератора строк, одной строки или списка строк.

**Параметры**:

-   `file_path` (str | Path): Путь к файлу или директории, которую нужно прочитать.
-   `as_list` (bool, optional): Если `True`, возвращает содержимое в виде генератора строк (для файлов) или списка строк (для директорий). По умолчанию `False`.
-   `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. Если не указан, включаются все файлы.
-   `chunk_size` (int, optional): Размер чанка (в байтах) для чтения файла. Используется для чтения больших файлов по частям. По умолчанию 8192.
-   `recursive` (bool, optional): Если `True`, рекурсивно обходит все поддиректории при чтении директории. По умолчанию `False`.
-   `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.

**Возвращает**:

-   `Generator[str, None, None]`: Если `as_list` равен `True` и `file_path` является файлом.
-   `str`: Если `as_list` равен `False` и `file_path` является файлом. Также возвращается объединенная строка, если `as_list` равен `False` и `file_path` является директорией.
-   `list[str]`: Возвращается, когда `file_path` - директория, `recursive` - `True` и `as_list` - `True`.
-   `None`: В случае ошибки или если `file_path` не является ни файлом, ни директорией.

**Вызывает исключения**:

-   `Exception`: Возникает при ошибке чтения файла или директории.

**Как работает функция**:

1.  Преобразует `file_path` в объект `Path`.
2.  Проверяет, является ли `file_path` файлом или директорией.
3.  Если это файл:
    -   Если `as_list` равен `True`, возвращает генератор строк, используя `_read_file_lines_generator`.
    -   Если `as_list` равен `False`, возвращает содержимое файла в виде строки, используя `_read_file_content`.
4.  Если это директория:
    -   Если `recursive` равен `True`, рекурсивно получает список всех файлов, соответствующих заданным шаблонам, используя `recursively_get_file_path`.
        -   Если `as_list` равен `True`, возвращает генератор строк, объединяя строки из всех файлов.
        -   Если `as_list` равен `False`, возвращает объединенную строку из содержимого всех файлов.
    -   Если `recursive` равен `False`, получает список файлов в текущей директории.
        -   Если `as_list` равен `True`, возвращает генератор строк, объединяя строки из всех файлов.
        -   Если `as_list` равен `False`, возвращает объединенную строку из содержимого всех файлов.
5.  Если `file_path` не является ни файлом, ни директорией, записывает сообщение об ошибке в лог и возвращает `None`.
6.  В случае возникновения исключения, записывает сообщение об ошибке в лог и возвращает `None`.

**Внутренние функции**:
- `_read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]`: Читает файл построчно и возвращает генератор строк.
- `_read_file_content(file_path: Path, chunk_size: int) -> str`: Читает файл целиком и возвращает его содержимое в виде строки.
- `recursively_get_file_path(root_dir: str | Path, patterns: str | list[str] = '*') -> list[Path]`: Рекурсивно получает список путей ко всем файлам, соответствующим заданным шаблонам.

**ASCII Flowchart**:

```
    Начало
    ↓
    Преобразование file_path в Path
    ↓
    Проверка: файл или директория?
    ├── Файл
    │   ├── as_list == True? → _read_file_lines_generator (генератор строк)
    │   └── as_list == False? → _read_file_content (строка)
    └── Директория
        ├── recursive == True?
        │   ├── recursively_get_file_path (список файлов)
        │   ├── as_list == True? → объединение строк из файлов (генератор строк)
        │   └── as_list == False? → объединение строк из файлов (строка)
        └── recursive == False?
            ├── получение списка файлов в текущей директории
            ├── as_list == True? → объединение строк из файлов (генератор строк)
            └── as_list == False? → объединение строк из файлов (строка)
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример чтения файла как строки
file_path = Path('example.txt')
content = read_text_file_generator(file_path)
if content:
    print(f'File content: {content[:100]}...')

# Пример чтения файла как списка строк
file_path = Path('example.txt')
lines = list(read_text_file_generator(file_path, as_list=True))
for line in lines:
    print(line)

# Пример чтения директории рекурсивно и получения объединенной строки
dir_path = Path('.')
content = read_text_file_generator(dir_path, recursive=True)
if content:
    print(f'Directory content: {content[:100]}...')
```

### `read_text_file`

```python
def read_text_file(
    file_path: Union[str, Path],
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    exc_info: bool = True,
) -> str | list[str] | None:
    """
    Read the contents of a file.

    Args:
        file_path (str | Path): Path to the file or directory.
        as_list (bool, optional): If True, returns content as list of lines. Defaults to False.
        extensions (list[str], optional): List of file extensions to include if reading a directory. Defaults to None.
        exc_info (bool, optional): If True, logs traceback on error. Defaults to True.

    Returns:
        str | list[str] | None: File content as a string or list of lines, or None if an error occurs.
    """
```

**Назначение**: Читает содержимое файла или файлов в директории. Возвращает строку или список строк.

**Параметры**:

-   `file_path` (str | Path): Путь к файлу или директории.
-   `as_list` (bool, optional): Если `True`, возвращает содержимое файла в виде списка строк. По умолчанию `False`.
-   `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
-   `exc_info` (bool, optional): Если `True`, логирует трассировку стека при возникновении ошибки. По умолчанию `True`.

**Возвращает**:

-   `str`: Содержимое файла в виде строки, если `as_list` равен `False`.
-   `list[str]`: Содержимое файла в виде списка строк, если `as_list` равен `True`.
-   `None`: Если произошла ошибка при чтении файла.

**Как работает функция**:

1.  Преобразует `file_path` в объект `Path`.
2.  Проверяет, является ли `file_path` файлом или директорией.
3.  Если это файл:
    -   Открывает файл в режиме чтения с кодировкой `utf-8`.
    -   Возвращает содержимое файла в виде списка строк, если `as_list` равен `True`, иначе возвращает содержимое файла в виде строки.
4.  Если это директория:
    -   Получает список всех файлов в директории, соответствующих заданным расширениям.
    -   Рекурсивно вызывает `read_text_file` для каждого файла.
    -   Объединяет содержимое всех файлов в список строк, если `as_list` равен `True`, иначе объединяет содержимое всех файлов в одну строку.
5.  Если `file_path` не является ни файлом, ни директорией, записывает предупреждение в лог и возвращает `None`.
6.  В случае возникновения исключения, записывает сообщение об ошибке в лог и возвращает `None`.

**ASCII Flowchart**:

```
    Начало
    ↓
    Преобразование file_path в Path
    ↓
    Проверка: файл или директория?
    ├── Файл
    │   ├── Открытие файла в режиме чтения
    │   ├── as_list == True? →  f.readlines() (список строк)
    │   └── as_list == False? → f.read() (строка)
    └── Директория
        ├── Получение списка файлов
        ├── Рекурсивный вызов read_text_file для каждого файла
        ├── as_list == True? → объединение в список строк
        └── as_list == False? → объединение в строку
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример чтения файла как строки
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
    print(f'File content: {content[:100]}...')

# Пример чтения файла как списка строк
file_path = Path('example.txt')
lines = read_text_file(file_path, as_list=True)
if lines:
    for line in lines:
        print(line)

# Пример чтения директории и объединения содержимого файлов в строку
dir_path = Path('.')
content = read_text_file(dir_path)
if content:
    print(f'Directory content: {content[:100]}...')
```

### `yield_text_from_files`

```python
def yield_text_from_files(
    file_path: str | Path,
    as_list: bool = False,
    chunk_size: int = 8192
) -> Generator[str, None, None] | str | None:
    """
    Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

    Args:
        file_path (str | Path): Путь к файлу.
        as_list (bool, optional): Если True, возвращает генератор строк. По умолчанию False.
        chunk_size (int, optional): Размер чанка для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или None в случае ошибки.

    Yields:
       str: Строки из файла, если as_list is True.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> for line in yield_text_from_files(file_path, as_list=True):
        ...     print(line)
        Первая строка файла
        Вторая строка файла
    """
```

**Назначение**: Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

**Параметры**:

-   `file_path` (str | Path): Путь к файлу.
-   `as_list` (bool, optional): Если `True`, возвращает генератор строк. По умолчанию `False`.
-   `chunk_size` (int, optional): Размер чанка для чтения файла в байтах.

**Возвращает**:

-   `Generator[str, None, None]`: Генератор строк, если `as_list` равен `True`.
-   `str`: Объединенная строка, если `as_list` равен `False`.
-   `None`: В случае ошибки.

**Yields**:

-   `str`: Строки из файла, если `as_list` равен `True`.

**Как работает функция**:

1.  Преобразует `file_path` в объект `Path`.
2.  Проверяет, является ли `file_path` файлом.
3.  Если это файл:
    -   Если `as_list` равен `True`, возвращает генератор строк, используя `_read_file_lines_generator`.
    -   Иначе, возвращает строку, используя `_read_file_content`.
4.  Если `file_path` не является файлом, записывает сообщение об ошибке в лог и возвращает `None`.
5.  В случае возникновения исключения, записывает сообщение об ошибке в лог и возвращает `None`.

**Внутренние функции**:

- `_read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]`: Читает файл построчно и генерирует строки.
- `_read_file_content(file_path: Path, chunk_size: int) -> str`: Читает файл целиком и возвращает его содержимое в виде строки.

**ASCII Flowchart**:

```
    Начало
    ↓
    Преобразование file_path в Path
    ↓
    Проверка: файл?
    ├── Да
    │   ├── as_list == True? → _read_file_lines_generator (генератор строк)
    │   └── as_list == False? → _read_file_content (строка)
    └── Нет
        └── Логирование ошибки и возврат None
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример использования генератора строк
file_path = Path('example.txt')
for line in yield_text_from_files(file_path, as_list=True):
    print(line)

# Пример получения содержимого файла в виде одной строки
file_path = Path('example.txt')
content = yield_text_from_files(file_path)
if content:
    print(content)
```

### `_read_file_content`

```python
def _read_file_content(file_path: Path, chunk_size: int) -> str:
    """
    Читает содержимое файла по чанкам и возвращает как строку.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Returns:
        str: Содержимое файла в виде строки.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает содержимое файла по частям (чанкам) заданного размера и возвращает его в виде строки.

**Параметры**:

-   `file_path` (Path): Путь к файлу, который нужно прочитать.
-   `chunk_size` (int): Размер чанка (в байтах) для чтения файла.

**Возвращает**:

-   `str`: Содержимое файла в виде строки.

**Вызывает исключения**:

-   `Exception`: Возникает при ошибке чтения файла.

**Как работает функция**:

1.  Открывает файл для чтения в текстовом режиме с кодировкой `utf-8`.
2.  Читает файл по частям (чанкам) размером `chunk_size` байт.
3.  Добавляет каждый прочитанный чанк к переменной `content`.
4.  Повторяет шаги 2-3 до тех пор, пока не будет достигнут конец файла.
5.  Возвращает содержимое файла, накопленное в переменной `content`.

**ASCII Flowchart**:

```
    Начало
    ↓
    Открытие файла в режиме чтения
    ↓
    Цикл: чтение файла по частям (чанкам)
    ├── Чтение чанка
    ├── Добавление чанка к переменной content
    └── Конец файла?
    ↓
    Возврат содержимого файла
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример чтения файла по чанкам
file_path = Path('example.txt')
chunk_size = 1024
content = _read_file_content(file_path, chunk_size)
print(f'File content: {content[:100]}...')
```

### `_read_file_lines_generator`

```python
def _read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]:
    """
    Читает файл по строкам с помощью генератора.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Yields:
        str: Строки из файла.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает файл построчно, используя генератор для экономии памяти.

**Параметры**:

-   `file_path` (Path): Путь к файлу, который нужно прочитать.
-   `chunk_size` (int): Размер чанка (в байтах) для чтения файла.

**Yields**:

-   `str`: Строки из файла.

**Вызывает исключения**:

-   `Exception`: Возникает при ошибке чтения файла.

**Как работает функция**:

1.  Открывает файл для чтения в текстовом режиме с кодировкой `utf-8`.
2.  В цикле читает файл по частям (чанкам) размером `chunk_size` байт.
3.  Разделяет каждый прочитанный чанк на строки, используя метод `splitlines()`.
4.  Если чанк не закончился полной строкой, добавляет последнюю строку к следующему чанку.
5.  Генерирует каждую строку из списка строк.

**ASCII Flowchart**:

```
    Начало
    ↓
    Открытие файла в режиме чтения
    ↓
    Цикл: чтение файла по частям (чанкам)
    ├── Чтение чанка
    ├── Разделение чанка на строки
    ├── Чанк закончился полной строкой?
    │   ├── Да → генерация строк
    │   └── Нет → добавление последней строки к следующему чанку
    └── Конец файла?
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример чтения файла построчно с использованием генератора
file_path = Path('example.txt')
chunk_size = 1024
for line in _read_file_lines_generator(file_path, chunk_size):
    print(line)
```

### `get_filenames_from_directory`

```python
def get_filenames_from_directory(
    directory: str | Path, ext: str | list[str] = '*'
) -> list[str]:
    """
    Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.

    Args:
        directory (str | Path): Путь к директории для поиска.
        ext (str | list[str], optional): Расширения для фильтрации.
            По умолчанию '*'.

    Returns:
        list[str]: Список имен файлов, найденных в директории.

    Example:
        >>> from pathlib import Path
        >>> directory = Path('.')
        >>> get_filenames_from_directory(directory, ['.txt', '.md'])
        ['example.txt', 'readme.md']
    """
```

**Назначение**: Возвращает список имен файлов в указанной директории, с возможностью фильтрации по расширению.

**Параметры**:

-   `directory` (str | Path): Путь к директории, в которой нужно получить список файлов.
-   `ext` (str | list[str], optional): Расширение или список расширений файлов для фильтрации. По умолчанию `'*'`, что означает отсутствие фильтрации.

**Возвращает**:

-   `list[str]`: Список имен файлов, найденных в директории.

**Как работает функция**:

1.  Проверяет, является ли указанный путь (`directory`) директорией. Если нет, записывает сообщение об ошибке в лог и возвращает пустой список.
2.  Преобразует входной параметр `ext` в список расширений. Если `ext` является строкой `'*'`, то список расширений остается пустым, что означает отсутствие фильтрации.
3.  Формирует список имен файлов, которые находятся в директории и соответствуют заданным расширениям.
4.  В случае возникновения исключения, записывает сообщение об ошибке в лог и возвращает пустой список.

**ASCII Flowchart**:

```
    Начало
    ↓
    Проверка: является ли directory директорией?
    ├── Нет → Логирование ошибки и возврат []
    └── Да
        ↓
        Преобразование ext в список расширений
        ↓
        Формирование списка имен файлов
        ↓
        Возврат списка имен файлов
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример получения списка всех файлов в директории
directory = Path('.')
filenames = get_filenames_from_directory(directory)
print(filenames)

# Пример получения списка файлов с расширениями .txt и .md
directory = Path('.')
filenames = get_filenames_from_directory(directory, ['.txt', '.md'])
print(filenames)
```

### `recursively_yield_file_path`

```python
def recursively_yield_file_path(
    root_dir: str | Path, patterns: str | list[str] = '*'
) -> Generator[Path, None, None]:
    """
    Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая директория для поиска.
        patterns (str | list[str]): Шаблоны для фильтрации файлов.

    Yields:
        Path: Путь к файлу, соответствующему шаблону.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
        ...    print(path)
        ./example.txt
        ./readme.md
    """
```

**Назначение**: Рекурсивно генерирует пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

**Параметры**:

-   `root_dir` (str | Path): Корневая директория для поиска.
-   `patterns` (str | list[str]): Шаблоны для фильтрации файлов.

**Yields**:

-   `Path`: Путь к файлу, соответствующему шаблону.

**Как работает функция**:

1.  Преобразует входной параметр `patterns` в список шаблонов.
2.  Для каждого шаблона выполняет рекурсивный поиск файлов, используя метод `rglob` объекта `Path`.
3.  Генерирует путь к каждому найденному файлу.
4.  В случае возникновения исключения, записывает сообщение об ошибке в лог.

**ASCII Flowchart**:

```
    Начало
    ↓
    Преобразование patterns в список шаблонов
    ↓
    Цикл по шаблонам
    ├── Рекурсивный поиск файлов, соответствующих шаблону
    └── Генерация пути к каждому найденному файлу
    ↓
    Завершение
```

**Примеры**:

```python
from pathlib import Path

# Пример рекурсивного поиска файлов с расширениями .txt и .md
root_dir = Path('.')
for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
    print(path)
```

### `recursively_get_file_path`

```python
def recursively_get_file_path(
    root_dir: str | Path,
    patterns: str | list[str] = '*'
) -> list[Path]:
    """
    Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая