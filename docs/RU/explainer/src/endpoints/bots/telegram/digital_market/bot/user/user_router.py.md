## ИНСТРУКЦИЯ:

Анализируй предоставленный код подробно и объясни его функциональность. Ответ должен включать три раздела:

1. **<алгоритм>**: Опиши рабочий процесс в виде пошаговой блок-схемы, включая примеры для каждого логического блока, и проиллюстрируй поток данных между функциями, классами или методами.
2. **<mermaid>**: Напиши код для диаграммы в формате `mermaid`, проанализируй и объясни все зависимости,
    которые импортируются при создании диаграммы.
    **ВАЖНО!** Убедитесь, что все имена переменных, используемые в диаграмме `mermaid`,
    имеют осмысленные и описательные имена. Имена переменных вроде `A`, `B`, `C`, и т.д., не допускаются!

    **Дополнительно**: Если в коде есть импорт `import header`, добавьте блок `mermaid` flowchart, объясняющий `header.py`:
    ```mermaid
    flowchart TD
        Start --> Header[<code>header.py</code><br> Determine Project Root]

        Header --> import[Import Global Settings: <br><code>from src import gs</code>]
    ```

3. **<объяснение>**: Предоставьте подробные объяснения:
   - **Импорты**: Их назначение и взаимосвязь с другими пакетами `src.`.
   - **Классы**: Их роль, атрибуты, методы и взаимодействие с другими компонентами проекта.
   - **Функции**: Их аргументы, возвращаемые значения, назначение и примеры.
   - **Переменные**: Их типы и использование.
   - Выделите потенциальные ошибки или области для улучшения.

Дополнительно, постройте цепочку взаимосвязей с другими частями проекта (если применимо).

Это обеспечивает всесторонний и структурированный анализ кода.
## Формат ответа: `.md` (markdown)
**КОНЕЦ ИНСТРУКЦИИ**
## <алгоритм>

**1. Обработка команды `/start` (`cmd_start`)**
   - **Начало**: Пользователь отправляет команду `/start`.
   - **Извлечение ID**: Получение `user_id` из сообщения.
   - **Поиск пользователя**: Поиск пользователя в базе данных по `telegram_id` с использованием `UserDAO.find_one_or_none`.
      - **Пример**: Если пользователь с `telegram_id=12345` найден, запрос вернет его данные из БД. Если нет - вернет `None`.
   - **Если пользователь найден**:
      - Отправка приветственного сообщения с основной клавиатурой `main_user_kb`.
      - **Пример**: "Привет, User! Выберите действие".
   - **Если пользователь не найден**:
       -  Создание `UserModel` с данными пользователя (telegram_id, username, first_name, last_name)
         - **Пример**: `UserModel(telegram_id=12345, username='user123', first_name='User', last_name='LastName')`
       -  Добавление пользователя в базу данных с использованием `UserDAO.add`.
       -  Отправка сообщения об успешной регистрации с основной клавиатурой `main_user_kb`.
      - **Пример**: "Благодарим за регистрацию! Выберите действие".

**2. Обработка нажатия кнопки "Главная" (`page_home`)**
   - **Начало**: Пользователь нажимает кнопку с `callback_data="home"`.
   - **Ответ на callback**: Отправка `call.answer("Главная страница")` для отображения индикатора загрузки.
   - **Отправка сообщения**: Отправка приветственного сообщения с основной клавиатурой `main_user_kb`.
   - **Пример**: "Привет, User! Выберите действие".

**3. Обработка нажатия кнопки "О магазине" (`page_about`)**
   - **Начало**: Пользователь нажимает кнопку с `callback_data="about"`.
   - **Ответ на callback**: Отправка `call.answer("О магазине")` для отображения индикатора загрузки.
   - **Отправка сообщения**: Отправка текстового сообщения с информацией о магазине и тестовыми данными для оплаты, сохраняя текущую клавиатуру.
   - **Пример**: Информационное сообщение о магазине.

**4. Обработка нажатия кнопки "Мой профиль" (`page_about`)**
   - **Начало**: Пользователь нажимает кнопку с `callback_data="my_profile"`.
   - **Ответ на callback**: Отправка `call.answer("Профиль")` для отображения индикатора загрузки.
   - **Получение статистики**: Получение статистики покупок пользователя с использованием `UserDAO.get_purchase_statistics`.
      - **Пример**: Возвращается словарь вида `{"total_amount": 1500, "total_purchases": 3}`
   - **Проверка наличия покупок**:
     - **Если покупок нет**: Отправка сообщения об отсутствии покупок с основной клавиатурой.
     - **Пример**: "У вас пока нет покупок. Откройте каталог!".
     - **Если покупки есть**: Формирование сообщения с количеством покупок и общей суммой и отправка сообщения с клавиатурой `purchases_kb`.
     - **Пример**: "Ваш профиль: Количество покупок: 3, Общая сумма: 1500₽. Хотите посмотреть детали?"

**5. Обработка нажатия кнопки "Мои покупки" (`page_user_purchases`)**
   - **Начало**: Пользователь нажимает кнопку с `callback_data="purchases"`.
   - **Ответ на callback**: Отправка `call.answer("Мои покупки")` для отображения индикатора загрузки.
   - **Удаление сообщения**: Попытка удалить предыдущее сообщение, чтобы не нагромождать интерфейс.
   - **Получение покупок**: Получение списка покупок пользователя с использованием `UserDAO.get_purchased_products`.
   - **Проверка наличия покупок**:
      - **Если покупок нет**: Отправка сообщения об отсутствии покупок с основной клавиатурой.
       - **Пример**: "У вас пока нет покупок. Откройте каталог!".
      - **Если покупки есть**:
         - Итерация по каждой покупке из списка:
           - Извлечение продукта из покупки
           - Формирование текстового сообщения с информацией о продукте, ценой, описанием и т.д.
           - **Пример**: "Информация о вашем товаре: Название: Продукт1, Цена: 100₽, ...".
           - **Если есть файл:** Отправка документа с описанием, иначе - отправка текстового сообщения с описанием товара.
         - Отправка финального сообщения с благодарностью и основной клавиатурой.
          - **Пример**: "Спасибо за доверие!".

## <mermaid>
```mermaid
flowchart TD
    subgraph User Interaction
        Start[Начало] --> StartCommand[/start command/]
         StartCommand --> CheckUser[Проверка пользователя в БД]
         CheckUser -- Пользователь найден --> SendGreeting[Отправить приветствие с main_user_kb]
         CheckUser -- Пользователь не найден --> CreateUser[Создать пользователя в БД]
         CreateUser --> SendRegistrationGreeting[Отправить сообщение о регистрации с main_user_kb]
         
         SendGreeting --> MainMenuNav
        SendRegistrationGreeting --> MainMenuNav
        
         MainMenuNav --> AboutCallback[/about callback/]
         AboutCallback --> AnswerAbout[Ответить "О магазине"]
         AnswerAbout --> SendAboutMessage[Отправить сообщение о магазине]
         
         MainMenuNav --> ProfileCallback[/my_profile callback/]
        ProfileCallback --> AnswerProfile[Ответить "Профиль"]
        AnswerProfile --> GetPurchaseStats[Получить статистику покупок]
        GetPurchaseStats -- Нет покупок --> SendNoPurchases[Отправить сообщение об отсутствии покупок с main_user_kb]
        GetPurchaseStats -- Есть покупки --> SendProfileInfo[Отправить профиль пользователя с purchases_kb]
        
        MainMenuNav --> PurchasesCallback[/purchases callback/]
        PurchasesCallback --> AnswerPurchases[Ответить "Мои покупки"]
        AnswerPurchases --> DeleteMessage[Удалить предыдущее сообщение]
        DeleteMessage --> GetPurchases[Получить список покупок]
        GetPurchases -- Нет покупок --> SendNoPurchasesAgain[Отправить сообщение об отсутствии покупок с main_user_kb]
        GetPurchases -- Есть покупки --> LoopPurchases[Цикл по покупкам]
        LoopPurchases --> GetProduct[Получить продукт из покупки]
        GetProduct --> PrepareProductText[Подготовить текстовое сообщение о продукте]
        PrepareProductText --> CheckFile[Проверка наличия файла]
        CheckFile -- Есть файл --> SendDocumentWithText[Отправить документ с описанием]
        CheckFile -- Нет файла --> SendText[Отправить текстовое описание]
        SendDocumentWithText --> LoopPurchases
        SendText --> LoopPurchases
        LoopPurchases -->  SendThanksMessage[Отправить сообщение благодарности с main_user_kb]
    end
    
    
    
    subgraph Data Access
      classDef database fill:#f9f,stroke:#333,stroke-width:2px
    	CheckUser -- database --> UserDAO.find_one_or_none
        CreateUser -- database --> UserDAO.add
        GetPurchaseStats -- database --> UserDAO.get_purchase_statistics
         GetPurchases -- database --> UserDAO.get_purchased_products
    end
    
    class UserInteraction fill:#ccf,stroke:#333,stroke-width:2px
     class DataAccess fill:#cfc,stroke:#333,stroke-width:2px
        
```

**Анализ зависимостей:**
- **aiogram:**
  - `Router`:  Используется для маршрутизации входящих сообщений и callback-запросов.
  - `F`:  Используется для фильтрации callback-запросов по значению `data`.
  - `CommandStart`: Фильтр для команды `/start`.
  - `Message`:  Тип объекта сообщения, получаемого от Telegram.
  - `CallbackQuery`: Тип объекта callback-запроса, получаемого от Telegram.
- **sqlalchemy.ext.asyncio:**
    - `AsyncSession`: Используется для работы с асинхронными сессиями базы данных.
- **bot.dao.dao:**
  - `UserDAO`: Data Access Object для работы с данными пользователей в базе данных.
- **bot.user.kbs:**
  - `main_user_kb`: Функция для создания клавиатуры главного меню пользователя.
  - `purchases_kb`: Функция для создания клавиатуры для просмотра покупок.
- **bot.user.schemas:**
   - `TelegramIDModel`: Схема для валидации `telegram_id`.
   - `UserModel`: Схема для валидации и работы с данными пользователя.

## <объяснение>

**Импорты:**

- `from aiogram import Router, F`: Импортирует необходимые классы и функции из библиотеки `aiogram` для создания роутера, фильтрации `callback_query`. `aiogram` - это библиотека для создания Telegram ботов.
- `from aiogram.filters import CommandStart`: Импортирует фильтр `CommandStart` для обработки команды `/start`.
- `from aiogram.types import Message, CallbackQuery`: Импортирует типы `Message` и `CallbackQuery` для работы с сообщениями и `callback` запросами от Telegram.
- `from sqlalchemy.ext.asyncio import AsyncSession`: Импортирует класс `AsyncSession` для работы с асинхронными сессиями базы данных `SQLAlchemy`.
- `from bot.dao.dao import UserDAO`: Импортирует класс `UserDAO` из модуля `bot.dao.dao` для работы с данными пользователей в базе данных.
- `from bot.user.kbs import main_user_kb, purchases_kb`: Импортирует функции для создания клавиатур главного меню и меню покупок из модуля `bot.user.kbs`.
- `from bot.user.schemas import TelegramIDModel, UserModel`: Импортирует модели `TelegramIDModel` и `UserModel` для валидации и работы с данными пользователей из модуля `bot.user.schemas`.

**Классы:**

- `Router`:
  -  `user_router = Router()`: Создание экземпляра роутера для обработки запросов, связанных с пользователями.

**Функции:**
- `@user_router.message(CommandStart())
async def cmd_start(message: Message, session_with_commit: AsyncSession)`:
    -   **Описание:** Асинхронная функция-обработчик команды `/start`.
    -   **Аргументы:**
        - `message: Message`: Объект сообщения от Telegram.
        - `session_with_commit: AsyncSession`: Асинхронная сессия базы данных с возможностью коммита.
    -   **Возвращаемое значение:** `None` (отправляет ответное сообщение пользователю).
    -   **Логика:**
        1.  Извлекает `user_id` из сообщения.
        2.  Ищет пользователя в базе данных по `telegram_id`.
        3.  Если пользователь найден, отправляет приветственное сообщение.
        4.  Если пользователь не найден, создает нового пользователя в базе данных и отправляет сообщение об успешной регистрации.
    -   **Пример:**
        - Если пользователь отправляет команду `/start`, функция проверяет, есть ли он в БД.
        - Если нет, добавляет пользователя в базу и отправляет сообщение: `🎉 <b>Благодарим за регистрацию!</b>. Теперь выберите необходимое действие.`
- `@user_router.callback_query(F.data == "home")
async def page_home(call: CallbackQuery)`:
    -   **Описание:** Асинхронная функция-обработчик `callback_query` с `data` = "home".
    -   **Аргументы:**
        - `call: CallbackQuery`: Объект `callback_query` от Telegram.
    -   **Возвращаемое значение:** `None` (отправляет ответное сообщение пользователю).
    -   **Логика:**
        1. Отвечает на `callback` сообщение, подтверждая действие.
        2. Отправляет приветственное сообщение с главной клавиатурой.
    -   **Пример:**
        - Если пользователь нажимает кнопку "Главная", бот отправит ему приветственное сообщение.
- `@user_router.callback_query(F.data == "about")
async def page_about(call: CallbackQuery)`:
    -   **Описание:** Асинхронная функция-обработчик `callback_query` с `data` = "about".
    -   **Аргументы:**
        - `call: CallbackQuery`: Объект `callback_query` от Telegram.
    -   **Возвращаемое значение:** `None` (отправляет ответное сообщение пользователю).
    -   **Логика:**
        1. Отвечает на `callback` сообщение, подтверждая действие.
        2. Отправляет текстовое сообщение с информацией о магазине.
    -  **Пример:**
        - Если пользователь нажимает кнопку "О магазине", бот отправит сообщение с информацией о магазине и тестовыми данными для оплаты.
- `@user_router.callback_query(F.data == "my_profile")
async def page_about(call: CallbackQuery, session_without_commit: AsyncSession)`:
    -   **Описание:** Асинхронная функция-обработчик `callback_query` с `data` = "my_profile".
    -   **Аргументы:**
        - `call: CallbackQuery`: Объект `callback_query` от Telegram.
        - `session_without_commit: AsyncSession`: Асинхронная сессия базы данных без возможности коммита.
    -   **Возвращаемое значение:** `None` (отправляет ответное сообщение пользователю).
    -   **Логика:**
        1.  Отвечает на `callback` сообщение, подтверждая действие.
        2.  Получает статистику покупок пользователя.
        3.  Формирует сообщение с количеством покупок и общей суммой.
        4.  Отправляет сообщение с клавиатурой просмотра покупок.
    -   **Пример:**
        - Если пользователь нажимает кнопку "Мой профиль", бот отправит ему сообщение о его количестве покупок и их общей стоимости.
- `@user_router.callback_query(F.data == "purchases")
async def page_user_purchases(call: CallbackQuery, session_without_commit: AsyncSession)`:
   - **Описание:** Асинхронная функция-обработчик `callback_query` с `data` = "purchases".
   - **Аргументы:**
      - `call: CallbackQuery`: Объект `callback_query` от Telegram.
      - `session_without_commit: AsyncSession`: Асинхронная сессия базы данных без возможности коммита.
   - **Возвращаемое значение:** `None` (отправляет ответное сообщение пользователю).
   - **Логика:**
        1.  Отвечает на `callback` сообщение, подтверждая действие.
        2.  Удаляет предыдущее сообщение.
        3.  Получает список покупок пользователя.
        4.  Если покупок нет, отправляет сообщение об их отсутствии.
        5.  Если покупки есть, отправляет сообщения с информацией о каждом товаре и файлами, если они есть.
        6. Отправляет благодарственное сообщение с главной клавиатурой.
   - **Пример:**
      - Если пользователь нажимает кнопку "Мои покупки", бот выведет все купленные товары с их описанием и файлами, если они есть.

**Переменные:**

-   `user_router: Router`: Роутер для обработки сообщений и callback-запросов пользователя.
-   `user_id: int`: ID пользователя в Telegram.
-   `user_info: Optional[UserModel]`: Данные пользователя, полученные из базы данных, либо `None`.
-   `values: UserModel`: Модель данных пользователя для добавления в базу данных.
- `purchases: dict`: Словарь со статистикой покупок пользователя, полученной из БД.
- `total_amount: int`: Сумма всех покупок пользователя.
- `total_purchases: int`: Количество покупок пользователя.
- `purchases: list`: Список покупок пользователя.
- `product: Product`: Объект продукта, полученный из покупки.
- `file_text: str`: Строка с информацией о наличии файла у продукта.
- `product_text: str`: Строка с информацией о продукте.

**Потенциальные ошибки и области для улучшения:**

1.  **Обработка ошибок:** В функции `page_user_purchases` есть блок `try-except` для удаления сообщения, но не обрабатываются другие потенциальные ошибки. Стоит добавить более общую обработку исключений в других функциях.
2.  **Логирование:** Отсутствует логирование. Стоит добавить логирование для отслеживания ошибок и действий пользователя.
3. **Дублирование кода**: Код приветствия и отправки сообщения об отсутствии покупок повторяется в разных функциях, что можно вынести в отдельные функции для избежания дублирования.
4. **Обработка ошибок БД**:  Не обрабатываются потенциальные ошибки при работе с БД, такие как ошибка подключения или таймаут.

**Взаимосвязь с другими частями проекта:**

-   **`bot.dao.dao`**: Модуль `UserDAO` предоставляет методы для работы с базой данных пользователей, что используется в данном роутере.
-   **`bot.user.kbs`**: Модуль предоставляет функции для создания клавиатур, которые используются в данном роутере для управления пользовательским интерфейсом.
-   **`bot.user.schemas`**: Модуль предоставляет схемы для валидации данных пользователей, которые используются при добавлении и поиске пользователей.
- **`src.gs`**:  Этот модуль используется для глобальных настроек проекта и является основой для работы всех частей проекта.

Этот код является частью логики обработки пользовательских запросов в Telegram боте, включая регистрацию, просмотр профиля, информации о магазине и истории покупок. Он взаимодействует с базой данных и использует другие части проекта для предоставления функциональности.