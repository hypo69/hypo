## Ответ на Задачу No 319: Разноцветные квадраты

### 1. Анализ задачи и решение

**Понимание задачи:**
* Задача заключается в поиске минимального количества квадратов разных размеров, необходимых для составления большего квадрата заданного размера `n`. 
* Нам нужно найти функцию `M(n)`, которая возвращает это минимальное количество, и затем вычислить сумму `M(n)` для всех `n` от 1 до 150.
* Оптимальная стратегия - использовать как можно большие квадраты на каждом этапе и затем использовать меньшие. Это можно сделать рекурсивно или итеративно. Рекурсивный подход, с мемоизацией будет эффективнее.
* Для случаев, когда `n` является квадратом числа, будет только один квадрат. Это базовый случай.

**Решение:**
1. **Мемоизация:** Чтобы избежать повторных вычислений, будем использовать мемоизацию (кэширование) результатов функции `M(n)`.
2. **Базовый случай:** Если `n` является полным квадратом, то `M(n)` равно 1.
3. **Рекурсивный шаг:** В противном случае, ищем наибольший квадрат `k*k` меньший чем `n*n`. 
    1. Считаем `M(n)` = `1` (за квадрат k*k) + `M` для остатка, где остаток может быть разделен на два прямоугольника - `n*(n-k)` и `k*(n-k)`.
    2. Находим для этих прямоугольников, сколько минимально нужно квадратов, рекурсивно вызывая `M(x)` для каждой части прямоугольника, где `x` -- сторона квадрата.
    3. Делаем рекурсивный вызов для `n - k`, где `n - k` -- сторона оставшегося квадрата, который заполняет разницу.
    4. Выбираем минимум из двух вариантов.
4. **Итеративный процесс:** Накапливаем сумму `M(n)` для всех n от 1 до 150.
5. **Возвращаем результат:** Сумма всех значений `M(n)`.

### 2. Алгоритм решения

1. Начать
2. Инициализировать словарь `memo` для мемоизации результатов `M(n)`.
3. Определить функцию `M(n)`:
   * Если `n` равно 0, вернуть 0.
   * Если `n` равно 1, вернуть 1.
   * Если результат `M(n)` уже есть в `memo`, вернуть его.
   * Найти наибольший квадрат `k*k`  меньший чем `n*n` (`k = floor(sqrt(n))`).
   * Если `n` равно `k*k`,  `M(n)` = 1, добавить в memo и вернуть 1.
   * Вычислить `M(n)`  как `1 + M(n - k)`
   * Сохранить результат в `memo[n]` и вернуть `memo[n]`
4. Инициализировать переменную `total_sum` со значением 0
5. Для каждого `n` от 1 до 150
   * Вычислить `M(n)` и добавить к `total_sum`.
6. Вернуть `total_sum`
7. Конец

### 3. Реализация на Python 3.12
```python
import math

def solve():
    memo = {}
    def M(n):
      if n == 0:
          return 0
      if n == 1:
        return 1
      if n in memo:
        return memo[n]
      
      k = int(math.sqrt(n))
      if k * k == n:
        memo[n] = 1
        return 1
      
      memo[n] = 1 + M(n - k)
      
      return memo[n]
    
    total_sum = 0
    for n in range(1, 151):
      total_sum += M(n)
    return total_sum
    

result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeMemo((Инициализировать memo = {}))
    InitializeMemo --> DefineMFunction((Определить функцию M(n)))
    DefineMFunction --> CheckBaseCase_0((Если n == 0, вернуть 0))
    CheckBaseCase_0 -- Да --> Return0((Вернуть 0))
    DefineMFunction --> CheckBaseCase_1((Если n == 1, вернуть 1))
    CheckBaseCase_1 -- Да --> Return1((Вернуть 1))
    DefineMFunction --> CheckMemo((Если n в memo, вернуть memo[n]))
    CheckMemo -- Да --> ReturnMemoN((Вернуть memo[n]))
    CheckMemo -- Нет --> FindLargestSquare((Найти k = floor(sqrt(n))))
    FindLargestSquare --> CheckPerfectSquare((Если k*k == n))
    CheckPerfectSquare -- Да --> SetMemoN_1((memo[n] = 1))
    SetMemoN_1 --> Return1_2((Вернуть 1))
    CheckPerfectSquare -- Нет --> CalculateM((memo[n] = 1 + M(n - k)))
    CalculateM --> ReturnMemoN2((Вернуть memo[n]))
    Return0 --> InitializeTotalSum((Инициализировать total_sum = 0))
    Return1 --> InitializeTotalSum
    ReturnMemoN --> InitializeTotalSum
     Return1_2 --> InitializeTotalSum
     ReturnMemoN2 --> InitializeTotalSum
     
    InitializeTotalSum --> LoopStart((Начать цикл: n от 1 до 150))
    LoopStart --> CallM((total_sum += M(n)))
    CallM --> LoopStart
    LoopStart --> ReturnTotalSum((Вернуть total_sum))
    ReturnTotalSum --> End((Конец))
```

**Легенда:**
*   **Start, End:** Начало и конец алгоритма.
*   **InitializeMemo:** Инициализация словаря `memo` для хранения результатов `M(n)`.
*   **DefineMFunction:** Определение функции `M(n)` для вычисления минимального количества квадратов.
*   **CheckBaseCase_0, CheckBaseCase_1:** Проверка базовых случаев: n=0 и n=1.
*   **Return0, Return1:** Возвращение значений для базовых случаев.
*  **CheckMemo:** Проверка наличия значения M(n) в memo.
*  **ReturnMemoN:** Возвращение значения из `memo`.
*  **FindLargestSquare:** Нахождение наибольшего квадрата k*k, меньшего чем n*n.
*  **CheckPerfectSquare:** Проверка, является ли n полным квадратом.
*  **SetMemoN_1:** Присваивание 1 к memo[n] в случае полного квадрата.
*  **Return1_2:** Возвращение 1 для полных квадратов.
*  **CalculateM:** Вычисление `M(n)` с использованием рекурсивного вызова `M(n-k)`.
*  **ReturnMemoN2:** Возвращение вычисленного значения `M(n)`.
* **InitializeTotalSum:** Инициализация переменной `total_sum` для накопления суммы результатов.
*   **LoopStart:** Начало цикла для `n` от 1 до 150.
*   **CallM:** Вычисление `M(n)` и добавление к `total_sum`.
*   **ReturnTotalSum:** Возврат общей суммы значений `M(n)`.
