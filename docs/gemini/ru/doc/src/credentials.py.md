{
  "Improved Optimized Full Code": "# Название модуля\n\n# src.credentials\n\n## Обзор\n\nМодуль `src.credentials` содержит класс `ProgramSettings`, который управляет глобальными настройками проекта, такими как пути, пароли, логины и настройки API. Он использует паттерн Singleton для обеспечения единственного экземпляра настроек.\n\n## Содержание\n\n1.  [Обзор](#обзор)\n2.  [Классы](#классы)\n    *   [ProgramSettings](#programsettings)\n3.  [Функции](#функции)\n    *   [set_project_root](#set_project_root)\n    *   [singleton](#singleton)\n\n## Классы\n\n### `ProgramSettings`\n\n**Описание**: Класс `ProgramSettings` представляет собой Singleton, хранящий основные параметры и настройки проекта.\n\n**Атрибуты**:\n\n*   `host_name` (str): Имя хоста, по умолчанию определяется как имя текущего хоста.\n*   `base_dir` (Path): Базовая директория проекта, определяется с помощью функции `set_project_root`.\n*   `config` (SimpleNamespace): Настройки конфигурации, загружаемые из файла `config.json`.\n*   `credentials` (SimpleNamespace): Учетные данные для различных сервисов и API.\n*   `path` (SimpleNamespace): Пути к различным директориям проекта.\n*   `host` (str): Хост, по умолчанию `'127.0.0.1'`.\n\n**Методы**:\n\n*   `__post_init__(self)`: Инициализирует объект после создания экземпляра класса, загружает конфигурацию, определяет пути и загружает учетные данные.\n*   `_load_credentials(self)`: Загружает учетные данные из KeePass.\n*   `_open_kp(self, retry: int = 3) -> PyKeePass | None`: Открывает базу данных KeePass.\n*   `_load_aliexpress_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Aliexpress API из KeePass.\n*   `_load_openai_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для OpenAI API из KeePass.\n*   `_load_gemini_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Gemini API из KeePass.\n*   `_load_telegram_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Telegram API из KeePass.\n*   `_load_discord_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Discord API из KeePass.\n*   `_load_prestashop_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для PrestaShop API из KeePass.\n*   `_load_serpapi_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для SerpAPI API из KeePass.\n*   `_load_smtp_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для SMTP из KeePass.\n*   `_load_facebook_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Facebook API из KeePass.\n*   `_load_gapi_credentials(self, kp: PyKeePass) -> bool`: Загружает учетные данные для Google API из KeePass.\n*   `now(self) -> str`: Возвращает текущую метку времени в формате год-месяц-день-часы-минуты-секунды-милисекунды.\n\n## Функции\n\n### `set_project_root`\n\n**Описание**: Функция `set_project_root` определяет корневую директорию проекта на основе наличия файлов-маркеров.\n\n```python\ndef set_project_root(marker_files: tuple = ('__root__', '.git')) -> Path:\n    \"\"\"\n    Finds the root directory of the project starting from the current file's directory,\n    searching upwards and stopping at the first directory containing any of the marker files.\n\n    Args:\n        marker_files (tuple): Filenames or directory names to identify the project root.\n\n    Returns:\n        Path: Path to the root directory if found, otherwise the directory where the script is located.\n    \"\"\"\n```\n\n**Параметры**:\n\n*   `marker_files` (tuple, optional): Список файлов-маркеров для определения корневой директории. По умолчанию `('__root__', '.git')`.\n\n**Возвращает**:\n\n*   `Path`: Путь к корневой директории проекта.\n\n### `singleton`\n\n**Описание**: Декоратор `singleton` реализует паттерн Singleton для класса.\n\n```python\ndef singleton(cls):\n    \"\"\"Декоратор для реализации Singleton.\"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n\n    return get_instance\n```\n\n**Параметры**:\n\n*   `cls` (class): Класс, для которого применяется паттерн Singleton.\n\n**Возвращает**:\n\n*   `get_instance` (function): Функция, возвращающая единственный экземпляр класса.\n\n```python\n\"\"\"\n.. module:: src\n    :platform: Windows, Unix\n    :synopsis: Global Project Settings: paths, passwords, logins, and API settings\n\n\"\"\"\n\nimport datetime\nfrom datetime import datetime\nimport getpass\nimport os\nimport sys\nimport json\nimport warnings\nimport socket\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom typing import Optional, List, Dict\n\nfrom pykeepass import PyKeePass\n\nfrom src.check_release import check_latest_release\nfrom src.logger.logger import logger\nfrom src.logger.exceptions import (\n    CredentialsError,\n    DefaultSettingsException,\n    HeaderChecksumError,\n    KeePassException,\n    PayloadChecksumError,\n    UnableToSendToRecycleBin,\n)\nfrom src.utils.file import read_text_file\nfrom src.utils.jjson import j_loads, j_loads_ns\nfrom src.utils.printer import pprint\n\n\ndef set_project_root(\n    marker_files: tuple = ('__root__', '.git')\n) -> Path:\n    \"\"\"\n    Finds the root directory of the project starting from the current file's directory,\n    searching upwards and stopping at the first directory containing any of the marker files.\n\n    Args:\n        marker_files (tuple): Filenames or directory names to identify the project root.\n\n    Returns:\n        Path: Path to the root directory if found, otherwise the directory where the script is located.\n    \"\"\"\n    __root__: Path\n    current_path: Path = Path(__file__).resolve().parent\n    __root__ = current_path\n    for parent in [current_path] + list(current_path.parents):\n        if any((parent / marker).exists() for marker in marker_files):\n            __root__ = parent\n            break\n    if __root__ not in sys.path:\n        sys.path.insert(0, str(__root__))\n    return __root__\n\n\ndef singleton(cls):\n    \"\"\"Декоратор для реализации Singleton.\"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n\n    return get_instance\n\n\n@singleton\n@dataclass\nclass ProgramSettings:\n    \"\"\"\n    `ProgramSettings` - класс настроек программы.\n\n    Синглтон, хранящий основные параметры и настройки проекта.\n    \"\"\"\n\n    host_name: str = field(default_factory=lambda: socket.gethostname())\n\n    base_dir: Path = field(default_factory=lambda: set_project_root())\n    config: SimpleNamespace = field(default_factory=lambda: SimpleNamespace())\n\n    credentials: SimpleNamespace = field(default_factory=lambda: SimpleNamespace(\n        aliexpress=SimpleNamespace(\n            api_key=None,\n            secret=None,\n            tracking_id=None,\n            username=None,\n            email=None,\n            password=None\n        ),\n        presta=SimpleNamespace(\n            client=SimpleNamespace(\n                server=None,\n                port=None,\n                database=None,\n                user=None,\n                password=None,\n            )\n        ),\n        openai=SimpleNamespace(\n            owner=SimpleNamespace(\n                api_key=None,\n                assistants=[SimpleNamespace()],\n                project_api=None\n            )\n        ),\n\n        gemini=SimpleNamespace(owner=SimpleNamespace(api_key=None)),\n\n        rev_com=SimpleNamespace(owner=SimpleNamespace(\n            client_api=None,\n            user_api=None)),\n\n        shutter_stock=SimpleNamespace(owner=SimpleNamespace(token=None)),\n\n        discord=SimpleNamespace(\n            owner=SimpleNamespace(\n                application_id=None,\n                public_key=None,\n                bot_token=None)\n        ),\n\n        telegram=SimpleNamespace(\n            bot=SimpleNamespace()\n        ),\n\n        serpapi=SimpleNamespace(owner=SimpleNamespace(api_key=None,)),\n        smtp=[],\n        facebook=[],\n        gapi={}\n    ))\n\n    path: SimpleNamespace = field(default_factory=lambda: SimpleNamespace(\n        root=None,\n        src=None,\n        bin=None,\n        log=None,\n        tmp=None,\n        data=None,\n        secrets=None,\n        google_drive=None,\n        external_storage=None,\n        tools=None,\n        dev_null='nul' if sys.platform == 'win32' else '/dev/null'\n    ))\n\n    host: str = field(default='127.0.0.1')\n\n    def __post_init__(self) -> None:\n        \"\"\"Выполняет инициализацию после создания экземпляра класса.\"\"\"\n        self.config = j_loads_ns(self.base_dir / 'src' / 'config.json')\n        if not self.config:\n            logger.error('Ошибка при загрузке настроек')\n            ...\n            sys.exit()\n        self.config.timestamp_format = getattr(\n            self.config,\n            'timestamp_format',\n            '%y_%m_%d_%H_%M_%S_%f'\n        )\n        self.config.project_name = self.base_dir.name\n        self.host = getattr(self.config, 'host', '127.0.0.1')\n        self.path: SimpleNamespace = SimpleNamespace(\n            root=Path(self.base_dir),\n            bin=Path(self.base_dir / 'bin'),  # <- тут бинарники (chrome, firefox, ffmpeg, ...)\n            src=Path(self.base_dir) / 'src',  # <- тут весь код\n            endpoints=Path(self.base_dir) / 'src' / 'endpoints',  # <- тут все клиенты\n            secrets=Path(\n                self.base_dir / 'secrets'),  # <- это папка с паролями и базой данных ! Ей нельзя попадать в гит!!!\n            toolbox=Path(self.base_dir / 'toolbox'),  # <- служебные утилиты\n            log=Path(getattr(self.config.path, 'log', self.base_dir / 'log')),\n            tmp=Path(getattr(self.config.path, 'tmp', self.base_dir / 'tmp')),\n            data=Path(getattr(self.config.path, 'data', self.base_dir / 'data')),\n            # <- дата от endpoints (hypo69, kazarinov, prestashop, etc ...)\n            google_drive=Path(\n                getattr(\n                    self.config.path,\n                    'google_drive',\n                    self.base_dir / 'google_drive'\n                )\n            ),  # <- GOOGLE DRIVE ЧЕРЕЗ ЛОКАЛЬНЫЙ ДИСК (NOT API)\n            external_storage=Path(\n                getattr(\n                    self.config.path,\n                    'external_storage',\n                    self.base_dir / 'external_storage'\n                )\n            ),  # <- Внешний диск\n        )\n\n        if check_latest_release(self.config.git_user, self.config.git):\n            ...  # Логика что делать когда есть новая версия hypo69 на github\n\n        # Paths to bin directories\n        gtk_bin_dir = self.path.bin / 'gtk' / 'gtk-nsis-pack' / 'bin'\n        ffmpeg_bin_dir = self.base_dir / 'bin' / 'ffmpeg' / 'bin'\n        graphviz_bin_dir = self.base_dir / 'bin' / 'graphviz' / 'bin'\n        wkhtmltopdf_bin_dir = self.base_dir / 'bin' / 'wkhtmltopdf' / 'files' / 'bin'\n\n        for bin_path in [self.base_dir, gtk_bin_dir, ffmpeg_bin_dir, graphviz_bin_dir, wkhtmltopdf_bin_dir]:\n            if bin_path not in sys.path:\n                sys.path.insert(0, str(bin_path))  # <- определяю пути к бунарникам в системных путях\n\n        os.environ['WEASYPRINT_DLL_DIRECTORIES'] = str(gtk_bin_dir)\n\n        # Suppress GTK log output to the console\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        self._load_credentials()\n\n    def _load_credentials(self) -> None:\n        \"\"\"Загружает учетные данные из настроек.\"\"\"\n\n        kp = self._open_kp(3)\n        if not kp:\n            print(\"Error :( \")\n            ...\n            sys.exit(1)\n\n        if not self._load_aliexpress_credentials(kp):\n            print('Failed to load Aliexpress credentials')\n\n        if not self._load_openai_credentials(kp):\n            print('Failed to load OpenAI credentials')\n\n        if not self._load_gemini_credentials(kp):\n            print('Failed to load GoogleAI credentials')\n\n        if not self._load_discord_credentials(kp):\n            print('Failed to load Discord credentials')\n\n        if not self._load_telegram_credentials(kp):\n            print('Failed to load Telegram credentials')\n\n        if not self._load_prestashop_credentials(kp):\n            print('Failed to load prestashop credentials')\n\n        if not self._load_smtp_credentials(kp):\n            print('Failed to load SMTP credentials')\n\n        if not self._load_facebook_credentials(kp):\n            print('Failed to load Facebook credentials')\n\n        if not self._load_gapi_credentials(kp):\n            print('Failed to load GAPI credentials')\n\n        if not self._load_serpapi_credentials(kp):\n            print('Failed to load https://serpapi.com credentials')\n\n    def _open_kp(self, retry: int = 3) -> PyKeePass | None:\n        \"\"\"Open KeePass database\n\n        Args:\n            retry (int): Number of retries\n        \"\"\"\n        while retry > 0:\n            try:\n                # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DEBUG ~~~~~~~ ⚠️ ФАЙЛ ПАРОЛЯ В ОТКРЫТОМ ВИДЕ ⚠️ ~~~~~~~~~~~~~~~~~~~~~~~\n                password: str = Path(\n                    self.path.secrets / 'password.txt').read_text(encoding=\"utf-8\") or None\n                \"\"\"password: содержит строку пароля в ⚠️ открытом ⚠️ виде. Можно удалить или сам файл или вытереть его содржимое \"\"\"\n\n                kp = PyKeePass(\n                    str(self.path.secrets / 'credentials.kdbx'),\n                    password=password or getpass.getpass(\n                        print('🔐 Enter KeePass master password: ').lower())\n                )\n\n                return kp\n            except Exception as ex:\n                print(f\"😔 Failed to open KeePass database Exception: {ex}\\n {retry-1} retries left.\")\n                ...\n                retry -= 1\n                if retry < 1:\n                    logger.critical(\n                        '🚨 Failed to open KeePass database after multiple attempts',\n                        None,\n                        False\n                    )\n                    ...\n                    sys.exit()\n\n    # Define methods for loading various credentials\n    def _load_aliexpress_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load Aliexpress API credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            entry = kp.find_groups(path=['suppliers', 'aliexpress', 'api']).entries[0]\n            self.credentials.aliexpress.api_key = entry.custom_properties.get('api_key', None)\n            self.credentials.aliexpress.secret = entry.custom_properties.get('secret', None)\n            self.credentials.aliexpress.tracking_id = entry.custom_properties.get('tracking_id', None)\n            self.credentials.aliexpress.email = entry.custom_properties.get('email', None)\n            self.credentials.aliexpress.password = entry.password\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract Aliexpress API key from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_openai_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load OpenAI credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            openai_api_keys = kp.find_groups(path=['openai']).entries\n            assistants: list = kp.find_groups(path=['openai', 'assistants']).entries\n\n            for entry in openai_api_keys:\n\n                try:\n                    # Создание нового SimpleNamespace для каждого API ключа (по умолчанию `hypotez`)\n                    entry_ns = SimpleNamespace()\n\n                    # Установка атрибута в self.credentials.presta.client с именем entry.title\n                    setattr(self.credentials.openai, entry.title, entry_ns)\n\n                    # Ссылка на созданный объект через entry.title\n                    _entry = getattr(self.credentials.openai, entry.title)\n\n                    setattr(_entry, 'api_key', entry.custom_properties.get('api_key', None))\n                    setattr(_entry, 'project_api', entry.custom_properties.get('project_api', None))\n\n                except Exception as ex:\n                    logger.error(f\"Failed to extract OpenAI API key from KeePass \", ex)\n                    ...\n\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract OpenAI credentials from KeePass \", ex)\n            ...\n            return False\n\n    def _load_gemini_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load GoogleAI credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            entries = kp.find_groups(path=['gemini']).entries\n\n            for entry in entries:\n                setattr(self.credentials.gemini, entry.title, entry.custom_properties.get('api_key', None))\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract GoogleAI credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_telegram_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load Telegram credentials from KeePass.\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            entries = kp.find_groups(path=['telegram']).entries\n            for entry in entries:\n                setattr(self.credentials.telegram, entry.title, entry.custom_properties.get('token', None))\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract Telegram credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_discord_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load Discord credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            entry = kp.find_groups(path=['discord']).entries[0]\n            self.credentials.discord.application_id = entry.custom_properties.get('application_id', None)\n            self.credentials.discord.public_key = entry.custom_properties.get('public_key', None)\n            self.credentials.discord.bot_token = entry.custom_properties.get('bot_token', None)\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract Discord credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_prestashop_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load prestashop credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n\n        for entry in kp.find_groups(path=['prestashop', 'clients']).entries:\n            try:\n                # Создаем новый SimpleNamespace для клиента\n                client_ns = SimpleNamespace()\n\n                # Устанавливаем атрибут в self.credentials.presta.client с именем entry.title\n                setattr(self.credentials.presta.client, entry.title, client_ns)\n\n                # Получаем ссылку на созданный объект через entry.title\n                current_client = getattr(self.credentials.presta.client, entry.title)\n\n                setattr(current_client, 'api_key', entry.custom_properties.get('api_key', None))\n                setattr(current_client, 'api_domain', entry.custom_properties.get('api_domain', None))\n                setattr(current_client, 'db_server', entry.custom_properties.get('db_server', None))\n                setattr(current_client, 'db_user', entry.custom_properties.get('db_user', None))\n                setattr(current_client, 'db_password', entry.custom_properties.get('db_password', None))\n\n            except Exception as ex:\n                print(f\"Failed to extract prestashop credentials from KeePass \", ex)\n                ...\n                return False\n\n        return True\n\n    def _load_serpapi_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load OpenAI credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            serpapi_credentials = kp.find_groups(path=['serpapi.com']).entries\n\n            for entry in serpapi_credentials:\n\n                try:\n                    # Создание нового SimpleNamespace для каждого API ключа (по умолчанию `hypotez`)\n                    entry_ns = SimpleNamespace()\n\n                    # Установка атрибута в self.credentials.presta.client с именем entry.title\n                    setattr(self.credentials.serpapi, entry.title, entry_ns)\n\n                    # Ссылка на созданный объект через entry.title\n                    _entry = getattr(self.credentials.serpapi, entry.title)\n                    setattr(_entry, 'api_key', entry.custom_properties.get('api_key', None))\n\n                except Exception as ex:\n                    logger.error(f\"Failed to extract serpapi.com API key from KeePass \", ex)\n                    ...\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract OpenAI credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_smtp_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load SMTP credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            for entry in kp.find_groups(path=['smtp']).entries:\n                self.credentials.smtp.append(SimpleNamespace(\n                    server=entry.custom_properties.get('server', None),\n                    port=entry.custom_properties.get('port', None),\n                    user=entry.custom_properties.get('user', None),\n                    password=entry.custom_properties.get('password', None),\n                ))\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract SMTP credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_facebook_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load Facebook credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            for entry in kp.find_groups(path=['facebook']).entries:\n                self.credentials.facebook.append(SimpleNamespace(\n                    app_id=entry.custom_properties.get('app_id', None),\n                    app_secret=entry.custom_properties.get('app_secret', None),\n                    access_token=entry.custom_properties.get('access_token', None),\n                ))\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract Facebook credentials from KeePass {ex}\")\n            ...\n            return False\n\n    def _load_gapi_credentials(self, kp: PyKeePass) -> bool:\n        \"\"\"Load Google API credentials from KeePass\n\n        Args:\n            kp (PyKeePass): The KeePass database instance.\n\n        Returns:\n            bool: True if loading was successful, False otherwise.\n        \"\"\"\n        try:\n            entry = kp.find_groups(path=['google', 'gapi']).entries[0]\n            self.credentials.gapi['api_key'] = entry.custom_properties.get('api_key', None)\n            return True\n        except Exception as ex:\n            print(f\"Failed to extract GAPI credentials from KeePass {ex}\")\n            ...\n            return False\n\n    @property\n    def now(self) -> str:\n        \"\"\"Возвращает текущую метку времени в формате год-месяц-день-часы-минуты-секунды-милисекунды.\n\n        Этот метод возвращает строку, представляющую текущую метку времени, в формате `год_месяц_день_часы_минуты_секунды_миллисекунды`.\n\n        Args:\n            dformat (str, optional): Формат для метки времени. По умолчанию `\'%y_%m_%d_%H_%M_%S_%f\'`.\n\n        Returns:\n            str: Текущая метка времени в строковом формате.\n        \"\"\"\n        timestamp = datetime.now().strftime(self.config.timestamp_format)\n        # Вернём только первые 3 цифры миллисекунд, т.к. %f возвращает микросекунды (6 цифр)\n        return f\"{timestamp[:-3]}\"\n\n\n# Global instance of ProgamSettings\ngs: ProgramSettings = ProgramSettings()\n",
  "Changes": "1.  Added documentation in Markdown format for the file, including a general overview, table of contents, and detailed descriptions of classes and functions.\n2.  Added documentation for the `set_project_root` and `singleton` functions.\n3.  Added documentation for the `ProgramSettings` class, including attributes and methods.\n4.  Formatted the code for better readability.\n"
}