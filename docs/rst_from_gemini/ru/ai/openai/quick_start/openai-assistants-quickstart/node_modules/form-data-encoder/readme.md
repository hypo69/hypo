```markdown
# form-data-кодировщик

Кодирует содержимое `FormData` в формате `multipart/form-data`.

[![Покрытие кода](https://codecov.io/github/octet-stream/form-data-encoder/coverage.svg?branch=master)](https://codecov.io/github/octet-stream/form-data-encoder?branch=master)
[![CI](https://github.com/octet-stream/form-data-encoder/workflows/CI/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/ci.yml)
[![ESLint](https://github.com/octet-stream/form-data-encoder/workflows/ESLint/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/eslint.yml)

## Установка

Вы можете установить этот пакет с помощью npm:

```bash
npm install form-data-encoder
```

Или yarn:

```bash
yarn add form-data-encoder
```

Или pnpm:

```bash
pnpm add form-data-encoder
```

## Поддержка ESM/CJS

Этот пакет поддерживает ESM и CJS по причинам обратной совместимости и для плавного перехода при конвертации ваших проектов только на ESM. Обратите внимание, что поддержка CJS будет удалена, так как [Node.js v12 достигнет окончания жизненного цикла](https://github.com/nodejs/release#release-schedule). Это изменение будет выпущено как обновление основной версии, поэтому вы не пропустите его.


## Использование

1. Для начала процесса кодирования необходимо создать новый экземпляр Encoder с `FormData`, который вы хотите закодировать:

```javascript
import {Readable} from "stream"

import {FormData, File} from "formdata-node"
import {FormDataEncoder} from "form-data-encoder"

import fetch from "node-fetch"

const form = new FormData()

form.set("приветствие", "Привет, мир!")
form.set("файл", new File(["Текст с пейзажем луны, увиденной через бинокль"], "файл.txt"))

const encoder = new FormDataEncoder(form)

const options = {
  method: "post",

  // Установите заголовки запроса, предоставленные Encoder.
  // Свойство `headers` содержит заголовки `Content-Type` и `Content-Length`.
  headers: encoder.headers,

  // Создайте поток Readable из Encoder.
  // Вы можете пропустить использование `Readable.from` для HTTP-клиентов, которые поддерживают асинхронные итерируемые объекты в теле запроса.
  // Encoder будет выдавать части кодированного содержимого FormData в формате multipart/form-data по мере потребления потока node-fetch.
  body: Readable.from(encoder.encode()) // или просто Readable.from(encoder)
}

const response = await fetch("https://httpbin.org/post", options)

console.log(await response.json())
```

2. Encoder поддерживает различные реализации FormData, совместимые со спецификацией. Давайте попробуем с [`formdata-polyfill`](https://github.com/jimmywarting/FormData):

```javascript
// ... (код аналогичен примеру 1, используя formdata-polyfill)
```

3. Поскольку Encoder является итерируемым (у него есть методы Symbol.asyncIterator и Symbol.iterator), вы можете использовать его с различными целевыми объектами. Допустим, вы хотите преобразовать содержимое FormData в `Blob`. Для этого вы можете написать функцию, подобную этой:

```javascript
// ... (код аналогичен примеру 3, с использованием Blob из formdata-node)
```

4.  ... (остальные примеры с пояснениями)

## API

### `class FormDataEncoder`

##### `constructor(form[, boundary, options]) -> {Encoder}`

  - **{FormDataLike}** form — Объект FormData для кодирования. Этот объект должен быть реализацией FormData, совместимой со спецификацией.
  - **{string}** [boundary] — Необязательная строка разделителя, которая будет использоваться кодировщиком. Если строка разделителя отсутствует, кодировщик сгенерирует её автоматически.
  - **{object}** [options] — Опции кодировщика.
  - **{boolean}** [options.enableAdditionalHeaders = false] — При включении кодировщик будет передавать дополнительные заголовки каждой части, такие как `Content-Length`. Обратите внимание, что веб-клиенты обычно не включают эти заголовки, поэтому при включении этой опции может возникнуть ошибка, если `multipart/form-data` не учитывает дополнительные заголовки.

Создает кодировщик `multipart/form-data`.

#### Свойства экземпляра

##### `boundary -> {string}`

Возвращает строку разделителя.

##### `contentType -> {string}`

Возвращает заголовок Content-Type.

##### `contentLength -> {string}`

Возвращает заголовок Content-Length.

##### `headers -> {object}`

Возвращает объект заголовков с заголовками Content-Type и Content-Length.

#### Методы экземпляра

##### `values() -> {Generator<Uint8Array | FileLike, void, undefined>}`

Создаёт итератор, позволяющий перебрать части form-data (с метаданными).
Этот метод **не** будет читать файлы.

##### `encode() -> {AsyncGenerator<Uint8Array, void, undefined>}`

Создаёт асинхронный итератор, позволяющий выполнять кодирование частями.
Этот метод **будет** читать файлы.

##### `[Symbol.iterator]() -> {Generator<Uint8Array | FileLike, void, undefined>}`

Псевдоним для метода `Encoder#values()`.

##### `[Symbol.asyncIterator]() -> {AsyncGenerator<Uint8Array, void, undefined>}`

Псевдоним для метода `Encoder#encode()`.

### `isFileLike(value) -> {boolean}`

Проверяет, является ли значение объектом, похожим на File.

  - **{unknown}** value — значение для проверки

### `isFormDataLike(value) -> {boolean}`

Проверяет, является ли значение объектом, похожим на FormData.

  - **{unknown}** value — значение для проверки
```