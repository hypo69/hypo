# Анализ кода модуля `4_awari.ru.md`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):** 
    -  **Преимущества:**
        - Документ в формате Markdown.
        - Представлены основные правила и логика игры Авари.
        - Присутствуют примеры работы программы.
    -  **Недостатки:**
        - Отсутствует код на Python, вместо этого дано текстовое описание.
        - Нет reStructuredText (RST) комментариев, как требуется.
        - Нет использования `j_loads` или `j_loads_ns`.
        - Отсутствуют импорты, функции и классы.
        - Не используется `logger.error` для обработки ошибок.
        - Не соблюден формат RST для документирования.
        - Нет примеров кода с docstring и TODO.

**Рекомендации по улучшению**
1. **Формат документации:**
   -   Переписать все комментарии в формате reStructuredText (RST).
   -   Добавить описание модуля в начале файла.
   -   Для каждой функции, метода и переменной добавить docstring.
2. **Код Python:**
   -   Реализовать игру в виде кода Python.
   -   Использовать `j_loads` или `j_loads_ns` для чтения конфигурационных файлов, если они необходимы.
   -   Внедрить обработку ошибок с использованием `logger.error`.
   -   Добавить комментарии в коде с объяснением каждой строки.
   -   Придерживаться PEP 8 при написании кода.
3. **Структура кода:**
   -   Создать функции для инициализации игры, хода игрока, хода компьютера, проверки условий, завершения игры и подсчёта очков.
   -   Использовать классы для представления доски и игрока, если это необходимо.
4. **Примеры кода:**
   -   Добавить примеры кода с использованием doctest в docstring.
   -   Добавить TODO комментарии для будущих улучшений.

**Улучшенный код**

```markdown
# Описание игры: **Awari** (Перемещение семян из лунок)
======================================================

Игра Авари (также известная как Манкала) является классической настольной игрой, в которой два игрока поочередно перемещают семена из лунок на своей стороне доски, стараясь накопить больше семян в своем "доме".

## Особенности:

- Игровое поле состоит из двух рядов лунок (по 6 в каждом ряду) и двух "домов" (по одному для каждого игрока).
- Игрок выбирает лунку на своей стороне и перемещает семена по часовой стрелке.
- Если последнее семя попадает в пустую лунку, напротив которой есть семена, игрок забирает все эти семена в свой "дом".
- Игра заканчивается, когда на одной из сторон доски заканчиваются семена.
- Побеждает тот, у кого в "доме" больше семян.

---

## Пошаговая инструкция для реализации

### 1. **Инициализация игры**

   - Создать массив (список) для представления игровой доски:

     ```
     [0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4]
     ```
     - Индексы 1–6: лунки игрока.
     - Индексы 8–13: лунки компьютера.
     - Индексы 0 и 7: дома игроков.
   - Установить начальное количество семян в каждой лунке (например, 4).

### 2. **Основной цикл игры**

   - **Ход игрока**:
     1. Запросить номер лунки, из которой игрок хочет взять семена.
     2. Проверить правильность выбора:
        - Лунка не пуста.
        - Лунка принадлежит игроку.
     3. Переместить семена из выбранной лунки, "рассыпая" их по кругу:
        - Добавлять по одному семени в каждую следующую лунку.
        - Пропустить дом противника.
     4. Проверить условия:
        - Если последнее семя попало в пустую лунку игрока, а напротив есть семена, переместить их в "дом".
        - Если последнее семя попало в "дом", игрок получает дополнительный ход.

   - **Ход компьютера**:
     - Использовать простой алгоритм выбора лунки (например, первая непустая лунка) или более сложный для "обучающегося" компьютера.
     - Повторить шаги, как для игрока.

   - **Завершение игры**:
     - Игра заканчивается, если на одной из сторон (игрока или компьютера) закончились семена.
     - Все оставшиеся семена перемещаются в "дом" игрока или компьютера на их стороне.

### 3. **Подсчет очков**

   - Подсчитать семена в "домах".
   - Объявить победителя:

     ```
     Игра окончена. Вы выиграли с [X] семенами!
     ```

### 4. **Дополнительные функции**

   - Отображение текущего состояния доски после каждого хода.
   - Возможность начать новую игру или выйти.

---

## Пример работы программы

1. **Начало игры**:

   ```
   Добро пожаловать в игру Awari!
   Текущая доска:
   [0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4]
   Ваш ход. Выберите лунку (1-6):
   > 3
   ```

2. **После хода игрока**:

   ```
   Вы взяли 4 семени из лунки 3.
   Текущая доска:
   [0, 4, 4, 0, 5, 5, 5, 0, 4, 4, 4, 4, 4, 4]
   Ход компьютера...
   Компьютер выбрал лунку 10.
   ```

3. **Завершение игры**:

   ```
   Игра окончена!
   Вы набрали 26 семян. Компьютер набрал 22 семени.
   Вы победили!
   ```

---

## Возможные ограничения

- Следить за тем, чтобы компьютер не делал некорректные ходы.
- При слишком большом поле (если изменить количество лунок) потребуется оптимизация.

---
```
```python
"""
Модуль для реализации игры Авари (Манкала).
=========================================================================================

Модуль содержит функции для инициализации игры, выполнения ходов игроков, проверки условий
победы и отображения текущего состояния доски.

Примеры использования
--------------------

Пример запуска игры:

.. code-block:: python

   from src.endpoints.ai_games.101_basic_computer_games.ru.rules.awari import play_awari
   play_awari()
"""
from typing import List, Tuple # импортируем необходимые типы
from src.logger.logger import logger # импортируем logger для логирования ошибок
from random import choice # импортируем choice для выбора случайного хода компьютера

def initialize_board() -> List[int]:
    """
    Инициализирует игровую доску.

    :return: Список, представляющий доску Авари с начальными значениями.
        Индексы 1-6 - лунки игрока, 8-13 - лунки компьютера, 0 и 7 - дома игроков.
    :rtype: List[int]
    """
    return [0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4] # создаем и возвращаем начальную доску

def display_board(board: List[int]) -> None:
    """
    Отображает текущее состояние игровой доски в консоли.

    :param board: Список, представляющий игровую доску.
    :type board: List[int]
    """
    print("---------------------") # разделение для лучшей читаемости
    print(f"Компьютер: {board[7]:2}  | {board[8]:2} {board[9]:2} {board[10]:2} {board[11]:2} {board[12]:2} {board[13]:2} |") # отображение лунок компьютера
    print(f"Игрок    : {board[0]:2}  | {board[1]:2} {board[2]:2} {board[3]:2} {board[4]:2} {board[5]:2} {board[6]:2} |") # отображение лунок игрока
    print("---------------------") # разделение для лучшей читаемости

def player_move(board: List[int], move: int) -> Tuple[List[int], bool]:
    """
    Выполняет ход игрока.

    :param board: Список, представляющий игровую доску.
    :type board: List[int]
    :param move: Индекс лунки, выбранной игроком.
    :type move: int
    :return: Кортеж, содержащий обновленную доску и флаг, указывающий, получил ли игрок дополнительный ход.
    :rtype: Tuple[List[int], bool]
    """
    seeds = board[move] # получаем количество семян из выбранной лунки
    board[move] = 0 # обнуляем выбранную лунку
    current_pos = move # устанавливаем текущую позицию
    extra_turn = False  # флаг для дополнительного хода
    while seeds > 0: # пока есть семена для распределения
        current_pos = (current_pos + 1) % len(board)  # двигаемся по кругу, пропуская дом противника
        if current_pos == 7: # пропускаем дом компьютера
            continue
        board[current_pos] += 1 # добавляем семя в текущую лунку
        seeds -= 1 # уменьшаем количество семян для распределения
    if 1 <= current_pos <= 6 and board[current_pos] == 1:
        opposite_pos = 14 - current_pos  # вычисляем противоположную позицию
        if board[opposite_pos] > 0:  # если напротив есть семена
           board[0] += board[current_pos] + board[opposite_pos] # собираем семена
           board[current_pos] = 0 # обнуляем текущую лунку
           board[opposite_pos] = 0 # обнуляем противоположную лунку
    if current_pos == 0: # если последнее семя попало в дом игрока, даем дополнительный ход
        extra_turn = True
    return board, extra_turn # возвращаем обновленную доску и флаг дополнительного хода

def computer_move(board: List[int]) -> Tuple[List[int], bool]:
    """
    Выполняет ход компьютера.

    :param board: Список, представляющий игровую доску.
    :type board: List[int]
    :return: Кортеж, содержащий обновленную доску и флаг, указывающий, получил ли компьютер дополнительный ход.
    :rtype: Tuple[List[int], bool]
    """
    possible_moves = [i for i in range(8, 14) if board[i] > 0]  # определяем возможные ходы
    if not possible_moves:
        return board, False # если ходов нет, возвращаем доску без изменений
    move = choice(possible_moves) # выбираем случайный ход
    seeds = board[move] # получаем количество семян из выбранной лунки
    board[move] = 0 # обнуляем выбранную лунку
    current_pos = move # устанавливаем текущую позицию
    extra_turn = False # флаг для дополнительного хода

    while seeds > 0: # пока есть семена для распределения
        current_pos = (current_pos + 1) % len(board) # двигаемся по кругу, пропуская дом игрока
        if current_pos == 0: # пропускаем дом игрока
            continue
        board[current_pos] += 1 # добавляем семя в текущую лунку
        seeds -= 1 # уменьшаем количество семян для распределения
    if 8 <= current_pos <= 13 and board[current_pos] == 1:
        opposite_pos = 14 - current_pos # вычисляем противоположную позицию
        if board[opposite_pos] > 0: # если напротив есть семена
           board[7] += board[current_pos] + board[opposite_pos] # собираем семена
           board[current_pos] = 0 # обнуляем текущую лунку
           board[opposite_pos] = 0 # обнуляем противоположную лунку
    if current_pos == 7: # если последнее семя попало в дом компьютера, даем дополнительный ход
        extra_turn = True
    return board, extra_turn # возвращаем обновленную доску и флаг дополнительного хода

def check_game_end(board: List[int]) -> bool:
    """
    Проверяет, закончилась ли игра.

    :param board: Список, представляющий игровую доску.
    :type board: List[int]
    :return: True, если игра закончилась, иначе False.
    :rtype: bool
    """
    player_side = sum(board[1:7]) # сумма семян на стороне игрока
    computer_side = sum(board[8:14]) # сумма семян на стороне компьютера
    return player_side == 0 or computer_side == 0 # возвращаем True если одна из сторон пуста

def calculate_score(board: List[int]) -> Tuple[int, int]:
    """
    Подсчитывает очки игроков.

    :param board: Список, представляющий игровую доску.
    :type board: List[int]
    :return: Кортеж, содержащий очки игрока и компьютера.
    :rtype: Tuple[int, int]
    """
    player_score = board[0] + sum(board[1:7])  # общее количество семян на стороне игрока
    computer_score = board[7] + sum(board[8:14]) # общее количество семян на стороне компьютера
    return player_score, computer_score  # возвращаем очки игрока и компьютера

def play_awari() -> None:
    """
    Запускает игру Авари.

    Функция инициализирует доску, отображает её и обеспечивает поочередные ходы игрока и компьютера,
    а также определяет победителя после окончания игры.
    """
    board = initialize_board()  # инициализируем доску
    current_player = "player"  # определяем текущего игрока
    while True:  # основной цикл игры
        display_board(board)  # отображаем доску
        if current_player == "player": # если ход игрока
            while True: # цикл для валидации хода
                try: # ловим ошибки ввода
                    move = int(input("Ваш ход. Выберите лунку (1-6): ")) # просим ввести ход
                    if 1 <= move <= 6 and board[move] > 0: # проверяем валидность хода
                        break # выходим из цикла, если ход валиден
                    else: # если ход не валиден
                        print("Неверный ход. Попробуйте еще раз.") # сообщаем об ошибке
                except ValueError: # если введен не номер
                    print("Неверный ввод. Пожалуйста, введите число от 1 до 6.") # сообщаем об ошибке
            board, extra_turn = player_move(board, move) # делаем ход игрока
            if not extra_turn: # если нет дополнительного хода, передаем ход компьютеру
                current_player = "computer"
        else: # если ход компьютера
            print("Ход компьютера...") # сообщаем о ходе компьютера
            board, extra_turn = computer_move(board) # делаем ход компьютера
            if not extra_turn:  # если нет дополнительного хода, передаем ход игроку
                current_player = "player"
        if check_game_end(board): # если игра закончилась
             display_board(board) # отображаем доску
             player_score, computer_score = calculate_score(board) # подсчитываем очки
             print("Игра окончена!") # сообщаем об окончании игры
             print(f"Вы набрали {player_score} семян. Компьютер набрал {computer_score} семян.") # сообщаем количество очков
             if player_score > computer_score: # если игрок победил
                print("Вы победили!") # сообщаем о победе
             elif computer_score > player_score: # если компьютер победил
                print("Компьютер победил!") # сообщаем о победе компьютера
             else: # если ничья
                print("Ничья!") # сообщаем о ничье
             break  # выходим из цикла игры

if __name__ == '__main__':
    play_awari()  # запускаем игру
```