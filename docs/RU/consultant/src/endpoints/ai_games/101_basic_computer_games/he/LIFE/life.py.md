# Анализ кода модуля `life.py`

**Качество кода: 7/10**

*   **Плюсы:**
    *   Код хорошо структурирован и разбит на логические функции.
    *   Используются информативные имена переменных и функций.
    *   Присутствует подробное описание логики работы программы и функций в виде комментариев.
    *   Наличие блок-схемы в виде mermaid.
    *   Наличие обработки исключений при вводе данных.
*   **Минусы:**
    *   Отсутствует использование `src.utils.jjson` для обработки файлов, хотя в этом коде нет операций с файлами.
    *   Нет логирования ошибок с использованием `src.logger.logger`.
    *   Комментарии не соответствуют стандарту reStructuredText (RST).
    *   Не все комментарии к коду достаточно подробные.
    *   Излишнее использование стандартных блоков `try-except`, предпочтительнее обрабатывать ошибки через `logger.error`.
    *   Отсутствует импорт `from src.logger.logger import logger`.

**Рекомендации по улучшению:**

1.  **Документация**:
    *   Переписать все комментарии и docstring в формате reStructuredText (RST).
    *   Добавить более подробные описания к каждой функции, переменной и параметрам, используя нотацию RST.
2.  **Логирование**:
    *   Использовать `from src.logger.logger import logger` для логирования ошибок и отладочной информации.
    *   Заменить `try-except` на `logger.error` для обработки ошибок.
3.  **Структура кода**:
    *   Убрать неиспользуемые импорты, если они есть.
    *   Убедиться, что имена функций, переменных соответствуют ранее обработанным файлам.
4.  **Обработка данных**:
    *   Заменить `json.load` на `j_loads` или `j_loads_ns` при работе с json файлами (не требуется в текущей реализации).
5.  **Комментарии**:
    *   Сделать комментарии более конкретными, избегать общих фраз типа "делаем" или "получаем".

**Оптимизированный код:**

```python
"""
Модуль LIFE:
=========================================================================================

Этот модуль реализует симуляцию игры "Жизнь" на клеточном автомате.

Описание:
    Игра "Жизнь" представляет собой простую симуляцию клеток, которые могут быть "живыми" или "мертвыми" на игровой доске.
    Состояние каждой клетки изменяется в каждом поколении в зависимости от количества живых соседей.
    Игра демонстрирует сложные закономерности, возникающие из простых правил.

Правила игры:
    1. Игра происходит на двумерной доске.
    2. Каждая клетка может быть "живой" (1) или "мертвой" (0).
    3. Каждое поколение вычисляется по следующим правилам:
        - Живая клетка с менее чем двумя живыми соседями умирает.
        - Живая клетка с двумя или тремя живыми соседями остается живой.
        - Живая клетка с более чем тремя живыми соседями умирает.
        - Мертвая клетка с ровно тремя живыми соседями оживает.
    4. Соседями клетки являются 8 клеток вокруг нее (включая диагональные).
    5. Игра продолжается, пока не достигнет заданного количества поколений или пользователь не остановит ее.

Алгоритм:
    1. Инициализировать доску:
        1.1. Получить от пользователя размер доски (количество строк и столбцов).
        1.2. Инициализировать доску случайными живыми или мертвыми клетками.
    2. Для каждого поколения:
        2.1. Создать новую доску для следующего поколения.
        2.2. Для каждой клетки на доске:
            2.2.1. Посчитать количество живых соседей клетки.
            2.2.2. Применить правила игры:
                - Если клетка жива и имеет менее 2 живых соседей, клетка умирает в следующем поколении.
                - Если клетка жива и имеет 2 или 3 живых соседа, клетка остается живой в следующем поколении.
                - Если клетка жива и имеет более 3 живых соседей, клетка умирает в следующем поколении.
                - Если клетка мертва и имеет ровно 3 живых соседа, клетка оживает в следующем поколении.
            2.2.3. Обновить новую доску состоянием клетки.
        2.3. Вывести новую доску.
        2.4. Сделать новую доску текущей.
    3. Конец игры.

Диаграмма потоков:

.. mermaid::
    flowchart TD
        Start["Начало"] --> InputBoardSize["<p align='left'>Ввод размера доски:\n    <code><b>rows, cols</b></code></p>"]
        InputBoardSize --> InitializeBoard["<p align='left'>Инициализация доски:\n    <code><b>board = random(rows, cols)</b></code></p>"]
        InitializeBoard --> InputGenerations["<p align='left'>Ввод количества поколений:\n    <code><b>numberOfGenerations</b></code></p>"]
        InputGenerations --> LoopStart{"Начало цикла: для каждого поколения"}
        LoopStart -- Да --> CreateNewBoard["Создание новой доски: <code><b>newBoard</b></code>"]
        CreateNewBoard --> LoopCellsStart{"Начало цикла: для каждой клетки на доске"}
        LoopCellsStart -- Да --> CountLiveNeighbors["Подсчет живых соседей: <code><b>liveNeighbors</b></code>"]
        CountLiveNeighbors --> ApplyRules["Применение правил игры"]
        ApplyRules --> UpdateNewBoard["Обновление новой доски: <code><b>newBoard[row][col]</b></code>"]
        UpdateNewBoard --> LoopCellsEnd{"Конец цикла: для каждой клетки на доске"}
        LoopCellsEnd -- Да --> LoopCellsStart
        LoopCellsEnd -- Нет --> PrintBoard["Вывод доски: <code><b>newBoard</b></code>"]
        PrintBoard --> UpdateBoard["Обновление доски: <code><b>board = newBoard</b></code>"]
        UpdateBoard --> LoopEnd{"Конец цикла: для каждого поколения"}
        LoopEnd -- Да --> LoopStart
        LoopEnd -- Нет --> End["Конец"]

Легенда:
    Start - Начало программы.
    InputBoardSize - Получение размера доски от пользователя (количество строк и столбцов).
    InitializeBoard - Инициализация доски со случайными значениями (живая или мертвая).
    InputGenerations - Получение количества поколений для отображения.
    LoopStart - Начало цикла для выполнения заданного количества поколений.
    CreateNewBoard - Создание новой доски для следующего поколения.
    LoopCellsStart - Начало цикла для каждой клетки на доске.
    CountLiveNeighbors - Подсчет живых соседей для заданной клетки.
    ApplyRules - Применение правил игры "Жизнь" к клетке, в зависимости от числа ее соседей.
    UpdateNewBoard - Обновление состояния клетки в новой доске.
    LoopCellsEnd - Конец цикла для каждой клетки на доске.
    PrintBoard - Вывод новой доски на экран.
    UpdateBoard - Обновление текущей доски новой доской.
    LoopEnd - Конец цикла для всех поколений.
    End - Конец программы.
"""
import random
import time
#  Импортируем модуль для логирования
from src.logger.logger import logger


def create_board(rows: int, cols: int) -> list[list[int]]:
    """
    Создает игровую доску заданного размера и заполняет ее случайными значениями 0 или 1.

    :param rows: Количество строк на доске.
    :param cols: Количество столбцов на доске.
    :return: Двумерный список (доска), содержащий 0 или 1 в случайном порядке.
    """
    #  Создание и возврат двумерного списка, заполненного случайными 0 или 1
    board = [[random.choice([0, 1]) for _ in range(cols)] for _ in range(rows)]
    return board


def count_live_neighbors(board: list[list[int]], row: int, col: int) -> int:
    """
    Подсчитывает количество живых соседей у заданной клетки на доске.
    Соседями считаются клетки, прилегающие к заданной (по вертикали, горизонтали и диагонали).

    :param board: Игровая доска.
    :param row: Номер строки клетки.
    :param col: Номер столбца клетки.
    :return: Количество живых соседей у заданной клетки.
    """
    rows = len(board)
    cols = len(board[0])
    live_neighbors = 0

    #  Считаем живых соседей, перебирая все соседние клетки
    for i in range(max(0, row - 1), min(rows, row + 2)):
        for j in range(max(0, col - 1), min(cols, col + 2)):
            if (i, j) != (row, col):  #  Исключаем саму клетку из подсчета
                live_neighbors += board[i][j]
    return live_neighbors


def next_generation(board: list[list[int]]) -> list[list[int]]:
    """
    Создает новую игровую доску, представляющую следующее поколение игры.
    Новое состояние клеток рассчитывается на основе правил игры.

    :param board: Текущая игровая доска.
    :return: Новая игровая доска, представляющая следующее поколение.
    """
    rows = len(board)
    cols = len(board[0])
    new_board = [[0 for _ in range(cols)] for _ in range(rows)]

    #  Создаем новую доску на основе правил
    for row in range(rows):
        for col in range(cols):
            live_neighbors = count_live_neighbors(board, row, col)
            #  Применяем правила игры
            if board[row][col] == 1:  #  Клетка жива
                if live_neighbors < 2 or live_neighbors > 3:
                    new_board[row][col] = 0  #  Клетка умирает
                else:
                    new_board[row][col] = 1  #  Клетка остается живой
            else:  #  Клетка мертва
                if live_neighbors == 3:
                    new_board[row][col] = 1  #  Клетка оживает

    return new_board


def print_board(board: list[list[int]]):
    """
    Выводит текущее состояние игровой доски на экран.
    Каждая строка доски выводится на новой строке, клетки разделены пробелами.

    :param board: Игровая доска для вывода.
    """
    #  Выводим доску на экран
    for row in board:
        print(' '.join(str(cell) for cell in row))
    print()  #  Выводим пустую строку для разделения поколений


def play_life(rows: int, cols: int, generations: int):
    """
    Запускает игру "Жизнь" с заданным количеством строк, столбцов и поколений.
    Игра обновляет и выводит состояние доски на каждом поколении.

    :param rows: Количество строк на доске.
    :param cols: Количество столбцов на доске.
    :param generations: Количество поколений для симуляции.
    """
    #  Инициализация и запуск игры
    board = create_board(rows, cols)
    for generation in range(generations):
        print(f"Поколение {generation + 1}:")
        print_board(board)
        board = next_generation(board)
        time.sleep(0.5)


if __name__ == "__main__":
    #  Обработка исключений при вводе данных
    try:
        rows = int(input("Введите количество строк доски: "))
        cols = int(input("Введите количество столбцов доски: "))
        generations = int(input("Введите количество поколений: "))

        #  Проверяем валидность введенных данных
        if rows <= 0 or cols <= 0 or generations <= 0:
            print("Число должно быть больше 0")
        else:
            play_life(rows, cols, generations)

    except ValueError as e:
        #  Логируем ошибку при неверном вводе данных
        logger.error("Неверный ввод данных. Пожалуйста, введите целые числа.", exc_info=e)
        print("Неверный ввод. Пожалуйста, введите целые числа.")
```