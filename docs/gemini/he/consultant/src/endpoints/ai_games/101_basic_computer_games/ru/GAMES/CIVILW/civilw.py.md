# Анализ кода модуля `civilw`

**Качество кода**

-   **Соответствие требованиям к формату кода (1-10):** 6/10
    -   **Преимущества:**
        -   Код выполняет основную логику игры "Гражданская война" согласно описанию.
        -   Присутствует базовый цикл игры, ввод данных от пользователя, расчет потерь и проверка условий победы.
        -   Используется модуль `random` для симуляции случайных событий.
        -   Есть обработка ошибок при вводе чисел (целых чисел)
    -   **Недостатки:**
        -   Отсутствует форматирование кода, что делает его менее читаемым.
        -   Код не документирован в формате reStructuredText (RST).
        -   Используется `print` для вывода сообщений, что не подходит для логирования ошибок (использовать `logger.error`).
        -   Нет обработки исключений, кроме `ValueError` (необходимо обернуть ввод в `try-except`).
        -   Нет разделения логики на функции.

**Рекомендации по улучшению**

1.  **Форматирование и стиль:**
    -   Используйте PEP 8 для форматирования кода.
    -   Добавьте пробелы после запятых и операторов.
    -   Разбейте код на логические блоки с помощью пустых строк.
2.  **Документация:**
    -   Добавьте docstring в формате reStructuredText (RST) для модуля и каждой функции.
3.  **Обработка ошибок:**
    -   Замените `print` на `logger.error` для вывода сообщений об ошибках.
    -   Оберните ввод данных в `try-except` для обработки возможных ошибок.
4.  **Структура кода:**
    -   Разбейте код на функции для большей модульности и читаемости.
    -   Создайте функции для ввода данных, расчета потерь, обновления армии и проверки победы.
    -   Избегайте глобальных переменных, передавайте параметры в функции.
5.  **Импорты:**
    - Добавить импорт `logger`
    - Упорядочите импорты по алфавиту.

**Улучшенный код**

```python
"""
Модуль CIVILW:
=================

Симуляция сражения между двумя армиями: Конфедерацией и Союзом. Игрок управляет Конфедерацией и принимает
решения о численности своих войск и типе атак.

:Difficulty: 7

Правила игры:
    1. Игрок управляет армией Конфедерации и должен победить армию Союза.
    2. Игрок вводит количество солдат для атаки.
    3. Игрок выбирает тип атаки: прямая (1) или обходная (2).
    4. В зависимости от выбора игрока и случайных факторов, производится расчет потерь для обеих сторон.
    5. После каждого сражения, игра выводит текущую численность войск обеих сторон.
    6. Игра завершается победой одной из сторон, когда численность войск противника становится равна или меньше 0.

Алгоритм:
    1. Установить начальную численность армии Союза (UnionForce) равной 1000 и армии Конфедерации (ConfederateForce) равной 800.
    2. Начать цикл "пока обе армии имеют численность больше 0":
        2.1. Запросить у игрока количество солдат, которых он хочет отправить в атаку (AttackForce).
            2.1.1. Если AttackForce больше, чем имеющиеся силы Конфедерации (ConfederateForce), то вывести сообщение "Недостаточно сил" и вернуться к началу шага 2.1
        2.2. Запросить у игрока тип атаки: прямая (1) или обходная (2) (AttackType).
        2.3. Вычислить потери Конфедерации (ConfederateLosses) случайным образом, умножив AttackForce на случайное число от 0 до 0.4 (для прямой атаки) или на случайное число от 0 до 0.2 (для обходного маневра).
            2.3.1. Если ConfederateLosses больше, чем AttackForce, ConfederateLosses установить равным AttackForce.
        2.4. Вычислить потери Союза (UnionLosses) случайным образом, умножив AttackForce на случайное число от 0 до 0.3.
            2.4.1. Если AttackType равно 2, то увеличить UnionLosses на случайное число от 0 до 100.
        2.5. Обновить численность армий:
            ConfederateForce = ConfederateForce - ConfederateLosses
            UnionForce = UnionForce - UnionLosses
        2.6. Вывести текущую численность армий обеих сторон.
        2.7. Проверить условие победы:
            2.7.1. Если UnionForce меньше или равен 0, то вывести сообщение "Конфедерация победила!" и закончить игру.
            2.7.2. Если ConfederateForce меньше или равен 0, то вывести сообщение "Союз победил!" и закончить игру.
    3. Конец игры.
"""
import random  # Импортирует модуль random для генерации случайных чисел
from src.logger.logger import logger  # Импортирует logger для записи ошибок

def get_attack_force(confederate_force: int) -> int:
    """
    Запрашивает у игрока количество солдат для атаки.

    :param confederate_force: Текущая численность армии Конфедерации.
    :return: Количество солдат для атаки.
    """
    while True:
        try:
            attack_force = int(input('Введите количество солдат для атаки (Конфедерация): '))  # Запрашивает ввод от пользователя
            if attack_force > confederate_force:
                print('Недостаточно сил! Попробуйте еще раз.')  # Выводит сообщение об ошибке
            else:
                return attack_force  # Возвращает введенное количество солдат
        except ValueError:
            logger.error('Ошибка ввода: Пожалуйста, введите целое число.')  # Логирует ошибку

def get_attack_type() -> int:
    """
    Запрашивает у игрока тип атаки.

    :return: Тип атаки (1 - прямая, 2 - обходная).
    """
    while True:
        try:
            attack_type = int(input('Выберите тип атаки (1 - прямая, 2 - обходная): '))  # Запрашивает ввод от пользователя
            if attack_type in [1, 2]:
                return attack_type  # Возвращает введенный тип атаки
            else:
                print('Неверный тип атаки, попробуйте еще раз')  # Выводит сообщение об ошибке
        except ValueError:
            logger.error('Ошибка ввода: Пожалуйста, введите целое число 1 или 2.')  # Логирует ошибку


def calculate_losses(attack_force: int, attack_type: int) -> tuple[int, int]:
    """
    Вычисляет потери для Конфедерации и Союза.

    :param attack_force: Количество солдат, участвующих в атаке.
    :param attack_type: Тип атаки (1 - прямая, 2 - обходная).
    :return: Кортеж (потери Конфедерации, потери Союза).
    """
    if attack_type == 1:  # Прямая атака
        confederate_losses = int(attack_force * random.random() * 0.4) # Расчет потерь Конфедерации при прямой атаке
    else:  # Обходной маневр
        confederate_losses = int(attack_force * random.random() * 0.2) # Расчет потерь Конфедерации при обходной атаке

    if confederate_losses > attack_force:
        confederate_losses = attack_force # Гарантирует, что потери не больше числа атакующих

    union_losses = int(attack_force * random.random() * 0.3) # Расчет потерь Союза
    if attack_type == 2:
        union_losses += random.randint(0, 100)  # Увеличение потерь Союза при обходной атаке

    return confederate_losses, union_losses  # Возвращает потери обеих сторон

def update_forces(confederate_force: int, union_force: int, confederate_losses: int, union_losses: int) -> tuple[int, int]:
    """
     Обновляет численность армий после сражения.

    :param confederate_force: Текущая численность армии Конфедерации.
    :param union_force: Текущая численность армии Союза.
    :param confederate_losses: Потери армии Конфедерации в сражении.
    :param union_losses: Потери армии Союза в сражении.
    :return: Кортеж (новая численность армии Конфедерации, новая численность армии Союза).
    """
    confederate_force -= confederate_losses  # Обновление численности армии Конфедерации
    union_force -= union_losses  # Обновление численности армии Союза
    return confederate_force, union_force  # Возвращает новые значения численности

def check_win_condition(confederate_force: int, union_force: int) -> bool:
    """
    Проверяет условия победы и выводит сообщение о победе.

    :param confederate_force: Текущая численность армии Конфедерации.
    :param union_force: Текущая численность армии Союза.
    :return: True, если игра закончилась, иначе False.
    """
    if union_force <= 0:
        print('Конфедерация победила!') # Вывод сообщения о победе Конфедерации
        return True
    elif confederate_force <= 0:
        print('Союз победил!')  # Вывод сообщения о победе Союза
        return True
    return False # Возвращает False, если игра еще не закончилась

def main():
    """
    Основная логика игры "Гражданская война".
    """
    union_force = 1000  # Начальная численность армии Союза
    confederate_force = 800  # Начальная численность армии Конфедерации

    while union_force > 0 and confederate_force > 0:  # Основной игровой цикл
        attack_force = get_attack_force(confederate_force) # Получение количества солдат для атаки
        attack_type = get_attack_type() # Получение типа атаки

        confederate_losses, union_losses = calculate_losses(attack_force, attack_type)  # Расчет потерь обеих сторон
        confederate_force, union_force = update_forces(confederate_force, union_force, confederate_losses, union_losses)  # Обновление численности армий

        print(f'Конфедерация: {confederate_force} солдат')  # Вывод текущей численности армии Конфедерации
        print(f'Союз: {union_force} солдат')  # Вывод текущей численности армии Союза

        if check_win_condition(confederate_force, union_force): # Проверка условия победы
            break # Завершение игры, если одна из сторон победила

if __name__ == '__main__':
    main() # Запуск основной функции
```