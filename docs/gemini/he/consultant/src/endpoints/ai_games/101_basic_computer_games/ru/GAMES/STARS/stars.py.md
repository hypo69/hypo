# Анализ кода модуля stars.py

**Качество кода**
- Соответствие требованиям к формату кода: 8/10
    - **Преимущества:**
        - Код читаемый и понятный, структура игры логически построена.
        - Использованы содержательные названия переменных и функций.
        - Есть подробные комментарии, объясняющие логику работы кода.
        - Имеется блок-схема для визуализации алгоритма игры.
    - **Недостатки:**
        - Отсутствует reStructuredText (RST) для документирования.
        - Не используются `j_loads` или `j_loads_ns` для чтения файлов (в данном случае это не требуется, так как нет работы с файлами, но нужно использовать в общем случае).
        - Нет обработки ошибок и использования `logger.error`.
        - Нет импортов, хотя в данном случае они не нужны.
        - Отсутствует описание модуля в формате RST в начале файла.
        - Использованы множественные комментарии `#` вместо docstring.
        - Нет описания параметров и возвращаемых значений функций с помощью docstring формата RST.
        - Использован `print` для вывода в консоль, в больших проектах это обычно делают через `logger`.
        - Использованы русские сообщения в коде, необходимо перевести их в переменные или сделать мультиязычность.

**Рекомендации по улучшению**

1.  **Документирование в reStructuredText (RST):**
    - Добавить docstring в формате RST для модуля, функций и методов.
    - Описать параметры функций и возвращаемые значения.
2.  **Обработка ошибок:**
    - Использовать `try-except` блоки для отлова возможных ошибок и выводить их через `logger.error`.
3.  **Улучшение структуры кода:**
    - Вынести логику проверки выигрыша в отдельную функцию.
    - Вынести текст сообщений в отдельные переменные или использовать локализацию.
4.  **Логирование:**
   - Использовать `logger` для вывода сообщений, особенно при отладке.
5.  **Использование констант:**
    - Вынести размер игрового поля (`boardSize`) в константу, а не в переменную.

**Улучшенный код**

```python
"""
Модуль, реализующий текстовую игру "Звезды".
=========================================================================================

Игра "Звезды" представляет собой простую текстовую игру, в которой игрок управляет положением "звезды" на экране, вводя команды для ее перемещения.
Цель игры - переместить звезду в правый нижний угол экрана.

:rules:
    - Изначально звезда находится в левом верхнем углу экрана (позиция 1,1).
    - Игрок вводит команды перемещения:
        - 'R' - переместить звезду вправо
        - 'L' - переместить звезду влево
        - 'U' - переместить звезду вверх
        - 'D' - переместить звезду вниз
    - Экран представляет собой сетку 12x12.
    - Игра заканчивается, когда звезда достигает правого нижнего угла экрана (позиция 12,12).

:algorithm:
    1. Установить начальную позицию звезды в (1, 1).
    2. Вывести на экран начальное расположение звезды, изображая ее символом "*".
    3. Начать цикл:
        3.1 Запросить ввод команды перемещения ('R', 'L', 'U', 'D').
        3.2 Обновить позицию звезды в зависимости от введенной команды.
        3.3 Проверить, достигла ли звезда позиции (12, 12). Если да, вывести сообщение о победе и завершить игру.
        3.4 Иначе вывести на экран новое расположение звезды.
    4. Конец игры.

:block_schema:
    ```mermaid
    flowchart TD
        Start["Начало"] --> InitializePosition["<p align='left'>Инициализация позиции звезды:\n    <code><b>\n    starRow = 1\n    starCol = 1\n    </b></code></p>"]
        InitializePosition --> DisplayBoard["Вывод начального положения звезды"]
        DisplayBoard --> LoopStart{"Начало цикла"}
        LoopStart --> InputMove["Ввод команды перемещения (R, L, U, D)"]
        InputMove --> UpdatePosition["<p align='left'>Обновление позиции звезды:\n    <code><b>\n    starRow, starCol = updatePosition(command, starRow, starCol)\n    </b></code></p>"]
        UpdatePosition --> CheckWin{"Проверка: <code><b>starRow == 12 and starCol == 12?</b></code>"}
        CheckWin -- Да --> OutputWin["Вывод сообщения: <b>YOU MADE IT!</b>"]
        OutputWin --> End["Конец"]
        CheckWin -- Нет --> DisplayBoardUpdated["Вывод нового положения звезды"]
        DisplayBoardUpdated --> LoopStart
    ```

:legend:
    - Start - Начало программы.
    - InitializePosition - Инициализация начальной позиции звезды: starRow (строка) и starCol (столбец) устанавливаются в 1.
    - DisplayBoard - Вывод на экран начального расположения звезды.
    - LoopStart - Начало игрового цикла.
    - InputMove - Запрос у игрока команды для перемещения звезды ('R', 'L', 'U', 'D').
    - UpdatePosition - Обновление позиции звезды на основе введенной команды.
    - CheckWin - Проверка, достигла ли звезда конечной позиции (12, 12).
    - OutputWin - Вывод сообщения о победе, если звезда достигла конечной позиции.
    - End - Конец программы.
    - DisplayBoardUpdated - Вывод на экран обновленного положения звезды.
"""
from src.logger.logger import logger  # подключаем logger #
# Инициализация начальной позиции звезды
starRow = 1
starCol = 1
# Размер игровой доски #
BOARD_SIZE = 12 # Заменили переменную на константу #
WIN_MESSAGE = "ПОЗДРАВЛЯЮ! Вы переместили звезду в правый нижний угол!"  # Сообщение о победе #


def printBoard(starRow: int, starCol: int) -> None:
    """
    Выводит на экран игровое поле с текущей позицией звезды.

    :param starRow: строка, в которой находится звезда.
    :type starRow: int
    :param starCol: столбец, в котором находится звезда.
    :type starCol: int
    :return: None
    :rtype: None
    """
    for row in range(1, BOARD_SIZE + 1): # Используем константу BOARD_SIZE #
        line = ""
        for col in range(1, BOARD_SIZE + 1): # Используем константу BOARD_SIZE #
            if row == starRow and col == starCol:
                line += "*"  # Отображаем звезду
            else:
                line += "."  # Отображаем пустую клетку
        print(line)


def updatePosition(command: str, starRow: int, starCol: int) -> tuple[int, int]:
    """
    Обновляет позицию звезды на основе введенной команды.

    :param command: команда перемещения ('R', 'L', 'U', 'D').
    :type command: str
    :param starRow: текущая строка звезды.
    :type starRow: int
    :param starCol: текущий столбец звезды.
    :type starCol: int
    :return: новая строка и столбец звезды.
    :rtype: tuple[int, int]
    """
    try: # Добавляем обработку ошибок #
        if command == 'R':  # Двигаемся вправо
            if starCol < BOARD_SIZE: # Используем константу BOARD_SIZE #
                starCol += 1
        elif command == 'L':  # Двигаемся влево
            if starCol > 1:
                starCol -= 1
        elif command == 'U':  # Двигаемся вверх
            if starRow > 1:
                starRow -= 1
        elif command == 'D':  # Двигаемся вниз
            if starRow < BOARD_SIZE: # Используем константу BOARD_SIZE #
                starRow += 1
    except Exception as ex: # Ловим все возможные ошибки и выводим в лог #
         logger.error(f'Ошибка при обновлении позиции звезды: {ex}', exc_info=True) # выводим сообщение об ошибке с деталями #
    return starRow, starCol


def check_win(starRow: int, starCol: int) -> bool:
    """
    Проверяет, достигла ли звезда конечной позиции.

    :param starRow: текущая строка звезды.
    :type starRow: int
    :param starCol: текущий столбец звезды.
    :type starCol: int
    :return: True, если звезда достигла конечной позиции, иначе False.
    :rtype: bool
    """
    return starRow == BOARD_SIZE and starCol == BOARD_SIZE # Используем константу BOARD_SIZE #


# Вывод начального положения звезды
printBoard(starRow, starCol)

# Основной игровой цикл
while True:
    # Запрос команды перемещения у пользователя
    command = input("Введите команду (R/L/U/D): ").upper()

    # Обновление позиции звезды на основе введенной команды
    starRow, starCol = updatePosition(command, starRow, starCol)

    # Вывод нового положения звезды на экран
    printBoard(starRow, starCol)

    # Проверка, достигла ли звезда конечной позиции
    if check_win(starRow, starCol): # вызываем функцию проверки победы #
        print(WIN_MESSAGE) # Используем переменную для сообщения #
        break  # Завершаем игру

```