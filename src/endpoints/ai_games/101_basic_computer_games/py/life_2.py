"""
<LIFE 2>:
=================
Сложность: 6
-----------------
Игра "Жизнь 2" - это симуляция клеточного автомата, где на игровом поле, представляющем собой сетку, живут и умирают "клетки". Игрок вводит начальную конфигурацию живых клеток, а затем программа итерирует поколения, показывая, как эти клетки изменяются в соответствии с простыми правилами. Игра наглядно демонстрирует концепцию возникновения сложных структур из простых правил. 
Правила игры:
1. Игровое поле представляет собой сетку (матрицу) размером 10x10.
2. Каждая ячейка поля может быть либо "живой" (обозначена как 1), либо "мертвой" (обозначена как 0).
3. Игрок на этапе инициализации вводит координаты живых клеток.
4. Каждое поколение (итерация) определяется следующим образом:
    - Для каждой клетки подсчитывается количество живых соседей. Соседями считаются 8 соседних клеток (сверху, снизу, слева, справа, и по диагонали).
    - Если живая клетка имеет 2 или 3 живых соседа, то она остается живой в следующем поколении. В остальных случаях она умирает (становится мертвой).
    - Если мертвая клетка имеет ровно 3 живых соседа, то она оживает (становится живой) в следующем поколении.
5. Игра продолжается до тех пор, пока игрок не решит завершить.

-----------------
Алгоритм:
1. Инициализация игрового поля: создается двумерный массив (матрица) 10x10, заполненный нулями (мертвые клетки).
2. Ввод начальной конфигурации: игрок вводит координаты (X, Y) живых клеток. Введенные координаты отмечаются как 1 в матрице.
3. Основной цикл:
   - Вывод текущего состояния поля на экран.
   - Создание нового массива (матрицы), который будет представлять следующее поколение.
   - Для каждой клетки в матрице:
       - Подсчет количества живых соседей.
       - Применение правил игры для определения состояния клетки в следующем поколении:
         - Если клетка живая (1) и имеет 2 или 3 живых соседа, то в следующем поколении она остается живой.
         - Если клетка живая (1) и имеет меньше 2 или больше 3 живых соседа, то в следующем поколении она становится мертвой (0).
         - Если клетка мертвая (0) и имеет ровно 3 живых соседа, то в следующем поколении она становится живой (1).
         - В противном случае, клетка остается мертвой (0).
   - Присвоение новой матрице в качестве текущей матрицы (обновление поколения).
   - Запрос у игрока, продолжать игру или нет. Если нет, то завершение игры.
   - Переход к следующему поколению.
4. Конец игры.

-----------------
Блок-схема:
```mermaid
graph TD
    A[Start] --> B(Initialize game board);
    B --> C{Input initial alive cells coordinates};
    C --> D(Print current game board);
    D --> E(Create next generation game board);
    E --> F{For each cell on game board};
    F --> G(Count alive neighbors);
    G --> H{Apply game rules};
    H --> I(Update next generation game board);
    I --> J{End for};
    J --> K(Update current game board with next generation game board);
    K --> L{Continue game?};
    L -- Yes --> D;
    L -- No --> M(End);
    
    
   
```
"""
```python
"""
Пояснения:
1. Инициализация игрового поля:
   - `game_board`: Двумерный список (матрица) размером 10x10, представляющий игровое поле.
   - Изначально все ячейки заполнены нулями (0), что означает, что все клетки мертвы.
2. Ввод начальной конфигурации:
   - Цикл while позволяет игроку вводить координаты живых клеток до тех пор, пока он не введет "stop".
   - Координаты вводятся в формате "x,y". Координаты преобразуются в целые числа и уменьшаются на 1 для работы с индексами массива.
   - При вводе некорректных координат или "stop" цикл завершается.
   - Введенные координаты используются для установки соответствующих ячеек в матрице `game_board` в значение 1 (живая клетка).
3. Основной цикл:
   - Этот цикл while выполняется до тех пор, пока игрок не введет "n" (нет) при запросе о продолжении игры.
   - На каждом шаге цикла происходит:
     - Вывод текущего состояния игрового поля на экран.
     - Создание новой матрицы `next_generation_board` для хранения состояния следующего поколения.
     - Проход по каждой ячейке матрицы `game_board`.
       - Подсчет количества живых соседей для текущей клетки.
         - Цикл прохода по соседям (от -1 до 1 по x и y относительно текущей клетки)
         - При подсчете, игнорируются недействительные координаты (за пределами игрового поля) и сама текущая клетка.
       - Применение правил игры для определения состояния клетки в следующем поколении:
         - Если клетка живая (значение 1) и имеет 2 или 3 живых соседа, то она остается живой в следующем поколении (запись 1 в `next_generation_board`).
         - Если клетка живая и имеет менее 2 или более 3 живых соседа, то она умирает (запись 0 в `next_generation_board`).
         - Если клетка мертвая (значение 0) и имеет ровно 3 живых соседа, то она оживает (запись 1 в `next_generation_board`).
         - В остальных случаях мертвая клетка остается мертвой (запись 0 в `next_generation_board`).
     - Обновление `game_board` с новым поколением, используя `next_generation_board`.
     - Запрос у игрока о продолжении игры.
4. Функция `print_board` используется для вывода текущего состояния игрового поля. Она проходится по всем строкам и столбцам `game_board`, печатая "O" для живых клеток и "." для мертвых.
5. Переменные:
   - `game_board`: двумерный список, представляющий игровое поле.
   - `next_generation_board`: двумерный список, хранящий состояние следующего поколения.
   - `x`, `y`: целые числа, представляющие координаты ячейки на игровом поле.
   - `alive_neighbors`: целое число, хранящее количество живых соседей для текущей клетки.
   - `continue_game`: строка, хранящая ответ пользователя о продолжении игры ("y" или "n").
   - `coord_input`: строка, хранящая ввод пользователя с координатами живой клетки.
6.  Функция `count_alive_neighbors`: считает живых соседей для заданной клетки.

licence:MIT(../licence)
"""
__author__ = 'hypo69 (hypo69@davidka.net)'

def print_board(board):
    """
    Выводит текущее состояние игрового поля.

    Args:
        board: Двумерный список, представляющий игровое поле.
    """
    for row in board:
        print(" ".join("O" if cell == 1 else "." for cell in row))

def count_alive_neighbors(board, row, col):
    """
    Подсчитывает количество живых соседей для заданной клетки.

    Args:
        board: Двумерный список, представляющий игровое поле.
        row: Индекс строки клетки.
        col: Индекс столбца клетки.

    Returns:
        Количество живых соседей.
    """
    alive_neighbors = 0
    for i in range(row - 1, row + 2):
        for j in range(col - 1, col + 2):
            if (i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and (i != row or j != col) and board[i][j] == 1):
                alive_neighbors += 1
    return alive_neighbors


# 1. Инициализация игрового поля
game_board = [[0 for _ in range(10)] for _ in range(10)]

# 2. Ввод начальной конфигурации
print("Введите координаты живых клеток в формате 'x,y' или 'stop' для завершения ввода.")
coord_input = input("Координаты: ")
while coord_input != "stop":
    try:
        x, y = map(int, coord_input.split(','))
        if 0 <= x <= 9 and 0 <= y <= 9:
            game_board[y][x] = 1 # Координаты меняем местами, так как матрица имеет формат [строка][столбец], а вводим мы сначала столбец
        else:
             print("Неверные координаты. Координаты должны быть от 0 до 9")
    except ValueError:
        print("Неверный формат ввода. Используйте формат 'x,y' или 'stop'.")
    coord_input = input("Координаты: ")

# 3. Основной цикл
continue_game = "y"
while continue_game.lower() == "y":
    # Вывод текущего состояния поля на экран
    print_board(game_board)
    
    # Создание нового массива (матрицы)
    next_generation_board = [[0 for _ in range(10)] for _ in range(10)]

    # Проход по каждой ячейке матрицы
    for row in range(10):
        for col in range(10):
            # Подсчет количества живых соседей
            alive_neighbors = count_alive_neighbors(game_board, row, col)
            
            # Применение правил игры
            if game_board[row][col] == 1: # Клетка живая
                if alive_neighbors == 2 or alive_neighbors == 3: # Клетка остается живой
                    next_generation_board[row][col] = 1
            else: # Клетка мертвая
                if alive_neighbors == 3: # Клетка оживает
                    next_generation_board[row][col] = 1
    
    # Обновление поколения
    game_board = next_generation_board

    # Запрос у игрока продолжать игру
    continue_game = input("Продолжить игру? (y/n): ")
print("Игра завершена.")

```