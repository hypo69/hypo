## Ответ на Задачу No 176: Прямоугольные треугольники с целыми сторонами

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Задача требует найти количество уникальных прямоугольных треугольников с целыми сторонами, где гипотенуза равна заданному значению `c`. Треугольники считаются "непохожими", если наборы длин сторон `a`, `b` и `c` уникальны.
*   Функция `F(c)` возвращает количество таких треугольников для данного значения `c`.
*   Функция `S(n)` возвращает сумму всех `c` (где `c <= n`) для которых `F(c) = 1`.
*   Нам нужно вычислить `S(10000000)`.

**Решение:**

1.  **Поиск Пифагоровых троек:**  Прямоугольный треугольник с целыми сторонами удовлетворяет теореме Пифагора:  `a² + b² = c²`. Нам нужно найти целые решения для `a` и `b` при заданном `c`.
2.  **Генерация Пифагоровых троек:** Используем параметрическое представление пифагоровых троек. Все примитивные пифагоровы тройки (a, b, c), то есть те, у которых НОД(a, b, c) = 1 можно получить по формулам:
    `a = m² - n²`
    `b = 2mn`
    `c = m² + n²`
    где `m` и `n` - натуральные числа, `m > n`, `m` и `n` взаимно просты и имеют разную четность.
3.  **Проверка уникальности:** Для данного `c`, мы должны проверить, сколько существует пар `(m, n)`, которые приводят к этому `c`.  Если найдена ровно одна такая пара, то `F(c) = 1`, и мы добавляем `c` в искомую сумму.
4.  **Учет масштабирования:** После генерации примитивных троек нужно проверить, не является ли искомое `c` масштабированием этих примитивных троек, для этого проверяем, что `c` кратно `m² + n²` и `c`/(`m² + n²`) это целое число и при этом получается только одна такая пара.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать переменную `total_sum` со значением 0.
3.  Для каждого `c` от 1 до 10000000:
    *   Инициализировать счетчик `count` со значением 0.
    *   Для каждого `m` от 2:
        *   Для каждого `n` от 1 до `m` - 1:
            *   Если `m` и `n` взаимно просты и имеют разную четность:
                *   Вычислить `hypotenuse = m² + n²`.
                *   Если `c` делится на `hypotenuse` без остатка и `c/hypotenuse` является целым:
                    *   увеличить счетчик `count`.
    *   Если `count` равен 1:
        *   Прибавить `c` к `total_sum`
4.  Вернуть `total_sum`
5.  Конец

### 3. Реализация на Python 3.12
```python
import math

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def count_pythagorean_triangles(c):
    count = 0
    for m in range(2, int(math.sqrt(c)) + 2):
        for n in range(1, m):
           if gcd(m, n) == 1 and (m % 2 != n % 2):
                hypotenuse = m * m + n * n
                if c % hypotenuse == 0 and c // hypotenuse > 0 :
                    count += 1
    return count

def sum_of_unique_hypotenuses(limit):
    total_sum = 0
    for c in range(1, limit + 1):
      if count_pythagorean_triangles(c) == 1:
         total_sum += c
    return total_sum

limit = 10000000
result = sum_of_unique_hypotenuses(limit)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeTotalSum((Инициализировать total_sum = 0))
    InitializeTotalSum --> LoopCStart((Начать цикл: c от 1 до 10000000))
    LoopCStart --> InitializeCount((Инициализировать count = 0))
    InitializeCount --> LoopMStart((Начать цикл: m от 2 до sqrt(c) + 2 ))
    LoopMStart --> LoopNStart((Начать цикл: n от 1 до m - 1))
    LoopNStart --> CheckGCD((Проверить: НОД(m,n) = 1 и m и n разной четности?))
    CheckGCD -- Да --> CalculateHypotenuse((Вычислить hypotenuse = m^2 + n^2))
    CalculateHypotenuse --> CheckDivisibility((Проверить: c делится на hypotenuse?))
    CheckDivisibility -- Да --> IncrementCount((Увеличить count))
    IncrementCount --> LoopNStart
    CheckDivisibility -- Нет --> LoopNStart
    CheckGCD -- Нет --> LoopNStart
    LoopNStart --> LoopMStart
    LoopMStart --> CheckCount((Проверить: count = 1?))
    CheckCount -- Да --> AddCToTotalSum((Добавить c к total_sum))
    AddCToTotalSum --> LoopCStart
    CheckCount -- Нет --> LoopCStart
    LoopCStart --> OutputTotalSum((Вывести total_sum))
    OutputTotalSum --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать total\_sum:** Создаем переменную для хранения суммы и присваиваем ей значение 0.
*   **Начать цикл: c от 1 до 10000000:** Цикл перебирает все значения гипотенузы до заданного предела.
*   **Инициализировать count:** Обнуляем счетчик найденных троек для текущего значения гипотенузы.
*   **Начать цикл: m от 2 до sqrt(c) + 2:**  Внутренние циклы перебирают значения `m` для генерации пифагоровых троек.
*   **Начать цикл: n от 1 до m - 1:** Внутренние циклы перебирают значения `n` для генерации пифагоровых троек.
*  **Проверить: НОД(m,n) = 1 и m и n разной четности?:** Проверяем условия при которых m и n образуют примитивную тройку
*   **Вычислить hypotenuse:** Вычисляем гипотенузу примитивной тройки по формуле.
*   **Проверить: c делится на hypotenuse?:** Проверяем, делится ли гипотенуза `c` на `hypotenuse` без остатка и является ли `c/hypotenuse` целым числом.
*   **Увеличить count:** Если условие деления выполняется, увеличиваем счетчик найденных троек.
*   **Проверить: count = 1?:** Проверяем, было ли найдено ровно одна тройка для текущего значения `c`.
*   **Добавить c к total\_sum:** Если `count` равно 1, то добавляем `c` к общей сумме.
*   **Вывести total\_sum:** Выводим полученную сумму.
