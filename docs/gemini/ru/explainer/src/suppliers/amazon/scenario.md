# <input code>

```python
## \file hypotez/src/suppliers/amazon/scenario.py
# -*- coding: utf-8 -*-\
#! venv/Scripts/python.exe
#! venv/bin/python/python3.12

"""
.. module: src.suppliers.amazon 
	:platform: Windows, Unix
	:synopsis:

"""
MODE = 'dev'

"""
	:platform: Windows, Unix
	:synopsis:

"""


"""
	:platform: Windows, Unix
	:synopsis:

"""


"""
  :platform: Windows, Unix

"""
"""
  :platform: Windows, Unix
  :platform: Windows, Unix
  :synopsis:
"""MODE = 'dev'
  
""" module: src.suppliers.amazon """


"""  Модуль сбора товаров со страницы категорий поставщика aliexpress.com через вебдрайвер

У каждого поставщика свой сценарий обреботки категорий

-Модуль Собирает список категорий со страниц продавца . `get_list_categories_from_site()`.\n@todo Сделать проверку на изменение категорий на страницах продавца. 
Продавец может добавлять новые категории, переименовывать или удалять/прятать уже существующие. 
По большому счету надо держать таблицу категории `PrestaShop.categories <-> aliexpress.shop.categoies`
- Собирает список товаров со страницы категории `get_list_products_in_category()`
- Итерируясь по списку передает управление в `grab_product_page()` отсылая функции текущий url страницы  
`grab_product_page()` обрабатывает поля товара и передает управление классу `Product` 

"""


from typing import Union
from pathlib import Path

from src import gs
from src.logger import logger

def get_list_products_in_category(s) -> list[str,str,None]:    
    """ Returns list of products urls from category page
    Если надо пролистстать - страницы категорий - листаю ??????

    Attrs:
    @param s: Supplier - Supplier intstance
    @returns list or one of products urls or None
    """
    d = s.driver
    l: dict = s.locators['category']
    if not l:
        """ Много проверок, потому, что код можно запускать от лица разных ихполнителей: Supplier, Product, Scenario """
        logger.error(f"А где локаторы? {l}")
        return
    d.scroll()

    #TODO: Нет листалки

    list_products_in_category = d.execute_locator(l['product_links'])
    """ Собираю ссылки на товары.  """
    if not list_products_in_category:
        logger.warning('Нет ссылок на товары')
        return
    
    list_products_in_category = [list_products_in_category] if isinstance(list_products_in_category, str) else list_products_in_category


    logger.info(f""" Найдено {len(list_products_in_category)} товаров """)
    
    #""" Проверяю наличие товара в базе данных магазина """
    #for asin in list_products_in_category:
    #    _asin = asin.split(f'\/')[-2]
    #    _sku = f'{s.supplier_id}_{_asin}' 
    #    if PrestaShopProduct.check(_sku) == False:
    #        """ Синтаксис для того, чтобы помнить,
    #        что я проверяю ОТСУТСТВИЕ товара в базе данных
    #        """
    #        continue
    #    else:
    #        """ Товар в базе данных """
    #        continue
            #TODO: Логику 


    return list_products_in_category
```

# <algorithm>

**Пошаговая блок-схема:**

1. **Вход:** Функция `get_list_products_in_category` получает объект `s` (предположительно, экземпляр класса `Supplier`).

2. **Получение драйвера и локаторов:** Извлекает веб-драйвер `d` и локаторы `l` из объекта `s`.

3. **Проверка локаторов:** Проверяет, что локаторы `l` существуют. Если нет, выводит ошибку в лог и возвращает `None`.

4. **Прокрутка страницы:** Вызывает метод `d.scroll()`.  (Предполагается, что это прокручивает страницу для загрузки всех товаров)

5. **Получение ссылок на товары:** Используя `d.execute_locator(l['product_links'])` получает список ссылок на товары.

6. **Проверка наличия ссылок:** Проверяет, что получен список ссылок. Если список пуст, выводит предупреждение в лог и возвращает `None`.

7. **Обработка типов данных:** Преобразует результат в список, если он был строкой.

8. **Вывод информации:** Выводит в лог количество найденных товаров.

9. **(Закомментированный код):** В закомментированном блоке представлена логика проверки наличия товара в базе данных.  Этот код сейчас не активен.

10. **Возврат:** Возвращает список ссылок на товары.


**Пример:**

Предположим, `s` — экземпляр класса `Supplier`,  `s.driver` — объект веб-драйвера, `s.locators['category']['product_links']` — правильное выражение, которое возвращает список ссылок. Функция `d.execute_locator` возвращает список строк: `['url1', 'url2', 'url3']`. Тогда функция вернет этот список.

# <mermaid>

```mermaid
graph TD
    A[get_list_products_in_category(s)] --> B{Проверка локаторов};
    B -- Локаторы существуют --> C[d.scroll()];
    B -- Локаторы отсутствуют --> D[logger.error, return None];
    C --> E[d.execute_locator(l['product_links'])];
    E --> F{Проверка списка ссылок};
    F -- Список не пуст --> G[Обработка типов данных];
    F -- Список пуст --> H[logger.warning, return None];
    G --> I[logger.info];
    I --> J[Возврат списка ссылок];
    
    
    subgraph "Закомментированный блок (проверка в БД)"
        J --> K[for asin in list_products_in_category];
        K --> L[Проверка в БД];
        L -- Результат проверки --> M[continue/continue];
    end
```

**Подключаемые зависимости:**

- `src.gs`:  Вероятно, содержит вспомогательные функции или классы для работы с Google Sheets или другими системами хранения данных.
- `src.logger`:  Модуль для логирования. Вероятно, используется для записи сообщений об ошибках, предупреждениях и информации в файл или консоль.


# <explanation>

**Импорты:**

- `from typing import Union`: Используется для указания типов переменных, но в данном случае не используется.
- `from pathlib import Path`: Используется для работы с файловыми путями, но в данном случае не используется.
- `from src import gs`: Импортирует модуль `gs` из пакета `src`. Предполагается, что этот модуль связан с обработкой данных (например, Google Sheets).
- `from src.logger import logger`: Импортирует переменную `logger` из модуля `logger`, находящегося в подпакете `src.logger`.  `logger` вероятно объект логгера, который используется для записи информации, предупреждений и ошибок в лог.

**Классы:**

Код определяет функцию `get_list_products_in_category`, которая, вероятно, используется в рамках класса `Supplier`. Класс `Supplier`  в данном фрагменте кода не определен, но имплицитно предполагается, что он содержит переменные `driver` и `locators`, а также имеет метод `execute_locator`.

**Функции:**

- `get_list_products_in_category(s)`:  Функция получает ссылки на товары на странице категории.
    - Принимает объект `s` (предположительно, экземпляр класса `Supplier`).
    - Возвращает список ссылок на товары или `None`, если ссылки не найдены или произошла ошибка.
    - Использует `s.driver` для управления веб-драйвером.
    - Использует `s.locators['category']` для получения локаторов элементов страницы.
    - В функции есть `TODO`, что говорит о том, что нужна реализация прокрутки по страницам.

**Переменные:**

- `d`: Переменная, хранит объект веб-драйвера.
- `l`: Переменная, хранит локаторы элементов страницы.
- `list_products_in_category`: Список ссылок на товары, которые получены с текущей страницы.
- `s`: Экземпляр класса `Supplier`, содержащий данные для работы.

**Возможные ошибки и улучшения:**

- Не реализовано листание по страницам (TODO).
- Нет обработки ошибок при выполнении `d.execute_locator`.
- Закомментированный код проверки наличия товара в базе данных нуждается в реализации и не использует существующие классы или функции.
- Неопределенность класса `PrestaShopProduct` и связанных методов `check`.  Функция `get_list_products_in_category` пытается взаимодействовать с внешним классом `PrestaShopProduct`, который не определен в данном фрагменте кода. Необходимо уточнить, как будет происходить взаимодействие с базой данных.
- Отсутствие ясности в логике обработки результатов проверки в БД. Необходимо указать, какие действия следует выполнять в зависимости от результата проверки.
-  Типы возвращаемых значений не всегда корректны. Вместо `list[str, str, None]` может быть достаточно `list[str]`.

**Цепочка взаимосвязей:**

Функция `get_list_products_in_category` в данном модуле является частью сценария сбора данных. Она получает данные от объекта `Supplier` (вероятно, представляющего поставщика), использует веб-драйвер для поиска ссылок на товары и возвращает полученный список ссылок. Далее эти ссылки, предположительно, будут использоваться для получения более подробных данных о каждом товаре (например, через вызовы `grab_product_page()`).