# Модуль `html2text`

## Обзор

Модуль `html2text` предназначен для конвертации HTML-документов в Markdown-форматированный текст. Он предоставляет инструменты для обработки HTML-разметки, извлечения текстового содержимого и его представления в удобочитаемом формате Markdown.

## Подробнее

Этот модуль полезен для извлечения текста из веб-страниц или HTML-файлов с сохранением структуры и форматирования, насколько это возможно в Markdown. Он используется для создания текстовых версий веб-контента, которые могут быть использованы для анализа, архивирования или отображения на устройствах с ограниченной поддержкой HTML.

## Классы

### `_html2text`

**Описание**: Класс `_html2text` является основным классом, который выполняет преобразование HTML в Markdown. Он наследуется от `HTMLParser.HTMLParser` и переопределяет методы для обработки различных HTML-тегов и атрибутов.

**Методы**:
- `__init__`: Инициализирует объект класса `_html2text`, устанавливает параметры вывода, базовый URL и другие настройки.
- `feed`: Обрабатывает входные данные HTML, заменяя теги `<script>`.
- `outtextf`: Добавляет текст в список вывода.
- `close`: Завершает обработку HTML, объединяет список вывода в строку и возвращает результат.
- `handle_charref`: Обрабатывает символьные ссылки.
- `handle_entityref`: Обрабатывает ссылки на сущности.
- `handle_starttag`: Обрабатывает начальные теги HTML.
- `handle_endtag`: Обрабатывает конечные теги HTML.
- `previousIndex`: Возвращает индекс набора атрибутов (ссылки) в списке `self.a`.
- `drop_last`: Удаляет последние символы из вывода.
- `handle_emphasis`: Обрабатывает различные текстовые выделения.
- `handle_tag`: Обрабатывает HTML-теги, определяет их тип и применяет соответствующее форматирование.
- `pbr`: Добавляет один перенос строки.
- `p`: Добавляет два переноса строки.
- `soft_br`: Добавляет мягкий перенос строки.
- `o`: Выводит данные с учетом текущего состояния и форматирования.
- `handle_data`: Обрабатывает текстовые данные, извлекая информацию и добавляя ее в вывод.
- `unknown_decl`: Обрабатывает неизвестные объявления.

## Функции

### `has_key`

```python
def has_key(x, y):
    """
    Args:
        x: Объект, для которого проверяется наличие ключа.
        y: Ключ, наличие которого необходимо проверить.

    Returns:
        bool: `True`, если ключ присутствует в объекте, `False` в противном случае.

    **Как работает функция**:
    Функция проверяет, есть ли ключ `y` в объекте `x`. Сначала проверяется, есть ли у объекта метод `has_key`.
    Если метод существует, он вызывается для проверки наличия ключа. Если метод отсутствует, используется оператор `in` для проверки.
    """
```

**Описание**: Проверяет наличие ключа в объекте (словаре или другом объекте с методом `has_key`).

**Параметры**:
- `x`: Объект, в котором нужно проверить наличие ключа.
- `y`: Ключ, наличие которого проверяется.

**Возвращает**:
- `bool`: `True`, если ключ присутствует в объекте, `False` в противном случае.

### `name2cp`

```python
def name2cp(k):
    """
    Args:
        k: Имя HTML-сущности.

    Returns:
        int: Кодовая точка Unicode для данной сущности.

    Raises:
        KeyError: Если сущность не найдена в `htmlentitydefs`.

    **Как работает функция**:

    Функция `name2cp` преобразует имя HTML-сущности в соответствующую кодовую точку Unicode.

    1. **Проверка на `apos`**: Если имя сущности равно `'apos'`, функция возвращает кодовую точку для символа апострофа (`'`).
    2. **Использование `htmlentitydefs.name2codepoint` (если доступно)**:
       - Если в модуле `htmlentitydefs` есть атрибут `name2codepoint` (что характерно для Python 2.3 и выше),
         функция использует его для прямого преобразования имени сущности в кодовую точку.
    3. **Использование `htmlentitydefs.entitydefs` (если `name2codepoint` отсутствует)**:
       - Если `name2codepoint` отсутствует, функция обращается к `htmlentitydefs.entitydefs`, который содержит
         определения сущностей в формате `&#код;`.
       - Если определение начинается с `&#` и заканчивается на `;`, функция извлекает числовой код из середины строки
         и преобразует его в целое число.
       - В противном случае, функция декодирует сущность как строку в кодировке `latin-1` и возвращает кодовую точку первого символа.
    4. **Обработка ошибок**:
       - Если сущность не найдена ни в `name2codepoint`, ни в `entitydefs`, функция вызывает исключение `KeyError`.
    """
```

**Описание**: Преобразует имя HTML-сущности в кодовую точку Unicode.

**Параметры**:
- `k`: Имя HTML-сущности.

**Возвращает**:
- `int`: Кодовая точка Unicode для данной сущности.

**Вызывает исключения**:
- `KeyError`: Если сущность не найдена в `htmlentitydefs`.

### `charref`

```python
def charref(name):
    """
    Args:
        name: Числовая ссылка на символ.

    Returns:
        str: Соответствующий символ Unicode.

    **Как работает функция**:
    Функция `charref` преобразует числовую ссылку на символ в символ Unicode.

    1. **Определение основания системы счисления**:
       - Проверяется, начинается ли имя ссылки с `'x'` или `'X'`. Если да, то число представлено в шестнадцатеричной системе счисления (основание 16).
       - В противном случае, число считается представленным в десятичной системе счисления (основание 10).
    2. **Преобразование в целое число**:
       - Используется функция `int()` для преобразования имени ссылки в целое число в соответствии с определенным основанием.
    3. **Проверка на наличие в `unifiable_n`**:
       - Если глобальная переменная `UNICODE_SNOB` не установлена и число `c` присутствует в словаре `unifiable_n`,
         функция возвращает соответствующее значение из `unifiable_n`.
    4. **Преобразование в символ Unicode**:
       - Если `UNICODE_SNOB` установлена или число отсутствует в `unifiable_n`, функция пытается преобразовать число `c`
         в символ Unicode с помощью функции `chr()`.
    5. **Обработка ошибок**:
       - Если возникает исключение `NameError` (например, в Python 2, где `chr()` не поддерживает все кодовые точки Unicode),
         функция также использует `chr()` для преобразования числа в символ.
    """
```

**Описание**: Преобразует числовую ссылку на символ в символ Unicode.

**Параметры**:
- `name`: Числовая ссылка на символ.

**Возвращает**:
- `str`: Соответствующий символ Unicode.

### `entityref`

```python
def entityref(c):
    """
    Args:
        c: Имя HTML-сущности.

    Returns:
        str: Соответствующий символ Unicode.

    Raises:
        KeyError: Если сущность не найдена в `unifiable` или `name2cp`.

    **Как работает функция**:

    Функция `entityref` преобразует имя HTML-сущности в соответствующий символ Unicode.

    1. **Проверка на наличие в `unifiable`**:
       - Если глобальная переменная `UNICODE_SNOB` не установлена и имя сущности `c` присутствует в словаре `unifiable`,
         функция возвращает соответствующее значение из `unifiable`.
         Словарь `unifiable` содержит замены для некоторых HTML-сущностей на их ASCII-эквиваленты.
    2. **Преобразование с использованием `name2cp`**:
       - Если `UNICODE_SNOB` установлена или имя сущности отсутствует в `unifiable`, функция пытается преобразовать имя
         сущности в кодовую точку Unicode с помощью функции `name2cp`.
    3. **Обработка ошибок**:
       - Если `name2cp` вызывает исключение `KeyError` (то есть, сущность не найдена), функция возвращает исходную сущность
         в формате `&сущность;`.
       - Если преобразование в кодовую точку прошло успешно, функция пытается преобразовать кодовую точку в символ Unicode
         с помощью функции `chr()`.
       - Если возникает исключение `NameError` (например, в Python 2, где `chr()` не поддерживает все кодовые точки Unicode),
         функция также использует `chr()` для преобразования кодовой точки в символ.
    """
```

**Описание**: Преобразует имя HTML-сущности в символ Unicode.

**Параметры**:
- `c`: Имя HTML-сущности.

**Возвращает**:
- `str`: Соответствующий символ Unicode.

**Вызывает исключения**:
- `KeyError`: Если сущность не найдена в `unifiable` или `name2cp`.

### `replaceEntities`

```python
def replaceEntities(s):
    """
    Args:
        s: Объект регулярного выражения, содержащий HTML-сущность.

    Returns:
        str: Соответствующий символ Unicode.

    **Как работает функция**:
    Функция `replaceEntities` заменяет HTML-сущности в строке на соответствующие символы Unicode.

    1. **Извлечение сущности**:
       - Извлекает имя сущности из объекта регулярного выражения `s` (группа 1).
    2. **Обработка числовых ссылок**:
       - Если имя сущности начинается с `#`, это числовая ссылка на символ.
       - Функция вызывает `charref` для преобразования числовой ссылки в символ Unicode.
    3. **Обработка именованных сущностей**:
       - Если имя сущности не начинается с `#`, это именованная сущность.
       - Функция вызывает `entityref` для преобразования именованной сущности в символ Unicode.
    """
```

**Описание**: Заменяет HTML-сущности в строке на соответствующие символы Unicode.

**Параметры**:
- `s`: Объект регулярного выражения, содержащий HTML-сущность.

**Возвращает**:
- `str`: Соответствующий символ Unicode.

### `unescape`

```python
def unescape(s):
    """
    Args:
        s: Строка, содержащая HTML-сущности.

    Returns:
        str: Строка с замененными HTML-сущностями на соответствующие символы Unicode.

    **Как работает функция**:
    Функция `unescape` заменяет все HTML-сущности в строке `s` на соответствующие символы Unicode.

    1. **Регулярное выражение**:
       - Используется регулярное выражение `r_unescape` для поиска всех HTML-сущностей в строке.
         Регулярное выражение ищет сущности в форматах `&#код;`, `&#xкод;` и `&имя;`.
    2. **Замена сущностей**:
       - Функция `re.sub` используется для замены всех найденных сущностей.
       - Для каждой найденной сущности вызывается функция `replaceEntities`, которая определяет тип сущности (числовая или именованная)
         и преобразует ее в соответствующий символ Unicode.
    """
```

**Описание**: Заменяет HTML-сущности в строке на соответствующие символы Unicode.

**Параметры**:
- `s`: Строка, содержащая HTML-сущности.

**Возвращает**:
- `str`: Строка с замененными HTML-сущностями на соответствующие символы Unicode.

### `onlywhite`

```python
def onlywhite(line):
    """Return true if the line does only consist of whitespace characters."""
```

**Описание**: Проверяет, состоит ли строка только из пробельных символов.

**Параметры**:
- `line`: Строка для проверки.

**Возвращает**:
- `bool`: `True`, если строка состоит только из пробельных символов, `False` в противном случае.

### `optwrap`

```python
def optwrap(text):
    """Wrap all paragraphs in the provided text."""
```

**Описание**: Переносит все абзацы в предоставленном тексте.

**Параметры**:
- `text`: Текст для переноса.

**Возвращает**:
- `str`: Текст с перенесенными абзацами.

### `hn`

```python
def hn(tag):
    """
    Args:
        tag: HTML-тег.

    Returns:
        int | None: Уровень заголовка, если тег является заголовком (h1-h9), иначе `None`.

    **Как работает функция**:
    Функция `hn` определяет уровень заголовка HTML-тега, если тег является заголовком (от `<h1>` до `<h2>`).

    1. **Проверка префикса и длины**:
       - Проверяется, начинается ли тег с символа `'h'` и имеет ли длину 2 символа. Это необходимо для того, чтобы тег соответствовал формату заголовка (`<h1>`, `<h2>` и т.д.).
    2. **Извлечение уровня заголовка**:
       - Пытается преобразовать второй символ тега в целое число. Если преобразование успешно, это число считается уровнем заголовка.
    3. **Проверка диапазона уровня**:
       - Проверяет, находится ли уровень заголовка в диапазоне от 1 до 9 включительно. Это гарантирует, что уровень заголовка является допустимым (от `<h1>` до `<h2>`).
    4. **Обработка ошибок**:
       - Если при преобразовании второго символа тега в целое число возникает исключение `ValueError`, функция возвращает 0.
         Это может произойти, если второй символ не является числом.
    """
```

**Описание**: Определяет уровень заголовка HTML-тега.

**Параметры**:
- `tag`: HTML-тег.

**Возвращает**:
- `int | None`: Уровень заголовка, если тег является заголовком (h1-h9), иначе `None`.

### `dumb_property_dict`

```python
def dumb_property_dict(style):
    """returns a hash of css attributes"""
```

**Описание**: Возвращает словарь CSS-атрибутов.

**Параметры**:
- `style`: Строка CSS-стилей.

**Возвращает**:
- `dict`: Словарь CSS-атрибутов.

### `dumb_css_parser`

```python
def dumb_css_parser(data):
    """returns a hash of css selectors, each of which contains a hash of css attributes"""
```

**Описание**: Возвращает словарь CSS-селекторов, каждый из которых содержит словарь CSS-атрибутов.

**Параметры**:
- `data`: Строка CSS-данных.

**Возвращает**:
- `dict`: Словарь CSS-селекторов и атрибутов.

### `element_style`

```python
def element_style(attrs, style_def, parent_style):
    """returns a hash of the \'final\' style attributes of the element"""
```

**Описание**: Возвращает словарь "финальных" атрибутов стиля элемента.

**Параметры**:
- `attrs`: Атрибуты элемента HTML.
- `style_def`: Определения стилей CSS.
- `parent_style`: Стили родительского элемента.

**Возвращает**:
- `dict`: Словарь атрибутов стиля элемента.

### `google_list_style`

```python
def google_list_style(style):
    """finds out whether this is an ordered or unordered list"""
```

**Описание**: Определяет, является ли список упорядоченным или неупорядоченным.

**Параметры**:
- `style`: Стили списка CSS.

**Возвращает**:
- `str`: `'ul'`, если список неупорядоченный, `'ol'` в противном случае.

### `google_nest_count`

```python
def google_nest_count(style):
    """calculate the nesting count of google doc lists"""
```

**Описание**: Вычисляет уровень вложенности списков Google Docs.

**Параметры**:
- `style`: Стили списка CSS.

**Возвращает**:
- `int`: Уровень вложенности списка.

### `google_has_height`

```python
def google_has_height(style):
    """check if the style of the element has the \'height\' attribute explicitly defined"""
```

**Описание**: Проверяет, определен ли атрибут `height` в стилях элемента.

**Параметры**:
- `style`: Стили элемента CSS.

**Возвращает**:
- `bool`: `True`, если атрибут `height` определен, `False` в противном случае.

### `google_text_emphasis`

```python
def google_text_emphasis(style):
    """return a list of all emphasis modifiers of the element"""
```

**Описание**: Возвращает список всех модификаторов выделения текста элемента.

**Параметры**:
- `style`: Стили элемента CSS.

**Возвращает**:
- `list`: Список модификаторов выделения текста.

### `google_fixed_width_font`

```python
def google_fixed_width_font(style):
    """check if the css of the current element defines a fixed width font"""
```

**Описание**: Проверяет, определен ли шрифт фиксированной ширины в CSS элемента.

**Параметры**:
- `style`: Стили элемента CSS.

**Возвращает**:
- `bool`: `True`, если шрифт фиксированной ширины определен, `False` в противном случае.

### `list_numbering_start`

```python
def list_numbering_start(attrs):
    """extract numbering from list element attributes"""
```

**Описание**: Извлекает начальный номер из атрибутов элемента списка.

**Параметры**:
- `attrs`: Атрибуты элемента HTML.

**Возвращает**:
- `int`: Начальный номер списка.

### `html2text_file`

```python
def html2text_file(html, out=wrapwrite, baseurl=''):
    """
    Args:
        html: HTML-код для преобразования.
        out: Функция для вывода результата. По умолчанию `wrapwrite`.
        baseurl: Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

    Returns:
        str: Преобразованный в текст HTML-код.

    **Как работает функция**:

    Функция `html2text_file` преобразует HTML-код в текст с использованием класса `_html2text`.

    1. **Инициализация парсера**:
       - Создается экземпляр класса `_html2text`, который является парсером HTML.
       - В качестве параметров передаются функция для вывода результата (`out`) и базовый URL (`baseurl`).
    2. **Обработка HTML**:
       - HTML-код передается парсеру с помощью метода `feed`.
       - После обработки всего HTML-кода в парсер передается пустая строка, чтобы завершить процесс.
    3. **Завершение и возврат результата**:
       - Метод `close` вызывается для завершения обработки и получения преобразованного текста.
       - Функция возвращает преобразованный текст.
    """
```

**Описание**: Преобразует HTML-файл в текст.

**Параметры**:
- `html`: HTML-код для преобразования.
- `out`: Функция для вывода результата. По умолчанию `wrapwrite`.
- `baseurl`: Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

**Возвращает**:
- `str`: Преобразованный в текст HTML-код.

### `html2text`

```python
def html2text(html, baseurl=''):
    """
    Args:
        html: HTML-код для преобразования.
        baseurl: Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

    Returns:
        str: Преобразованный в текст HTML-код с переносом строк.

    **Как работает функция**:

    Функция `html2text` преобразует HTML-код в текст и выполняет перенос строк для улучшения читаемости.

    1. **Преобразование в текст**:
       - HTML-код преобразуется в текст с помощью функции `html2text_file`.
       - В качестве параметров передаются HTML-код и базовый URL.
    2. **Перенос строк**:
       - Полученный текст передается в функцию `optwrap`, которая выполняет перенос строк в соответствии с заданной шириной.
    3. **Возврат результата**:
       - Функция возвращает преобразованный текст с переносом строк.
    """
```

**Описание**: Преобразует HTML в текст с переносом строк.

**Параметры**:
- `html`: HTML-код для преобразования.
- `baseurl`: Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

**Возвращает**:
- `str`: Преобразованный в текст HTML-код с переносом строк.

### `wrapwrite`

```python
def wrapwrite(text):
    """
    Args:
        text: Текст для вывода.

    **Как работает функция**:
    Функция `wrapwrite` выводит текст в стандартный поток вывода, кодируя его в UTF-8.

    1. **Кодирование в UTF-8**:
       - Текст кодируется в кодировку UTF-8 с использованием метода `encode('utf-8')`.
    2. **Вывод в стандартный поток**:
       - В зависимости от версии Python, вывод осуществляется либо через `sys.stdout.buffer.write` (для Python 3),
         либо через `sys.stdout.write` (для Python 2).
       - Это позволяет корректно выводить Unicode-символы в консоль.
    """
```

**Описание**: Выводит текст в стандартный поток вывода, кодируя его в UTF-8.

**Параметры**:
- `text`: Текст для вывода.