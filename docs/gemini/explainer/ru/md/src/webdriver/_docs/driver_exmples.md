# Примеры использования классов `Driver` и `Chrome`

Этот документ содержит примеры использования классов `Driver` и `Chrome`, демонстрирующие различные методы для управления браузерным драйвером, навигации по страницам, взаимодействия с элементами и другими полезными функциями.

**Импорты:**

```python
from src.webdriver import Driver, Chrome
from selenium.webdriver.common.by import By
```

**Основная функция `main`:**

```python
def main():
    # ... (Примеры использования)
```

**Примеры:**

* **Создание экземпляра Chrome драйвера и навигация по URL:**

```python
chrome_driver = Driver(Chrome)
if chrome_driver.get_url("https://www.example.com"):
    print("Успешно перешли на URL")
```
Этот пример создает экземпляр класса `Driver`, используя `Chrome` в качестве драйвера, и пытается перейти на указанный URL. Метод `get_url` возвращает `True`, если навигация прошла успешно, и `False` в противном случае.


* **Извлечение домена из URL:**

```python
domain = chrome_driver.extract_domain("https://www.example.com/path/to/page")
print(f"Извлеченный домен: {domain}")
```
Метод `extract_domain` извлекает доменную часть из предоставленного URL.


* **Сохранение `cookies` в локальный файл:**

```python
success = chrome_driver._save_cookies_localy()
if success:
    print("Cookies сохранены успешно")
```
Метод `_save_cookies_localy()` сохраняет `cookies` в локальный файл.  Важно обратить внимание на `_` в начале имени метода, это указывает на то, что данный метод предназначен для внутреннего использования и не является частью публичного API.


* **Обновление текущей страницы:**

```python
if chrome_driver.page_refresh():
    print("Страница обновлена успешно")
```
Обновляет текущую страницу в браузере.


* **Прокрутка страницы вниз:**

```python
if chrome_driver.scroll(scrolls=3, direction='forward', frame_size=1000, delay=1):
    print("Страница прокручена вниз успешно")
```
Прокручивает страницу вниз на заданное количество раз. Параметры `scrolls`, `direction`, `frame_size` и `delay` позволяют настроить процесс прокрутки.


* **Получение языка текущей страницы:**

```python
page_language = chrome_driver.locale
print(f"Язык страницы: {page_language}")
```
Возвращает язык страницы, определенный браузером.


* **Установка кастомного User-Agent:**

```python
user_agent = {
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36'
}
custom_chrome_driver = Driver(Chrome, user_agent=user_agent)
if custom_chrome_driver.get_url("https://www.example.com"):
    print("Успешно перешли на URL с пользовательским user-agent")
```
Создаёт экземпляр `Driver` с заданным `user-agent`.


* **Поиск элемента по CSS селектору:**

```python
element = chrome_driver.find_element(By.CSS_SELECTOR, 'h1')
if element:
    print(f"Найден элемент с текстом: {element.text}")
```
Использует `find_element` для поиска элемента по CSS селектору.  Необходимо обработать случай, когда элемент не найден.


* **Получение текущего URL:**

```python
current_url = chrome_driver.current_url
print(f"Текущий URL: {current_url}")
```
Возвращает текущий URL в браузере.


* **Фокусировка окна:**

```python
chrome_driver.window_focus()
print("Окно сфокусировано")
```
Устанавливает фокус на браузерное окно.


**Примечания:**

* **Зависимости:** Убедитесь, что у вас установлены необходимые библиотеки (например, `selenium`, `fake_useragent`, и другие, если они используются в `src` модулях).
* **Настройки:** Пути к файлам настроек (если они есть) должны быть корректными и определены в `gs` (global settings).
* **Обработка исключений:** В реальных приложениях необходимо добавлять обработку исключений (например, `try...except` блоки), чтобы предотвратить аварийное завершение программы при ошибках.
* **Закрытие драйвера:** После завершения работы с драйвером необходимо его закрыть, чтобы освободить ресурсы.


Этот документ предоставляет подробные примеры использования классов `Driver` и `Chrome`.  Важно понимать, что `_save_cookies_localy` - это *внутренний* метод, не предназначенный для прямого вызова из кода.  Перед использованием проверьте API документацию и/или реализацию этих классов для получения полного понимания функциональности.