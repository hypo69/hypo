# Анализ кода модуля GOMOKO

**Качество кода**
8
- Плюсы
    - Документ содержит подробное описание игры и пошаговую инструкцию.
    - Присутствуют примеры работы программы, что помогает понять игровой процесс.
    - Описаны возможные ограничения и рекомендации по реализации.
- Минусы
    - Отсутствует reStructuredText (RST) оформление.
    - Не указано использование `j_loads` или `j_loads_ns`.
    - Нет инструкций по логированию ошибок.
    - Нет документации для функций, методов и переменных.
    - Нет примера кода.

**Рекомендации по улучшению**

1.  Переписать комментарии в формате reStructuredText (RST).
2.  Добавить описание модуля в начале файла.
3.  Включить примеры использования `j_loads` или `j_loads_ns`.
4.  Добавить логирование ошибок с использованием `from src.logger.logger import logger`.
5.  Предоставить документацию для каждой функции, метода и переменной в формате RST.
6.  Добавить пример реализации на Python.

**Оптимизиробанный код**

```markdown
"""
Инструкция для реализации игры Гомоку (GOMOKO).
==============================================

Этот документ содержит описание игры Гомоку, пошаговую инструкцию для реализации, примеры работы программы,
возможные ограничения и рекомендации по реализации.

"""

### Название игры: **GOMOKO** (Гомоку)

---

#### Описание
**GOMOKO** — это классическая стратегическая игра на поле 15x15, в которой игроки поочередно ставят свои фишки (обычно черные и белые) на поле с целью составить непрерывную линию из пяти фишек по вертикали, горизонтали или диагонали. Победителем становится тот, кто первым составит такую линию.

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - При запуске игры программа приветствует игрока и объясняет правила.
   - Игрок выбирает цвет фишки (черные или белые), в зависимости от этого программа будет управлять ходами другого игрока (компьютера или второго игрока).
   - Программа генерирует игровое поле размером 15x15, где каждая ячейка может быть пустой или занята фишкой.
   - Игрок начинает игру первым, если не выбрано иное.

#### 2. **Основной процесс игры**
   - **Ход игрока:**
     1. Игрок выбирает клетку на поле, куда он хочет поставить свою фишку (например, указывает координаты клетки, как в шахматах: A1, D4, и т.д.).
     2. Если клетка уже занята, программа запрашивает ввод новой позиции.
   
   - **Ход противника:**
     1. Противник (компьютер или второй игрок) делает свой ход, и программа обновляет поле.

   - **Проверка победы:**
     1. После каждого хода программа проверяет, есть ли на поле линия из 5 фишек подряд по вертикали, горизонтали или диагонали.
     2. Если линия из 5 фишек найдена, игра заканчивается, и победитель объявляется.

#### 3. **Завершение игры**
   - Программа сообщает победителя и предлагает начать новую игру:
     ```
     Поздравляем! Победитель: Игрок (черные/белые).
     Хотите сыграть снова? (да/нет)
     ```

   - Если игрок выбирает "да", начинается новый раунд с пустым полем.
   - Если "нет", программа завершает работу.

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в игру GOMOKO!
   Выберите цвет фишек: (черные/белые):
   > черные
   Ваш ход. Выберите позицию (например, D4):
   > D4
   ```

2. **Ход противника:**
   ```
   Противник (белые) делает ход в F5.
   Поле после хода противника:
   A1 . . . . . .
   A2 . . . . . .
   ...
   D4 X . . . . .
   ...
   ```

3. **Результат игры:**
   ```
   Ваш ход. Выберите позицию:
   > D5
   Поле после вашего хода:
   A1 . . . . . .
   A2 . . . . . .
   ...
   D4 X . . . . .
   D5 X . . . . .
   ...

   Вы выиграли! Поздравляем!
   Хотите сыграть снова? (да/нет):
   > нет
   Спасибо за игру!
   ```

---

### Возможные ограничения
- Поле ограничено размером 15x15.
- Игроки могут ставить фишки только в пустые клетки.
- Если поле заполнилось, а победитель не найден, игра заканчивается ничьей.

---

### Реализация
Игра может быть реализована на Python с использованием следующих возможностей:
- **Модуль `random`** для реализации простого ИИ противника (если требуется).
- **Циклы и условия** для обработки ходов игроков и проверки победных условий.
- **Модуль для вывода**: можно реализовать текстовую визуализацию поля, обновляя его после каждого хода.

Рекомендуется:
- Реализовать графическую версию игры для улучшения восприятия.
- Добавить возможность игры с компьютером с разными уровнями сложности.

```python
"""
Пример реализации игры Гомоку (GOMOKO) на Python.
===============================================

Этот модуль содержит базовую реализацию игры Гомоку с текстовым интерфейсом.

"""
import random
from src.logger.logger import logger  # Импорт модуля для логирования

def initialize_board(size: int) -> list[list[str]]:
    """
    Инициализирует игровое поле заданного размера.

    :param size: Размер игрового поля (например, 15 для поля 15x15).
    :return: Двумерный список, представляющий игровое поле.
    """
    return [['.' for _ in range(size)] for _ in range(size)]

def print_board(board: list[list[str]]) -> None:
    """
    Выводит текущее состояние игрового поля в консоль.

    :param board: Двумерный список, представляющий игровое поле.
    """
    for row in board:
        print(' '.join(row))

def get_player_move(board: list[list[str]]) -> tuple[int, int]:
    """
    Запрашивает у игрока ввод координат для хода и проверяет их корректность.

    :param board: Двумерный список, представляющий игровое поле.
    :return: Кортеж с координатами хода (строка, столбец).
    """
    while True:
        try:
            move_str = input("Ваш ход. Введите позицию (например, D4): ").upper()
            if len(move_str) < 2:
                 logger.error("Некорректный ввод, пожалуйста введите позицию в формате D4.") # логирование ошибки некорректного ввода
                 continue
            col_str = move_str[0]
            row_str = move_str[1:]

            col = ord(col_str) - ord('A')
            row = int(row_str) - 1
            
            if 0 <= row < len(board) and 0 <= col < len(board[0]) and board[row][col] == '.':
                return row, col
            else:
                 logger.error("Некорректный ввод, пожалуйста убедитесь, что позиция находится в пределах игрового поля и не занята")# логирование ошибки некорректного ввода
        except ValueError:
             logger.error("Некорректный ввод, пожалуйста используйте буквы для столбцов и цифры для строк.") # логирование ошибки некорректного ввода

def get_computer_move(board: list[list[str]]) -> tuple[int, int]:
    """
    Генерирует случайный ход для компьютера.

    :param board: Двумерный список, представляющий игровое поле.
    :return: Кортеж с координатами хода (строка, столбец).
    """
    while True:
        row = random.randint(0, len(board) - 1)
        col = random.randint(0, len(board[0]) - 1)
        if board[row][col] == '.':
            return row, col

def check_winner(board: list[list[str]], row: int, col: int, player: str) -> bool:
    """
    Проверяет, есть ли победитель после последнего хода.

    :param board: Двумерный список, представляющий игровое поле.
    :param row: Строка последнего хода.
    :param col: Столбец последнего хода.
    :param player: Символ игрока ('X' или 'O').
    :return: True, если есть победитель, иначе False.
    """
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)] # направления для проверки

    for dr, dc in directions:
        count = 1
        for i in range(1, 5):
            nr, nc = row + dr * i, col + dc * i
            if 0 <= nr < len(board) and 0 <= nc < len(board[0]) and board[nr][nc] == player:
                count += 1
            else:
                break
        for i in range(1, 5):
            nr, nc = row - dr * i, col - dc * i
            if 0 <= nr < len(board) and 0 <= nc < len(board[0]) and board[nr][nc] == player:
                count += 1
            else:
                break
        if count >= 5:
            return True
    return False

def play_gomoku():
    """
    Основная функция для запуска игры Гомоку.
    """
    print("Добро пожаловать в игру GOMOKO!")
    while True:
        player_color = input("Выберите цвет фишек: (черные/белые): ").lower()
        if player_color in ['черные', 'белые']:
            break
        else:
            logger.error("Некорректный ввод, пожалуйста введите 'черные' или 'белые'.")# логирование ошибки некорректного ввода

    board_size = 15
    board = initialize_board(board_size)
    player_symbol = 'X' if player_color == 'черные' else 'O'
    computer_symbol = 'O' if player_color == 'черные' else 'X'
    current_player = 'player'
    
    while True:
        print_board(board)

        if current_player == 'player':
            row, col = get_player_move(board)
            board[row][col] = player_symbol
        else:
            row, col = get_computer_move(board)
            board[row][col] = computer_symbol
            print(f"Противник делает ход в {chr(col + ord('A'))}{row + 1}")

        if check_winner(board, row, col, player_symbol if current_player == 'player' else computer_symbol):
            print_board(board)
            print(f"Вы выиграли!" if current_player == 'player' else "Компьютер выиграл!")
            break
        
        if all('.' not in row for row in board):
            print("Ничья!")
            break

        current_player = 'computer' if current_player == 'player' else 'player'

    play_again = input("Хотите сыграть снова? (да/нет): ").lower()
    if play_again == 'да':
        play_gomoku()
    else:
        print("Спасибо за игру!")
if __name__ == "__main__":
    play_gomoku()