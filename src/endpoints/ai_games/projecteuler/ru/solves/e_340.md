## Ответ на Задачу No 340: Странная функция

### 1. Анализ задачи и решение
**Понимание задачи:**

*   Задача определяет рекурсивную функцию `f(n)`, которая для `n < 3` возвращает `n`, а для `n >= 3` возвращает сумму `f(n-1) + f(n-2) + f(n-3)`.
*   Функция `g(a, b, c)` считает сумму всех значений `f(n)` в диапазоне `[a, b]`, таких что `f(n) mod 10^9` равно `c`.
*   Необходимо вычислить `S(n) = ∑ g(0, 10^k, k)`, где `k` принимает значения от 0 до `n`, а затем вывести `S(18) mod 10^9`.
*   Основная сложность - эффективно вычислить `f(n)` для больших `n`, так как прямой рекурсивный вызов приведет к переполнению стека и медленной работе. Нам нужно использовать динамическое программирование или мемоизацию.

**Решение:**

1.  **Вычисление f(n) с мемоизацией:** Реализуем функцию `f(n)` с мемоизацией, чтобы избежать повторных вычислений. Храним вычисленные значения в словаре или списке.
2.  **Вычисление g(a, b, c):** Создадим функцию `g(a, b, c)` которая переберет все значения `n` в диапазоне `[a, b]`, вычислит `f(n)`, и если `f(n) mod 10^9 == c`, добавит `f(n)` к общей сумме.
3.  **Вычисление S(n):** Реализуем функцию `S(n)`, которая вычисляет сумму `g(0, 10^k, k)` для всех `k` от `0` до `n`.
4.  **Вывод S(18) mod 10^9:** Вызываем функцию `S(18)` и выводим результат по модулю `10^9`.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать словарь или список `memo` для хранения вычисленных значений `f(n)`.
3.  Определить функцию `f(n)`:
    *   Если `n < 3`, вернуть `n`.
    *   Если `n` есть в `memo`, вернуть `memo[n]`.
    *   Иначе вычислить `f(n) = f(n-1) + f(n-2) + f(n-3)` с помощью рекурсивного вызова и сохранить результат в `memo[n]` и вернуть `memo[n]`.
4.  Определить функцию `g(a, b, c)`:
    *   Инициализировать `total_sum` = 0.
    *   Для всех `n` от `a` до `b`:
        *   Вычислить `f_n = f(n)`.
        *   Если `f_n % 10^9 == c`, то добавить `f_n` к `total_sum`.
    *   Вернуть `total_sum`.
5.  Определить функцию `S(n)`:
    *   Инициализировать `final_sum` = 0.
    *   Для всех `k` от `0` до `n`:
        *   Вычислить `g_k = g(0, 10^k, k)`.
        *   Добавить `g_k` к `final_sum`.
    *   Вернуть `final_sum`.
6.  Вычислить `result = S(18)`.
7.  Вывести `result % 10^9`.
8.  Конец

### 3. Реализация на Python 3.12
```python
def solve():
    memo = {}

    def f(n):
        if n < 3:
            return n
        if n in memo:
            return memo[n]
        memo[n] = (f(n - 1) + f(n - 2) + f(n - 3))
        return memo[n]

    def g(a, b, c):
        total_sum = 0
        for n in range(a, b + 1):
            f_n = f(n)
            if f_n % 10**9 == c:
                total_sum += f_n
        return total_sum

    def S(n):
        final_sum = 0
        for k in range(n + 1):
            final_sum += g(0, 10**k, k)
        return final_sum

    result = S(18)
    print(result % 10**9)


solve()

```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeMemo((Инициализировать memo = {}))
    InitializeMemo --> DefineF((Определить функцию f(n)))
    DefineF --> DefineG((Определить функцию g(a,b,c)))
    DefineG --> DefineS((Определить функцию S(n)))
    DefineS --> CalculateResult((Вычислить result = S(18)))
    CalculateResult --> PrintResult((Вывести result % 10^9))
    PrintResult --> End((Конец))

    subgraph DefineF
        FStart((Начало f(n))) --> FCheckN((n < 3?))
        FCheckN -- Да --> FReturnN((Вернуть n))
        FCheckN -- Нет --> FCheckMemo((n in memo?))
        FCheckMemo -- Да --> FReturnMemo((Вернуть memo[n]))
        FCheckMemo -- Нет --> FCalculate((Вычислить f(n) = f(n-1) + f(n-2) + f(n-3)))
        FCalculate --> FStoreMemo((Сохранить в memo[n]))
        FStoreMemo --> FReturnCalculated((Вернуть memo[n]))
        FReturnN --> FEnd((Конец f(n)))
         FReturnMemo --> FEnd
        FReturnCalculated --> FEnd
    end

    subgraph DefineG
         GStart((Начало g(a,b,c))) --> GInitSum((Инициализировать total_sum = 0))
        GInitSum --> GLoopStart((Начать цикл: n от a до b))
        GLoopStart --> GCalculateFn((Вычислить f_n = f(n)))
         GCalculateFn --> GCheckMod((f_n % 10^9 == c?))
        GCheckMod -- Да --> GAddToSum((Добавить f_n к total_sum))
        GAddToSum --> GLoopStart
        GCheckMod -- Нет --> GLoopStart
         GLoopStart --> GReturnSum((Вернуть total_sum))
       GReturnSum --> GEnd((Конец g(a,b,c)))
    end

    subgraph DefineS
        SStart((Начало S(n))) --> SInitFinalSum((Инициализировать final_sum = 0))
        SInitFinalSum --> SLoopStart((Начать цикл: k от 0 до n))
        SLoopStart --> SCalculateGk((Вычислить g_k = g(0, 10^k, k)))
        SCalculateGk --> SAddToFinalSum((Добавить g_k к final_sum))
        SAddToFinalSum --> SLoopStart
        SLoopStart --> SReturnFinalSum((Вернуть final_sum))
        SReturnFinalSum --> SEnd((Конец S(n)))
    end
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать memo:** Создаем словарь для хранения вычисленных значений функции `f(n)`.
*   **Определить функцию f(n):** Блок, содержащий логику функции `f(n)` с мемоизацией.
    *   **Начало f(n), Конец f(n):** Начало и конец функции `f(n)`.
    *   **n < 3?**: Проверка условия `n < 3`.
    *   **Вернуть n:** Возврат значения `n`, если условие `n < 3` истинно.
    *    **n in memo?**: Проверка, есть ли значение `n` в словаре `memo`.
    *   **Вернуть memo[n]**: Возвращаем значение из словаря `memo`.
    *   **Вычислить f(n) = f(n-1) + f(n-2) + f(n-3):** Рекурсивно вычисляем значение функции `f(n)`.
    *   **Сохранить в memo[n]:** Сохраняем вычисленное значение в словаре `memo`.
    *   **Вернуть memo[n]:** Возвращаем вычисленное значение.
*   **Определить функцию g(a, b, c):** Блок, содержащий логику функции `g(a, b, c)`.
    *    **Начало g(a,b,c), Конец g(a,b,c):** Начало и конец функции `g(a,b,c)`.
    *  **Инициализировать total_sum = 0:** Инициализация переменной для хранения суммы.
    *   **Начать цикл: n от a до b**: Начало цикла по диапазону `[a,b]`.
    *   **Вычислить f_n = f(n):** Вычисление значения f(n).
    *  **f_n % 10^9 == c?:** Проверка остатка от деления.
    *   **Добавить f_n к total_sum:** Добавление `f_n` к общей сумме.
    *   **Вернуть total_sum**: Возврат суммы.
*   **Определить функцию S(n):** Блок, содержащий логику функции `S(n)`.
     *   **Начало S(n), Конец S(n):** Начало и конец функции `S(n)`.
    *    **Инициализировать final_sum = 0:** Инициализация переменной для хранения итоговой суммы.
    *    **Начать цикл: k от 0 до n:** Начало цикла по диапазону `[0,n]`.
    *   **Вычислить g_k = g(0, 10^k, k):** Вычисление значения `g` для текущего `k`.
    *    **Добавить g_k к final_sum:** Добавление `g_k` к итоговой сумме.
    *   **Вернуть final_sum:** Возврат итоговой суммы.
*   **Вычислить result = S(18):** Вычисление `S(18)`.
*   **Вывести result % 10^9:** Вывод результата по модулю.
