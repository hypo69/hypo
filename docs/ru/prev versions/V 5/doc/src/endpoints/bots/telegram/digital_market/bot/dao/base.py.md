# Модуль для работы с базой данных (DAO)

## Обзор

Модуль `base.py` предоставляет базовый класс `BaseDAO` для выполнения стандартных операций с базой данных, таких как создание, чтение, обновление и удаление (CRUD). Он использует `SQLAlchemy` для взаимодействия с базой данных и предназначен для асинхронной работы. Класс `BaseDAO` является универсальным и может быть использован с любой моделью базы данных, наследующейся от `Base`.

## Подробней

`BaseDAO` предоставляет набор методов для выполнения операций с базой данных, таких как поиск записей по ID или фильтрам, добавление, обновление, удаление и подсчет записей. Он также поддерживает пагинацию и массовое обновление записей. Модуль использует логирование для отслеживания операций и обработки ошибок.

## Классы

### `BaseDAO`

**Описание**:
Базовый класс для доступа к данным. Предоставляет методы для выполнения CRUD-операций с использованием `SQLAlchemy`.

**Как работает класс**:

Класс `BaseDAO` является универсальным (Generic), параметризованным типом `T`, который должен быть наследником класса `Base` (модели SQLAlchemy). Он предоставляет набор методов для выполнения стандартных операций с базой данных, таких как:

- Поиск одной или нескольких записей по различным критериям.
- Добавление одной или нескольких записей.
- Обновление существующих записей.
- Удаление записей.
- Подсчет количества записей.
- Пагинация результатов запросов.

Все методы класса являются асинхронными и принимают экземпляр `AsyncSession` для выполнения операций с базой данных. Класс также использует логирование для записи информации о выполняемых операциях и обработки ошибок.

**Методы**:

- `find_one_or_none_by_id`: Найти запись по ID.
- `find_one_or_none`: Найти одну запись по фильтрам.
- `find_all`: Найти все записи по фильтрам.
- `add`: Добавить одну запись.
- `add_many`: Добавить несколько записей.
- `update`: Обновить записи по фильтрам.
- `delete`: Удалить записи по фильтру.
- `count`: Подсчитать количество записей.
- `paginate`: Пагинация записей.
- `find_by_ids`: Найти несколько записей по списку ID.
- `upsert`: Создать запись или обновить существующую.
- `bulk_update`: Массовое обновление записей.

### `find_one_or_none_by_id`

```python
    @classmethod
    async def find_one_or_none_by_id(cls, data_id: int, session: AsyncSession):
        """Найти запись по ID"""
```

**Описание**:
Находит одну запись в базе данных по заданному ID.

**Как работает функция**:

1.  Логирует начало поиска записи указанной модели по заданному ID.
2.  Формирует запрос к базе данных с использованием `select` и фильтра `filter_by` для поиска записи с заданным ID.
3.  Выполняет запрос асинхронно с использованием `session.execute`.
4.  Извлекает результат запроса с помощью `result.scalar_one_or_none()`, который возвращает либо найденную запись, либо `None`, если запись не найдена.
5.  Логирует информацию о том, была ли найдена запись.
6.  Возвращает найденную запись или `None`.
7.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `data_id` (int): ID записи для поиска.
- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.

**Возвращает**:

- `T | None`: Найденная запись типа `T` (модель базы данных) или `None`, если запись не найдена.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_one_or_none_by_id
data_id = 123
session = AsyncSession(engine)
record = await BaseDAO.find_one_or_none_by_id(data_id=data_id, session=session)
if record:
    print(f'Запись с ID {data_id} найдена: {record}')
else:
    print(f'Запись с ID {data_id} не найдена')
```

### `find_one_or_none`

```python
    @classmethod
    async def find_one_or_none(cls, session: AsyncSession, filters: BaseModel):
        """Найти одну запись по фильтрам"""
```

**Описание**:
Находит одну запись в базе данных, соответствующую заданным фильтрам.

**Как работает функция**:

1.  Извлекает словарь фильтров из объекта `BaseModel`, исключая неустановленные значения.
2.  Логирует начало поиска записи указанной модели по заданным фильтрам.
3.  Формирует запрос к базе данных с использованием `select` и фильтра `filter_by` для поиска записи, соответствующей заданным фильтрам.
4.  Выполняет запрос асинхронно с использованием `session.execute`.
5.  Извлекает результат запроса с помощью `result.scalar_one_or_none()`, который возвращает либо найденную запись, либо `None`, если запись не найдена.
6.  Логирует информацию о том, была ли найдена запись.
7.  Возвращает найденную запись или `None`.
8.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для поиска записи.

**Возвращает**:

- `T | None`: Найденная запись типа `T` (модель базы данных) или `None`, если запись не найдена.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_one_or_none
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str
    age: int

filters = UserFilter(name='John', age=30)
session = AsyncSession(engine)
record = await BaseDAO.find_one_or_none(session=session, filters=filters)
if record:
    print(f'Запись найдена по фильтрам: {record}')
else:
    print('Запись не найдена по фильтрам')
```

### `find_all`

```python
    @classmethod
    async def find_all(cls, session: AsyncSession, filters: BaseModel | None = None):
        """Найти все записи по фильтрам"""
```

**Описание**:
Находит все записи в базе данных, соответствующие заданным фильтрам.

**Как работает функция**:

1.  Извлекает словарь фильтров из объекта `BaseModel`, исключая неустановленные значения. Если фильтры не заданы, создает пустой словарь.
2.  Логирует начало поиска всех записей указанной модели по заданным фильтрам.
3.  Формирует запрос к базе данных с использованием `select` и фильтра `filter_by` для поиска всех записей, соответствующих заданным фильтрам.
4.  Выполняет запрос асинхронно с использованием `session.execute`.
5.  Извлекает результаты запроса с помощью `result.scalars().all()`, который возвращает список всех найденных записей.
6.  Логирует количество найденных записей.
7.  Возвращает список найденных записей.
8.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `filters` (BaseModel | None, optional): Объект `BaseModel`, содержащий фильтры для поиска записей. По умолчанию `None`.

**Возвращает**:

- `List[T]`: Список найденных записей типа `T` (модель базы данных).

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_all
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

filters = UserFilter(name='John')
session = AsyncSession(engine)
records = await BaseDAO.find_all(session=session, filters=filters)
print(f'Найдено {len(records)} записей.')
for record in records:
    print(record)
```

### `add`

```python
    @classmethod
    async def add(cls, session: AsyncSession, values: BaseModel):
        """Добавить одну запись"""
```

**Описание**:
Добавляет одну запись в базу данных.

**Как работает функция**:

1.  Извлекает словарь значений из объекта `BaseModel`, исключая неустановленные значения.
2.  Логирует начало добавления записи указанной модели с заданными параметрами.
3.  Создает новый экземпляр модели базы данных с использованием извлеченных значений.
4.  Добавляет новый экземпляр в сессию `SQLAlchemy`.
5.  Выполняет операцию `flush` для сохранения изменений в базе данных.
6.  Логирует информацию об успешном добавлении записи.
7.  В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.
8.  Возвращает добавленный экземпляр модели.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `values` (BaseModel): Объект `BaseModel`, содержащий значения для создания новой записи.

**Возвращает**:

- `T`: Добавленный экземпляр модели типа `T` (модель базы данных).

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при добавлении записи в базу данных.

**Примеры**:

```python
# Пример использования функции add
from pydantic import BaseModel

class UserCreate(BaseModel):
    name: str
    age: int

values = UserCreate(name='John', age=30)
session = AsyncSession(engine)
new_record = await BaseDAO.add(session=session, values=values)
print(f'Запись успешно добавлена: {new_record}')
```

### `add_many`

```python
    @classmethod
    async def add_many(cls, session: AsyncSession, instances: List[BaseModel]):
        """Добавить несколько записей"""
```

**Описание**:
Добавляет несколько записей в базу данных.

**Как работает функция**:

1.  Извлекает список словарей значений из списка объектов `BaseModel`, исключая неустановленные значения.
2.  Логирует начало добавления нескольких записей указанной модели.
3.  Создает список новых экземпляров модели базы данных с использованием извлеченных значений.
4.  Добавляет все новые экземпляры в сессию `SQLAlchemy`.
5.  Выполняет операцию `flush` для сохранения изменений в базе данных.
6.  Логирует информацию об успешном добавлении записей.
7.  В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.
8.  Возвращает список добавленных экземпляров модели.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `instances` (List[BaseModel]): Список объектов `BaseModel`, содержащих значения для создания новых записей.

**Возвращает**:

- `List[T]`: Список добавленных экземпляров модели типа `T` (модель базы данных).

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при добавлении записей в базу данных.

**Примеры**:

```python
# Пример использования функции add_many
from pydantic import BaseModel
from typing import List

class UserCreate(BaseModel):
    name: str
    age: int

instances = [
    UserCreate(name='John', age=30),
    UserCreate(name='Jane', age=25)
]
session = AsyncSession(engine)
new_records = await BaseDAO.add_many(session=session, instances=instances)
print(f'Успешно добавлено {len(new_records)} записей.')
for record in new_records:
    print(record)
```

### `update`

```python
    @classmethod
    async def update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel):
        """Обновить записи по фильтрам"""
```

**Описание**:
Обновляет записи в базе данных, соответствующие заданным фильтрам, новыми значениями.

**Как работает функция**:

1.  Извлекает словарь фильтров и словарь значений из объектов `BaseModel`, исключая неустановленные значения.
2.  Логирует начало обновления записей указанной модели по заданным фильтрам и с заданными параметрами.
3.  Формирует запрос на обновление с использованием `sqlalchemy_update` и фильтрации по заданным фильтрам.
4.  Выполняет запрос асинхронно с использованием `session.execute`.
5.  Выполняет операцию `flush` для сохранения изменений в базе данных.
6.  Логирует количество обновленных записей.
7.  Возвращает количество обновленных записей.
8.  В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для поиска записей для обновления.
- `values` (BaseModel): Объект `BaseModel`, содержащий новые значения для обновления записей.

**Возвращает**:

- `int`: Количество обновленных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при обновлении записей в базе данных.

**Примеры**:

```python
# Пример использования функции update
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str

class UserUpdate(BaseModel):
    age: int

filters = UserFilter(name='John')
values = UserUpdate(age=31)
session = AsyncSession(engine)
updated_count = await BaseDAO.update(session=session, filters=filters, values=values)
print(f'Обновлено {updated_count} записей.')
```

### `delete`

```python
    @classmethod
    async def delete(cls, session: AsyncSession, filters: BaseModel):
        """Удалить записи по фильтру"""
```

**Описание**:
Удаляет записи из базы данных, соответствующие заданным фильтрам.

**Как работает функция**:

1.  Извлекает словарь фильтров из объекта `BaseModel`, исключая неустановленные значения.
2.  Логирует начало удаления записей указанной модели по заданным фильтрам.
3.  Проверяет, что задан хотя бы один фильтр для удаления. Если фильтры не заданы, выбрасывает исключение `ValueError`.
4.  Формирует запрос на удаление с использованием `sqlalchemy_delete` и фильтрации по заданным фильтрам.
5.  Выполняет запрос асинхронно с использованием `session.execute`.
6.  Выполняет операцию `flush` для сохранения изменений в базе данных.
7.  Логирует количество удаленных записей.
8.  Возвращает количество удаленных записей.
9.  В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для поиска записей для удаления.

**Возвращает**:

- `int`: Количество удаленных записей.

**Вызывает исключения**:

- `ValueError`: Если не задан ни один фильтр для удаления.
- `SQLAlchemyError`: Если возникает ошибка при удалении записей из базы данных.

**Примеры**:

```python
# Пример использования функции delete
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str

filters = UserFilter(name='John')
session = AsyncSession(engine)
deleted_count = await BaseDAO.delete(session=session, filters=filters)
print(f'Удалено {deleted_count} записей.')
```

### `count`

```python
    @classmethod
    async def count(cls, session: AsyncSession, filters: BaseModel | None = None):
        """Подсчитать количество записей"""
```

**Описание**:
Подсчитывает количество записей в базе данных, соответствующих заданным фильтрам.

**Как работает функция**:

1.  Извлекает словарь фильтров из объекта `BaseModel`, исключая неустановленные значения. Если фильтры не заданы, создает пустой словарь.
2.  Логирует начало подсчета количества записей указанной модели по заданным фильтрам.
3.  Формирует запрос к базе данных с использованием `select(func.count(cls.model.id))` и фильтра `filter_by` для подсчета записей, соответствующих заданным фильтрам.
4.  Выполняет запрос асинхронно с использованием `session.execute`.
5.  Извлекает результат запроса с помощью `result.scalar()`, который возвращает количество найденных записей.
6.  Логирует количество найденных записей.
7.  Возвращает количество найденных записей.
8.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `filters` (BaseModel | None, optional): Объект `BaseModel`, содержащий фильтры для подсчета записей. По умолчанию `None`.

**Возвращает**:

- `int`: Количество записей, соответствующих заданным фильтрам.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции count
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

filters = UserFilter(name='John')
session = AsyncSession(engine)
count = await BaseDAO.count(session=session, filters=filters)
print(f'Найдено {count} записей.')
```

### `paginate`

```python
    @classmethod
    async def paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None):
        """Пагинация записей"""
```

**Описание**:
Получает записи из базы данных с поддержкой пагинации и фильтрации.

**Как работает функция**:

1.  Извлекает словарь фильтров из объекта `BaseModel`, исключая неустановленные значения. Если фильтры не заданы, создает пустой словарь.
2.  Логирует начало пагинации записей указанной модели по заданным фильтрам, странице и размеру страницы.
3.  Формирует запрос к базе данных с использованием `select` и фильтра `filter_by` для выбора записей, соответствующих заданным фильтрам.
4.  Добавляет к запросу параметры `offset` и `limit` для реализации пагинации.
5.  Выполняет запрос асинхронно с использованием `session.execute`.
6.  Извлекает результаты запроса с помощью `result.scalars().all()`, который возвращает список записей на текущей странице.
7.  Логирует количество найденных записей на текущей странице.
8.  Возвращает список записей на текущей странице.
9.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `page` (int, optional): Номер страницы для пагинации. По умолчанию 1.
- `page_size` (int, optional): Количество записей на странице. По умолчанию 10.
- `filters` (BaseModel, optional): Объект `BaseModel`, содержащий фильтры для выбора записей. По умолчанию `None`.

**Возвращает**:

- `List[T]`: Список записей на текущей странице типа `T` (модель базы данных).

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции paginate
from pydantic import BaseModel
from typing import Optional

class UserFilter(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None

filters = UserFilter(name='John')
session = AsyncSession(engine)
page = 2
page_size = 10
records = await BaseDAO.paginate(session=session, page=page, page_size=page_size, filters=filters)
print(f'Найдено {len(records)} записей на странице {page}.')
for record in records:
    print(record)
```

### `find_by_ids`

```python
    @classmethod
    async def find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]:
        """Найти несколько записей по списку ID"""
```

**Описание**:
Находит несколько записей в базе данных по списку ID.

**Как работает функция**:

1.  Логирует начало поиска записей указанной модели по списку ID.
2.  Формирует запрос к базе данных с использованием `select` и фильтра `filter` с условием `cls.model.id.in_(ids)` для поиска записей, ID которых находятся в заданном списке.
3.  Выполняет запрос асинхронно с использованием `session.execute`.
4.  Извлекает результаты запроса с помощью `result.scalars().all()`, который возвращает список всех найденных записей.
5.  Логирует количество найденных записей.
6.  Возвращает список найденных записей.
7.  В случае возникновения ошибки `SQLAlchemyError`, логирует ошибку и повторно выбрасывает исключение.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `ids` (List[int]): Список ID записей для поиска.

**Возвращает**:

- `List[Any]`: Список найденных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_by_ids
ids = [1, 2, 3]
session = AsyncSession(engine)
records = await BaseDAO.find_by_ids(session=session, ids=ids)
print(f'Найдено {len(records)} записей по списку ID.')
for record in records:
    print(record)
```

### `upsert`

```python
    @classmethod
    async def upsert(cls, session: AsyncSession, unique_fields: List[str], values: BaseModel):
        """Создать запись или обновить существующую"""
```

**Описание**:
Создает новую запись в базе данных или обновляет существующую, если запись с заданными уникальными полями уже существует.

**Как работает функция**:

1.  Извлекает словарь значений из объекта `BaseModel`, исключая неустановленные значения.
2.  Формирует словарь фильтров на основе заданных уникальных полей и значений из словаря значений.
3.  Логирует начало операции `upsert` для указанной модели.
4.  Пытается найти существующую запись с использованием функции `find_one_or_none` и сформированных фильтров.
5.  Если запись найдена, обновляет ее атрибуты значениями из словаря значений и выполняет операцию `flush` для сохранения изменений в базе данных. Логирует информацию об обновлении существующей записи.
6.  Если запись не найдена, создает новый экземпляр модели базы данных с использованием извлеченных значений, добавляет его в сессию `SQLAlchemy` и выполняет операцию `flush` для сохранения изменений в базе данных. Логирует информацию о создании новой записи.
7.  Возвращает обновленную или созданную запись.
8.  В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `unique_fields` (List[str]): Список уникальных полей, которые используются для поиска существующей записи.
- `values` (BaseModel): Объект `BaseModel`, содержащий значения для создания или обновления записи.

**Возвращает**:

- `T`: Обновленная или созданная запись типа `T` (модель базы данных).

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении операции `upsert`.

**Примеры**:

```python
# Пример использования функции upsert
from pydantic import BaseModel
from typing import List

class User(BaseModel):
    name: str
    email: str
    age: int

unique_fields = ['email']
values = User(name='John', email='john@example.com', age=30)
session = AsyncSession(engine)
record = await BaseDAO.upsert(session=session, unique_fields=unique_fields, values=values)
print(f'Запись успешно создана или обновлена: {record}')
```

### `bulk_update`

```python
    @classmethod
    async def bulk_update(cls, session: AsyncSession, records: List[BaseModel]) -> int:
        """Массовое обновление записей"""
```

**Описание**:
Выполняет массовое обновление записей в базе данных.

**Как работает функция**:

1.  Логирует начало массового обновления записей указанной модели.
2.  Итерируется по списку записей для обновления.
3.  Для каждой записи извлекает словарь значений из объекта `BaseModel`, исключая неустановленные значения.
4.  Проверяет наличие ID в словаре значений. Если ID отсутствует, переходит к следующей записи.
5.  Формирует словарь с данными для обновления, исключая поле 'id'.
6.  Формирует запрос на обновление с использованием `sqlalchemy_update` и фильтрации по ID записи.
7.  Выполняет запрос асинхронно с использованием `session.execute`.
8.  Увеличивает счетчик обновленных записей на количество строк, затронутых запросом.
9.  Выполняет операцию `flush` для сохранения изменений в базе данных.
10. Логирует количество обновленных записей.
11. Возвращает количество обновленных записей.
12. В случае возникновения ошибки `SQLAlchemyError`, выполняет откат транзакции и логирует ошибку.

**Параметры**:

- `session` (AsyncSession): Асинхронная сессия `SQLAlchemy` для выполнения запросов к базе данных.
- `records` (List[BaseModel]): Список объектов `BaseModel`, содержащих значения для обновления записей.

**Возвращает**:

- `int`: Количество обновленных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если возникает ошибка при выполнении массового обновления.

**Примеры**:

```python
# Пример использования функции bulk_update
from pydantic import BaseModel
from typing import List

class UserUpdate(BaseModel):
    id: int
    name: str
    age: int

records = [
    UserUpdate(id=1, name='John', age=31),
    UserUpdate(id=2, name='Jane', age=26)
]
session = AsyncSession(engine)
updated_count = await BaseDAO.bulk_update(session=session, records=records)
print(f'Обновлено {updated_count} записей.')