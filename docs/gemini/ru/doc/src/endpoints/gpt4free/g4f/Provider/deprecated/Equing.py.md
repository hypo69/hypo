# Модуль `Equing`

## Обзор

Модуль `Equing` представляет собой класс-провайдер для взаимодействия с сервисом `next.eqing.tech`. Он предоставляет функциональность для создания и получения завершений (responses) от моделей GPT, включая поддержку потоковой передачи данных.

## Подробнее

Этот модуль является частью набора провайдеров в проекте `hypotez`, предназначенных для обеспечения доступа к различным AI-моделям. Он реализует абстрактный класс `AbstractProvider` и предоставляет методы для отправки запросов к API `Equing` и обработки ответов.

## Классы

### `Equing(AbstractProvider)`

**Описание**:
Класс `Equing` предоставляет интерфейс для взаимодействия с сервисом `next.eqing.tech`.

**Наследует**:
`AbstractProvider` - абстрактный класс, определяющий интерфейс для всех провайдеров.

**Атрибуты**:
- `url` (str): URL-адрес сервиса `next.eqing.tech`.
- `working` (bool): Указывает, работает ли провайдер в данный момент.
- `supports_stream` (bool): Указывает, поддерживает ли провайдер потоковую передачу данных.
- `supports_gpt_35_turbo` (bool): Указывает, поддерживает ли провайдер модель `gpt-3.5-turbo`.
- `supports_gpt_4` (bool): Указывает, поддерживает ли провайдер модель `gpt-4`.

**Методы**:
- `create_completion(model: str, messages: list[dict[str, str]], stream: bool, **kwargs: Any) -> CreateResult`

## Функции

### `create_completion(model: str, messages: list[dict[str, str]], stream: bool, **kwargs: Any) -> CreateResult`

**Назначение**:
Отправляет запрос к API `Equing` для получения завершения (completion) на основе предоставленных параметров.

**Параметры**:
- `model` (str): Идентификатор модели, которую необходимо использовать.
- `messages` (list[dict[str, str]]): Список сообщений, составляющих контекст запроса. Каждое сообщение представлено в виде словаря, содержащего роли и контент.
- `stream` (bool): Определяет, использовать ли потоковый режим передачи данных.
- `**kwargs` (Any): Дополнительные параметры запроса, такие как `temperature`, `presence_penalty`, `frequency_penalty` и `top_p`.

**Возвращает**:
- `CreateResult`: Генератор, выдающий части завершения (completion) в потоковом режиме или строку с полным завершением, если потоковый режим не используется.

**Как работает функция**:

1.  **Формирование заголовков запроса**:
    -   Создается словарь `headers`, содержащий заголовки HTTP-запроса, необходимые для взаимодействия с API `Equing`.
        Устанавливаются такие параметры, как `authority`, `accept`, `accept-language`, `content-type`, `origin`, `referer`, `user-agent` и другие.
        Эти заголовки сообщают серверу информацию о клиенте, типе запроса и формате ожидаемого ответа.

2.  **Формирование тела запроса (JSON)**:
    -   Создается словарь `json_data`, который содержит параметры запроса в формате JSON.
        В этот словарь включаются сообщения (`messages`), флаг потоковой передачи (`stream`), модель (`model`) и другие параметры, такие как `temperature`, `presence_penalty`, `frequency_penalty` и `top_p`.
        Значения для `temperature`, `presence_penalty`, `frequency_penalty` и `top_p` извлекаются из `kwargs`, если они там присутствуют, иначе используются значения по умолчанию.

3.  **Отправка POST-запроса к API**:
    -   Используется библиотека `requests` для отправки POST-запроса к API `Equing` по адресу `https://next.eqing.tech/api/openai/v1/chat/completions`.
        В запросе передаются заголовки `headers` и данные в формате JSON `json_data`.
        Параметр `stream` определяет, будет ли ответ получен в потоковом режиме.

4.  **Обработка ответа в не потоковом режиме**:
    -   Если `stream` равен `False`, функция ожидает полный ответ от сервера.
        После получения ответа, он преобразуется из формата JSON и извлекается содержимое сообщения (`content`) из структуры `response.json()["choices"][0]["message"]["content"]`.
        Это содержимое возвращается как результат работы функции.

5.  **Обработка ответа в потоковом режиме**:
    -   Если `stream` равен `True`, функция начинает итерировать по содержимому ответа, получая его частями (chunks) размером 1024 байта.
        Для каждой полученной части проверяется, содержит ли она ключ `b'content'`.
        Если ключ найден, часть ответа декодируется из формата UTF-8, разделяется по строке `data: `, и преобразуется из формата JSON.
        Из полученного JSON извлекается токен (`token`) из структуры `line_json['choices'][0]['delta'].get('content')`.
        Если токен существует, он выдается как результат итерации, что позволяет получать ответ частями.

**Примеры**:

Пример 1: Запрос без потоковой передачи

```python
response = Equing.create_completion(
    model='gpt-3.5-turbo',
    messages=[{'role': 'user', 'content': 'Hello, how are you?'}],
    stream=False
)
print(next(response))  # Вывод: I am doing well, thank you!
```

Пример 2: Запрос с потоковой передачей

```python
response = Equing.create_completion(
    model='gpt-3.5-turbo',
    messages=[{'role': 'user', 'content': 'Tell me a story.'}],
    stream=True
)
for chunk in response:
    print(chunk, end='')  # Вывод: (части рассказа)
```