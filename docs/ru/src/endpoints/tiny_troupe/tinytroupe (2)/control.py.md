# Модуль управления симуляцией Tiny Troupe

## Обзор

Модуль `control.py` предоставляет механизмы управления симуляциями, включая кэширование и транзакционность. Он содержит классы и функции для запуска, остановки, сохранения состояния симуляции, а также для управления агентами, средами и фабриками внутри симуляции. Модуль также обеспечивает возможность кэширования результатов выполнения функций для повышения производительности.

## Подробнее

Этот модуль является центральным элементом управления симуляциями в Tiny Troupe. Он позволяет создавать, запускать и останавливать симуляции, а также сохранять и восстанавливать их состояние. Кэширование результатов выполнения функций позволяет избежать повторных вычислений, что особенно полезно для длительных и сложных симуляций. Транзакционный механизм обеспечивает консистентность данных при выполнении операций.

## Классы

### `Simulation`

**Описание**: Класс `Simulation` управляет жизненным циклом симуляции, включая добавление агентов, сред и фабрик, а также сохранение и восстановление состояния симуляции.

**Принцип работы**:
Класс `Simulation` инициализируется с уникальным идентификатором (ID). Он предоставляет методы для запуска (`begin`), остановки (`end`) и сохранения состояния симуляции (`checkpoint`). В процессе работы симуляции в нее добавляются агенты, среды и фабрики. Для повышения производительности используется механизм кэширования, который позволяет сохранять результаты выполнения функций и повторно использовать их при необходимости. Также поддерживается транзакционность, что позволяет гарантировать консистентность данных при выполнении операций.

**Атрибуты**:
- `id` (str): Уникальный идентификатор симуляции.
- `agents` (list): Список агентов в симуляции.
- `name_to_agent` (dict): Словарь, отображающий имена агентов в объекты агентов.
- `environments` (list): Список сред в симуляции.
- `factories` (list): Список фабрик в симуляции.
- `name_to_factory` (dict): Словарь, отображающий имена фабрик в объекты фабрик.
- `name_to_environment` (dict): Словарь, отображающий имена сред в объекты сред.
- `status` (str): Статус симуляции (`STATUS_STOPPED` или `STATUS_STARTED`).
- `cache_path` (str): Путь к файлу кэша.
- `auto_checkpoint` (bool): Флаг автоматического сохранения состояния после каждой транзакции.
- `has_unsaved_cache_changes` (bool): Флаг, указывающий на наличие несохраненных изменений в кэше.
- `_under_transaction` (bool): Флаг, указывающий на то, находится ли симуляция в состоянии транзакции.
- `cached_trace` (list): Список состояний симуляции, используемых для кэширования.
- `cache_misses` (int): Количество промахов кэша.
- `cache_hits` (int): Количество попаданий в кэш.
- `execution_trace` (list): Список состояний выполнения симуляции.

**Методы**:
- `__init__(self, id="default", cached_trace:list=None)`: Инициализирует новый экземпляр класса `Simulation`.
- `begin(self, cache_path:str=None, auto_checkpoint:bool=False)`: Запускает симуляцию.
- `end(self)`: Останавливает симуляцию.
- `checkpoint(self)`: Сохраняет текущее состояние симуляции в файл.
- `add_agent(self, agent)`: Добавляет агента в симуляцию.
- `add_environment(self, environment)`: Добавляет среду в симуляцию.
- `add_factory(self, factory)`: Добавляет фабрику в симуляцию.
- `_execution_trace_position(self) -> int`: Возвращает текущую позицию в трассе выполнения.
- `_function_call_hash(self, function_name, *args, **kwargs) -> int`: Вычисляет хеш вызова функции.
- `_skip_execution_with_cache(self)`: Пропускает выполнение, используя кэшированное состояние.
- `_is_transaction_event_cached(self, event_hash) -> bool`: Проверяет, кэшировано ли событие транзакции.
- `_drop_cached_trace_suffix(self)`: Удаляет суффикс кэшированной трассы.
- `_add_to_execution_trace(self, state: dict, event_hash: int, event_output)`: Добавляет состояние в трассу выполнения.
- `_add_to_cache_trace(self, state: dict, event_hash: int, event_output)`: Добавляет состояние в кэшированную трассу.
- `_load_cache_file(self, cache_path:str)`: Загружает кэш из файла.
- `_save_cache_file(self, cache_path:str)`: Сохраняет кэш в файл.
- `begin_transaction(self)`: Начинает транзакцию.
- `end_transaction(self)`: Завершает транзакцию.
- `is_under_transaction(self)`: Проверяет, находится ли симуляция в состоянии транзакции.
- `_clear_communications_buffers(self)`: Очищает буферы обмена данными агентов и сред.
- `_encode_simulation_state(self) -> dict`: Кодирует текущее состояние симуляции.
- `_decode_simulation_state(self, state: dict)`: Декодирует заданное состояние симуляции.

### `Transaction`

**Описание**: Класс `Transaction` управляет выполнением функций в контексте транзакции, обеспечивая кэширование и консистентность данных.

**Принцип работы**:
Класс `Transaction` принимает объект, над которым выполняется транзакция, ссылку на симуляцию, функцию и ее аргументы. При выполнении транзакции проверяется, запущена ли симуляция и доступен ли результат выполнения функции в кэше. Если результат кэширован, он используется повторно. В противном случае функция выполняется, ее результат кэшируется, и состояние симуляции сохраняется.

**Атрибуты**:
- `obj_under_transaction`: Объект, над которым выполняется транзакция.
- `simulation`: Ссылка на объект `Simulation`.
- `function_name` (str): Имя функции, выполняемой в транзакции.
- `function`: Функция, выполняемая в транзакции.
- `args` (tuple): Позиционные аргументы функции.
- `kwargs` (dict): Именованные аргументы функции.

**Методы**:
- `__init__(self, obj_under_transaction, simulation, function, *args, **kwargs)`: Инициализирует новый экземпляр класса `Transaction`.
- `execute(self)`: Выполняет транзакцию.
- `_encode_function_output(self, output) -> dict`: Кодирует выходные данные функции для кэширования.
- `_decode_function_output(self, encoded_output: dict)`: Декодирует кэшированные выходные данные функции.

### `SkipTransaction`

**Описание**: Класс исключения, используемый для обозначения пропуска транзакции.

### `CacheOutOfSync`

**Описание**: Класс исключения, используемый для обозначения рассинхронизации кэша.

### `ExecutionCached`

**Описание**: Класс исключения, используемый для обозначения того, что выполнение уже кэшировано.

## Функции

### `transactional`

```python
def transactional(func):
    """
    A helper decorator that makes a function simulation-transactional.
    """
```

**Назначение**: Декоратор, который делает функцию транзакционной в контексте симуляции.

**Параметры**:
- `func` (function): Функция, которую необходимо сделать транзакционной.

**Возвращает**:
- `wrapper` (function): Обертка для исходной функции, обеспечивающая транзакционность.

**Как работает функция**:

1.  Декоратор `transactional` принимает функцию `func` в качестве аргумента.
2.  Внутри декоратора определяется функция `wrapper`, которая будет заменять исходную функцию `func`.
3.  Функция `wrapper` принимает произвольные аргументы `*args` и `**kwargs`.
4.  Извлекается объект, над которым выполняется транзакция (`obj_under_transaction`), и текущая симуляция (`simulation`).
5.  Создается экземпляр класса `Transaction` с переданными аргументами.
6.  Вызывается метод `execute` экземпляра `Transaction` для выполнения транзакции.
7.  Результат выполнения транзакции возвращается.

```
    A(func)
    |
    B(wrapper)
    |
    C(obj_under_transaction, simulation)
    |
    D(Transaction.execute())
    |
    E(result)
```

Где:

-   `A` - Применение декоратора к функции.
-   `B` - Создание обертки `wrapper` для функции.
-   `C` - Извлечение объекта транзакции и текущей симуляции.
-   `D` - Выполнение транзакции.
-   `E` - Возврат результата выполнения транзакции.

**Примеры**:

```python
@transactional
def my_func(self, param1: str, param2: int) -> bool:
    # Какая-то логика
    return True
```

### `reset`

```python
def reset():
    """
    Resets the entire simulation control state.
    """
```

**Назначение**: Сброс состояния управления симуляцией.

**Как работает функция**:
1.  Обнуляет глобальные переменные `_current_simulations` и `_current_simulation_id`, используемые для хранения текущих симуляций.

### `_simulation`

```python
def _simulation(id="default"):
    """

    """
```

**Назначение**: Возвращает объект симуляции по идентификатору.

**Параметры**:
- `id` (str): Идентификатор симуляции. По умолчанию `"default"`.

**Возвращает**:
- Объект `Simulation`.

**Как работает функция**:
1.  Проверяет, существует ли симуляция с указанным идентификатором в словаре `_current_simulations`.
2.  Если симуляция не существует, создает новый экземпляр класса `Simulation` и сохраняет его в словаре `_current_simulations`.
3.  Возвращает объект симуляции.

### `begin`

```python
def begin(cache_path=None, id="default", auto_checkpoint=False):
    """
    Marks the start of the simulation being controlled.
    """
```

**Назначение**: Запускает симуляцию.

**Параметры**:
- `cache_path` (str, optional): Путь к файлу кэша.
- `id` (str, optional): Идентификатор симуляции. По умолчанию `"default"`.
- `auto_checkpoint` (bool, optional): Флаг автоматического сохранения состояния после каждой транзакции. По умолчанию `False`.

**Как работает функция**:
1.  Проверяет, не запущена ли уже симуляция.
2.  Если симуляция не запущена, вызывает метод `begin` объекта `Simulation` для запуска симуляции.
3.  Сохраняет идентификатор запущенной симуляции в глобальной переменной `_current_simulation_id`.

### `end`

```python
def end(id="default"):
    """
    Marks the end of the simulation being controlled.
    """
```

**Назначение**: Останавливает симуляцию.

**Параметры**:
- `id` (str, optional): Идентификатор симуляции. По умолчанию `"default"`.

**Как работает функция**:
1.  Вызывает метод `end` объекта `Simulation` для остановки симуляции.
2.  Обнуляет глобальную переменную `_current_simulation_id`.

### `checkpoint`

```python
def checkpoint(id="default"):
    """
    Saves current simulation state.
    """
```

**Назначение**: Сохраняет текущее состояние симуляции.

**Параметры**:
- `id` (str, optional): Идентификатор симуляции. По умолчанию `"default"`.

**Как работает функция**:
1.  Вызывает метод `checkpoint` объекта `Simulation` для сохранения состояния симуляции.

### `current_simulation`

```python
def current_simulation():
    """
    Returns the current simulation.
    """
```

**Назначение**: Возвращает текущую симуляцию.

**Возвращает**:
- Объект `Simulation` или `None`, если симуляция не запущена.

**Как работает функция**:
1.  Проверяет, запущена ли симуляция.
2.  Если симуляция запущена, возвращает объект `Simulation` с использованием идентификатора из глобальной переменной `_current_simulation_id`.
3.  Если симуляция не запущена, возвращает `None`.

### `cache_hits`

```python
def cache_hits(id="default"):
    """
    Returns the number of cache hits.
    """
```

**Назначение**: Возвращает количество попаданий в кэш для указанной симуляции.

**Параметры**:
- `id` (str, optional): Идентификатор симуляции. По умолчанию `"default"`.

**Возвращает**:
- Количество попаданий в кэш (int).

**Как работает функция**:
1.  Вызывает метод `cache_hits` объекта `Simulation` для получения количества попаданий в кэш.

### `cache_misses`

```python
def cache_misses(id="default"):
    """
    Returns the number of cache misses.
    """
```

**Назначение**: Возвращает количество промахов кэша для указанной симуляции.

**Параметры**:
- `id` (str, optional): Идентификатор симуляции. По умолчанию `"default"`.

**Возвращает**:
- Количество промахов кэша (int).

**Как работает функция**:
1.  Вызывает метод `cache_misses` объекта `Simulation` для получения количества промахов кэша.

```
A(id)
|
B(Simulation.cache_misses)
|
C(return)
```

Где:

-   `A` - Функция принимает идентификатор симуляции `id`.
-   `B` - Вызывается метод `cache_misses` у объекта `Simulation` с переданным идентификатором.
-   `C` - Функция возвращает полученное значение промахов кэша.
```