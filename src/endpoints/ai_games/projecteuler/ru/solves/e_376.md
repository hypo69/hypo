## Ответ на Задачу No 376: Непересекающиеся пути

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Нам дано множество точек S(n) на плоскости, где 0 ≤ x, y ≤ n и x, y - целые числа.
*   N(n) - количество путей из (0, 0) в (n, n), состоящих из шагов вправо или вверх, без самопересечений.
*   F(n) - количество путей из (0, 0) в (n, n) без самопересечений, которые никогда не выходят за пределы области S(n).
*   L(n) = F(n) mod 1000000007.
*   Нам нужно найти L(10^6).

**Решение:**

1.  **Пути без ограничений:** Количество путей из (0, 0) в (n, n) без ограничений равно биномиальному коэффициенту C(2n, n). Это количество способов выбрать n шагов вправо из 2n шагов (n вправо, n вверх). Формула C(n, k) = n! / (k! * (n-k)!)
2.  **Пути, выходящие за область:**  Путь выходит за область S(n), если он достигает прямой y = x + 1. Количество таких путей равно количеству путей из (-1, 1) в (n, n). Эти пути симметрично отображаются относительно прямой y=x+1.
3.  **Количество путей F(n):** Количество непересекающихся путей внутри S(n), это количество всех путей из (0,0) в (n,n) минус количество путей из (-1,1) в (n,n), которое равно C(2n,n) - C(2n, n-1).
4.  **Модульная арифметика:** Поскольку результат нужно вернуть по модулю 1000000007, необходимо выполнять все операции с учетом модуля, чтобы избежать переполнения.
5.  **Вычисление биномиальных коэффициентов:** Биномиальные коэффициенты можно эффективно вычислять, используя факториалы и их обратные по модулю. Для этого можно предподсчитать факториалы и обратные факториалы.
6.  **Оптимизация:**  Использование предрасчета факториалов и обратных к ним по модулю позволяет ускорить вычисление F(n)

### 2. Алгоритм решения

1.  Начать.
2.  Объявить и инициализировать константу `MOD` = 1000000007.
3.  Определить функцию `power(base, exp, mod)`, которая вычисляет `base^exp` по модулю `mod` используя бинарное возведение в степень.
4.  Определить функцию `modInverse(n, mod)`, которая вычисляет обратное по модулю n для числа `n` по модулю `mod`.
5.  Определить функцию `binom(n, k, fact, invFact, mod)`, которая вычисляет биномиальный коэффициент C(n, k) по модулю `mod`, используя предвычисленные факториалы и обратные факториалы.
6.  Определить функцию `calculate_f(n, fact, invFact, mod)`, которая вычисляет F(n) = C(2n, n) - C(2n, n-1) по модулю `mod`.
7.  Предвычислить факториалы и обратные факториалы для значений до 2 * 10^6 (максимальное необходимое значение для вычисления биномиальных коэффициентов при n = 10^6).
8.  Вычислить L(10^6) = F(10^6) mod 1000000007, используя `calculate_f`.
9.  Вернуть `L(10^6)`.
10. Конец.

### 3. Реализация на Python 3.12
```python
MOD = 1000000007

def power(base, exp, mod):
    """Calculates base^exp % mod using binary exponentiation."""
    res = 1
    base %= mod
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2
    return res

def modInverse(n, mod):
    """Calculates the modular inverse of n modulo mod."""
    return power(n, mod - 2, mod)

def binom(n, k, fact, invFact, mod):
    """Calculates the binomial coefficient C(n, k) % mod."""
    if k < 0 or k > n:
        return 0
    num = fact[n]
    den = (invFact[k] * invFact[n - k]) % mod
    return (num * den) % mod

def calculate_f(n, fact, invFact, mod):
    """Calculates F(n) = C(2n, n) - C(2n, n-1) % mod."""
    c1 = binom(2 * n, n, fact, invFact, mod)
    c2 = binom(2 * n, n - 1, fact, invFact, mod)
    return (c1 - c2 + mod) % mod


def main():
  """Main function to solve the problem"""
  n = 10**6
  max_val = 2 * n
  fact = [1] * (max_val + 1)
  invFact = [1] * (max_val + 1)

  # Precompute factorials
  for i in range(1, max_val + 1):
    fact[i] = (fact[i - 1] * i) % MOD

  # Precompute modular inverses of factorials
  invFact[max_val] = modInverse(fact[max_val], MOD)
  for i in range(max_val - 1, 0, -1):
    invFact[i] = (invFact[i+1] * (i + 1)) % MOD

  result = calculate_f(n, fact, invFact, MOD)
  print(result)

if __name__ == "__main__":
    main()
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeMOD((Инициализировать MOD = 1000000007))
    InitializeMOD --> PrecomputeFacts((Предвычислить факториалы и обратные факториалы))
    PrecomputeFacts --> CalculateF1M((Вычислить F(10^6) = C(2 * 10^6, 10^6) - C(2 * 10^6, 10^6 - 1) mod MOD))
    CalculateF1M --> OutputResult((Вывести результат F(10^6) mod MOD))
    OutputResult --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
*  **Инициализировать MOD:** Инициализация константы MOD для операций по модулю.
* **Предвычислить факториалы и обратные факториалы:** Предварительное вычисление факториалов и обратных факториалов по модулю для ускорения вычислений биномиальных коэффициентов.
* **Вычислить F(10^6) = C(2 * 10^6, 10^6) - C(2 * 10^6, 10^6 - 1) mod MOD:** Вычисление значения функции F(n) для n = 10^6 с использованием предвычисленных значений и операций по модулю.
* **Вывести результат F(10^6) mod MOD:** Вывод окончательного результата.
