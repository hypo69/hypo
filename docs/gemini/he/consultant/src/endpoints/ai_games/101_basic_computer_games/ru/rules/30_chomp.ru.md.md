# Анализ кода модуля `30_chomp.ru.md`

**Качество кода**

- **Соответствие требованиям к формату кода (1-10):** 7
    -  **Преимущества:**
        - Документ содержит полное описание правил игры "CHOMP" на русском языке.
        - Текст структурирован с использованием заголовков и подзаголовков.
        - Есть пошаговая инструкция для реализации игры.
        - Представлен пример работы программы.
    - **Недостатки:**
        - Документ не является исполняемым кодом Python.
        - Отсутствует формат reStructuredText (RST) для комментариев и документации.
        - Нет комментариев в стиле Python docstring.
        - Не используется `j_loads` или `j_loads_ns` для чтения файлов.
        - Отсутствуют импорты и не применены рекомендации по форматированию кода.
        - Нет обработки ошибок и логирования.

**Рекомендации по улучшению**

1. **Преобразование в Python-скрипт:** Необходимо преобразовать описание игры в исполняемый Python-скрипт.
2. **Формат reStructuredText (RST):** Все комментарии и документация должны быть переписаны в формате RST.
3. **Документирование кода:** Каждая функция, метод и класс должны иметь docstring в формате, совместимом с Sphinx.
4. **Использование `j_loads`:** При чтении файлов необходимо использовать `j_loads` или `j_loads_ns` из `src.utils.jjson`.
5. **Обработка ошибок:** Добавить обработку ошибок с помощью `logger.error`.
6. **Логирование:** Использовать `from src.logger.logger import logger` для записи ошибок.
7. **Импорты:** Добавить необходимые импорты для работы скрипта.
8. **Структура кода:** Организовать код в функции и классы для лучшей читаемости и поддержки.

**Улучшенный код**

```python
"""
Модуль для реализации игры CHOMP (Печенька).
=========================================================================================

Модуль содержит реализацию игры CHOMP, где игроки по очереди "съедают" клетки с печеньки,
стараясь не "съесть" отравленную клетку в верхнем левом углу.

Пример использования
--------------------

Пример запуска игры CHOMP:

.. code-block:: python

   from src.endpoints.ai_games.101_basic_computer_games.ru.rules import chomp

   chomp.play_chomp()
"""

import sys # импортируем sys для выхода из игры
from src.logger.logger import logger # импортируем logger для логирования ошибок

def init_game() -> tuple[int, int, int]:
    """
    Инициализирует игру, запрашивая параметры игры у пользователя.

    :return: (число игроков, число рядов, число столбцов)
    :rtype: tuple[int, int, int]
    """
    try: # оборачиваем ввод данных в блок try-except для обработки ошибок
        num_players = int(input('Введите количество игроков: ')) # получаем кол-во игроков
        rows = int(input('Введите количество рядов: ')) # получаем кол-во рядов
        cols = int(input('Введите количество столбцов: ')) # получаем кол-во столбцов
        if num_players < 1 or rows < 1 or cols < 1: # проверяем корректность введенных данных
            raise ValueError('Количество игроков, рядов и столбцов должно быть положительным.') # вызываем ошибку если данные не корректны
        return num_players, rows, cols # возвращаем параметры игры
    except ValueError as e: # перехватываем ошибку если ввод некорректный
        logger.error(f'Ошибка ввода: {e}') # логируем ошибку
        sys.exit(1) # выходим из программы
    except Exception as e: # перехватываем все другие ошибки
        logger.error(f'Непредвиденная ошибка при инициализации игры: {e}') # логируем ошибку
        sys.exit(1) # выходим из программы

def make_move(board: list[list[int]], row: int, col: int):
    """
    Выполняет ход игрока, убирая клетки с игрового поля.

    :param board: игровое поле.
    :type board: list[list[int]]
    :param row: выбранная строка.
    :type row: int
    :param col: выбранный столбец.
    :type col: int
    """
    rows = len(board) # получаем количество строк
    cols = len(board[0]) # получаем количество столбцов
    for i in range(row, rows): # идем по строкам
        for j in range(col, cols): # идем по столбцам
            board[i][j] = 0 # ставим 0, что означает пустую клетку

def check_winner(board: list[list[int]]) -> bool:
    """
    Проверяет, съел ли игрок отравленную клетку.

    :param board: игровое поле.
    :type board: list[list[int]]
    :return: True, если отравленная клетка (верхний левый угол) съедена, иначе False.
    :rtype: bool
    """
    return board[0][0] == 0 # возвращаем True если верхний левый угол пустой (0) и False в обратном случае

def print_board(board: list[list[int]]):
    """
    Выводит игровое поле в консоль.

    :param board: игровое поле.
    :type board: list[list[int]]
    """
    for row in board: # проходим по строкам доски
        print(' '.join(map(str, row))) # выводим строку

def play_chomp():
    """
    Запускает игровой процесс CHOMP.
    """
    print('Добро пожаловать в игру CHOMP!') # приветствуем пользователя

    num_players, rows, cols = init_game() # инициализируем игру

    board = [[1 for _ in range(cols)] for _ in range(rows)] # создаем игровую доску
    board[0][0] = 'P'  # Отравленная печенька в верхнем левом углу

    current_player = 1 # начинаем с первого игрока

    while True: # цикл игры
        print_board(board) # выводим доску на экран

        try:
            row, col = map(int, input(f'Игрок {current_player}, введите координаты клетки (ряд, колонка), начиная с 0: ').split(',')) # получаем координаты от игрока
        except ValueError:
            logger.error('Некорректный ввод. Пожалуйста, введите два числа через запятую.') # логируем ошибку
            continue

        if not (0 <= row < rows and 0 <= col < cols): # проверяем правильность ввода
             logger.error('Некорректные координаты. Пожалуйста, выберите клетку в пределах игрового поля.') # логируем ошибку
             continue

        if board[row][col] == 0: # если выбранная клетка пустая, просим повторить ввод
            logger.error('Эта клетка уже съедена. Пожалуйста, выберите другую клетку.') # логируем ошибку
            continue

        make_move(board, row, col)  # выполняем ход

        if check_winner(board):  # проверяем победителя
            print(f'Игрок {current_player} съел отравленную печеньку! Игра окончена.')  # выводим сообщение о проигрыше
            break

        current_player = 3 - current_player # переключаемся на другого игрока

    while True: # играем до тех пор, пока не надоест
        play_again = input('Хотите сыграть снова? (да/нет): ').lower() # спрашиваем пользователя хочет ли он сыграть снова
        if play_again == 'да':
            play_chomp() # запускаем игру снова
            break
        elif play_again == 'нет':
            print('Спасибо за игру!') # прощаемся с пользователем
            break
        else:
            logger.error('Некорректный ввод. Пожалуйста, введите "да" или "нет".') # если ввод некорректный, просим ввести еще раз
```