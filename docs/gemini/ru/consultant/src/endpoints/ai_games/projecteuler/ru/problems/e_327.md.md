# Анализ кода модуля e_327

**Качество кода**
8
- Плюсы
    - Код представляет собой описание задачи, а не исполняемый код. Это соответствует заданию на анализ и улучшение.
    - Описание задачи достаточно подробное и понятное.
- Минусы
    - Отсутствует какой-либо код для анализа и улучшения. Это скорее текст задачи, а не код, требующий рефакторинга.
    - Нет импортов, функций, классов или переменных для анализа.

**Рекомендации по улучшению**
Поскольку предоставленный "код" является описанием задачи, а не исполняемым кодом, рекомендации по улучшению будут направлены на то, как можно было бы подойти к решению этой задачи в коде Python.

1. **Создание функций для симуляции:**
    - Необходимо создать функцию для моделирования раунда игры.
    - Функция должна принимать на вход текущее состояние ящиков (количество шаров в каждом ящике), количество ящиков и возвращать новое состояние.
2. **Реализация проверки на простоту:**
   - Реализовать функцию для проверки, является ли число простым.
3. **Функция для подсчета счастливых ящиков:**
   - Функция для подсчета количества ящиков с простым количеством шаров.
4. **Моделирование большого количества раундов:**
    - Цикл для выполнения большого количества симуляций (например, 10000) для получения приближенного значения математического ожидания.
5. **Расчет математического ожидания:**
    - Вычисление среднего количества счастливых ящиков.
6. **Логирование результатов:**
    - Использование логгера для вывода промежуточных и финальных результатов.

**Оптимизированный код**
```python
"""
Модуль для решения задачи 327 Project Euler.
=========================================================================================

Модуль содержит функции для симуляции процесса с шариками в ящиках, 
проверки чисел на простоту и вычисления математического ожидания количества счастливых ящиков.

Пример использования
--------------------

Пример использования функций:

.. code-block:: python

    result = calculate_expected_happy_boxes(10_000_000, 10000)
    print(f"E(10^7) = {result:.10f}")
"""

import math
import random
from src.logger.logger import logger  # Импорт логгера

def is_prime(n: int) -> bool:
    """
    Проверяет, является ли число простым.

    :param n: Число для проверки.
    :return: True, если число простое, иначе False.
    """
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def simulate_round(boxes: list[int], num_boxes: int) -> list[int]:
    """
    Моделирует один раунд игры с ящиками и шарами.

    :param boxes: Список, представляющий текущее количество шаров в каждом ящике.
    :param num_boxes: Общее количество ящиков.
    :return: Обновленный список с количеством шаров в каждом ящике после раунда.
    """
    try:
        # Удваиваем количество шаров в каждом ящике
        boxes = [box * 2 for box in boxes]
        # Выбираем случайный ящик и удаляем из него один шар
        remove_from_box = random.randint(0, num_boxes - 1)
        boxes[remove_from_box] -= 1
        return boxes
    except Exception as ex:
        logger.error(f"Ошибка при симуляции раунда: {ex}")
        return boxes

def count_happy_boxes(boxes: list[int]) -> int:
    """
    Считает количество "счастливых" ящиков (с простым числом шаров).

    :param boxes: Список с количеством шаров в каждом ящике.
    :return: Количество ящиков с простым числом шаров.
    """
    try:
        count = 0
        for box in boxes:
            if is_prime(box):
                count += 1
        return count
    except Exception as ex:
        logger.error(f"Ошибка при подсчете счастливых ящиков: {ex}")
        return 0


def calculate_expected_happy_boxes(num_rounds: int, num_simulations: int, num_boxes: int = 1000) -> float:
    """
    Вычисляет математическое ожидание количества счастливых ящиков после заданного количества раундов.

    :param num_rounds: Количество раундов.
    :param num_simulations: Количество симуляций для расчета ожидания.
    :param num_boxes: Количество ящиков.
    :return: Математическое ожидание количества счастливых ящиков.
    """
    try:
        total_happy_boxes = 0
        for _ in range(num_simulations):
            boxes = [1] * num_boxes  # Начальное состояние: один шар в каждом ящике
            for _ in range(num_rounds):
                boxes = simulate_round(boxes, num_boxes)
            total_happy_boxes += count_happy_boxes(boxes)
        return total_happy_boxes / num_simulations
    except Exception as ex:
        logger.error(f"Ошибка при расчете математического ожидания: {ex}")
        return 0.0

if __name__ == '__main__':
    # Вычисление ожидаемого количества счастливых ящиков для 10^7 раундов
    num_rounds = 10_000_000  
    num_simulations = 1000  # Количество симуляций (можно увеличить для большей точности)
    
    result = calculate_expected_happy_boxes(num_rounds, num_simulations)
    print(f"E({num_rounds}) = {result:.10f}")
```