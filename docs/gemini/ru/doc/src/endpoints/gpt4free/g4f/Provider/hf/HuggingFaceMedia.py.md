# Модуль HuggingFaceMedia
## Обзор
Модуль `HuggingFaceMedia` предоставляет асинхронный интерфейс для генерации изображений и видео, используя различные модели и API, предоставляемые Hugging Face. Он поддерживает как бесплатные, так и требующие аутентификации сервисы. Модуль предназначен для интеграции с другими частями проекта `hypotez`, обеспечивая возможность генерации медиаконтента на основе текстовых запросов.

## Подробней
Модуль использует различные API Hugging Face и сторонних провайдеров для генерации изображений и видео на основе текстовых запросов. Поддерживаются различные задачи, такие как `text-to-image` и `text-to-video`. Класс `HuggingFaceMedia` реализует логику выбора подходящего провайдера, формирования запросов и обработки ответов.

## Классы

### `HuggingFaceMedia`
**Описание**: Класс для асинхронной генерации изображений и видео с использованием API Hugging Face.
**Наследует**: `AsyncGeneratorProvider`, `ProviderModelMixin`.

**Атрибуты**:
- `label` (str): Метка провайдера "HuggingFace (Image/Video Generation)".
- `parent` (str): Родительский провайдер "HuggingFace".
- `url` (str): URL главной страницы Hugging Face "https://huggingface.co".
- `working` (bool): Индикатор работоспособности провайдера (всегда `True`).
- `needs_auth` (bool): Индикатор необходимости аутентификации (всегда `True`).
- `tasks` (list[str]): Список поддерживаемых задач: `["text-to-image", "text-to-video"]`.
- `provider_mapping` (dict[str, dict]): Словарь соответствия моделей провайдерам.
- `task_mapping` (dict[str, str]): Словарь соответствия моделей задачам.
- `models` (list[str]): Список доступных моделей.
- `image_models` (list[str]): Список моделей для генерации изображений.
- `video_models` (list[str]): Список моделей для генерации видео.

**Методы**:

- `get_models(**kwargs) -> list[str]`: Получает список доступных моделей для генерации медиаконтента.
- `get_mapping(model: str, api_key: str = None)`: Получает информацию о соответствии модели и провайдера.
- `create_async_generator(model: str, messages: Messages, api_key: str = None, extra_data: dict = {}, prompt: str = None, proxy: str = None, timeout: int = 0, n: int = 1, aspect_ratio: str = None, height: int = None, width: int = None, resolution: str = "480p", **kwargs)`: Создает асинхронный генератор для генерации медиаконтента.

## Функции

### `get_models`
```python
@classmethod
def get_models(cls, **kwargs) -> list[str]:
    """
    Получает список доступных моделей для генерации медиаконтента.
    
    Args:
        **kwargs: Дополнительные аргументы (не используются).

    Returns:
        list[str]: Список доступных моделей.
    """
```

**Назначение**:
Метод `get_models` извлекает список доступных моделей из API Hugging Face для задач генерации изображений и видео. Если список моделей еще не был получен, он делает запрос к API, обрабатывает полученные данные и сохраняет их для дальнейшего использования.

**Как работает функция**:

1. **Проверка наличия моделей**: Проверяет, был ли уже получен список моделей (`cls.models`).
2. **Запрос к API Hugging Face**: Если список моделей пуст, отправляет GET-запрос к API Hugging Face для получения информации о моделях с поддержкой inference и задачами `text-to-image` и `text-to-video`.
3. **Обработка ответа**: Если запрос успешен (`response.ok`):
   - Извлекает список моделей из JSON-ответа.
   - Формирует словарь `providers`, где ключом является идентификатор модели, а значением — список провайдеров для этой модели, поддерживающих задачи генерации медиаконтента.
   - Создает список `new_models`, содержащий идентификаторы моделей и информацию о провайдерах.
   - Формирует словарь `cls.task_mapping`, где ключом является идентификатор модели, а значением — задача, которую она поддерживает (`text-to-image` или `text-to-video`).
   - Создает списки `cls.image_models` и `cls.video_models` на основе `cls.task_mapping`.
4. **Обработка ошибок**: Если запрос к API завершается с ошибкой, устанавливает `cls.models` в пустой список.
5. **Возврат результата**: Возвращает список доступных моделей (`cls.models`).

**ASCII flowchart**:

```
A [Проверка cls.models]
|
B [Запрос к API Hugging Face]
|
C [Обработка ответа API]
|
D [Формирование списков моделей и задач]
|
E [Возврат списка моделей]
```

**Примеры**:

```python
# Пример вызова метода get_models
models = HuggingFaceMedia.get_models()
print(models)
```

### `get_mapping`
```python
@classmethod
async def get_mapping(cls, model: str, api_key: str = None):
    """
    Получает информацию о соответствии модели и провайдера.

    Args:
        model (str): Имя модели.
        api_key (str, optional): API-ключ для аутентификации. По умолчанию `None`.

    Returns:
        dict: Словарь с информацией о соответствии модели и провайдера.
    """
```

**Назначение**:
Метод `get_mapping` получает информацию о соответствии между моделью и провайдером, используя API Hugging Face. Эта информация включает в себя данные о доступных задачах и настройках для конкретной модели.

**Как работает функция**:

1. **Проверка кэша**: Проверяет, есть ли уже информация о соответствии модели и провайдера в кэше (`cls.provider_mapping`). Если есть, возвращает ее.
2. **Формирование заголовков**: Создает заголовки запроса, включая API-ключ, если он предоставлен.
3. **Асинхронный запрос к API**: Отправляет асинхронный GET-запрос к API Hugging Face для получения информации о модели.
4. **Обработка ответа**: Если запрос успешен:
   - Извлекает данные о соответствии модели и провайдера из JSON-ответа.
   - Сохраняет информацию в кэше (`cls.provider_mapping`).
5. **Обработка ошибок**: В случае ошибки выбрасывает исключение `ModelNotSupportedError`.
6. **Возврат результата**: Возвращает словарь с информацией о соответствии модели и провайдера.

**ASCII flowchart**:

```
A [Проверка кэша cls.provider_mapping]
|
B [Формирование заголовков]
|
C [Асинхронный GET-запрос к API Hugging Face]
|
D [Обработка ответа API]
|
E [Сохранение в кэш]
|
F [Возврат словаря с информацией]
```

**Примеры**:

```python
# Пример вызова метода get_mapping
import asyncio

async def main():
    mapping = await HuggingFaceMedia.get_mapping("stabilityai/stable-diffusion-2")
    print(mapping)

asyncio.run(main())
```

### `create_async_generator`
```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    api_key: str = None,
    extra_data: dict = {},
    prompt: str = None,
    proxy: str = None,
    timeout: int = 0,
    # Video & Image Generation
    n: int = 1,
    aspect_ratio: str = None,
    # Only for Image Generation
    height: int = None,
    width: int = None,
    # Video Generation
    resolution: str = "480p",
    **kwargs
):
    """
    Создает асинхронный генератор для генерации медиаконтента.

    Args:
        model (str): Имя модели.
        messages (Messages): Список сообщений для формирования запроса.
        api_key (str, optional): API-ключ для аутентификации. По умолчанию `None`.
        extra_data (dict, optional): Дополнительные данные для запроса. По умолчанию `{}`.
        prompt (str, optional): Текстовый запрос. По умолчанию `None`.
        proxy (str, optional): Адрес прокси-сервера. По умолчанию `None`.
        timeout (int, optional): Время ожидания запроса. По умолчанию `0`.
        n (int, optional): Количество генерируемых медиафайлов. По умолчанию `1`.
        aspect_ratio (str, optional): Соотношение сторон изображения/видео. По умолчанию `None`.
        height (int, optional): Высота изображения (только для изображений). По умолчанию `None`.
        width (int, optional): Ширина изображения (только для изображений). По умолчанию `None`.
        resolution (str, optional): Разрешение видео (только для видео). По умолчанию `"480p"`.
        **kwargs: Дополнительные аргументы.

    Yields:
        Reasoning: Объяснение процесса генерации.
        ProviderInfo: Информация о провайдере.
        ImageResponse | VideoResponse: Сгенерированное изображение или видео.
    """
```

**Назначение**:
Метод `create_async_generator` создает асинхронный генератор для генерации медиаконтента на основе предоставленных параметров. Он выбирает подходящего провайдера, формирует запросы к API и обрабатывает ответы, предоставляя сгенерированный контент в виде изображений или видео.

**Как работает функция**:

1. **Выбор провайдера**: Определяет выбранного провайдера на основе параметра `model`. Если провайдер не указан, выбирает первый доступный из списка.
2. **Форматирование запроса**: Форматирует текстовый запрос с использованием функции `format_image_prompt`.
3. **Получение информации о провайдере**: Получает информацию о соответствии модели и провайдера с использованием метода `get_mapping`.
4. **Формирование заголовков**: Создает заголовки запроса, включая API-ключ, если он предоставлен.
5. **Определение параметров запроса**: Определяет параметры запроса в зависимости от выбранного провайдера и задачи (генерация изображения или видео).
6. **Асинхронные запросы к API**: Отправляет асинхронные POST-запросы к API выбранного провайдера для генерации медиаконтента.
7. **Обработка ответов**: Обрабатывает ответы API, извлекая сгенерированные изображения или видео.
8. **Обработка ошибок**: Обрабатывает ошибки, возникающие в процессе генерации, и выбрасывает исключения `ModelNotSupportedError` в случае, если модель не поддерживается.
9. **Асинхронный генератор**: Предоставляет сгенерированный контент в виде асинхронного генератора, который возвращает информацию о провайдере, этапы генерации и сгенерированные изображения или видео.

**ASCII flowchart**:

```
A [Выбор провайдера]
|
B [Форматирование запроса]
|
C [Получение информации о провайдере]
|
D [Формирование заголовков]
|
E [Определение параметров запроса]
|
F [Асинхронные POST-запросы к API]
|
G [Обработка ответов API]
|
H [Обработка ошибок]
|
I [Асинхронный генератор]
```

**Примеры**:

```python
# Пример вызова метода create_async_generator
import asyncio
from typing import List, Dict

async def main():
    messages: List[Dict[str, str]] = [{"role": "user", "content": "Generate a futuristic cityscape"}]
    generator = HuggingFaceMedia.create_async_generator(
        model="stabilityai/stable-diffusion-2",
        messages=messages
    )
    async for item in generator:
        print(item)

asyncio.run(main())