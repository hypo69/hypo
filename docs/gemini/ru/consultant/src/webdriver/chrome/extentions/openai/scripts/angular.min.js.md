# Анализ кода модуля `angular.min.js`

**Качество кода: 7/10**

-  **Плюсы:**
    - Код минимизирован, что характерно для production-версии.
    - Присутствует общая структура, хотя и затруднённая для чтения из-за минимизации.
    - Код разбит на отдельные функции и модули, что способствует модульности.

-  **Минусы:**
    - Код минимизирован, что делает его крайне нечитаемым и затрудняет понимание логики.
    - Отсутствует документация в коде, что усложняет его понимание и сопровождение.
    - Используются сокращенные имена переменных и функций, что снижает понятность кода.
    - Использование глобальных переменных и объектов (например, `z`) может привести к конфликтам.
    - Присутствует потенциальная избыточность кода из-за отсутствия оптимизации в минимизированной версии.
    - Не используются стандартные средства обработки ошибок, что затрудняет отладку.

**Рекомендации по улучшению**
   -   **Документация:**
      -  Добавить docstring в reStructuredText (RST) формате ко всем функциям и модулям.
      -  Описать назначение каждого модуля, класса, функции, метода и переменной.
   -   **Импорты:**
      -   Проверить и добавить все необходимые импорты.
   -   **Обработка ошибок:**
      -   Использовать `src.logger.logger` для логирования ошибок вместо `try-except`.
      -   Добавить информативные сообщения об ошибках.
   -   **Именование:**
      -   Переименовать переменные и функции в более понятные и осмысленные.
      -   Использовать snake_case для переменных и функций.
   -   **Структура:**
       -  Реорганизовать код для повышения читаемости, даже при минимальном изменении логики.
       -  Разбить на более мелкие и логически завершенные блоки.
    -  **Комментарии**:
       -  Добавить комментарии к сложным участкам кода, объясняя их логику.
       -  Использовать rST комментарии для документации кода.
    -  **Глобальные переменные**:
       -  Избегать использования глобальных переменных и по возможности использовать локальные или параметры функций.

**Оптимизированный код**
```python
"""
Модуль angular.min.js
=========================================================================================

Этот модуль содержит минимизированную версию AngularJS 1.8.2.
Используется для обеспечения функциональности Angular в браузере.

"""
import json
from typing import Any, Dict, List, Optional, Union, Callable
from src.utils.jjson import j_loads, j_loads_ns
from src.logger.logger import logger

# TODO: Добавить все необходимые импорты

Xb = {'objectMaxDepth': 5, 'urlErrorParamsEnabled': True}
# TODO: Использовать camel_case
def configure_error_handling(options: Optional[Dict] = None) -> Dict:
    """
    Настраивает параметры обработки ошибок.

    :param options: Словарь с опциями конфигурации.
    :return: Словарь с текущими настройками.
    """
    if not options:
        return Xb
    if 'objectMaxDepth' in options and isinstance(options['objectMaxDepth'], int) and options['objectMaxDepth'] > 0:
        Xb['objectMaxDepth'] = options['objectMaxDepth']
    if 'urlErrorParamsEnabled' in options and isinstance(options['urlErrorParamsEnabled'], bool):
        Xb['urlErrorParamsEnabled'] = options['urlErrorParamsEnabled']
    return Xb


def is_valid_max_depth(depth: Any) -> bool:
    """
    Проверяет, является ли значение допустимой максимальной глубиной.

    :param depth: Проверяемое значение.
    :return: True, если значение является допустимой максимальной глубиной, иначе False.
    """
    return isinstance(depth, int) and depth > 0

def create_error_constructor(module_name: str, error_class: Optional[Callable] = None) -> Callable:
    """
    Создаёт конструктор ошибок для модуля.

    :param module_name: Имя модуля для ошибок.
    :param error_class: Класс ошибки, который будет использован.
    :return: Функция-конструктор ошибок.
    """
    error_class = error_class or Exception
    def error_constructor(error_code: str, *args: Any) -> Exception:
        """
        Конструктор ошибок.

        :param error_code: Код ошибки.
        :param args: Дополнительные аргументы для сообщения об ошибке.
        :return: Новый объект ошибки.
        """
        if module_name:
           message = f'[{module_name}:{error_code}] http://errors.angularjs.org/1.8.2/{module_name}/{error_code}'
        else:
           message = f'[{error_code}] http://errors.angularjs.org/1.8.2/{error_code}'
        for i, arg in enumerate(args):
           arg_str = str(arg) if not isinstance(arg, (dict, list))  else json.dumps(arg)
           message += f'{"?" if i == 0 else "&"}p{i + 1}={arg_str}'

        return error_class(message)
    return error_constructor


def is_array_like(value: Any) -> bool:
    """
    Проверяет, является ли значение массивоподобным объектом.

    :param value: Проверяемое значение.
    :return: True, если значение является массивоподобным объектом, иначе False.
    """
    if value is None or isinstance(value, (bool, int, float, str)):
        return False
    if isinstance(value, (list, tuple)) or (hasattr(value, '__class__') and value.__class__.__name__ == 'NodeList'):
        return True
    length = getattr(value, 'length', None)
    return isinstance(length, int) and length >= 0 and length - 1 in value or callable(getattr(value, 'item', None))


def for_each(obj: Any, callback: Callable, this_arg: Any = None) -> Any:
    """
    Выполняет итерацию по объекту.

    :param obj: Объект для итерации.
    :param callback: Функция обратного вызова для каждого элемента.
    :param this_arg: Значение 'this' внутри обратного вызова.
    :return: Исходный объект.
    """
    if not obj:
      return obj

    if isinstance(obj, dict):
        for key in obj:
            if key != 'prototype' and key != 'length' and key != 'name' and obj.get(key):
                callback(obj[key], key, obj)
    elif is_array_like(obj):
        is_object_type = isinstance(obj, object)
        for i in range(len(obj)):
            if (is_object_type or i in obj):
                callback(obj[i], i, obj)
    elif callable(getattr(obj, 'forEach', None)) and obj.forEach != for_each:
        obj.forEach(callback, this_arg, obj)
    else:
        if hasattr(obj, 'hasOwnProperty') and callable(obj.hasOwnProperty):
             for key in obj:
                if obj.hasOwnProperty(key):
                  callback(obj[key], key, obj)
        else:
            for key in obj:
                if hasattr(obj, key):
                    callback(obj[key], key, obj)
    return obj

def sort_object_keys(obj: dict, callback: Callable, this_arg: Any = None) -> List:
    """
    Сортирует ключи объекта и выполняет обратный вызов для каждого ключа.

    :param obj: Объект, чьи ключи необходимо отсортировать.
    :param callback: Функция обратного вызова для каждого ключа.
    :param this_arg: Значение 'this' внутри обратного вызова.
    :return: Список отсортированных ключей.
    """
    keys = sorted(obj.keys())
    for key in keys:
       callback(obj[key], key, obj)
    return keys

def reverse_args_callback(callback: Callable) -> Callable:
    """
    Инвертирует аргументы функции обратного вызова.

    :param callback: Исходная функция обратного вызова.
    :return: Новая функция обратного вызова с инвертированными аргументами.
    """
    def _wrapper(arg1: Any, arg2: Any) -> None:
       callback(arg2, arg1)
    return _wrapper

def get_unique_id() -> int:
    """
    Генерирует уникальный идентификатор.

    :return: Уникальный целочисленный идентификатор.
    """
    global qb
    qb += 1
    return qb
qb = 0

def copy_properties(target: dict, sources: List, deep_copy=False) -> dict:
    """
    Копирует свойства из одного или нескольких объектов в целевой объект.

    :param target: Целевой объект.
    :param sources: Список объектов-источников.
    :param deep_copy: Флаг, указывающий на необходимость глубокого копирования.
    :return: Модифицированный целевой объект.
    """
    target_hash = target.get('$$hashKey')
    for source in sources:
      if isinstance(source, dict) or isinstance(source,list):
           for key in source:
             value = source[key]
             if deep_copy and isinstance(value, dict):
                 if not isinstance(target.get(key),dict) :
                     target[key] = {}
                 copy_properties(target[key], [value], deep_copy)
             elif deep_copy and isinstance(value, list):
                 if not isinstance(target.get(key),list) :
                     target[key] = []
                 copy_properties(target[key], [value], deep_copy)
             else:
                 target[key] = value
      elif isinstance(source, (list,tuple)):
           for key in range(len(source)):
                value = source[key]
                if deep_copy and isinstance(value, dict):
                    if not isinstance(target.get(key),dict) :
                        target[key] = {}
                    copy_properties(target[key], [value], deep_copy)
                elif deep_copy and isinstance(value, list):
                     if not isinstance(target.get(key),list) :
                         target[key] = []
                     copy_properties(target[key], [value], deep_copy)
                else:
                  target[key] = value

    if target_hash:
      target['$$hashKey'] = target_hash
    else:
        target.pop('$$hashKey',None)
    return target

def extend(target: dict, *sources: dict) -> dict:
    """
    Расширяет целевой объект свойствами из других объектов.
    
    :param target: Целевой объект.
    :param sources: Объекты источники.
    :return: Расширенный целевой объект.
    """
    return copy_properties(target, list(sources), False)

def merge(target: dict, *sources: dict) -> dict:
   """
    Мерджит целевой объект свойствами из других объектов.
    
    :param target: Целевой объект.
    :param sources: Объекты источники.
    :return: Расширенный целевой объект.
    """
   return copy_properties(target, list(sources), True)

def parse_int(value: str) -> int:
    """
    Преобразует строку в целое число.

    :param value: Строка для преобразования.
    :return: Целое число, полученное из строки.
    """
    return int(value, 10)

def create_object_with_prototype(prototype: dict, properties: dict) -> dict:
   """
    Создает новый объект с заданным прототипом.
    :param prototype: Прототип объекта.
    :param properties: Свойства для нового объекта.
    :return: Новый объект.
    """
   return extend(Object.create(prototype), properties)

def noop() -> None:
   """
    Функция-заглушка, которая ничего не делает.
    """
   pass

def return_value(value: Any) -> Any:
   """
    Функция, которая возвращает переданное значение.
    
    :param value: Значение для возврата.
    :return: Переданное значение.
   """
   return value

def return_constant_value(value: Any) -> Callable:
   """
    Функция, возвращающая функцию, которая возвращает константное значение.
    
    :param value: Константное значение.
    :return: Функция, которая возвращает константное значение.
   """
   def _wrapper() -> Any:
      return value
   return _wrapper

def is_stringable(value: Any) -> bool:
    """
    Проверяет, можно ли преобразовать значение в строку.

    :param value: Проверяемое значение.
    :return: True, если значение можно преобразовать в строку, иначе False.
    """
    return isinstance(getattr(value, 'toString', None), Callable) and  getattr(value, 'toString', None) != str

def is_undefined(value: Any) -> bool:
    """
    Проверяет, является ли значение неопределённым.

    :param value: Проверяемое значение.
    :return: True, если значение неопределённое, иначе False.
    """
    return value is None

def is_defined(value: Any) -> bool:
    """
    Проверяет, является ли значение определённым.

    :param value: Проверяемое значение.
    :return: True, если значение определённое, иначе False.
    """
    return value is not None

def is_object(value: Any) -> bool:
   """
    Проверяет, является ли значение объектом.
    
    :param value: Значение для проверки.
    :return: True, если значение является объектом, False в противном случае.
    """
   return value is not None and isinstance(value, object)

def is_plain_object(value: Any) -> bool:
   """
    Проверяет, является ли значение простым объектом.
    
    :param value: Значение для проверки.
    :return: True, если значение является простым объектом, False в противном случае.
    """
   return is_object(value) and not isinstance(value, list) and not callable(getattr(value,'item', None))

def is_string(value: Any) -> bool:
    """
    Проверяет, является ли значение строкой.

    :param value: Проверяемое значение.
    :return: True, если значение является строкой, иначе False.
    """
    return isinstance(value, str)

def is_number(value: Any) -> bool:
    """
    Проверяет, является ли значение числом.

    :param value: Проверяемое значение.
    :return: True, если значение является числом, иначе False.
    """
    return isinstance(value, (int, float))

def is_date(value: Any) -> bool:
    """
    Проверяет, является ли значение объектом даты.

    :param value: Проверяемое значение.
    :return: True, если значение является датой, иначе False.
    """
    return isinstance(value, type(datetime.datetime.now()))

def is_array(value: Any) -> bool:
    """
    Проверяет, является ли значение массивом.

    :param value: Проверяемое значение.
    :return: True, если значение является массивом, иначе False.
    """
    return isinstance(value, list) or isinstance(value, tuple)

def is_error(value: Any) -> bool:
    """
    Проверяет, является ли значение объектом ошибки.

    :param value: Проверяемое значение.
    :return: True, если значение является ошибкой, иначе False.
    """
    return isinstance(value, Exception) or (hasattr(value, '__class__') and value.__class__.__name__ in ('Error','Exception','DOMException'))

def is_function(value: Any) -> bool:
    """
    Проверяет, является ли значение функцией.

    :param value: Проверяемое значение.
    :return: True, если значение является функцией, иначе False.
    """
    return callable(value)

def is_regexp(value: Any) -> bool:
    """
    Проверяет, является ли значение регулярным выражением.

    :param value: Проверяемое значение.
    :return: True, если значение является регулярным выражением, иначе False.
    """
    return isinstance(value, type(re.compile('')))

def is_window(value: Any) -> bool:
    """
    Проверяет, является ли значение объектом окна.

    :param value: Проверяемое значение.
    :return: True, если значение является окном, иначе False.
    """
    return value and value == getattr(value, 'window', None)

def is_jq_lite(value: Any) -> bool:
    """
    Проверяет, является ли значение объектом jqLite.

    :param value: Проверяемое значение.
    :return: True, если значение является jqLite, иначе False.
    """
    return  value and callable(getattr(value, '$evalAsync', None)) and callable(getattr(value, '$watch', None))

def is_boolean(value: Any) -> bool:
    """
    Проверяет, является ли значение булевым.

    :param value: Проверяемое значение.
    :return: True, если значение булево, иначе False.
    """
    return isinstance(value, bool)

def is_typed_array(value: Any) -> bool:
   """
   Проверяет, является ли значение массивом байтов.
   
   :param value: Значение для проверки.
   :return: True, если значение является массивом байтов, False в противном случае.
   """
   return value and isinstance(getattr(value, 'length', None),int) and  re.match(r'^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$', str(value))

def is_element(value: Any) -> bool:
  """
  Проверяет, является ли значение элементом DOM или JQuery.

  :param value: Значение для проверки.
  :return: True, если значение является элементом, иначе False.
  """
  return bool(value and (getattr(value,'nodeName', None) or (getattr(value,'prop', None) and getattr(value,'attr', None) and getattr(value,'find', None))))

def create_hash_map(keys: str) -> dict:
    """
    Создает хеш-карту из строки, разделенной запятыми.

    :param keys: Строка с ключами, разделёнными запятыми.
    :return: Словарь с ключами из строки и значениями True.
    """
    keys_list = keys.split(',')
    return {key: True for key in keys_list}


def get_node_name(element: Any) -> str:
    """
    Получает имя узла элемента DOM или JQuery.

    :param element: Элемент DOM или JQuery.
    :return: Имя узла элемента в нижнем регистре.
    """
    if isinstance(element, (list, tuple)) and element and isinstance(element[0], (type(datetime.datetime.now()),type(None))):
      element = element[0]

    if  getattr(element, 'nodeName', None):
        return str(element.nodeName).lower()
    elif isinstance(element, dict) and  getattr(element.get(0,None), 'nodeName', None):
        return  str(element[0].nodeName).lower()
    return ""

def remove_element_from_array(array: list, element: Any) -> int:
    """
    Удаляет элемент из массива.

    :param array: Массив, из которого нужно удалить элемент.
    :param element: Элемент, который нужно удалить.
    :return: Индекс удалённого элемента или -1, если элемент не найден.
    """
    try:
        index = array.index(element)
        array.pop(index)
        return index
    except ValueError:
        return -1

def stringify_object_with_circular_reference(obj: Any, initial_depth: int = 0) -> Any:
    """
    Преобразует объект в строку JSON, обрабатывая циклические ссылки.

    :param obj: Объект для преобразования.
    :param initial_depth: Максимальная глубина.
    :return: Строку JSON или измененное значение.
    """
    def recursive_copy(obj, depth):
      """
      Рекурсивная функция для копирования объекта с циклическими ссылками.

      :param obj: Объект для обработки.
      :param depth: Текущая глубина рекурсии.
      :return: Копию объекта или "...".
      """
      if not is_object(obj):
          return obj
      
      if initial_depth is not None and  depth > initial_depth:
          return "..."
      
      if isinstance(obj,(type(datetime.datetime.now()), type(re.compile('')),type(None))):
         return str(obj)
    
      if obj in seen:
          return "..."
      seen.add(obj)
    
      new_obj = {} if isinstance(obj, dict) else []
      if isinstance(obj, dict):
         for key, value in obj.items():
           new_obj[key] = recursive_copy(value, depth + 1)
      elif is_array_like(obj):
          for i, value in enumerate(obj):
              new_obj.append(recursive_copy(value, depth + 1))

      if hasattr(obj,'$$hashKey'):
        new_obj['$$hashKey'] = obj.get('$$hashKey',None)
      return new_obj

    seen = set()
    try:
      return json.dumps(recursive_copy(obj, 0), default=str,ensure_ascii=False)
    except Exception as ex:
        logger.error(f'Ошибка при преобразовании объекта в JSON: {ex}')
        return "..."



def deep_copy(source: Any, target: Any = None, max_depth: Optional[int] = None) -> Any:
    """
    Выполняет глубокое копирование объекта, обрабатывая циклические ссылки.
    
    :param source: Объект для копирования.
    :param target: Целевой объект (если передан).
    :param max_depth: Максимальная глубина копирования.
    :return: Копию исходного объекта.
    """

    def copy_recursive(source: Any, target: Any, depth:int):
      """
        Рекурсивная функция для глубокого копирования объекта.
        
        :param source: Исходный объект.
        :param target: Целевой объект.
        :param depth: Текущая глубина рекурсии.
        :return: Скопированный объект или target, если source is None.
      """
      if not is_object(source):
          return source
      if max_depth and depth > max_depth:
          return "..."
      if source in seen:
           return target
    
      seen.add(source)
      if target is None:
         target = {} if isinstance(source, dict) else []
      if isinstance(source, dict):
         for key, value in source.items():
             if deep_copy and isinstance(value, dict):
                 if not isinstance(target.get(key),dict) :
                     target[key] = {}
                 copy_recursive(value,target[key],depth + 1)
             elif deep_copy and isinstance(value, list):
                 if not isinstance(target.get(key),list) :
                      target[key] = []
                 copy_recursive(value,target[key],depth + 1)
             else:
                target[key] = copy_recursive(value, None, depth+1)

      elif is_array_like(source):
           for key, value in enumerate(source):
              target.append(copy_recursive(value,None,depth + 1))

      if hasattr(source,'$$hashKey'):
           target['$$hashKey'] = source.get('$$hashKey', None)
      return target

    seen = set()
    if isinstance(target,list) and target:
        target.clear()
    elif isinstance(target,dict) and target:
        for k in list(target):
            target.pop(k)
    if target:
        target = copy_recursive(source, target,0)
    else:
        target = copy_recursive(source, None, 0)

    return target

def are_equal(a: Any, b: Any) -> bool:
    """
    Проверяет на равенство два значения.

    :param a: Первое значение.
    :param b: Второе значение.
    :return: True, если значения равны, иначе False.
    """
    if a is b:
       return True
    if not is_object(a) and not is_object(b):
       return a == b
    if a is None or b is None:
        return False
    if a != a and b != b:
        return True
    if type(a) != type(b):
        return False
    if isinstance(a, list):
        if len(a) != len(b):
           return False
        for index in range(len(a)):
           if not are_equal(a[index], b[index]):
               return False
        return True
    elif is_date(a):
        return is_date(b) and a.timestamp() == b.timestamp()
    elif is_regexp(a):
        return is_regexp(b) and str(a) == str(b)
    elif is_jq_lite(a) or is_jq_lite(b) or is_window(a) or is_window(b) or is_array(b) or is_date(b) or is_regexp(b):
        return False
    else:
        seen_a = set()
        for key in a:
            if key.startswith('$') or not callable(getattr(a, key, None)):
               if not are_equal(a[key], b.get(key,None)):
                  return False
               seen_a.add(key)
        for key in b:
            if key not in seen_a and key.startswith('$') or not callable(getattr(b, key, None)) and is_defined(b.get(key)):
                return False
        return True
    return False


def concat_arrays(target: list, *sources: list) -> list:
    """
    Объединяет несколько массивов в один новый массив.

    :param target: Целевой массив, в который будут добавлены элементы.
    :param sources: Массивы-источники для объединения.
    :return: Результирующий массив.
    """
    for source in sources:
      if source:
         if isinstance(source, list):
            target.extend(source)
         else:
           target.extend(list(source))
    return target


def apply_function(this_arg: Any, func: Callable, *args: Any) -> Any:
   """
   Применяет функцию к заданному this и аргументам.
   
   :param this_arg: Значение this.
   :param func: Функция для вызова.
   :param args: Аргументы.
   :return: Результат вызова функции.
   """
   if not callable(func):
      return func
   elif args:
       if callable(getattr(func, 'apply', None)):
        return func.apply(this_arg, args)
       else:
        return func(args)
   else:
      if callable(getattr(func, 'call', None)):
        return func.call(this_arg)
      else:
         return func()

def safe_stringify(value: Any, replacer: Optional[Callable] = None, space: Optional[Union[int, str]] = None) -> Optional[str]:
    """
    Безопасно преобразует значение в JSON-строку.

    :param value: Значение для преобразования.
    :param replacer: Функция, которая может преобразовать результат.
    :param space: Отступ для форматирования.
    :return: JSON-строка или None, если значение неопределено.
    """
    if is_undefined(value):
        return None
    return json.dumps(value, default=replacer, indent=space, ensure_ascii=False)

def safe_parse(value: str) -> Any:
    """
    Безопасно преобразует JSON-строку обратно в объект.

    :param value: JSON-строка.
    :return: Объект, полученный из JSON-строки.
    """
    if is_string(value):
        return j_loads(value)
    return value

def parse_time_offset(time_string: str, default_offset: int = 0) -> int:
    """
    Преобразует строку времени в смещение в минутах.

    :param time_string: Строка времени.
    :param default_offset: Значение по умолчанию, если не удалось распарсить.
    :return: Смещение в минутах.
    """
    time_string = re.sub(r':', '', time_string).replace(' ', '')
    time_match = re.search(r'(\d+)', time_string)
    if time_match:
      time =  int(time_match.group(1))
      return  (time // 100) * 60 + (time % 100)
    return default_offset


def add_minutes(date: datetime.datetime, minutes: int) -> datetime.datetime:
    """
    Добавляет минуты к объекту datetime.
    
    :param date: Объект datetime.
    :param minutes: Количество минут для добавления.
    :return: Новый объект datetime.
    """
    new_date = datetime.datetime.fromtimestamp(date.timestamp())
    return new_date + datetime.timedelta(minutes=minutes)

def apply_time_zone_offset(date: datetime.datetime, time_string: str, negative:bool = False) -> datetime.datetime:
     """
      Применяет смещение часового пояса к объекту datetime.
      :param date: Объект datetime.
      :param time_string: Строка смещения времени.
      :return: Новый объект datetime.
     """
     offset = date.utcoffset().total_seconds() / 60
     tz_offset = parse_time_offset(time_string, offset)
     if negative:
        tz_offset *= -1
     return add_minutes(date, (tz_offset - offset)*(-1 if negative else 1))

def get_first_tag(html: str) -> str:
    """
    Получает первый HTML-тег из строки.

    :param html: Строка HTML.
    :return: Первый HTML-тег.
    """
    try:
       element = BeautifulSoup(html, 'html.parser').body.contents[0]
       return "<" + str(element.name) + ">" if element.name  else str(element)
    except Exception as ex:
        return ""

def decode_uri_component(uri_component: str) -> str:
    """
    Декодирует URI-компонент.

    :param uri_component: URI-компонент.
    :return: Декодированный URI-компонент.
    """
    try:
        return unquote(uri_component)
    except Exception as ex:
        return ""


def parse_query_string(query_string: str) -> Dict:
   """
   Преобразует строку запроса в словарь.

   :param query_string: Строка запроса.
   :return: Словарь параметров запроса.
   """
   params = {}
   if not query_string:
     return params
   for item in query_string.split('&'):
      if item:
          try:
              name, value = item.split('=', 1)
              name = decode_uri_component(name.replace('+', '%20'))
              if value:
                  value = decode_uri_component(value.replace('+', '%20'))
              else:
                 value = True
              if name in params:
                   if isinstance(params[name], list):
                     params[name].append(value)
                   else:
                     params[name] = [params[name],value]
              else:
                  params[name] = value

          except Exception:
               name = item
               name = decode_uri_component(name.replace('+', '%20'))
               params[name] = True
   return params


def create_query_string(params: dict) -> str:
    """
    Создаёт строку запроса из словаря параметров.

    :param params: Словарь параметров.
    :return: Строка запроса.
    """
    if not params:
        return ""
    parts = []
    for key, value in params.items():
      encoded_key = urlencode(key, safe='@:$')
      if is_array(value):
         for v in value:
            encoded_value = urlencode(v, safe='@:$')
            parts.append(f'{encoded_key}={encoded_value}')
      else:
        encoded_value = urlencode(value, safe='@:$') if value is not True else ''
        parts.append(f'{encoded_key}{"=" + encoded_value if encoded_value  else "" }')

    return '&'.join(parts)


def encode_query_string(value: Any, as_query_param: bool = False) -> str:
   """
   Кодирует значение для использования в строке запроса.
   
   :param value: Значение.
   :param as_query_param: Флаг, определяющий способ кодирования пробелов.
   :return: Закодированная строка.
   """
   encoded = urlencode(str(