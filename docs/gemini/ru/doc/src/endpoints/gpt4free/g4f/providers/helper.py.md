# Модуль `helper.py`

## Обзор

Модуль `helper.py` содержит набор вспомогательных функций, используемых в проекте `hypotez`. Он включает функции для преобразования различных типов данных в строки, форматирования промптов для языковых моделей, генерации случайных строк и шестнадцатеричных значений, фильтрации `None` значений из словарей, конкатенации чанков данных и форматирования cookies.

## Подробнее

Этот модуль предоставляет инструменты для подготовки данных и форматирования запросов, которые необходимы для взаимодействия с различными API и сервисами, используемыми в проекте `hypotez`. Он также содержит функции для обработки и форматирования cookies.

## Функции

### `to_string`

```python
def to_string(value) -> str:
    """ Функция преобразует различные типы данных в строку.

    Args:
        value: Значение, которое необходимо преобразовать в строку.

    Returns:
        str: Строковое представление входного значения.
             Если `value` является словарем, содержащим ключ "name", возвращается пустая строка.
             Если `value` является словарем, содержащим ключ "bucket_id", читается содержимое bucket и возвращается в виде строки.
             Если `value` является словарем с type="text", возвращается значение ключа "text".
             Если `value` является списком, возвращается объединение строковых представлений элементов списка, у которых type="text".
             В остальных случаях возвращается строковое представление `value`.
    """
```

**Как работает функция**:

1.  **Проверка типа данных**: Определяется тип входного параметра `value`.
2.  **Обработка строки**: Если `value` является строкой, она возвращается без изменений.
3.  **Обработка словаря**:
    *   Если словарь содержит ключ `"name"`, возвращается пустая строка.
    *   Если словарь содержит ключ `"bucket_id"`, извлекается директория bucket и содержимое читается, после чего возвращается объединенная строка.
    *   Если словарь содержит ключ `"type"` со значением `"text"`, возвращается значение ключа `"text"`.
    *   В остальных случаях возвращается пустая строка.
4.  **Обработка списка**:
    *   Список итерируется, и каждый элемент, у которого `"type"` равен `"text"`, преобразуется в строку и объединяется в одну строку, которая затем возвращается.
5.  **Обработка других типов данных**: Если `value` не является строкой, словарем или списком, он преобразуется в строку с помощью `str(value)` и возвращается.

```
Тип данных value -> Проверка на строку -> Да: Возврат value
|                     -> Нет: Проверка на словарь -> Да: Проверка на "name" -> Да: Возврат ""
|                                                |                       -> Нет: Проверка на "bucket_id" -> Да: Чтение bucket -> Возврат содержимого
|                                                |                       -> Нет: Проверка на "type"="text" -> Да: Возврат text
|                                                |                       -> Нет: Возврат ""
|                     -> Нет: Проверка на список -> Да: Итерация списка, преобразование в строку элементов с type="text" -> Возврат объединенной строки
|                     -> Нет: Преобразование в строку с помощью str(value) -> Возврат строки
```

**Примеры**:

```python
>>> to_string("test")
'test'
>>> to_string({"name": "example"})
''
>>> to_string({"type": "text", "text": "hello"})
'hello'
```

### `format_prompt`

```python
def format_prompt(messages: Messages, add_special_tokens: bool = False, do_continue: bool = False, include_system: bool = True) -> str:
    """
    Форматирует серию сообщений в единую строку, с возможностью добавления специальных токенов.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.
        add_special_tokens (bool): Флаг, указывающий, следует ли добавлять специальные токены форматирования.
        do_continue (bool):  Если True, то не добавляет "Assistant:" в конце.
        include_system (bool): Флаг, указывающий, следует ли включать сообщения с ролью "system".

    Returns:
        str: Отформатированная строка, содержащая все сообщения.
    """
```

**Как работает функция**:

1.  **Проверка на необходимость добавления специальных токенов**: Если `add_special_tokens` равен `False` и количество сообщений меньше или равно 1, возвращается строковое представление содержимого первого сообщения.
2.  **Фильтрация сообщений**: Фильтруется список сообщений, чтобы исключить сообщения с ролью "system", если `include_system` равен `False`.
3.  **Форматирование сообщений**: Создается список кортежей, содержащих роль и содержимое каждого сообщения. Затем формируется строка, объединяющая все сообщения в формате `'{role.capitalize()}: {content}'`.
4.  **Возврат отформатированной строки**: Возвращается отформатированная строка. Если `do_continue` равен `False`, к строке добавляется `"\\nAssistant:"` в конце.

```
Проверка add_special_tokens и len(messages) -> Да: Возврат to_string(messages[0]["content"])
|
Нет: Фильтрация сообщений (исключение system, если include_system=False) -> Форматирование сообщений в строку '{role.capitalize()}: {content}' -> Возврат строки + "\\nAssistant:", если do_continue=False
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Hello"}]
>>> format_prompt(messages)
'User: Hello\nAssistant:'
>>> messages = [{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "Hi"}]
>>> format_prompt(messages, add_special_tokens=True)
'User: Hello\nAssistant: Hi\nAssistant:'
```

### `get_system_prompt`

```python
def get_system_prompt(messages: Messages) -> str:
    """
    Извлекает системные промпты из списка сообщений.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.

    Returns:
        str: Строка, содержащая все системные промпты, объединенные символом новой строки.
    """
```

**Как работает функция**:

1.  **Фильтрация системных сообщений**: Извлекаются все сообщения, у которых роль равна "system".
2.  **Объединение сообщений**: Содержимое каждого системного сообщения объединяется в одну строку с использованием символа новой строки в качестве разделителя.
3.  **Возврат результата**: Возвращается строка, содержащая объединенные системные промпты.

```
Фильтрация сообщений с role="system" -> Объединение содержимого сообщений через '\\n' -> Возврат строки
```

**Примеры**:

```python
>>> messages = [{"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "Hello"}]
>>> get_system_prompt(messages)
'You are a helpful assistant.'
```

### `get_last_user_message`

```python
def get_last_user_message(messages: Messages) -> str:
    """
    Извлекает последнее сообщение пользователя из списка сообщений.

    Args:
        messages (Messages): Список словарей сообщений, каждый из которых содержит 'role' и 'content'.

    Returns:
        str: Строка, содержащая последнее сообщение пользователя, или пустая строка, если сообщений от пользователя нет.
    """
```

**Как работает функция**:

1.  **Инициализация**: Создается копия списка сообщений и пустой список `user_messages`.
2.  **Поиск последнего сообщения пользователя**:
    *   Цикл `while` выполняется до тех пор, пока в списке сообщений есть элементы.
    *   Извлекается последнее сообщение из списка.
    *   Если роль сообщения равна `"user"`, его содержимое добавляется в список `user_messages`.
    *   Если роль сообщения не равна `"user"`, цикл завершается.
3.  **Объединение сообщений**: Содержимое всех сообщений пользователя объединяется в одну строку с использованием символа новой строки в качестве разделителя.
4.  **Возврат результата**: Возвращается строка, содержащая объединенные сообщения пользователя в обратном порядке (от последнего к первому).

```
Инициализация: user_messages = [], messages_copy = messages.copy() -> Цикл: извлечение последнего сообщения -> Проверка role == "user" -> Да: Добавление content в user_messages
                                                                    |                                                                -> Нет: Выход из цикла
-> Объединение user_messages через '\\n' -> Возврат строки
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "Hi"}, {"role": "user", "content": "How are you?"}]
>>> get_last_user_message(messages)
'How are you?'
>>> messages = [{"role": "assistant", "content": "Hi"}]
>>> get_last_user_message(messages)
''
```

### `format_image_prompt`

```python
def format_image_prompt(messages, prompt: str = None) -> str:
    """
    Форматирует промпт для генерации изображений.

    Args:
        messages: Список сообщений.
        prompt (str, optional): Промпт. Если `None`, используется последнее сообщение пользователя.

    Returns:
        str: Отформатированный промпт.
    """
```

**Как работает функция**:

1.  **Проверка наличия промпта**: Если `prompt` равен `None`, вызывается функция `get_last_user_message` для получения последнего сообщения пользователя.
2.  **Возврат результата**: Возвращается `prompt` или последнее сообщение пользователя, если `prompt` равен `None`.

```
Проверка prompt is None -> Да: get_last_user_message(messages) -> Возврат последнего сообщения пользователя
|                           -> Нет: Возврат prompt
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "Cat"}]
>>> format_image_prompt(messages)
'Cat'
>>> format_image_prompt(messages, prompt="Dog")
'Dog'
```

### `format_prompt_max_length`

```python
def format_prompt_max_length(messages: Messages, max_lenght: int) -> str:
    """
    Форматирует промпт, обрезая его до максимальной длины.

    Args:
        messages (Messages): Список сообщений.
        max_lenght (int): Максимальная длина промпта.

    Returns:
        str: Отформатированный и обрезанный промпт.
    """
```

**Как работает функция**:

1.  **Форматирование промпта**: Вызывается функция `format_prompt` для форматирования списка сообщений в промпт.
2.  **Проверка длины промпта**: Если длина промпта превышает `max_lenght`, предпринимаются попытки сократить промпт:
    *   Если количество сообщений больше 6, промпт формируется из первых трех и последних трех сообщений.
    *   Если длина нового промпта все еще превышает `max_lenght`, и количество сообщений больше 2, промпт формируется только из системных сообщений и последнего сообщения.
    *   Если длина промпта все еще превышает `max_lenght`, промптом становится содержимое последнего сообщения.
3.  **Логирование**: Логируется информация об усечении сообщения.
4.  **Возврат результата**: Возвращается отформатированный и, возможно, обрезанный промпт.

```
Форматирование промпта: prompt = format_prompt(messages) -> Проверка длины prompt > max_lenght -> Да: Проверка len(messages) > 6 -> Да: prompt = format_prompt(messages[:3] + messages[-3:])
                                                                                                  |                                                                         -> Нет: Проверка len(messages) > 2 -> Да: prompt = format_prompt([m for m in messages if m["role"] == "system"] + messages[-1:])
                                                                                                  |                                                                                                                         -> Нет: prompt = messages[-1]["content"]
                                                                                                  |   
                                                                                                  -> Логирование усечения -> Возврат prompt
                                                                                                  -> Нет: Возврат prompt
```

**Примеры**:

```python
>>> messages = [{"role": "user", "content": "This is a very long message."}]
>>> format_prompt_max_length(messages, 10)
'This is a very long message.'
```

### `get_random_string`

```python
def get_random_string(length: int = 10) -> str:
    """
    Генерирует случайную строку указанной длины, содержащую строчные буквы и цифры.

    Args:
        length (int, optional): Длина генерируемой случайной строки. По умолчанию 10.

    Returns:
        str: Случайная строка указанной длины.
    """
```

**Как работает функция**:

1.  **Генерация случайной строки**: Генерируется случайная строка путем выбора случайных символов из строчных букв и цифр `length` раз.
2.  **Возврат результата**: Возвращается сгенерированная случайная строка.

```
Генерация случайной строки из строчных букв и цифр длиной length -> Возврат строки
```

**Примеры**:

```python
>>> get_random_string(5)
'a1b2c'
```

### `get_random_hex`

```python
def get_random_hex(length: int = 32) -> str:
    """
    Генерирует случайную шестнадцатеричную строку длиной n.

    Returns:
        str: Случайная шестнадцатеричная строка из n символов.
    """
```

**Как работает функция**:

1.  **Генерация случайной шестнадцатеричной строки**: Генерируется случайная шестнадцатеричная строка путем выбора случайных символов из шестнадцатеричных цифр `length` раз.
2.  **Возврат результата**: Возвращается сгенерированная случайная шестнадцатеричная строка.

```
Генерация случайной шестнадцатеричной строки из шестнадцатеричных цифр длиной length -> Возврат строки
```

**Примеры**:

```python
>>> get_random_hex(5)
'a1b2c'
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением `None`.

    Args:
        **kwargs: Произвольные ключевые аргументы.

    Returns:
        dict: Отфильтрованный словарь, не содержащий элементов со значением `None`.
    """
```

**Как работает функция**:

1.  **Фильтрация словаря**: Создается новый словарь, содержащий только те элементы из `kwargs`, у которых значение не равно `None`.
2.  **Возврат результата**: Возвращается отфильтрованный словарь.

```
Фильтрация kwargs: удаление элементов со значением None -> Возврат отфильтрованного словаря
```

**Примеры**:

```python
>>> filter_none(a=1, b=None, c=2)
{'a': 1, 'c': 2}
```

### `async_concat_chunks`

```python
async def async_concat_chunks(chunks: AsyncIterator) -> str:
    """
    Асинхронно объединяет чанки данных в одну строку.

    Args:
        chunks (AsyncIterator): Асинхронный итератор чанков данных.

    Returns:
        str: Объединенная строка.
    """
```

**Как работает функция**:

1.  **Асинхронная конкатенация**: Асинхронно перебирает чанки в `chunks` и объединяет их в одну строку.
2.  **Возврат результата**: Возвращается объединенная строка.

```
Асинхронная итерация по chunks и объединение в строку -> Возврат объединенной строки
```

**Примеры**:

```python
# Пример использования требует асинхронного контекста
```

### `concat_chunks`

```python
def concat_chunks(chunks: Iterator) -> str:
    """
    Объединяет чанки данных в одну строку.

    Args:
        chunks (Iterator): Итератор чанков данных.

    Returns:
        str: Объединенная строка.
    """
```

**Как работает функция**:

1.  **Конкатенация**: Перебирает чанки в `chunks`, преобразует каждый чанк в строку и объединяет их в одну строку.
2.  **Фильтрация**: Исключает чанки, являющиеся исключениями или имеющие значение `None`.
3.  **Возврат результата**: Возвращается объединенная строка.

```
Итерация по chunks, преобразование в строку и объединение -> Фильтрация: исключение None и исключений -> Возврат объединенной строки
```

**Примеры**:

```python
>>> concat_chunks(["a", "b", "c"])
'abc'
```

### `format_cookies`

```python
def format_cookies(cookies: Cookies) -> str:
    """
    Форматирует словарь cookies в строку для отправки в HTTP-запросе.

    Args:
        cookies (Cookies): Словарь cookies.

    Returns:
        str: Строка, содержащая отформатированные cookies.
    """
```

**Как работает функция**:

1.  **Форматирование**: Преобразует каждый элемент словаря `cookies` в строку формата `"{k}={v}"` и объединяет их через `"; "`.
2.  **Возврат результата**: Возвращается отформатированная строка cookies.

```
Преобразование cookies в строку формата "{k}={v}" и объединение через "; " -> Возврат отформатированной строки
```

**Примеры**:

```python
>>> cookies = {"name": "value", "name2": "value2"}
>>> format_cookies(cookies)
'name=value; name2=value2'