# Анализ кода модуля `81_slots.ru.md`

**Качество кода**
- Соответствие требованиям к формату кода (1-10): 
    - **Преимущества**:
        - Документ хорошо структурирован и предоставляет подробное описание игры "Слоты".
        - Присутствует пошаговая инструкция для реализации игры, примеры работы и возможные ограничения.
        - Содержит рекомендации по улучшению и описание необходимых инструментов для реализации на Python.
    - **Недостатки**:
        - Файл представляет собой markdown-документ, а не код на Python, что не позволяет применить автоматические проверки кода и docstring.
        - Нет конкретного кода, который можно анализировать и улучшать.
        - Отсутствуют docstring, reStructuredText (RST) комментарии.
        - Не используются `j_loads` или `j_loads_ns`, так как нет работы с файлами JSON.
        - Нет использования `from src.logger.logger import logger` для регистрации ошибок, поскольку нет кода Python.

**Рекомендации по улучшению**

1.  **Преобразование в код Python:**
    - Реализовать описанный алгоритм игры в виде кода на Python.
    - Разделить код на функции и классы для лучшей читаемости и повторного использования.

2.  **Добавление docstring:**
    -  Написать docstring в формате RST для всех модулей, классов, методов и функций.
    -  Добавить комментарии `#` к каждому значительному шагу кода.

3.  **Использование логгера:**
    -  Использовать `from src.logger.logger import logger` для регистрации ошибок и отладочной информации.
    -  Избегать чрезмерного использования блоков try-except, предпочитая логгирование ошибок.

4.  **Обработка пользовательского ввода:**
    -  Добавить проверки на правильность ввода данных пользователем.
    -  Реализовать обработку исключений при вводе некорректных данных.

5.  **Улучшение алгоритма игры:**
    - Добавить возможность выбора разных видов ставок.
    - Реализовать графический интерфейс (GUI) для визуализации.
    - Добавить возможность игры с несколькими игроками.

**Улучшенный код**
```python
"""
Модуль для реализации игры "Слоты" (игровой автомат)
=====================================================

Этот модуль содержит класс `SlotsGame`, имитирующий работу игрового автомата.
Игрок делает ставки и вращает барабаны, чтобы получить выигрышные комбинации.

Пример использования:
--------------------

.. code-block:: python

    game = SlotsGame()
    game.start_game()
"""
import random
from src.logger.logger import logger  # Подключаем логгер для обработки ошибок


class SlotsGame:
    """
    Класс, реализующий логику игры "Слоты".

    :ivar symbols: Список символов, используемых в игре.
    :vartype symbols: list
    :ivar points: Количество очков у игрока.
    :vartype points: int
    :ivar bet: Сумма текущей ставки игрока.
    :vartype bet: int
    """

    def __init__(self):
        """
        Инициализирует игру с начальными значениями.
        """
        self.symbols = ['яблоко', 'банан', 'вишня', 'лимон', 'семёрка']  # Список возможных символов
        self.points = 100  # Начальное количество очков
        self.bet = 0  # Начальная ставка

    def display_welcome_message(self):
        """
        Выводит приветственное сообщение и правила игры.
        """
        print("Добро пожаловать в SLOTS!")
        print("Ваша задача — делать ставки и крутить барабаны, чтобы получить выигрышные комбинации.")
        print("Игра продолжается до тех пор, пока у вас есть очки для ставок.")
        print("Удачи!")

    def get_bet(self):
        """
        Получает ставку от игрока и проверяет её валидность.

        :raises ValueError: Если введена неверная ставка.
        """
        while True:
            try:
                bet = int(input(f"У вас {self.points} очков. Введите сумму ставки: "))
                if bet <= 0:  # Проверяем ставку на валидность
                     logger.error('Ставка должна быть положительной.')
                     print('Ставка должна быть положительной.')
                     continue
                if bet > self.points: # Проверяем, достаточно ли у игрока очков для ставки
                    logger.error(f'У вас недостаточно очков для этой ставки. Попробуйте снова. {bet=}, {self.points=}')
                    print("У вас недостаточно очков для этой ставки. Попробуйте снова.")
                else:
                    self.bet = bet # Устанавливаем ставку, если она валидна
                    print("Ставка принята.")
                    return
            except ValueError:
                logger.error('Неверный формат ставки, введите целое число.')
                print("Неверный формат ставки, введите целое число.")

    def spin_reels(self) -> list:
        """
        Выполняет вращение барабанов и возвращает случайные символы.

        :return: Список случайных символов.
        :rtype: list
        """
        reels = [random.choice(self.symbols) for _ in range(3)]
        print(f"Барабаны: {', '.join(reels)}")  # Выводим результат вращения барабанов
        return reels

    def calculate_result(self, reels: list) -> int:
        """
        Подсчитывает результат вращения барабанов и возвращает количество выигранных очков.

        :param reels: Список символов на барабанах.
        :type reels: list
        :return: Количество выигранных очков.
        :rtype: int
        """
        if len(set(reels)) == 1: # Проверяем, есть ли три одинаковых символа
             win_amount = self.bet * 10 # Начисляем 10 раз ставку за три одинаковых символа
             print(f"Вы выиграли {win_amount} очков!")
             return win_amount
        elif len(set(reels)) == 2 and (reels[0] == reels[1] or reels[0] == reels[2] or reels[1] == reels[2]):
             win_amount = self.bet * 5 # Начисляем 5 раз ставку за два одинаковых символа
             print(f"Вы выиграли {win_amount} очков!")
             return win_amount
        else:
            print(f"Вы проиграли {self.bet} очков.")
            return -self.bet # Возвращаем отрицательную ставку, если нет выигрыша

    def update_points(self, win_amount: int):
        """
        Обновляет количество очков игрока.

        :param win_amount: Количество очков, выигранных или проигранных.
        :type win_amount: int
        """
        self.points += win_amount # Обновляем количество очков игрока
        print(f"У вас теперь {self.points} очков.")

    def check_game_over(self) -> bool:
        """
        Проверяет, закончилась ли игра.

        :return: True, если игра закончилась, иначе False.
        :rtype: bool
        """
        if self.points <= 0:  # Проверяем, закончились ли очки у игрока
            print("Игра окончена! У вас 0 очков.")
            return True
        return False

    def play_again(self) -> bool:
        """
        Предлагает игроку сыграть ещё раз.

        :return: True, если игрок хочет сыграть ещё раз, иначе False.
        :rtype: bool
        """
        while True:
            choice = input("Хотите сыграть снова? (да/нет): ").lower()
            if choice in ["да", "нет"]:
                return choice == "да"
            else:
                logger.error("Неверный ввод, введите 'да' или 'нет'.")
                print("Неверный ввод, введите 'да' или 'нет'.")

    def start_game(self):
        """
        Запускает игру.
        """
        self.display_welcome_message() # Выводим приветственное сообщение
        while True:
            self.get_bet() # Получаем ставку от игрока
            reels = self.spin_reels()  # Крутим барабаны
            win_amount = self.calculate_result(reels) # Считаем выигрыш
            self.update_points(win_amount)  # Обновляем количество очков
            if self.check_game_over(): # Проверяем, закончилась ли игра
                break
            if not self.play_again(): # Предлагаем игроку сыграть еще раз
                 print("Спасибо за игру!")
                 break
            self.points = 100  # начинаем игру с начальным количеством очков если хотим играть еще
            print("Новая игра! У вас 100 очков")

if __name__ == "__main__":
    game = SlotsGame() # Создаем экземпляр класса игры
    game.start_game() # Запускаем игру
```