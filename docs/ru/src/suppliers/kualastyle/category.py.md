# Модуль `category`

## Обзор

Модуль `category` предназначен для сбора данных о товарах с сайта Kualastyle, начиная со страниц категорий. Он включает в себя функции для извлечения списка категорий и товаров, а также для навигации по страницам категорий.

## Подробней

Этот модуль является частью процесса сбора данных о товарах с сайта поставщика Kualastyle. Он использует веб-драйвер для навигации по сайту, извлечения информации о категориях и товарах, а также для обработки страниц категорий. Модуль предназначен для работы с категориями продуктов на сайте поставщика и обеспечивает функции для сбора списка категорий и товаров. Важной задачей является отслеживание изменений в категориях на сайте поставщика для поддержания актуальности данных.

## Функции

### `get_list_products_in_category`

```python
def get_list_products_in_category(s: Supplier) -> list[str, str, None]:
    """Returns list of products urls from category page
    Если надо пролистстать - страницы категорий - листаю ??????

    Attrs:
        s - Supplier
    @returns
        list or one of products urls or None
    """
    ...
```

**Назначение**: Извлекает список URL-адресов товаров со страницы категории. Функция также выполняет пролистывание страниц категорий, если это необходимо.

**Параметры**:
- `s` (Supplier): Объект поставщика, содержащий информацию о текущем сценарии, локаторы элементов и экземпляр веб-драйвера.

**Возвращает**:
- `list[str, str, None]`: Список URL-адресов товаров на странице категории. Может вернуть `None`, если список товаров не найден.

**Как работает функция**:

1.  **Инициализация драйвера и локаторов**: Извлекает экземпляр веб-драйвера и локаторы для работы со страницей категории из объекта поставщика `s`.
2.  **Ожидание и закрытие баннера**: Ожидает загрузки страницы в течение 1 секунды и пытается закрыть всплывающий баннер, если он отображается.
3.  **Прокрутка страницы**: Выполняет прокрутку страницы для загрузки всех элементов, которые могут быть скрыты при первоначальной загрузке.
4.  **Извлечение списка товаров**: Извлекает список веб-элементов, представляющих ссылки на товары, используя локатор `product_links`.
5.  **Обработка отсутствия товаров**: Если список товаров пуст, записывает предупреждение в журнал и возвращает `None`.
6.  **Пагинация**: Если на странице есть пагинация, функция итерируется по страницам, собирая ссылки на товары с каждой страницы.
7.  **Формирование результата**: Преобразует полученный список ссылок на товары в список URL-адресов.
8.  **Логирование**: Записывает отладочное сообщение в журнал, указывающее количество найденных товаров в текущей категории.

Внутри функции происходят следующие действия и преобразования:

*   **Инициализация**: Извлечение драйвера и локаторов из объекта поставщика.
*   **Ожидание и закрытие баннера**: Ожидание загрузки страницы и закрытие баннера (если есть).
*   **Прокрутка**: Прокрутка страницы для загрузки всех элементов.
*   **Извлечение ссылок**: Извлечение ссылок на товары с текущей страницы.
*   **Пагинация**: Переход на следующую страницу, если есть пагинация, и добавление новых ссылок на товары.
*   **Формирование списка**: Формирование единого списка ссылок на товары.

**Примеры**:

```python
from src.suppliers import Supplier
from unittest.mock import MagicMock

# Создаем мок объекта Supplier
supplier_mock = MagicMock(spec=Supplier)
supplier_mock.driver = MagicMock()
supplier_mock.locators = {
    'category': {
        'product_links': 'locator_to_product_links',
        'close_banner': 'locator_to_close_banner'
    },
    'product':{
        'close_banner': 'locator_to_close_banner'
    }
}
supplier_mock.current_scenario = {'name': 'Test Category'}
supplier_mock.driver.execute_locator.return_value = ['http://example.com/product1', 'http://example.com/product2']

# Вызываем функцию
product_list = get_list_products_in_category(supplier_mock)

# Проверяем результат
if product_list:
    print(f"Found products: {product_list}")
else:
    print("No products found.")
```

### `paginator`

```python
def paginator(d: Driver, locator: dict, list_products_in_category: list):
    """Листалка"""
    response = d.execute_locator(locator['pagination']['<-'])
    if not response or (isinstance(response, list) and len(response) == 0):
        ...
        return
    return True
```

**Назначение**: Функция `paginator` предназначена для навигации по страницам категорий с использованием механизма пагинации. Она определяет, есть ли следующая страница, и переходит на неё.

**Параметры**:

*   `d` (Driver): Экземпляр веб-драйвера, используемый для взаимодействия с веб-страницей.
*   `locator` (dict): Словарь, содержащий локаторы для элементов пагинации, таких как кнопка "следующая страница".
*   `list_products_in_category` (list): Список URL-адресов товаров в текущей категории.

**Возвращает**:

*   `True`: Если переход на следующую страницу выполнен успешно.
*   `None`: Если переход на следующую страницу невозможен (например, достигнута последняя страница).

**Как работает функция**:

1.  **Поиск элемента пагинации**: Функция пытается найти элемент управления пагинацией (например, кнопку "следующая страница") на веб-странице, используя локатор `locator['pagination']['<-']`.
2.  **Проверка наличия следующей страницы**: Если элемент управления пагинацией не найден или список элементов пагинации пуст, функция предполагает, что текущая страница является последней, и возвращает `None`.
3.  **Переход на следующую страницу**: Если элемент управления пагинацией найден, функция выполняет клик по нему, что приводит к переходу на следующую страницу.
4.  **Возврат результата**: Если переход на следующую страницу выполнен успешно, функция возвращает `True`.

Внутри функции происходят следующие действия и преобразования:

*   **Поиск элемента пагинации**: Используется метод `d.execute_locator` для поиска элемента управления пагинацией на странице.
*   **Проверка ответа**: Проверяется, был ли найден элемент управления пагинацией и не является ли список элементов пустым.
*   **Возврат результата**: Возвращается `True`, если пагинация прошла успешно, и `None` в противном случае.

**Примеры**:

```python
from unittest.mock import MagicMock
from src.webdriver.driver import Driver

# Создаем мок объекта Driver
driver_mock = MagicMock(spec=Driver)
driver_mock.execute_locator.return_value = True  # Имитируем успешный переход на следующую страницу

# Определяем локаторы
locators = {
    'pagination': {
        '<-': 'locator_for_next_page'
    }
}

# Список товаров
product_list = ['http://example.com/product1', 'http://example.com/product2']

# Вызываем функцию
result = paginator(driver_mock, locators, product_list)

# Проверяем результат
print(f"Pagination result: {result}")

# Pagination result: True
```

### `get_list_categories_from_site`

```python
def get_list_categories_from_site(s):
    """сборщик актуальных категорий с сайта"""
    ...
```

**Назначение**: Функция выполняет сбор актуальных категорий с сайта.

**Параметры**:
- `s`: Параметр не имеет аннотации типов. Предположительно, это объект, содержащий информацию о сайте для сбора данных.

**Возвращает**:
- Функция не имеет аннотации возвращаемого типа.

**Как работает функция**:
1.  Функция выполняет сбор актуальных категорий с сайта. Подробности реализации скрыты.

Внутри функции происходят следующие действия и преобразования:
*   Сбор категорий: <инструкция для модели gemini:Сбор категорий с сайта с использованием Selenium>

**Примеры**:

```python
from unittest.mock import MagicMock

# Mocking the 's' object and its attributes
s_mock = MagicMock()
# s_mock.method.return_value = ... # If 's' object has methods that return values, mock them

get_list_categories_from_site(s_mock)

# Since the function body is hidden, we can only test that the function runs without errors
# and that any mocked methods are called as expected.