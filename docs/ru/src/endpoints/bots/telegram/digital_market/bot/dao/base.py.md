# Модуль `base.py`

## Обзор

Модуль `base.py` предоставляет базовый класс `BaseDAO` для работы с базами данных в асинхронном режиме с использованием SQLAlchemy. Он включает в себя набор методов для выполнения основных операций CRUD (Create, Read, Update, Delete), а также методы для пагинации, подсчета количества записей и массового обновления.

## Подробней

Этот модуль предназначен для упрощения взаимодействия с базой данных и предоставляет абстракции для выполнения стандартных операций, таких как добавление, обновление, удаление и выборка данных. Он использует SQLAlchemy для работы с базой данных и `pydantic` для валидации данных. Логирование всех операций выполняется с помощью модуля `logger` из `src.logger`.

## Классы

### `BaseDAO`

**Описание**: Базовый класс для Data Access Object (DAO), предоставляющий методы для взаимодействия с базой данных. Этот класс является универсальным и может использоваться с любой моделью SQLAlchemy, наследующей `Base`.

**Принцип работы**:
Класс `BaseDAO` предоставляет набор асинхронных методов для выполнения операций CRUD с использованием SQLAlchemy. Он принимает модель SQLAlchemy в качестве параметра типа `T` и предоставляет методы для поиска, добавления, обновления и удаления записей в базе данных. Все методы логируют свои действия с использованием модуля `logger`.

**Методы**:

- `find_one_or_none_by_id(cls, data_id: int, session: AsyncSession)`: Находит запись по ID.
- `find_one_or_none(cls, session: AsyncSession, filters: BaseModel)`: Находит одну запись по фильтрам.
- `find_all(cls, session: AsyncSession, filters: BaseModel | None = None)`: Находит все записи по фильтрам.
- `add(cls, session: AsyncSession, values: BaseModel)`: Добавляет одну запись.
- `add_many(cls, session: AsyncSession, instances: List[BaseModel])`: Добавляет несколько записей.
- `update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel)`: Обновляет записи по фильтрам.
- `delete(cls, session: AsyncSession, filters: BaseModel)`: Удаляет записи по фильтру.
- `count(cls, session: AsyncSession, filters: BaseModel | None = None)`: Подсчитывает количество записей.
- `paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None)`: Выполняет пагинацию записей.
- `find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]`: Находит несколько записей по списку ID.
- `upsert(cls, session: AsyncSession, unique_fields: List[str], values: BaseModel)`: Создает запись или обновляет существующую.
- `bulk_update(cls, session: AsyncSession, records: List[BaseModel]) -> int`: Массовое обновление записей.

## Функции

### `find_one_or_none_by_id`

```python
@classmethod
async def find_one_or_none_by_id(cls, data_id: int, session: AsyncSession):
    """Найти запись по ID"""
```

**Назначение**: Поиск записи в базе данных по ее уникальному идентификатору.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `data_id` (int): Уникальный идентификатор записи, которую необходимо найти.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.

**Возвращает**:
- `record`: Объект модели, найденный в базе данных, или `None`, если запись с указанным `data_id` не найдена.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Логирование**: В начале работы функция логирует попытку поиска записи указанной модели с заданным `data_id`.
2. **Формирование запроса**: Строится SQL-запрос для выбора записи из таблицы, соответствующей модели `cls.model`, где поле `id` равно `data_id`.
3. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
4. **Обработка результата**: Извлекается единственный скалярный результат или `None`, если ничего не найдено.
5. **Логирование результата**: В зависимости от того, найдена ли запись, функция логирует соответствующее сообщение.
6. **Возврат значения**: Возвращается найденная запись или `None`.
7. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Логирование попытки поиска записи
↓
B: Формирование SQL-запроса для поиска записи по ID
↓
C: Асинхронное выполнение запроса
↓
D: Извлечение результата (запись или None)
↓
E: Логирование результата поиска
↓
F: Возврат найденной записи или None
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
user_id = 123
user = await BaseDAO[User].find_one_or_none_by_id(data_id=user_id, session=session)
if user:
    print(f"Найдена запись пользователя с ID {user_id}: {user}")
else:
    print(f"Запись пользователя с ID {user_id} не найдена")
```

### `find_one_or_none`

```python
@classmethod
async def find_one_or_none(cls, session: AsyncSession, filters: BaseModel):
    """Найти одну запись по фильтрам"""
```

**Назначение**: Поиск одной записи в базе данных, соответствующей заданным фильтрам.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для поиска записи.

**Возвращает**:
- `record`: Объект модели, найденный в базе данных, или `None`, если запись, соответствующая фильтрам, не найдена.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров**: Преобразует объект `filters` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку поиска одной записи указанной модели с заданными фильтрами.
3. **Формирование запроса**: Строится SQL-запрос для выбора записи из таблицы, соответствующей модели `cls.model`, с применением фильтров из полученного словаря.
4. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
5. **Обработка результата**: Извлекается единственный скалярный результат или `None`, если ничего не найдено.
6. **Логирование результата**: В зависимости от того, найдена ли запись, функция логирует соответствующее сообщение.
7. **Возврат значения**: Возвращается найденная запись или `None`.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Преобразование фильтров из BaseModel в словарь
↓
B: Логирование попытки поиска записи по фильтрам
↓
C: Формирование SQL-запроса с фильтрами
↓
D: Асинхронное выполнение запроса
↓
E: Извлечение результата (запись или None)
↓
F: Логирование результата поиска
↓
G: Возврат найденной записи или None
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str
    age: int

filters = UserFilter(name="John", age=30)
user = await BaseDAO[User].find_one_or_none(session=session, filters=filters)
if user:
    print(f"Найдена запись пользователя: {user}")
else:
    print("Запись пользователя не найдена")
```

### `find_all`

```python
@classmethod
async def find_all(cls, session: AsyncSession, filters: BaseModel | None = None):
    """Найти все записи по фильтрам"""
```

**Назначение**: Поиск всех записей в базе данных, соответствующих заданным фильтрам.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `filters` (BaseModel | None): Объект `BaseModel`, содержащий фильтры для поиска записей. Если `None`, возвращаются все записи.

**Возвращает**:
- `records`: Список объектов модели, найденных в базе данных.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров**: Если `filters` не `None`, преобразует объект `filters` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку поиска всех записей указанной модели с заданными фильтрами.
3. **Формирование запроса**: Строится SQL-запрос для выбора всех записей из таблицы, соответствующей модели `cls.model`, с применением фильтров из полученного словаря.
4. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
5. **Обработка результата**: Извлекаются все найденные записи.
6. **Логирование результата**: Логируется количество найденных записей.
7. **Возврат значения**: Возвращается список найденных записей.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Преобразование фильтров из BaseModel в словарь (если filters не None)
↓
B: Логирование попытки поиска всех записей по фильтрам
↓
C: Формирование SQL-запроса с фильтрами
↓
D: Асинхронное выполнение запроса
↓
E: Извлечение всех найденных записей
↓
F: Логирование количества найденных записей
↓
G: Возврат списка найденных записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    age_gt: int

filters = UserFilter(age_gt=25)
users = await BaseDAO[User].find_all(session=session, filters=filters)
print(f"Найдено {len(users)} пользователей старше 25 лет")
```

### `add`

```python
@classmethod
async def add(cls, session: AsyncSession, values: BaseModel):
    """Добавить одну запись"""
```

**Назначение**: Добавление новой записи в базу данных.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `values` (BaseModel): Объект `BaseModel`, содержащий значения для создания новой записи.

**Возвращает**:
- `new_instance`: Объект модели, представляющий добавленную запись.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование значений**: Преобразует объект `values` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку добавления записи указанной модели с заданными параметрами.
3. **Создание экземпляра модели**: Создает новый экземпляр модели `cls.model` с использованием значений из полученного словаря.
4. **Добавление в сессию**: Добавляет новый экземпляр в сессию SQLAlchemy.
5. **Применение изменений**: Пытается применить изменения к базе данных.
6. **Логирование успеха**: Логирует сообщение об успешном добавлении записи.
7. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, выполняет откат транзакции, логирует ошибку и перебрасывает исключение.
8. **Возврат значения**: Возвращает новый экземпляр модели.

```
A: Преобразование значений из BaseModel в словарь
↓
B: Логирование попытки добавления записи
↓
C: Создание экземпляра модели с использованием значений из словаря
↓
D: Добавление экземпляра в сессию SQLAlchemy
↓
E: Попытка применения изменений к базе данных
↓
F: Логирование успеха
↓
G: Возврат нового экземпляра модели
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserCreate(BaseModel):
    name: str
    age: int

user_data = UserCreate(name="Alice", age=28)
new_user = await BaseDAO[User].add(session=session, values=user_data)
print(f"Добавлен новый пользователь: {new_user}")
```

### `add_many`

```python
@classmethod
async def add_many(cls, session: AsyncSession, instances: List[BaseModel]):
    """Добавить несколько записей"""
```

**Назначение**: Добавление нескольких записей в базу данных за один раз.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `instances` (List[BaseModel]): Список объектов `BaseModel`, содержащих значения для создания новых записей.

**Возвращает**:
- `new_instances`: Список объектов модели, представляющих добавленные записи.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование значений**: Преобразует каждый объект `BaseModel` в списке `instances` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку добавления нескольких записей указанной модели.
3. **Создание экземпляров моделей**: Создает новые экземпляры модели `cls.model` для каждого словаря значений.
4. **Добавление в сессию**: Добавляет все новые экземпляры в сессию SQLAlchemy.
5. **Применение изменений**: Пытается применить изменения к базе данных.
6. **Логирование успеха**: Логирует сообщение об успешном добавлении записей.
7. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, выполняет откат транзакции, логирует ошибку и перебрасывает исключение.
8. **Возврат значения**: Возвращает список новых экземпляров моделей.

```
A: Преобразование значений из BaseModel в словарь для каждого элемента списка
↓
B: Логирование попытки добавления нескольких записей
↓
C: Создание экземпляров моделей для каждого словаря значений
↓
D: Добавление экземпляров в сессию SQLAlchemy
↓
E: Попытка применения изменений к базе данных
↓
F: Логирование успеха
↓
G: Возврат списка новых экземпляров моделей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel
from typing import List

class UserCreate(BaseModel):
    name: str
    age: int

users_data = [
    UserCreate(name="Alice", age=28),
    UserCreate(name="Bob", age=32),
    UserCreate(name="Charlie", age=24)
]
new_users = await BaseDAO[User].add_many(session=session, instances=users_data)
print(f"Добавлено {len(new_users)} новых пользователей")
```

### `update`

```python
@classmethod
async def update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel):
    """Обновить записи по фильтрам"""
```

**Назначение**: Обновление существующих записей в базе данных на основе заданных фильтров.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для выбора записей для обновления.
- `values` (BaseModel): Объект `BaseModel`, содержащий значения для обновления записей.

**Возвращает**:
- `result.rowcount` (int): Количество обновленных записей.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров и значений**: Преобразует объекты `filters` и `values` в словари, исключая неустановленные значения.
2. **Логирование**: Логирует попытку обновления записей указанной модели с заданными фильтрами и параметрами.
3. **Формирование запроса**: Строит SQL-запрос для обновления записей в таблице, соответствующей модели `cls.model`, с применением фильтров и новых значений.
4. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
5. **Применение изменений**: Пытается применить изменения к базе данных.
6. **Логирование результата**: Логирует количество обновленных записей.
7. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, выполняет откат транзакции, логирует ошибку и перебрасывает исключение.
8. **Возврат значения**: Возвращает количество обновленных записей.

```
A: Преобразование фильтров и значений из BaseModel в словари
↓
B: Логирование попытки обновления записей
↓
C: Формирование SQL-запроса для обновления записей
↓
D: Асинхронное выполнение запроса
↓
E: Попытка применения изменений к базе данных
↓
F: Логирование количества обновленных записей
↓
G: Возврат количества обновленных записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str

class UserUpdate(BaseModel):
    age: int

filters = UserFilter(name="Alice")
update_data = UserUpdate(age=29)
updated_count = await BaseDAO[User].update(session=session, filters=filters, values=update_data)
print(f"Обновлено {updated_count} записей")
```

### `delete`

```python
@classmethod
async def delete(cls, session: AsyncSession, filters: BaseModel):
    """Удалить записи по фильтру"""
```

**Назначение**: Удаление записей из базы данных на основе заданных фильтров.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `filters` (BaseModel): Объект `BaseModel`, содержащий фильтры для выбора записей для удаления.

**Возвращает**:
- `result.rowcount` (int): Количество удаленных записей.

**Вызывает исключения**:
- `ValueError`: Если не указаны фильтры для удаления.
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров**: Преобразует объект `filters` в словарь, исключая неустановленные значения.
2. **Проверка наличия фильтров**: Проверяет, что указан хотя бы один фильтр для удаления.
3. **Логирование**: Логирует попытку удаления записей указанной модели с заданными фильтрами.
4. **Формирование запроса**: Строит SQL-запрос для удаления записей из таблицы, соответствующей модели `cls.model`, с применением фильтров.
5. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
6. **Применение изменений**: Пытается применить изменения к базе данных.
7. **Логирование результата**: Логирует количество удаленных записей.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, выполняет откат транзакции, логирует ошибку и перебрасывает исключение. Если не указаны фильтры, вызывает исключение `ValueError`.
9. **Возврат значения**: Возвращает количество удаленных записей.

```
A: Преобразование фильтров из BaseModel в словарь
↓
B: Проверка наличия фильтров
↓
C: Логирование попытки удаления записей
↓
D: Формирование SQL-запроса для удаления записей
↓
E: Асинхронное выполнение запроса
↓
F: Попытка применения изменений к базе данных
↓
G: Логирование количества удаленных записей
↓
H: Возврат количества удаленных записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    name: str

filters = UserFilter(name="Alice")
deleted_count = await BaseDAO[User].delete(session=session, filters=filters)
print(f"Удалено {deleted_count} записей")
```

### `count`

```python
@classmethod
async def count(cls, session: AsyncSession, filters: BaseModel | None = None):
    """Подсчитать количество записей"""
```

**Назначение**: Подсчет количества записей в базе данных, соответствующих заданным фильтрам.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `filters` (BaseModel | None): Объект `BaseModel`, содержащий фильтры для выбора записей для подсчета. Если `None`, подсчитываются все записи.

**Возвращает**:
- `count` (int): Количество записей, соответствующих фильтрам.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров**: Если `filters` не `None`, преобразует объект `filters` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку подсчета количества записей указанной модели с заданными фильтрами.
3. **Формирование запроса**: Строит SQL-запрос для подсчета количества записей в таблице, соответствующей модели `cls.model`, с применением фильтров.
4. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
5. **Обработка результата**: Извлекает результат подсчета.
6. **Логирование результата**: Логирует количество найденных записей.
7. **Возврат значения**: Возвращает количество записей.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Преобразование фильтров из BaseModel в словарь (если filters не None)
↓
B: Логирование попытки подсчета количества записей
↓
C: Формирование SQL-запроса для подсчета записей
↓
D: Асинхронное выполнение запроса
↓
E: Извлечение результата подсчета
↓
F: Логирование количества найденных записей
↓
G: Возврат количества записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    age_gt: int

filters = UserFilter(age_gt=25)
user_count = await BaseDAO[User].count(session=session, filters=filters)
print(f"Количество пользователей старше 25 лет: {user_count}")
```

### `paginate`

```python
@classmethod
async def paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None):
    """Пагинация записей"""
```

**Назначение**: Получение записей из базы данных с использованием пагинации.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `page` (int): Номер страницы для извлечения записей (по умолчанию 1).
- `page_size` (int): Количество записей на странице (по умолчанию 10).
- `filters` (BaseModel | None): Объект `BaseModel`, содержащий фильтры для выбора записей. Если `None`, возвращаются все записи.

**Возвращает**:
- `records` (List[Any]): Список записей, соответствующих фильтрам и находящихся на указанной странице.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование фильтров**: Если `filters` не `None`, преобразует объект `filters` в словарь, исключая неустановленные значения.
2. **Логирование**: Логирует попытку пагинации записей указанной модели с заданными фильтрами и параметрами страницы.
3. **Формирование запроса**: Строит SQL-запрос для выбора записей из таблицы, соответствующей модели `cls.model`, с применением фильтров и параметров пагинации (номер страницы и размер страницы).
4. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
5. **Обработка результата**: Извлекает записи, находящиеся на указанной странице.
6. **Логирование результата**: Логирует количество найденных записей на странице.
7. **Возврат значения**: Возвращает список записей.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Преобразование фильтров из BaseModel в словарь (если filters не None)
↓
B: Логирование попытки пагинации записей
↓
C: Формирование SQL-запроса для выбора записей с пагинацией
↓
D: Асинхронное выполнение запроса
↓
E: Извлечение записей, находящихся на указанной странице
↓
F: Логирование количества найденных записей на странице
↓
G: Возврат списка записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel

class UserFilter(BaseModel):
    age_gt: int

filters = UserFilter(age_gt=25)
page_number = 2
page_size = 10
users = await BaseDAO[User].paginate(session=session, page=page_number, page_size=page_size, filters=filters)
print(f"На странице {page_number} найдено {len(users)} пользователей старше 25 лет")
```

### `find_by_ids`

```python
@classmethod
async def find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]:
    """Найти несколько записей по списку ID"""
```

**Назначение**: Поиск нескольких записей в базе данных по списку их идентификаторов.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `ids` (List[int]): Список идентификаторов записей, которые необходимо найти.

**Возвращает**:
- `records` (List[Any]): Список объектов модели, найденных в базе данных.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Логирование**: Логирует попытку поиска записей указанной модели по списку ID.
2. **Формирование запроса**: Строит SQL-запрос для выбора записей из таблицы, соответствующей модели `cls.model`, где поле `id` находится в списке `ids`.
3. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
4. **Обработка результата**: Извлекаются все найденные записи.
5. **Логирование результата**: Логирует количество найденных записей по списку ID.
6. **Возврат значения**: Возвращается список найденных записей.
7. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, она логируется, и исключение перебрасывается для дальнейшей обработки.

```
A: Логирование попытки поиска записей по списку ID
↓
B: Формирование SQL-запроса для поиска записей по списку ID
↓
C: Асинхронное выполнение запроса
↓
D: Извлечение всех найденных записей
↓
E: Логирование количества найденных записей по списку ID
↓
F: Возврат списка найденных записей
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
user_ids = [1, 2, 3]
users = await BaseDAO[User].find_by_ids(session=session, ids=user_ids)
print(f"Найдено {len(users)} пользователей с ID: {user_ids}")
```

### `upsert`

```python
@classmethod
async def upsert(cls, session: AsyncSession, unique_fields: List[str], values: BaseModel):
    """Создать запись или обновить существующую"""
```

**Назначение**: Создание новой записи в базе данных или обновление существующей, если запись с указанными уникальными полями уже существует.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `unique_fields` (List[str]): Список уникальных полей, используемых для поиска существующей записи.
- `values` (BaseModel): Объект `BaseModel`, содержащий значения для создания или обновления записи.

**Возвращает**:
- `existing` или `new_instance`: Объект модели, представляющий обновленную или созданную запись.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Преобразование значений**: Преобразует объект `values` в словарь, исключая неустановленные значения.
2. **Формирование фильтров**: Создает словарь фильтров на основе уникальных полей и их значений.
3. **Логирование**: Логирует попытку выполнения операции upsert для указанной модели.
4. **Поиск существующей записи**: Пытается найти существующую запись по уникальным полям.
5. **Обновление существующей записи**: Если запись найдена, обновляет ее значения и применяет изменения к базе данных.
6. **Создание новой записи**: Если запись не найдена, создает новую запись и добавляет ее в базу данных.
7. **Логирование результата**: Логирует сообщение об обновлении или создании записи.
8. **Обработка ошибок**: В случае возникновения ошибки SQLAlchemy, выполняет откат транзакции, логирует ошибку и перебрасывает исключение.
9. **Возврат значения**: Возвращает обновленную или созданную запись.

```
A: Преобразование значений из BaseModel в словарь
↓
B: Формирование фильтров на основе уникальных полей
↓
C: Логирование попытки выполнения операции upsert
↓
D: Поиск существующей записи по уникальным полям
↓
E: Обновление существующей записи (если найдена) или создание новой записи (если не найдена)
↓
F: Логирование результата
↓
G: Возврат обновленной или созданной записи
```

**Примеры**:

```python
# Предположим, что существует модель User и асинхронная сессия session
from pydantic import BaseModel
from typing import List

class UserCreate(BaseModel):
    email: str
    name: str
    age: int

user_data = UserCreate(email="test@example.com", name="Test User", age=30)
unique_fields = ["email"]
user = await BaseDAO[User].upsert(session=session, unique_fields=unique_fields, values=user_data)
print(f"Выполнена операция upsert для пользователя: {user}")
```

### `bulk_update`

```python
@classmethod
async def bulk_update(cls, session: AsyncSession, records: List[BaseModel]) -> int:
    """Массовое обновление записей"""
```

**Назначение**: Массовое обновление записей в базе данных.

**Параметры**:
- `cls`: Ссылка на класс `BaseDAO`.
- `session` (AsyncSession): Асинхронная сессия SQLAlchemy для выполнения операций с базой данных.
- `records` (List[BaseModel]): Список объектов `BaseModel`, содержащих значения для обновления записей. Каждый объект должен содержать поле `id` для идентификации записи.

**Возвращает**:
- `updated_count` (int): Количество обновленных записей.

**Вызывает исключения**:
- `SQLAlchemyError`: Если возникает ошибка при выполнении запроса к базе данных.

**Как работает функция**:

1. **Логирование**: Логирует попытку массового обновления записей указанной модели.
2. **Итерация по записям**: Перебирает записи в списке `records`.
3. **Преобразование записи в словарь**: Преобразует каждую запись в словарь, исключая неустановленные значения.
4. **Проверка наличия ID**: Проверяет, что запись содержит поле `id`. Если поле отсутствует, переходит к следующей записи.
5. **Формирование запроса на обновление**: Строит SQL-запрос для обновления записи с указанным `id` и новыми значениями.
6. **Выполнение запроса**: Асинхронно выполняется запрос к базе данных с использованием предоставленной сессии.
7. **Подсчет обновленных записей**: Увеличивает счетчик обновленных записей на количество записей, обновленных текущим запросом.
8. **Применение изменений**: П