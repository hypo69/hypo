## <алгоритм>

### Класс `Simulation`
1. **Инициализация (`__init__`)**:
   - Создает экземпляр симуляции с заданным `id` (по умолчанию "default").
   - Инициализирует пустые списки для агентов (`agents`), сред (`environments`) и фабрик (`factories`).
   - Создает словари для быстрого доступа к агентам, средам и фабрикам по их именам (`name_to_agent`, `name_to_environment`, `name_to_factory`).
   - Устанавливает начальный статус симуляции как "stopped" (`STATUS_STOPPED`).
   - Определяет путь к файлу кэша (`cache_path`) на основе `id`.
   - Устанавливает флаги для автоматического сохранения (`auto_checkpoint`) и наличия несохраненных изменений кэша (`has_unsaved_cache_changes`).
   - Инициализирует флаг, указывающий на нахождение в транзакции (`_under_transaction`).
   - Инициализирует пустые списки для кэшированного (`cached_trace`) и текущего (`execution_trace`) состояний симуляции.
   - **Пример**: `sim = Simulation(id="test_sim")`

2. **Начало симуляции (`begin`)**:
   - Проверяет, что симуляция остановлена, и переводит ее в статус "started".
   - Устанавливает путь к файлу кэша, если указан.
   - Устанавливает флаг автоматического сохранения.
   - Очищает старые данные об агентах, средах и фабриках, используя статические методы `clear_agents`, `clear_environments`, `clear_factories` из соответствующих классов.
   - Сбрасывает счетчик автоматических id в `utils._fresh_id_counter` в 0.
   - Загружает кэш из файла, если `cache_path` указан, вызывая `_load_cache_file`.
   - **Пример**: `sim.begin(cache_path="./test_cache.json", auto_checkpoint=True)`

3. **Завершение симуляции (`end`)**:
   - Проверяет, что симуляция запущена, и переводит ее в статус "stopped".
   - Сохраняет текущее состояние симуляции, вызывая `checkpoint`.
   - **Пример**: `sim.end()`

4. **Сохранение состояния (`checkpoint`)**:
   - Если есть несохраненные изменения кэша, сохраняет их в файл, вызывая `_save_cache_file`.
   - **Пример**: `sim.checkpoint()`

5. **Добавление агента (`add_agent`)**:
   - Проверяет уникальность имени агента.
   - Устанавливает `simulation_id` агента.
   - Добавляет агента в список `agents` и словарь `name_to_agent`.
   - **Пример**: `sim.add_agent(agent)`

6. **Добавление среды (`add_environment`)**:
   - Проверяет уникальность имени среды.
   - Устанавливает `simulation_id` среды.
   - Добавляет среду в список `environments` и словарь `name_to_environment`.
   - **Пример**: `sim.add_environment(env)`

7. **Добавление фабрики (`add_factory`)**:
   - Проверяет уникальность имени фабрики.
   - Устанавливает `simulation_id` фабрики.
   - Добавляет фабрику в список `factories` и словарь `name_to_factory`.
    - **Пример**: `sim.add_factory(factory)`
    
8. **Управление кэшем и цепочкой выполнения**:
    - `_execution_trace_position`: Возвращает текущую позицию в `execution_trace`.
    - `_function_call_hash`: Вычисляет хеш вызова функции.
    - `_skip_execution_with_cache`: Пропускает выполнение, если есть кэшированное состояние.
    - `_is_transaction_event_cached`: Проверяет, совпадает ли хеш события с кэшированным.
    - `_drop_cached_trace_suffix`: Удаляет кэшированные записи после текущей позиции.
    - `_add_to_execution_trace`: Добавляет состояние в `execution_trace`.
    - `_add_to_cache_trace`: Добавляет состояние в `cached_trace`.
    - `_load_cache_file`: Загружает кэш из файла.
    - `_save_cache_file`: Сохраняет кэш в файл.
    
9. **Управление транзакциями**:
    - `begin_transaction`: Начинает транзакцию, устанавливая флаг `_under_transaction` и очищает буферы сообщений.
    - `end_transaction`: Завершает транзакцию, сбрасывая флаг `_under_transaction`.
    - `is_under_transaction`: Проверяет, находится ли симуляция внутри транзакции.
    - `_clear_communications_buffers`: Очищает буферы сообщений агентов и сред.
   
10. **Кодирование/декодирование состояния**:
    - `_encode_simulation_state`: Кодирует состояние симуляции (агентов, сред и т.д.) в словарь.
    - `_decode_simulation_state`: Декодирует состояние симуляции из словаря.
    
### Класс `Transaction`
1. **Инициализация (`__init__`)**:
   - Принимает объект под транзакцией (`obj_under_transaction`), объект симуляции (`simulation`), функцию (`function`), аргументы (`*args`) и именованные аргументы (`**kwargs`).
   - Сохраняет имя функции, функцию, аргументы и именованные аргументы.
   - Проверяет, привязана ли транзакция к симуляции, если да, то проверяет, соответствует ли идентификатор симуляции объекта идентификатору симуляции транзакции.
   - Если объект не привязан к симуляции, добавляет его в симуляцию (агента, среду или фабрику).
    - **Пример**: `trans = Transaction(agent, sim, agent.move, x=1, y=2)`

2. **Выполнение (`execute`)**:
   - Если симуляция не запущена, выполняет функцию и возвращает результат.
   - Если симуляция запущена, вычисляет хеш вызова функции.
   - Если хеш есть в кэше, восстанавливает состояние симуляции из кэша и возвращает кэшированный результат.
   - Если хеша нет в кэше:
     - Начинает транзакцию, если ее нет (`begin_transaction`).
     - Удаляет кэшированный след с текущей позиции.
     - Выполняет функцию, сохраняет результат, кодирует состояние симуляции, добавляет в `cached_trace` и `execution_trace`.
     - Завершает транзакцию (`end_transaction`).
   - Вызывает `checkpoint` если `auto_checkpoint` установлен.
     - **Пример**: `result = trans.execute()`

3. **Кодирование/декодирование вывода функции**:
    - `_encode_function_output`: Кодирует вывод функции для кэширования (ссылки на `TinyPerson`, `TinyWorld`, `TinyFactory`, или JSON-совместимые типы).
    - `_decode_function_output`: Декодирует кэшированный вывод функции.
  
### Декоратор `transactional`
- Оборачивает функцию, создавая экземпляр `Transaction` и вызывая его метод `execute` для выполнения.
 - **Пример**:
   ```python
     @transactional
     def move(self, x, y):
         self.x += x
         self.y += y
   ```

### Функции управления симуляцией
1.  **Сброс состояния (`reset`)**:
    - Сбрасывает глобальные переменные `_current_simulations` и `_current_simulation_id`, инициализируя их для новой симуляции.
    
2.  **Получение симуляции (`_simulation`)**:
    - Возвращает объект симуляции по `id`, создавая его если нет.

3.  **Начало симуляции (`begin`)**:
    - Запускает симуляцию через метод `begin` класса `Simulation`, устанавливая `_current_simulation_id`.
    
4.  **Конец симуляции (`end`)**:
    - Завершает симуляцию через метод `end` класса `Simulation`, сбрасывая `_current_simulation_id`.
    
5.  **Сохранение состояния (`checkpoint`)**:
    - Сохраняет состояние симуляции через метод `checkpoint` класса `Simulation`.

6.  **Получение текущей симуляции (`current_simulation`)**:
    - Возвращает текущую запущенную симуляцию.
    
### Цепочка вызовов

1. Пользователь вызывает `begin` для начала симуляции, которая создает экземпляр `Simulation` и загружает данные из кэша.
2.  При вызове функции, помеченной декоратором `@transactional`, вызывается класс `Transaction` и его метод `execute`.
3. `Transaction.execute` проверяет, существует ли кэшированное состояние. Если нет, функция выполняется, а результат и состояние кэшируются.
4.  При вызове `checkpoint` кэш сохраняется в файл.
5.  При вызове `end` симуляция завершается и кэш сохраняется.

## <mermaid>

```mermaid
flowchart TD
    subgraph Simulation Class
        A[__init__] --> B[begin]
        B --> C[clear_agents/clear_environments/clear_factories]
        C --> D[_load_cache_file]
        D --> E[status=started]
        E --> F[add_agent/add_environment/add_factory]
        F --> G[_execution_trace_position]
        G --> H[_function_call_hash]
        H --> I[_skip_execution_with_cache]
         I -->J[_is_transaction_event_cached]
         J -->K[_drop_cached_trace_suffix]
         K -->L[_add_to_execution_trace]
         L -->M[_add_to_cache_trace]
         M -->N[_load_cache_file]
         N -->O[_save_cache_file]
         O -->P[begin_transaction]
         P -->Q[end_transaction]
         Q -->R[_clear_communications_buffers]
         R -->S[_encode_simulation_state]
         S -->T[_decode_simulation_state]
         T -->U[checkpoint]
        U -->V[end]
    end
    
    subgraph Transaction Class
       W[__init__] --> X[execute]
         X --> Y[_is_transaction_event_cached]
         Y -- Cached --> Z[_skip_execution_with_cache]
         Z --> AA[_decode_simulation_state]
         AA --> AB[_decode_function_output]
         Y -- Not Cached --> AC[begin_transaction]
         AC --> AD[_drop_cached_trace_suffix]
         AD --> AE[function(*args, **kwargs)]
         AE --> AF[_encode_function_output]
         AF --> AG[_encode_simulation_state]
         AG --> AH[_add_to_cache_trace]
          AH --> AI[_add_to_execution_trace]
           AI --> AJ[end_transaction]
         AJ --> AK[checkpoint]
    end

    subgraph Transactional Decorator
       AL[transactional] --> AM[wrapper]
        AM --> AN[Transaction.__init__]
        AN --> AO[Transaction.execute]
    end
    
     subgraph Control Functions
      AP[reset]
      AQ[_simulation]
      AR[begin]
      AS[end]
      AT[checkpoint]
      AU[current_simulation]
     end
    
    AO --> AK
    AK --> AT
    
   
    style A fill:#f9f,stroke:#333,stroke-width:2px
     style W fill:#ccf,stroke:#333,stroke-width:2px
     style AL fill:#cfc,stroke:#333,stroke-width:2px
     style AP fill:#ffc,stroke:#333,stroke-width:2px

```
### Зависимости `mermaid`

Диаграмма `mermaid` отображает основные классы и функции, связанные с управлением симуляцией, а также их взаимосвязи и порядок вызова. 

1. **`Simulation Class`**: Описывает жизненный цикл симуляции, начиная с инициализации (`__init__`) и заканчивая завершением (`end`). Включает в себя:
   - `__init__`: Инициализирует объект симуляции.
   - `begin`: Запускает симуляцию, загружает кэш, очищает данные.
   - `clear_agents/clear_environments/clear_factories`:  Очищает списки агентов, окружений и фабрик, подготавливая их к симуляции.
   - `_load_cache_file`: Загружает данные из файла кэша.
   - `status=started`: Устанавливает статус симуляции как "запущена".
   - `add_agent/add_environment/add_factory`: Добавляет агентов, окружения и фабрики в симуляцию.
   - `_execution_trace_position`: Получает текущую позицию в цепочке выполнения.
   - `_function_call_hash`: Вычисляет хэш вызова функции.
   - `_skip_execution_with_cache`: Пропускает выполнение если есть кэш.
   - `_is_transaction_event_cached`: Проверяет есть ли событие в кэше.
   - `_drop_cached_trace_suffix`: Удаляет кэш после текущей позиции.
   - `_add_to_execution_trace`: Добавляет состояние в цепочку выполнения.
   - `_add_to_cache_trace`: Добавляет состояние в кэш.
   - `_load_cache_file`: Загружает данные кэша из файла.
   - `_save_cache_file`: Сохраняет данные кэша в файл.
   - `begin_transaction`: Начинает транзакцию.
   - `end_transaction`: Завершает транзакцию.
   - `_clear_communications_buffers`: Очищает буферы обмена данными.
   - `_encode_simulation_state`: Кодирует состояние симуляции.
   - `_decode_simulation_state`: Декодирует состояние симуляции.
   - `checkpoint`: Сохраняет состояние симуляции.
   - `end`: Завершает симуляцию.
   

2. **`Transaction Class`**: Класс, инкапсулирующий логику транзакций и кэширования вызовов функций. Включает в себя:
   - `__init__`: Инициализирует транзакцию.
   - `execute`: Выполняет функцию и управляет кэшированием.
   - `_is_transaction_event_cached`: Проверяет есть ли событие в кэше.
    - `_skip_execution_with_cache`: Пропускает выполнение, если есть кэшированная версия.
    - `_decode_simulation_state`: Декодирует состояние симуляции из кэша.
    - `_decode_function_output`: Декодирует результат функции из кэша.
    - `begin_transaction`: Начинает транзакцию.
    - `_drop_cached_trace_suffix`: Удаляет кэш после текущей позиции.
    - `function(*args, **kwargs)`: Выполняет функцию.
    - `_encode_function_output`: Кодирует результат функции для кэширования.
    - `_encode_simulation_state`: Кодирует текущее состояние симуляции.
    - `_add_to_cache_trace`: Добавляет состояние в кэш.
    - `_add_to_execution_trace`: Добавляет состояние в цепочку выполнения.
     - `end_transaction`: Завершает транзакцию.
    - `checkpoint`: Сохраняет состояние симуляции.

3. **`Transactional Decorator`**: Декоратор, преобразующий функции в транзакционные. Включает в себя:
   - `transactional`: Декоратор.
   - `wrapper`: Функция-обертка, создающая и выполняющая транзакцию.
   - `Transaction.__init__`: Инициализация транзакции.
   - `Transaction.execute`: Выполнение транзакции.

4. **`Control Functions`**: Функции для управления жизненным циклом симуляции. Включают в себя:
    - `reset`: Сбрасывает состояние симуляции.
    - `_simulation`: Возвращает текущую симуляцию.
    - `begin`: Начинает симуляцию.
    - `end`: Завершает симуляцию.
    - `checkpoint`: Сохраняет состояние симуляции.
    - `current_simulation`: Возвращает текущую активную симуляцию.

**Связи**:
- **Вызовы внутри классов**: Внутри классов `Simulation` и `Transaction` показаны вызовы методов, что отражает внутренний поток выполнения.
- **Декоратор**: Декоратор `transactional` инициирует создание и выполнение транзакции через `Transaction.__init__` и `Transaction.execute`.
- **Связь с функциями управления**: Транзакции используют методы класса `Simulation`, и управляются внешними функциями, такими как `begin`, `end` и `checkpoint`.

## <объяснение>

### Импорты
- `json`: Используется для работы с JSON-форматом, в основном для сохранения и загрузки кэша симуляции в файл.
- `os`: Предоставляет интерфейс для взаимодействия с операционной системой, используется в основном для работы с файлами и каталогами, например, для замены файлов при сохранении кэша.
- `tempfile`: Используется для создания временных файлов, что необходимо для безопасного сохранения кэша, чтобы избежать потери данных при сбое сохранения.
- `tinytroupe`: Базовый пакет, в котором находится данный модуль.
- `tinytroupe.utils as utils`: Содержит утилиты, используемые в проекте, такие как функция `custom_hash`, которая необходима для вычисления хешей состояний.
- `logging`: Используется для логирования событий симуляции.

### Класс `Simulation`
- **Роль**: Управляет жизненным циклом симуляции, включая начало, конец, сохранение состояния и добавление агентов, сред и фабрик.
- **Атрибуты**:
    - `id`: Уникальный идентификатор симуляции.
    - `agents`: Список агентов, участвующих в симуляции.
    - `name_to_agent`: Словарь, обеспечивающий быстрый доступ к агентам по их имени.
    - `environments`: Список сред, в которых происходят действия агентов.
    - `factories`: Список фабрик, которые могут создавать агентов или среды.
    - `name_to_environment`: Словарь для быстрого доступа к средам по их имени.
    - `name_to_factory`: Словарь для быстрого доступа к фабрикам по их имени.
    - `status`: Текущий статус симуляции (запущена или остановлена).
    - `cache_path`: Путь к файлу кэша.
    - `auto_checkpoint`: Флаг, указывающий на необходимость автоматического сохранения состояния после каждой транзакции.
    - `has_unsaved_cache_changes`: Флаг, указывающий на наличие несохраненных изменений в кэше.
    - `_under_transaction`: Флаг, указывающий, выполняется ли транзакция в данный момент.
    - `cached_trace`: Список состояний, сохраненных в кэше.
    - `execution_trace`: Список состояний, возникших при текущем выполнении симуляции.
- **Методы**:
    - `__init__`: Конструктор класса, инициализирует атрибуты объекта.
    - `begin`: Запускает симуляцию.
    - `end`: Завершает симуляцию.
    - `checkpoint`: Сохраняет текущее состояние симуляции в файл.
    - `add_agent`, `add_environment`, `add_factory`: Добавляют соответствующие объекты в симуляцию.
    - `_execution_trace_position`, `_function_call_hash`, `_skip_execution_with_cache`, `_is_transaction_event_cached`, `_drop_cached_trace_suffix`, `_add_to_execution_trace`, `_add_to_cache_trace`: Методы для управления цепочкой выполнения и кэширования.
    - `_load_cache_file`, `_save_cache_file`: Методы для загрузки и сохранения кэша симуляции в файл.
    - `begin_transaction`, `end_transaction`, `is_under_transaction`: Методы для управления транзакциями.
    - `_clear_communications_buffers`: Очищает буферы сообщений агентов и сред.
    - `_encode_simulation_state`, `_decode_simulation_state`: Методы для преобразования состояния симуляции в формат словаря и обратно.
- **Взаимодействие**: `Simulation` взаимодействует с классами `TinyPerson`, `TinyWorld`, `TinyFactory` для управления их состояниями, а также с классом `Transaction` для выполнения транзакционных операций.

### Класс `Transaction`
- **Роль**: Инкапсулирует выполнение транзакций, включая кэширование и восстановление состояния.
- **Атрибуты**:
    - `obj_under_transaction`: Объект, над которым выполняется транзакция.
    - `simulation`: Объект `Simulation`, к которому привязана транзакция.
    - `function_name`: Имя функции, которая выполняется в рамках транзакции.
    - `function`: Функция, которая выполняется в рамках транзакции.
    - `args`, `kwargs`: Аргументы и именованные аргументы функции.
- **Методы**:
    - `__init__`: Конструктор класса, инициализирует атрибуты объекта.
    - `execute`: Выполняет транзакцию, управляя кэшированием и восстановлением состояния.
    - `_encode_function_output`, `_decode_function_output`: Методы для кодирования и декодирования результата выполнения функции.
- **Взаимодействие**: `Transaction` взаимодействует с классом `Simulation` для доступа к кэшу, сохранению и восстановлению состояния симуляции, а также с декоратором `@transactional` для управления выполнением транзакций.

### Декоратор `@transactional`
- **Роль**: Преобразует обычные методы классов в транзакционные методы.
- **Функциональность**:
    - Оборачивает функцию, создавая экземпляр `Transaction`.
    - Вызывает метод `execute` экземпляра `Transaction`, обеспечивая кэширование и восстановление состояния.
    - Возвращает результат выполнения транзакции.
- **Взаимодействие**: `@transactional` используется для добавления логики управления транзакциями к методам классов, которые участвуют в симуляции.

### Функции управления симуляцией
- `reset()`: Сбрасывает глобальные переменные, используемые для управления симуляциями.
- `_simulation(id="default")`: Возвращает объект `Simulation` для указанного `id` (или создает новый, если такого нет).
- `begin(cache_path=None, id="default", auto_checkpoint=False)`: Запускает симуляцию, настраивая кэш и автоматические сохранения.
- `end(id="default")`: Завершает симуляцию.
- `checkpoint(id="default")`: Сохраняет текущее состояние симуляции.
- `current_simulation()`: Возвращает текущий активный объект `Simulation`.

### Переменные
- `_current_simulations`: Словарь, хранящий объекты `Simulation`, доступные по их `id`.
- `_current_simulation_id`: Текущий `id` запущенной симуляции.

### Потенциальные ошибки и области для улучшения
- **Обработка ошибок**: Могут возникать ошибки при загрузке/сохранении кэша.
- **Параллелизм**: В настоящее время код не поддерживает параллельное выполнение нескольких симуляций.
- **Сложность**: Код имеет сложную логику, особенно в части кэширования, которую можно упростить, выделив отдельные классы или функции для отдельных задач.
- **Расширяемость**: Добавление поддержки новых типов вывода функций может быть неудобным, поскольку это требует внесения изменений в метод `_encode_function_output` класса `Transaction`.
- **Проверка типов**: Отсутствует строгая проверка типов при загрузке/сохранении кэша.

### Взаимосвязь с другими частями проекта
- Данный модуль `control.py` является центральным элементом системы симуляции, он управляет жизненным циклом симуляции, кэшированием и транзакциями.
- Модуль взаимодействует с:
    - Модулями `agent.py`, `environment.py`, `factory.py` (через классы `TinyPerson`, `TinyWorld` и `TinyFactory`) для управления их состояниями и сохранения их в кэш.
    - Модулем `utils.py` для получения функций хеширования.
    - Взаимодействует с глобальными настройками через `src.gs` (не показано в текущем коде, но подразумевается из использования `src.`).
- Модуль зависит от других частей проекта и обеспечивает координированное выполнение симуляции.

Этот анализ предоставляет подробное понимание функциональности кода, его структуры, взаимосвязей между классами и методами, а также потенциальных улучшений.