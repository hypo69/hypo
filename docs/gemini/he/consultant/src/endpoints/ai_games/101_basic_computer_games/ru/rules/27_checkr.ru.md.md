# Анализ кода модуля `27_checkr.ru.md`

**Качество кода**

- **Соответствие требованиям к формату кода (1-10):** 
    -  Код представлен в формате Markdown (`.md`), что соответствует заданию.
    -  Используется русский язык, как и требуется.
    -  Структура документа соответствует требованиям пошаговой инструкции для реализации игры.
    -  Присутствуют примеры работы программы, возможные ограничения и описание реализации.

- **Преимущества:**
    -   Хорошая и понятная структуризация документа с использованием заголовков и подзаголовков.
    -   Подробное описание правил игры и пошаговая инструкция.
    -   Наличие примеров работы программы помогает понять, как должна работать игра.

- **Недостатки:**
    -   Отсутствует код на языке Python, который можно было бы проанализировать с точки зрения соответствия требованиям docstring и комментариев.
    -   Представлен только текстовый документ с описанием игры, а не исполняемый код.
    -   Документ не содержит reStructuredText (RST) форматирования.

**Рекомендации по улучшению**

1.  **Добавить код на Python:** Необходимо добавить реализацию игры на Python с использованием требований к docstring и комментариям.
2.  **Использовать reStructuredText (RST):**
    -   Следует переформатировать комментарии и docstring в соответствии с reStructuredText.
    -   Добавить описание модуля, функций и классов в формате RST.
3.  **Внедрить обработку ошибок:** В реализации кода необходимо добавить обработку ошибок с использованием `logger.error` вместо стандартных `try-except`.
4.  **Соблюдать структуру кода:** Код должен следовать стандартным правилам Python PEP8.
5.  **Унификация именования:** Использовать snake_case для функций и переменных.
6.  **Добавление импортов:**  При необходимости, добавить все нужные импорты.
7.  **Преобразование данных:** При необходимости, использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` для чтения файлов.

**Улучшенный код**

```markdown
### Название игры: **CHECKR** (Шашки)

#### Описание
**CHECKR** — это классическая игра в шашки, где игрок и компьютер поочередно делают ходы. Игрок управляет фигурами, которые обозначены "O", в то время как фигуры компьютера обозначены "X". Игра проходит на стандартной доске 8x8, где фигуры могут двигаться по диагонали. Цель игры — захватить все фигуры противника или заблокировать их так, чтобы они не могли двигаться.

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - В начале игры на доске размещаются фигуры:
     - Игрок управляет фигурами "O".
     - Компьютер управляет фигурами "X".
   - Игрок и компьютер делают ходы поочередно. Игрок начинает первым.

#### 2. **Основной цикл игры**
   - **Ход игрока:**
     1. Игрок вводит координаты фигуры, которую он хочет переместить, например, (3, 5).
     2. Затем игрок вводит координаты целевой клетки для перемещения, например, (4, 6).
     3. Программа проверяет, возможно ли выполнение хода. Если ход невозможен (например, если клетка занята), программа попросит игрока выбрать другой ход.
   
   - **Ход компьютера:**
     1. Компьютер делает свой ход по аналогии с игроком. Программа анализирует доску и выбирает оптимальное движение для своей фигуры.

   - **Победа:**
     - Игра продолжается до тех пор, пока один из игроков не останется без фигур или не заблокирует все фигуры противника.
     - Когда игрок или компьютер выигрывает, программа выводит сообщение о победе:
       ```
       ПОБЕДА! ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!
       ```

#### 3. **Подсчёт победителя**
   - Победителем становится тот, кто первым уничтожит все фигуры противника или заблокирует их так, что они не смогут двигаться.

#### 4. **Завершение игры**
   - После завершения игры программа предложит начать новую партию:
     ```
     Хотите сыграть снова? (да/нет)
     ```

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в игру Шашки!
   Вы играете за "O", компьютер за "X".
   Ваш ход.
   Введите координаты фигуры для перемещения (X,Y): 3,5
   Введите целевую клетку для перемещения (X,Y): 4,6
   ```

2. **После хода игрока:**
   ```
   Ход игрока: перемещена фигура с (3,5) на (4,6).
   Ход компьютера.
   ```

3. **Завершение игры:**
   ```
   ПОБЕДА! ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!
   Хотите сыграть снова? (да/нет)
   > нет
   Спасибо за игру!
   ```

---

### Возможные ограничения
- Компьютер не позволяет делать нелегальные ходы, такие как перескок через свою фигуру.
- Программа не поддерживает сложные варианты, такие как «двойные» или «тройные» прыжки, и может потерять фигуру, если игрок попытается выполнить такой ход.

---

### Реализация
Игра реализована с использованием базовых операций для перемещения фигур по доске и проверки валидности хода.

```python
"""
Модуль для реализации игры в шашки.
=========================================================================================

Модуль содержит функции и классы, необходимые для игры в шашки,
включая инициализацию доски, обработку ходов игрока и компьютера,
а также проверку условий победы.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    game = CheckersGame()
    game.run()

"""
from src.logger.logger import logger  # Импортируем логгер

class CheckersGame:
    """
    Класс, представляющий игру в шашки.

    :ivar board: Игровое поле в виде списка списков.
    :vartype board: list[list[str]]
    :ivar current_player: Текущий игрок ('O' - игрок, 'X' - компьютер).
    :vartype current_player: str
    """
    def __init__(self):
        """
        Инициализация игры.

        Устанавливает начальное состояние доски и текущего игрока.
        """
        self.board = self.create_board()  # Инициализируем доску
        self.current_player = 'O'  # Начинает игрок

    def create_board(self) -> list[list[str]]:
        """
        Создает начальную доску для игры в шашки.

        :return: Игровое поле в виде списка списков.
        :rtype: list[list[str]]
        """
        board = [[' ' for _ in range(8)] for _ in range(8)] # Создаем пустую доску
        # Размещаем фигуры компьютера (X)
        for row in range(3):
            for col in range(8):
                if (row + col) % 2 == 1:
                  board[row][col] = 'X'
        # Размещаем фигуры игрока (O)
        for row in range(5, 8):
            for col in range(8):
                if (row + col) % 2 == 1:
                    board[row][col] = 'O'
        return board
    
    def display_board(self) -> None:
      """
      Отображает текущее состояние доски в консоли.
      """
      print("  0 1 2 3 4 5 6 7")
      for i, row in enumerate(self.board):
          print(f"{i} {' '.join(row)}")
      
    def get_player_move(self) -> tuple[tuple[int, int], tuple[int, int]]:
        """
        Получает ход игрока.

        :return: Кортеж из начальной и конечной координат хода.
        :rtype: tuple[tuple[int, int], tuple[int, int]]
        """
        while True:
            try:
                start_x, start_y = map(int, input("Введите координаты фигуры для перемещения (X,Y): ").split(',')) # Получаем начальные координаты
                end_x, end_y = map(int, input("Введите целевую клетку для перемещения (X,Y): ").split(',')) # Получаем конечные координаты
                if not self.is_valid_move(start_x, start_y, end_x, end_y): # Проверяем валидность хода
                  print("Недопустимый ход, попробуйте еще раз.")
                  continue # Просим ввести координаты заново, если ход недопустим
                return (start_x, start_y), (end_x, end_y) # Возвращаем координаты хода
            except ValueError:
                logger.error("Неверный формат ввода. Пожалуйста, введите числа через запятую.") # Логируем ошибку, если неверный ввод
                print("Неверный формат ввода. Пожалуйста, введите числа через запятую.")

    def is_valid_move(self, start_x: int, start_y: int, end_x: int, end_y: int) -> bool:
        """
        Проверяет, является ли ход допустимым.

        :param start_x: Начальная координата X.
        :type start_x: int
        :param start_y: Начальная координата Y.
        :type start_y: int
        :param end_x: Конечная координата X.
        :type end_x: int
        :param end_y: Конечная координата Y.
        :type end_y: int
        :return: True, если ход допустим, False в противном случае.
        :rtype: bool
        """
        if not (0 <= start_x < 8 and 0 <= start_y < 8 and 0 <= end_x < 8 and 0 <= end_y < 8): # Проверяем, что координаты в пределах доски
            return False  # Возвращаем False, если координаты не в пределах доски
        if self.board[start_x][start_y] != self.current_player: # Проверяем, что ходит фигура текущего игрока
            return False # Возвращаем False, если ходит не фигура текущего игрока
        if self.board[end_x][end_y] != ' ': # Проверяем, что конечная клетка свободна
            return False # Возвращаем False, если конечная клетка занята
        if abs(end_x - start_x) != 1 or abs(end_y - start_y) != 1:  # Проверяем, что перемещение по диагонали на 1 клетку
           return False
        return True # Возвращаем True, если все условия валидности выполнены

    def make_move(self, start: tuple[int, int], end: tuple[int, int]) -> None:
        """
        Выполняет ход.

        :param start: Начальные координаты хода.
        :type start: tuple[int, int]
        :param end: Конечные координаты хода.
        :type end: tuple[int, int]
        """
        start_x, start_y = start # Распаковываем координаты начала
        end_x, end_y = end # Распаковываем координаты конца
        self.board[end_x][end_y] = self.board[start_x][start_y] # Перемещаем фигуру на новую позицию
        self.board[start_x][start_y] = ' ' # Освобождаем старую позицию

    def check_winner(self) -> str | None:
        """
        Проверяет наличие победителя.

        :return: Победивший игрок ('O' или 'X') или None, если нет победителя.
        :rtype: str | None
        """
        o_count = 0 # Инициализируем счетчик для фигур игрока
        x_count = 0 # Инициализируем счетчик для фигур компьютера
        for row in self.board:
            for cell in row:
                if cell == 'O':
                    o_count += 1 # Увеличиваем счетчик фигур игрока
                elif cell == 'X':
                    x_count += 1 # Увеличиваем счетчик фигур компьютера
        if o_count == 0:
            return 'X' # Возвращаем 'X', если у игрока не осталось фигур
        if x_count == 0:
            return 'O' # Возвращаем 'O', если у компьютера не осталось фигур
        return None # Возвращаем None, если нет победителя

    def switch_player(self) -> None:
        """
        Переключает текущего игрока.
        """
        self.current_player = 'X' if self.current_player == 'O' else 'O'  # Меняем текущего игрока

    def computer_move(self) -> None:
      """
      Выполняет ход компьютера.
      
      :return: None
      """
      best_move = None # Инициализируем лучший ход
      for start_x in range(8):
        for start_y in range(8):
          if self.board[start_x][start_y] == 'X': # Проверяем, что текущая клетка содержит фигуру компьютера
            for end_x in range(8):
              for end_y in range(8):
                  if self.is_valid_move(start_x, start_y, end_x, end_y): # Проверяем, является ли ход допустимым
                    best_move = ((start_x, start_y), (end_x,end_y)) # Сохраняем лучший ход
                    break
              if best_move:
                 break
        if best_move:
            break
      if best_move:
        self.make_move(best_move[0], best_move[1]) # Выполняем лучший ход
        print(f'Ход компьютера: перемещена фигура с {best_move[0]} на {best_move[1]}.')
      else:
        print("Компьютер не может сделать ход.") # Выводим сообщение, если компьютер не может сделать ход
    def play_again(self) -> bool:
        """
        Предлагает сыграть еще раз.

        :return: True, если игрок хочет сыграть еще раз, False в противном случае.
        :rtype: bool
        """
        while True:
            answer = input("Хотите сыграть снова? (да/нет) ").lower()  # Получаем ответ от пользователя
            if answer in ['да', 'yes']:
                return True # Возвращаем True, если игрок хочет сыграть еще раз
            elif answer in ['нет', 'no']:
                return False # Возвращаем False, если игрок не хочет играть
            else:
                logger.error("Неверный ввод. Пожалуйста, введите 'да' или 'нет'.") # Логируем ошибку некорректного ввода
                print("Неверный ввод. Пожалуйста, введите 'да' или 'нет'.")

    def run(self) -> None:
        """
        Запускает игру.
        """
        print("Добро пожаловать в игру Шашки!")
        self.display_board() # Отображаем начальную доску
        while True:
            if self.current_player == 'O':
                print("Ваш ход.")
                start, end = self.get_player_move() # Получаем ход игрока
                self.make_move(start, end) # Выполняем ход игрока
                print(f"Ход игрока: перемещена фигура с {start} на {end}.")
            else:
                print("Ход компьютера.")
                self.computer_move() # Выполняем ход компьютера
            self.display_board()  # Отображаем доску после хода
            winner = self.check_winner() # Проверяем наличие победителя
            if winner:
                print(f'ПОБЕДА! {"ВЫ ЗАХВАТИЛИ ВСЕ ФИГУРЫ ПРОТИВНИКА!" if winner == "O" else "КОМПЬЮТЕР ЗАХВАТИЛ ВСЕ ВАШИ ФИГУРЫ!"}')
                if not self.play_again(): # Если не хочет играть, то выходим
                   break
                else:
                   self.__init__() # Иначе, начинаем игру заново
                   self.display_board() # Отображаем начальную доску
            self.switch_player() # Переключаем игрока
        print("Спасибо за игру!")

if __name__ == '__main__':
    game = CheckersGame() # Создаем экземпляр игры
    game.run() # Запускаем игру
```