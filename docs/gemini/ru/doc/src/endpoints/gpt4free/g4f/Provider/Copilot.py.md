# Модуль Copilot
## Обзор

Модуль `Copilot` предоставляет интерфейс для взаимодействия с Microsoft Copilot. Он позволяет отправлять текстовые запросы и изображения, получать ответы в виде текста или изображений, а также поддерживает потоковую передачу данных.

## Подробнее

Модуль содержит класс `Copilot`, который реализует взаимодействие с Copilot через веб-сокеты. Он использует библиотеку `curl_cffi` для установки соединения и обмена данными. Если `curl_cffi` недоступна, модуль выдает ошибку `MissingRequirementsError`. Также, если не найдены HAR файлы, используется `nodriver` для получения токена доступа.

Модуль поддерживает различные модели, включая `Copilot` и `Think Deeper`. Он также обрабатывает ошибки аутентификации и предоставляет возможность загрузки изображений.

## Классы

### `Conversation`

**Описание**: Класс представляет собой разговор с Copilot и содержит идентификатор разговора.

**Наследует**: `JsonConversation`

**Аттрибуты**:

-   `conversation_id` (str): Уникальный идентификатор разговора.

### `Copilot`

**Описание**: Класс реализует взаимодействие с Microsoft Copilot.

**Наследует**: `AbstractProvider`, `ProviderModelMixin`

**Аттрибуты**:

-   `label` (str): Метка провайдера ("Microsoft Copilot").
-   `url` (str): URL Microsoft Copilot ("https://copilot.microsoft.com").
-   `working` (bool): Флаг, указывающий на работоспособность провайдера (True).
-   `supports_stream` (bool): Флаг, указывающий на поддержку потоковой передачи данных (True).
-   `default_model` (str): Модель по умолчанию ("Copilot").
-   `models` (list[str]): Список поддерживаемых моделей (["Copilot", "Think Deeper"]).
-   `model_aliases` (dict[str, str]): Псевдонимы моделей ({"gpt-4": "Copilot", "gpt-4o": "Copilot", "o1": "Think Deeper", "reasoning": "Think Deeper", "dall-e-3": "Copilot"}).
-   `websocket_url` (str): URL веб-сокета для взаимодействия с Copilot ("wss://copilot.microsoft.com/c/api/chat?api-version=2").
-   `conversation_url` (str): URL для создания разговоров ("https://copilot.microsoft.com/c/api/conversations").
-   `_access_token` (str): Токен доступа.
-   `_cookies` (dict): Куки для аутентификации.

**Методы**:

-   `create_completion`: Создает запрос к Copilot и возвращает результат.

## Функции

### `create_completion`

```python
@classmethod
def create_completion(
    cls,
    model: str,
    messages: Messages,
    stream: bool = False,
    proxy: str = None,
    timeout: int = 900,
    prompt: str = None,
    media: MediaListType = None,
    conversation: BaseConversation = None,
    return_conversation: bool = False,
    api_key: str = None,
    **kwargs
) -> CreateResult:
    """
    Создает запрос к Copilot и возвращает результат.

    Args:
        model (str): Название модели для использования.
        messages (Messages): Список сообщений для отправки.
        stream (bool): Флаг, указывающий на использование потоковой передачи данных. По умолчанию `False`.
        proxy (str): Адрес прокси-сервера. По умолчанию `None`.
        timeout (int): Максимальное время ожидания ответа в секундах. По умолчанию 900.
        prompt (str): Текст запроса. По умолчанию `None`.
        media (MediaListType): Список медиафайлов для отправки. По умолчанию `None`.
        conversation (BaseConversation): Объект разговора. По умолчанию `None`.
        return_conversation (bool): Флаг, указывающий на необходимость возврата объекта разговора. По умолчанию `False`.
        api_key (str): API ключ для аутентификации. По умолчанию `None`.
        **kwargs: Дополнительные аргументы.

    Returns:
        CreateResult: Результат запроса.

    Raises:
        MissingRequirementsError: Если не установлена библиотека `curl_cffi`.
        NoValidHarFileError: Если не найдены валидные HAR-файлы.
        MissingAuthError: Если не удалось получить токен доступа.
        RuntimeError: При возникновении ошибок во время взаимодействия с Copilot.
    """
```

**Как работает функция**:

1.  Проверяет наличие библиотеки `curl_cffi`. Если она отсутствует, вызывает исключение `MissingRequirementsError`.
2.  Определяет модель для использования, применяя псевдонимы, если необходимо.
3.  Определяет URL веб-сокета для подключения.
4.  Если токен доступа уже существует, использует его. Если нет, пытается прочитать его из HAR-файлов. Если HAR-файлы не найдены, пытается получить токен доступа с помощью `nodriver`.
5.  Создает сессию с использованием `curl_cffi` с заданными параметрами (timeout, proxy, headers, cookies).
6.  Если токен доступа был получен, обновляет куки в сессии.
7.  Получает информацию о пользователе. Если пользователь не найден, обнуляет токен доступа.
8.  Если объект разговора не передан, создает новый разговор.
9.  Формирует запрос на основе переданных сообщений и медиафайлов.
10. Устанавливает соединение с веб-сокетом.
11. Отправляет запрос Copilot.
12. Получает ответы от Copilot и обрабатывает их в цикле.
13. В зависимости от типа события (`appendText`, `generatingImage`, `imageGenerated`, `done`, `suggestedFollowups`, `replaceText`, `error`) возвращает соответствующие данные.
14. При возникновении ошибки выбрасывает исключение `RuntimeError`.
15. Закрывает соединение с веб-сокетом.

```
Начало
  │
  ├── Проверка curl_cffi
  │   └── Если отсутствует: Ошибка MissingRequirementsError
  │
  ├── Определение модели
  │   └── Применение псевдонимов
  │
  ├── Определение URL веб-сокета
  │   │
  │   ├── Проверка токена доступа
  │   │   └── Если отсутствует:
  │   │       ├── Чтение из HAR-файлов
  │   │       │   └── Если не найдены:
  │   │       │       └── Получение с помощью nodriver
  │   │       │           └── RequestLogin (yield)
  │   │       │           └── get_access_token_and_cookies
  │   │       └── Обновление URL веб-сокета
  │   │
  │   ├── Создание сессии curl_cffi
  │   │   └── Обновление куки
  │   │
  │   ├── Получение информации о пользователе
  │   │   └── Если пользователь не найден: обнуление токена
  │   │
  │   ├── Проверка объекта разговора
  │   │   └── Если отсутствует:
  │   │       ├── Создание нового разговора
  │   │       └── POST запрос к conversation_url
  │   │
  │   ├── Формирование запроса
  │   │   └── Обработка сообщений и медиафайлов
  │   │
  │   ├── Установка соединения с веб-сокетом
  │   │
  │   ├── Отправка запроса Copilot
  │   │
  │   ├── Получение ответов в цикле
  │   │   └── Обработка событий (appendText, generatingImage, imageGenerated, done, suggestedFollowups, replaceText, error)
  │   │       └── Генерация соответствующих объектов (yield)
  │   │
  │   ├── Закрытие соединения с веб-сокетом
  │   │
  │   └── Выход
  │
  └── Конец
```

**Примеры**:

```python
# Пример 1: Отправка текстового запроса
result = Copilot.create_completion(
    model="Copilot",
    messages=[{"role": "user", "content": "Привет, как дела?"}],
    stream=True
)

for item in result:
    print(item)

# Пример 2: Отправка запроса с изображением
result = Copilot.create_completion(
    model="Think Deeper",
    messages=[{"role": "user", "content": "Опиши это изображение."}],
    media="path/to/image.jpg",
    stream=False
)

for item in result:
    print(item)
```

### `get_access_token_and_cookies`

```python
async def get_access_token_and_cookies(url: str, proxy: str = None, target: str = "ChatAI",):
    """
    Асинхронно получает токен доступа и куки с использованием nodriver.

    Args:
        url (str): URL для получения токена доступа и куки.
        proxy (str): Адрес прокси-сервера. По умолчанию `None`.
        target (str): Целевой сервис. По умолчанию "ChatAI".

    Returns:
        tuple[str, dict]: Кортеж, содержащий токен доступа и словарь куки.
    """
```

**Как работает функция**:

1.  Запускает браузер с использованием `nodriver`.
2.  Открывает указанный URL в браузере.
3.  Извлекает токен доступа из `localStorage`.
4.  Получает куки для указанного URL.
5.  Закрывает страницу и браузер.
6.  Возвращает токен доступа и куки.

```
Начало
  │
  ├── Запуск браузера (nodriver)
  │
  ├── Открытие URL в браузере
  │
  ├── Извлечение токена доступа из localStorage
  │
  ├── Получение куки
  │
  ├── Закрытие страницы и браузера
  │
  └── Возврат токена доступа и куки
  │
  └── Конец
```

### `readHAR`

```python
def readHAR(url: str):
    """
    Читает HAR-файлы и извлекает токен доступа и куки.

    Args:
        url (str): URL для поиска в HAR-файлах.

    Returns:
        tuple[str, dict]: Кортеж, содержащий токен доступа и словарь куки.

    Raises:
        NoValidHarFileError: Если не найдены валидные HAR-файлы.
    """
```

**Как работает функция**:

1.  Получает список HAR-файлов.
2.  Проходит по каждому HAR-файлу.
3.  Читает содержимое HAR-файла.
4.  Проходит по каждой записи в HAR-файле.
5.  Если URL записи начинается с указанного URL, извлекает токен доступа из заголовка `authorization` и куки.
6.  Если токен доступа не найден, выбрасывает исключение `NoValidHarFileError`.
7.  Возвращает токен доступа и куки.

```
Начало
  │
  ├── Получение списка HAR-файлов
  │
  ├── Проход по каждому HAR-файлу
  │   ├── Чтение содержимого HAR-файла
  │   ├── Проход по каждой записи в HAR-файле
  │   │   ├── Проверка URL записи
  │   │   │   └── Если начинается с указанного URL:
  │   │   │       ├── Извлечение токена доступа из заголовка authorization
  │   │   │       └── Извлечение куки
  │   │   └── Если токен доступа не найден:
  │   │       └── Ошибка NoValidHarFileError
  │   └── Выход из цикла
  │
  └── Возврат токена доступа и куки
  │
  └── Конец
```

### `get_clarity`

```python
def get_clarity() -> bytes:
    """
    Возвращает закодированное тело запроса для Clarity.

    Returns:
        bytes: Закодированное тело запроса.
    """
```

**Как работает функция**:

1.  Определяет закодированное в base64 тело запроса.
2.  Декодирует тело запроса из base64.
3.  Возвращает декодированное тело запроса.

```
Начало
  │
  ├── Определение закодированного тела запроса
  │
  ├── Декодирование тела запроса из base64
  │
  └── Возврат декодированного тела запроса
  │
  └── Конец