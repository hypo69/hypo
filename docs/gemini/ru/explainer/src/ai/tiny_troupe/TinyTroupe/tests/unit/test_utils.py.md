## ИНСТРУКЦИЯ:

Анализируй предоставленный код подробно и объясни его функциональность. Ответ должен включать три раздела:  

1. **<алгоритм>**: Опиши рабочий процесс в виде пошаговой блок-схемы, включая примеры для каждого логического блока, и проиллюстрируй поток данных между функциями, классами или методами.  
2. **<mermaid>**: Напиши код для диаграммы в формате `mermaid`, проанализируй и объясни все зависимости, 
    которые импортируются при создании диаграммы. 
    **ВАЖНО!** Убедитесь, что все имена переменных, используемые в диаграмме `mermaid`, 
    имеют осмысленные и описательные имена. Имена переменных вроде `A`, `B`, `C`, и т.д., не допускаются!  
    
    **Дополнительно**: Если в коде есть импорт `import header`, добавьте блок `mermaid` flowchart, объясняющий `header.py`:\
    ```mermaid
    flowchart TD
        Start --> Header[<code>header.py</code><br> Determine Project Root]
    
        Header --> import[Import Global Settings: <br><code>from src import gs</code>] 
    ```

3. **<объяснение>**: Предоставьте подробные объяснения:  
   - **Импорты**: Их назначение и взаимосвязь с другими пакетами `src.`.  
   - **Классы**: Их роль, атрибуты, методы и взаимодействие с другими компонентами проекта.  
   - **Функции**: Их аргументы, возвращаемые значения, назначение и примеры.  
   - **Переменные**: Их типы и использование.  
   - Выделите потенциальные ошибки или области для улучшения.  

Дополнительно, постройте цепочку взаимосвязей с другими частями проекта (если применимо).  

Это обеспечивает всесторонний и структурированный анализ кода.
## Формат ответа: `.md` (markdown)
**КОНЕЦ ИНСТРУКЦИИ**
```markdown
## <алгоритм>

### `test_extract_json`
1. **Ввод**: Строка `text`, содержащая JSON (или не содержащая).
2. **Вызов** `extract_json(text)`
3. **Внутри `extract_json`**:
    - Поиск JSON объекта в `text`.
    - Если JSON найден:
        - Пытаемся его распарсить.
        - Если парсинг успешен, возвращаем JSON объект.
        - Если парсинг не успешен (например, некорректный JSON), возвращаем пустой словарь.
    - Если JSON не найден, возвращаем пустой словарь.
4. **Вывод**: JSON объект (словарь или список) или пустой словарь.
5. **Примеры**:
   - Ввод: `'Some text before {"key": "value"} some text after'`  -> Вывод: `{"key": "value"}`
   - Ввод: `'Some text before [{"key": "value"}, {"key2": "value2"}] some text after'`  -> Вывод: `[{"key": "value"}, {"key2": "value2"}]`
   - Ввод: `'Some text before {"key": "\'value\'"} some text after'`  -> Вывод: `{"key": "'value'"}`
   - Ввод: `'Some text before {"key": "value",} some text after'`  -> Вывод: `{}`
   - Ввод: `'Some text with no JSON'`  -> Вывод: `{}`

### `test_name_or_empty`
1. **Ввод**: Объект `entity` (или `None`).
2. **Вызов** `name_or_empty(entity)`
3. **Внутри `name_or_empty`**:
   - Проверяем, является ли `entity` экземпляром класса `MockEntity` или `None`.
   - Если `entity` не `None` и имеет атрибут `name`, возвращаем значение `entity.name`.
   - Иначе возвращаем пустую строку `""`.
4. **Вывод**: Имя объекта (строка) или пустая строка.
5. **Примеры**:
   - Ввод: Объект `MockEntity` с именем `"Test"` -> Вывод: `"Test"`
   - Ввод: `None` -> Вывод: `""`

### `test_repeat_on_error`
1. **Ввод**: Функция `decorated_function`, количество повторных попыток `retries`, список допустимых исключений `exceptions`.
2. **Вызов**: `decorated_function()` (вызывается после применения декоратора `repeat_on_error`).
3. **Внутри `repeat_on_error`**:
    - Декоратор оборачивает `decorated_function` и обрабатывает исключения.
    - Цикл повторных попыток (максимум `retries` раз).
    - Внутри цикла вызываем `decorated_function`.
    - Если возникает исключение из списка `exceptions`, повторяем попытку.
    - Если возникло исключение не из `exceptions` или превышено количество `retries`, выкидываем исключение.
    - Если функция отработала без ошибок, выходим из цикла.
4. **Вывод**: Возвращает результат функции, если она отработала успешно. Если количество `retries` исчерпано, или функция вернула исключение, которое не входит в `exceptions`, то выкидывается исключение.
5. **Примеры**:
   - Ввод: `retries=3`, `exceptions=[DummyException]`, `dummy_function` выкидывает `DummyException` 3 раза -> `dummy_function` вызывается 3 раза, выкидывается `DummyException`.
   - Ввод: `retries=3`, `exceptions=[DummyException]`, `dummy_function` не выкидывает исключение -> `dummy_function` вызывается 1 раз.
   - Ввод: `retries=3`, `exceptions=[DummyException]`, `dummy_function` выкидывает `RuntimeError` -> `dummy_function` вызывается 1 раз, выкидывается `RuntimeError`.

## <mermaid>

```mermaid
flowchart TD
    subgraph test_extract_json
        A[Start: `test_extract_json()`] --> B{Has JSON in Text?};
        B -- Yes --> C[Parse JSON];
        C -- Success --> D[Return JSON];
        C -- Fail --> E[Return Empty Dict];
        B -- No --> E;
        D --> F[End: Return JSON];
        E --> F;
    end
    
    subgraph test_name_or_empty
       G[Start: `test_name_or_empty()`] --> H{Is Entity None?};
       H -- No --> I{Has Entity Attribute 'name'?};
       I -- Yes --> J[Return Entity.name];
       I -- No --> K[Return Empty String];
       H -- Yes --> K;
       J --> L[End: Return Name or Empty String];
       K --> L;
    end

    subgraph test_repeat_on_error
        M[Start: `test_repeat_on_error()`] --> N[Call `decorated_function`];
        N --> O{Exception Occurred?};
        O -- Yes --> P{Exception in Allowed List?};
        P -- Yes --> Q{Retries Exhausted?};
        Q -- No --> N;
        Q -- Yes --> R[Raise Exception];
        P -- No --> R;
        O -- No --> S[End: Return result];
        R --> S;
    end

    test_extract_json --> test_name_or_empty
    test_name_or_empty --> test_repeat_on_error
```

**Объяснение `mermaid`:**

- Диаграмма состоит из трех подграфов, соответствующих трем тестовым функциям: `test_extract_json`, `test_name_or_empty` и `test_repeat_on_error`.
- В каждом подграфе показан поток выполнения тестовых функций.
- **`test_extract_json`**: Начинается с проверки наличия JSON в тексте. Если JSON найден, то выполняется попытка его парсинга. В зависимости от результата парсинга, возвращается либо распарсенный JSON, либо пустой словарь. Если JSON не найден, возвращается пустой словарь.
- **`test_name_or_empty`**: Проверяет, является ли переданный объект `None`. Если нет, то проверяется наличие атрибута `name`. Если атрибут есть, то его значение возвращается, иначе возвращается пустая строка. Если объект является `None`, то сразу возвращается пустая строка.
- **`test_repeat_on_error`**: Вызывает декорированную функцию. Если возникает исключение, то проверяется, находится ли оно в списке разрешенных исключений. Если да, то проверяется, исчерпаны ли попытки повторения. Если попытки исчерпаны или исключение не в списке разрешенных, исключение перебрасывается. В случае успешного выполнения функции возвращается ее результат.
- Направления стрелок указывают поток управления внутри каждой функции.
- Существует связь между блоками: `test_extract_json` --> `test_name_or_empty` --> `test_repeat_on_error`, показывающая логическую последовательность тестовых функций.

## <объяснение>

### Импорты

-   `pytest`: Используется для написания и запуска тестов.
-   `unittest.mock.MagicMock`: Используется для создания мок-объектов, которые могут эмулировать поведение других объектов в тестах.
-   `sys`: Используется для добавления путей к модулям в `sys.path`, чтобы импортировать модули из других директорий. В данном случае добавляются пути `../../tinytroupe/`, `../../` и `..`, что позволяет импортировать `tinytroupe.utils` и `testing_utils`
-   `tinytroupe.utils`: Содержит функции `name_or_empty`, `extract_json`, и `repeat_on_error`, которые тестируются.
-   `testing_utils`: Содержит дополнительные утилиты, используемые в тестах.

### Классы

-   `MockEntity`: Вспомогательный класс, используемый для тестирования `name_or_empty`. Имеет атрибут `name`.
    
- `DummyException`: Вспомогательный класс исключения, используемый для тестирования `repeat_on_error`.

### Функции

-   `test_extract_json()`:
    -   **Назначение:** Тестирует функцию `extract_json`, которая извлекает JSON из строки.
    -   **Аргументы:** Нет.
    -   **Возвращаемое значение:** Нет. Проверяет результат с помощью `assert`.
    -   **Примеры**:
        -   Вызов `extract_json` с корректным JSON, возвращает этот JSON.
        -   Вызов с JSON массивом, возвращает массив.
        -   Вызов с escaped char в JSON, возвращает распарсенный JSON.
        -   Вызов с некорректным JSON, возвращает пустой словарь.
        -   Вызов без JSON, возвращает пустой словарь.
-   `test_name_or_empty()`:
    -   **Назначение:** Тестирует функцию `name_or_empty`, которая возвращает имя объекта, если оно есть, иначе пустую строку.
    -   **Аргументы:** Нет.
    -   **Возвращаемое значение:** Нет. Проверяет результат с помощью `assert`.
    -   **Примеры**:
        -   Вызов с объектом `MockEntity`, возвращает имя объекта.
        -   Вызов с `None`, возвращает пустую строку.
-   `test_repeat_on_error()`:
    -   **Назначение:** Тестирует декоратор `repeat_on_error`, который позволяет повторять выполнение функции при возникновении определенных исключений.
    -   **Аргументы:** Нет.
    -   **Возвращаемое значение:** Нет. Проверяет результат с помощью `assert`.
    -   **Примеры**:
        -   Вызов с `dummy_function`, выбрасывающей исключение, и проверкой числа повторов.
        -   Вызов с `dummy_function`, не выбрасывающей исключение, и проверкой, что функция выполнилась один раз.
        -   Вызов с `dummy_function`, выбрасывающей исключение, не входящее в разрешенный список исключений, и проверкой, что исключение поднимается.

### Переменные

-   `text`: Строковая переменная, содержащая JSON или текст для `test_extract_json`.
-   `result`: Переменная, хранящая результат выполнения тестируемых функций.
-   `entity`: Объект `MockEntity`, передаваемый в `test_name_or_empty`.
-   `retries`: Количество попыток повторения для `test_repeat_on_error`.
-   `dummy_function`: `MagicMock` объект, используется для имитации вызова функции.
-   `decorated_function`: Функция, декорированная с помощью `repeat_on_error` для `test_repeat_on_error`.

### Области для улучшения

-   В коде есть комментарий `TODO`, указывающий на отсутствие теста для функции `json_serializer`.
-   Добавить более подробные проверки крайних случаев для каждой функции.
-   Рассмотреть возможность параметризации тестов для увеличения покрытия кода.

### Цепочка взаимосвязей с другими частями проекта

-   Тестовый файл `test_utils.py` зависит от `tinytroupe.utils`, где реализованы тестируемые функции, и от `testing_utils`, где могут находиться вспомогательные функции для тестов.
-   Тесты проверяют корректность работы функций, которые, в свою очередь, используются в других частях проекта, например, в модулях обработки данных или интеграции с внешними сервисами.
-   Использование `sys.path.append` указывает, что этот файл находится в поддиректории и взаимодействует с другими модулями проекта.
```