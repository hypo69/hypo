# Модуль `web_search`

## Обзор

Модуль `web_search` предоставляет инструменты для выполнения веб-поиска и извлечения информации из результатов поиска. Он использует библиотеку `duckduckgo-search` для выполнения поисковых запросов и `beautifulsoup4` для извлечения текста из веб-страниц. Модуль также включает функции для кэширования результатов поиска и форматирования результатов для использования в других частях проекта `hypotez`.

## Подробнее

Этот модуль предназначен для интеграции веб-поиска в другие процессы, такие как ответы на запросы пользователей или обогащение контекста для языковых моделей. Он предоставляет функции для поиска, извлечения текста и форматирования результатов, что позволяет эффективно использовать информацию из интернета.

## Классы

### `SearchResults`

**Описание**: Класс для хранения результатов веб-поиска.

**Принцип работы**:
Класс `SearchResults` предназначен для организации и хранения данных, полученных в результате веб-поиска. Он содержит список объектов `SearchResultEntry`, представляющих отдельные результаты поиска, а также информацию об использованном количестве слов. Класс предоставляет методы для итерации по результатам, получения их в виде словаря и извлечения источников.

**Методы**:

- `__init__(self, results: list, used_words: int)`:
    - **Назначение**: Инициализирует объект `SearchResults`.
    - **Параметры**:
        - `results (list)`: Список объектов `SearchResultEntry`, представляющих результаты поиска.
        - `used_words (int)`: Количество слов, использованных в результатах поиска.
    - **Как работает функция**:
        1. Присваивает переданные значения атрибутам `results` и `used_words`.

- `from_dict(cls, data: dict)`:
    - **Назначение**: Создает объект `SearchResults` из словаря.
    - **Параметры**:
        - `data (dict)`: Словарь, содержащий данные для создания объекта `SearchResults`. Ожидается, что словарь содержит ключи "results" (список словарей для `SearchResultEntry`) и "used_words" (количество использованных слов).
    - **Возвращает**:
        - `SearchResults`: Объект `SearchResults`, созданный на основе данных из словаря.
    - **Как работает функция**:
        1. Преобразует список словарей в список объектов `SearchResultEntry`.
        2. Создает и возвращает объект `SearchResults` с использованием преобразованных данных.
    - **Примеры**:
        ```python
        data = {"results": [{"title": "Example", "url": "http://example.com", "snippet": "Example snippet", "text": "Example text"}], "used_words": 100}
        results = SearchResults.from_dict(data)
        print(results.used_words)  # Вывод: 100
        ```

- `__iter__(self)`:
    - **Назначение**: Обеспечивает возможность итерации по результатам поиска.
    - **Возвращает**:
        - `Iterator[SearchResultEntry]`: Итератор по списку результатов поиска.
    - **Как работает функция**:
        1. Использует `yield from` для итерации по списку `self.results`.
        - **Пример**:

            ```python
            results = SearchResults([SearchResultEntry("title1", "url1", "snippet1"), SearchResultEntry("title2", "url2", "snippet2")], 50)
            for result in results:
                print(result.title)  # Вывод: title1, title2
            ```

- `__str__(self)`:
    - **Назначение**: Преобразует результаты поиска в строку для удобного представления.
    - **Возвращает**:
        - `str`: Строковое представление результатов поиска, включающее заголовки, текст/сниппеты и источники.
    - **Как работает функция**:
        1. Итерируется по списку результатов поиска.
        2. Форматирует каждый результат, добавляя заголовок, текст (или сниппет, если текст отсутствует) и источник.
        3. Объединяет отформатированные результаты в одну строку, разделяя их символами новой строки.
    -  **Примеры**:

        ```python
        results = SearchResults([SearchResultEntry("title1", "url1", "snippet1", "text1"), SearchResultEntry("title2", "url2", "snippet2", "text2")], 50)
        print(str(results))
        # Вывод:
        # Title: title1
        #
        # text1
        #
        # Source: [[0]](url1)
        #
        #
        # Title: title2
        #
        # text2
        #
        # Source: [[1]](url2)
        ```

- `__len__(self) -> int`:
    - **Назначение**: Возвращает количество результатов поиска.
    - **Возвращает**:
        - `int`: Количество результатов в списке `self.results`.
    - **Как работает функция**:
        1. Возвращает длину списка `self.results`.
    - **Примеры**:

        ```python
        results = SearchResults([SearchResultEntry("title1", "url1", "snippet1"), SearchResultEntry("title2", "url2", "snippet2")], 50)
        print(len(results))  # Вывод: 2
        ```

- `get_sources(self) -> Sources`:
    - **Назначение**: Извлекает источники результатов поиска.
    - **Возвращает**:
        - `Sources`: Объект `Sources`, содержащий список словарей с URL и заголовками результатов поиска.
    - **Как работает функция**:
        1. Создает список словарей, где каждый словарь содержит URL и заголовок результата поиска.
        2. Возвращает объект `Sources`, созданный на основе этого списка.
    -  **Примеры**:

        ```python
        results = SearchResults([SearchResultEntry("title1", "url1", "snippet1"), SearchResultEntry("title2", "url2", "snippet2")], 50)
        sources = results.get_sources()
        print(sources.sources)
        # Вывод:
        # [{'url': 'url1', 'title': 'title1'}, {'url': 'url2', 'title': 'title2'}]
        ```

- `get_dict(self)`:
    - **Назначение**: Преобразует объект `SearchResults` в словарь.
    - **Возвращает**:
        - `dict`: Словарь, содержащий данные объекта `SearchResults`.
    - **Как работает функция**:
        1. Преобразует каждый объект `SearchResultEntry` в словаре.
        2. Создает словарь, содержащий список словарей результатов и количество использованных слов.
    -  **Примеры**:

        ```python
        results = SearchResults([SearchResultEntry("title1", "url1", "snippet1"), SearchResultEntry("title2", "url2", "snippet2")], 50)
        data = results.get_dict()
        print(data)
        # Вывод:
        # {'results': [{'title': 'title1', 'url': 'url1', 'snippet': 'snippet1', 'text': None}, {'title': 'title2', 'url': 'url2', 'snippet': 'snippet2', 'text': None}], 'used_words': 50}
        ```

### `SearchResultEntry`

**Описание**: Класс для хранения отдельного результата веб-поиска.

**Принцип работы**:
Класс `SearchResultEntry` представляет собой запись отдельного результата веб-поиска. Он содержит информацию о заголовке, URL, сниппете и тексте результата. Класс предоставляет методы для установки текста результата и преобразования объекта в словарь.

**Методы**:

- `__init__(self, title: str, url: str, snippet: str, text: str = None)`:
    - **Назначение**: Инициализирует объект `SearchResultEntry`.
    - **Параметры**:
        - `title (str)`: Заголовок результата поиска.
        - `url (str)`: URL результата поиска.
        - `snippet (str)`: Сниппет (краткое описание) результата поиска.
        - `text (str, optional)`: Полный текст результата поиска. По умолчанию `None`.
    - **Как работает функция**:
        1. Присваивает переданные значения соответствующим атрибутам объекта.

- `set_text(self, text: str)`:
    - **Назначение**: Устанавливает полный текст результата поиска.
    - **Параметры**:
        - `text (str)`: Полный текст результата поиска.
    - **Как работает функция**:
        1. Присваивает переданное значение атрибуту `self.text`.

- `get_dict(self)`:
    - **Назначение**: Преобразует объект `SearchResultEntry` в словарь.
    - **Возвращает**:
        - `dict`: Словарь, содержащий данные объекта `SearchResultEntry`.
    - **Как работает функция**:
        1. Создает и возвращает словарь, содержащий значения атрибутов `title`, `url`, `snippet` и `text`.
    -  **Примеры**:

        ```python
        entry = SearchResultEntry("title1", "url1", "snippet1", "text1")
        data = entry.get_dict()
        print(data)
        # Вывод:
        # {'title': 'title1', 'url': 'url1', 'snippet': 'snippet1', 'text': 'text1'}
        ```

## Функции

### `scrape_text`

```python
def scrape_text(html: str, max_words: int = None, add_source=True, count_images: int = 2) -> Iterator[str]:
    """
    Извлекает текст из HTML-кода веб-страницы.

    Args:
        html (str): HTML-код веб-страницы.
        max_words (int, optional): Максимальное количество слов для извлечения. По умолчанию `None` (без ограничений).
        add_source (bool, optional): Нужно ли добавлять источник в конце извлеченного текста. По умолчанию `True`.
        count_images (int, optional): Максимальное количество изображений для извлечения. По умолчанию 2.

    Yields:
        str: Извлеченный текст из HTML-кода.

    Как работает функция:
    1.  Инициализирует `BeautifulSoup` для парсинга HTML.
    2.  Пытается найти основной контент, используя селекторы CSS (`main`, `.main-content-wrapper` и другие).
    3.  Удаляет ненужные элементы (например, `.c-globalDisclosure` для Zdnet).
    4.  Извлекает изображения (если `count_images > 0`) и текст из различных элементов (`h1, h2, h3, h4, h5, h6, p, pre, table, ul`)
        с проверкой на максимальное количество слов и избежание дубликатов.
    5.  Добавляет ссылку на источник (если `add_source` - `True`) из канонической ссылки.

    Внутри функции происходят следующие действия и преобразования:
    A: Парсинг HTML с использованием `BeautifulSoup`.
    |
    B: Поиск основного контента с использованием CSS-селекторов.
    |
    C: Удаление нежелательных элементов.
    |
    D: Извлечение текста и изображений.
    |
    E: Добавление источника (если указано).
    """
    ...
```

**Описание**: Извлекает текст из HTML-кода веб-страницы, используя библиотеку `BeautifulSoup`.

**Параметры**:

- `html (str)`: HTML-код веб-страницы.
- `max_words (int, optional)`: Максимальное количество слов для извлечения. По умолчанию `None` (без ограничений).
- `add_source (bool, optional)`: Нужно ли добавлять источник в конце извлеченного текста. По умолчанию `True`.
- `count_images (int, optional)`: Максимальное количество изображений для извлечения. По умолчанию 2.

**Возвращает**:

- `Iterator[str]`: Итератор, возвращающий извлеченный текст из HTML-кода.

**Как работает функция**:

1.  Инициализирует `BeautifulSoup` для парсинга HTML.
2.  Пытается найти основной контент, используя селекторы CSS (`main`, `.main-content-wrapper` и другие).
3.  Удаляет ненужные элементы (например, `.c-globalDisclosure` для Zdnet).
4.  Извлекает текст и изображения (если `count_images > 0`) из различных элементов (`h1, h2, h3, h4, h5, h6, p, pre, table, ul`)
    с проверкой на максимальное количество слов и избежание дубликатов.
5.  Добавляет ссылку на источник (если `add_source` - `True`) из канонической ссылки.

**Внутри функции происходят следующие действия и преобразования**:

A: Парсинг HTML с использованием `BeautifulSoup`.
|
B: Поиск основного контента с использованием CSS-селекторов.
|
C: Удаление нежелательных элементов.
|
D: Извлечение текста и изображений.
|
E: Добавление источника (если указано).

**Примеры**:

```python
html = "<html><body><h1>Title</h1><p>Text</p></body></html>"
text = "".join(scrape_text(html, max_words=100, add_source=False))
print(text)  # Вывод: Title Text
```

### `fetch_and_scrape`

```python
async def fetch_and_scrape(session: ClientSession, url: str, max_words: int = None, add_source: bool = False) -> str:
    """
    Асинхронно загружает HTML-код веб-страницы и извлекает из него текст.

    Args:
        session (ClientSession): Асинхронная сессия для выполнения HTTP-запросов.
        url (str): URL веб-страницы.
        max_words (int, optional): Максимальное количество слов для извлечения. По умолчанию `None` (без ограничений).
        add_source (bool, optional): Нужно ли добавлять источник в конце извлеченного текста. По умолчанию `False`.

    Returns:
        str | None: Извлеченный текст из HTML-кода или `None` в случае ошибки.

    Как работает функция:
    1.  Формирует путь к файлу кэша на основе URL и даты.
    2.  Если файл кэша существует, читает текст из него и возвращает.
    3.  Если файл кэша не существует, выполняет GET-запрос к указанному URL.
    4.  Извлекает текст из HTML-кода с использованием функции `scrape_text`.
    5.  Сохраняет извлеченный текст в файл кэша.

    Внутри функции происходят следующие действия и преобразования:
    A: Формирование пути к файлу кэша.
    |
    B: Проверка наличия файла кэша.
    |
    C: Выполнение HTTP-запроса (если кэш отсутствует).
    |
    D: Извлечение текста с использованием `scrape_text`.
    |
    E: Сохранение текста в файл кэша.
    """
    ...
```

**Описание**: Асинхронно загружает HTML-код веб-страницы и извлекает из него текст.

**Параметры**:

- `session (ClientSession)`: Асинхронная сессия для выполнения HTTP-запросов.
- `url (str)`: URL веб-страницы.
- `max_words (int, optional)`: Максимальное количество слов для извлечения. По умолчанию `None` (без ограничений).
- `add_source (bool, optional)`: Нужно ли добавлять источник в конце извлеченного текста. По умолчанию `False`.

**Возвращает**:

- `str | None`: Извлеченный текст из HTML-кода или `None` в случае ошибки.

**Как работает функция**:

1.  Формирует путь к файлу кэша на основе URL и даты.
2.  Если файл кэша существует, читает текст из него и возвращает.
3.  Если файл кэша не существует, выполняет GET-запрос к указанному URL.
4.  Извлекает текст из HTML-кода с использованием функции `scrape_text`.
5.  Сохраняет извлеченный текст в файл кэша.

**Внутри функции происходят следующие действия и преобразования**:

A: Формирование пути к файлу кэша.
|
B: Проверка наличия файла кэша.
|
C: Выполнение HTTP-запроса (если кэш отсутствует).
|
D: Извлечение текста с использованием `scrape_text`.
|
E: Сохранение текста в файл кэша.

**Примеры**:

```python
import asyncio
from aiohttp import ClientSession

async def main():
    async with ClientSession() as session:
        text = await fetch_and_scrape(session, "http://example.com", max_words=100)
        print(text)

asyncio.run(main())
```

### `search`

```python
async def search(query: str, max_results: int = 5, max_words: int = 2500, backend: str = "auto", add_text: bool = True, timeout: int = 5, region: str = "wt-wt") -> SearchResults:
    """
    Выполняет поиск в интернете и возвращает результаты.

    Args:
        query (str): Поисковый запрос.
        max_results (int, optional): Максимальное количество результатов для возврата. По умолчанию 5.
        max_words (int, optional): Максимальное количество слов для извлечения из каждой страницы. По умолчанию 2500.
        backend (str, optional): Бэкэнд для поиска (например, "auto", "api", "html"). По умолчанию "auto".
        add_text (bool, optional): Нужно ли добавлять полный текст каждой страницы в результаты. По умолчанию `True`.
        timeout (int, optional): Время ожидания HTTP-запроса в секундах. По умолчанию 5.
        region (str, optional): Регион поиска. По умолчанию "wt-wt".

    Returns:
        SearchResults: Объект `SearchResults`, содержащий результаты поиска.

    Raises:
        MissingRequirementsError: Если не установлены необходимые библиотеки (`duckduckgo-search` и `beautifulsoup4`).

    Как работает функция:
    1. Проверяет наличие необходимых библиотек.
    2. Выполняет поиск с использованием `ddgs.text`.
    3. Для каждого результата создает объект `SearchResultEntry`.
    4. Если `add_text` равен `True`, выполняет асинхронную загрузку и извлечение текста для каждого результата.
    5. Форматирует результаты и возвращает объект `SearchResults`.

    Внутри функции происходят следующие действия и преобразования:
    A: Проверка наличия необходимых библиотек.
    |
    B: Выполнение поиска с использованием `ddgs.text`.
    |
    C: Создание объектов `SearchResultEntry`.
    |
    D: Асинхронная загрузка и извлечение текста (если указано).
    |
    E: Форматирование результатов и создание объекта `SearchResults`.
    """
    ...
```

**Описание**: Выполняет поиск в интернете и возвращает результаты.

**Параметры**:

- `query (str)`: Поисковый запрос.
- `max_results (int, optional)`: Максимальное количество результатов для возврата. По умолчанию 5.
- `max_words (int, optional)`: Максимальное количество слов для извлечения из каждой страницы. По умолчанию 2500.
- `backend (str, optional)`: Бэкэнд для поиска (например, "auto", "api", "html"). По умолчанию "auto".
- `add_text (bool, optional)`: Нужно ли добавлять полный текст каждой страницы в результаты. По умолчанию `True`.
- `timeout (int, optional)`: Время ожидания HTTP-запроса в секундах. По умолчанию 5.
- `region (str, optional)`: Регион поиска. По умолчанию "wt-wt".

**Возвращает**:

- `SearchResults`: Объект `SearchResults`, содержащий результаты поиска.

**Вызывает исключения**:

- `MissingRequirementsError`: Если не установлены необходимые библиотеки (`duckduckgo-search` и `beautifulsoup4`).

**Как работает функция**:

1. Проверяет наличие необходимых библиотек.
2. Выполняет поиск с использованием `ddgs.text`.
3. Для каждого результата создает объект `SearchResultEntry`.
4. Если `add_text` равен `True`, выполняет асинхронную загрузку и извлечение текста для каждого результата.
5. Форматирует результаты и возвращает объект `SearchResults`.

**Внутри функции происходят следующие действия и преобразования**:

A: Проверка наличия необходимых библиотек.
|
B: Выполнение поиска с использованием `ddgs.text`.
|
C: Создание объектов `SearchResultEntry`.
|
D: Асинхронная загрузка и извлечение текста (если указано).
|
E: Форматирование результатов и создание объекта `SearchResults`.

**Примеры**:

```python
import asyncio

async def main():
    results = await search("example query", max_results=3)
    print(len(results))

asyncio.run(main())
```

### `do_search`

```python
async def do_search(prompt: str, query: str = None, instructions: str = DEFAULT_INSTRUCTIONS, **kwargs) -> tuple[str, Sources]:
    """
    Выполняет поиск и форматирует результаты для использования в запросе к языковой модели.

    Args:
        prompt (str): Исходный запрос пользователя.
        query (str, optional): Поисковый запрос. Если `None`, используется первая строка `prompt`. По умолчанию `None`.
        instructions (str, optional): Инструкции для языковой модели. По умолчанию `DEFAULT_INSTRUCTIONS`.
        **kwargs: Дополнительные параметры для функции `search`.

    Returns:
        tuple[str, Sources]: Кортеж, содержащий отформатированный запрос и источники результатов поиска.

    Как работает функция:
    1. Проверяет, нужно ли выполнять поиск (если инструкции уже есть в запросе или нет поискового запроса).
    2. Если `query` равен `None`, использует первую строку `prompt` в качестве поискового запроса.
    3. Выполняет поиск с использованием функции `search`.
    4. Форматирует результаты поиска и добавляет их в запрос.

    Внутри функции происходят следующие действия и преобразования:
    A: Проверка необходимости выполнения поиска.
    |
    B: Определение поискового запроса.
    |
    C: Выполнение поиска с использованием `search`.
    |
    D: Форматирование результатов и создание нового запроса.
    """
    ...
```

**Описание**: Выполняет поиск и форматирует результаты для использования в запросе к языковой модели.

**Параметры**:

- `prompt (str)`: Исходный запрос пользователя.
- `query (str, optional)`: Поисковый запрос. Если `None`, используется первая строка `prompt`. По умолчанию `None`.
- `instructions (str, optional)`: Инструкции для языковой модели. По умолчанию `DEFAULT_INSTRUCTIONS`.
- `**kwargs`: Дополнительные параметры для функции `search`.

**Возвращает**:

- `tuple[str, Sources]`: Кортеж, содержащий отформатированный запрос и источники результатов поиска.

**Как работает функция**:

1. Проверяет, нужно ли выполнять поиск (если инструкции уже есть в запросе или нет поискового запроса).
2. Если `query` равен `None`, использует первую строку `prompt` в качестве поискового запроса.
3. Выполняет поиск с использованием функции `search`.
4. Форматирует результаты поиска и добавляет их в запрос.

**Внутри функции происходят следующие действия и преобразования**:

A: Проверка необходимости выполнения поиска.
|
B: Определение поискового запроса.
|
C: Выполнение поиска с использованием `search`.
|
D: Форматирование результатов и создание нового запроса.

**Примеры**:

```python
import asyncio

async def main():
    prompt = "What is the capital of France?"
    new_prompt, sources = await do_search(prompt)
    print(new_prompt)

asyncio.run(main())
```

### `get_search_message`

```python
def get_search_message(prompt: str, raise_search_exceptions=False, **kwargs) -> str:
    """
    Выполняет поиск и возвращает отформатированное сообщение.

    Args:
        prompt (str): Исходный запрос пользователя.
        raise_search_exceptions (bool, optional): Нужно ли поднимать исключения, связанные с поиском. По умолчанию `False`.
        **kwargs: Дополнительные параметры для функции `do_search`.

    Returns:
        str: Отформатированное сообщение, содержащее результаты поиска.

    Как работает функция:
    1. Вызывает функцию `do_search` для выполнения поиска.
    2. Перехватывает исключения `DuckDuckGoSearchException` и `MissingRequirementsError`.
    3. Если `raise_search_exceptions` равен `True`, поднимает исключение.
    4. В противном случае, логирует ошибку и возвращает исходный запрос.

    Внутри функции происходят следующие действия и преобразования:
    A: Выполнение поиска с использованием `do_search`.
    |
    B: Перехват и обработка исключений.
    """
    ...
```

**Описание**: Выполняет поиск и возвращает отформатированное сообщение.

**Параметры**:

- `prompt (str)`: Исходный запрос пользователя.
- `raise_search_exceptions (bool, optional)`: Нужно ли поднимать исключения, связанные с поиском. По умолчанию `False`.
- `**kwargs`: Дополнительные параметры для функции `do_search`.

**Возвращает**:

- `str`: Отформатированное сообщение, содержащее результаты поиска.

**Как работает функция**:

1. Вызывает функцию `do_search` для выполнения поиска.
2. Перехватывает исключения `DuckDuckGoSearchException` и `MissingRequirementsError`.
3. Если `raise_search_exceptions` равен `True`, поднимает исключение.
4. В противном случае, логирует ошибку и возвращает исходный запрос.

**Внутри функции происходят следующие действия и преобразования**:

A: Выполнение поиска с использованием `do_search`.
|
B: Перехват и обработка исключений.

**Примеры**:

```python
prompt = "What is the capital of France?"
message = get_search_message(prompt)
print(message)
```

### `spacy_get_keywords`

```python
def spacy_get_keywords(text: str):
    """
    Извлекает ключевые слова из текста с использованием библиотеки `spaCy`.

    Args:
        text (str): Текст для извлечения ключевых слов.

    Returns:
        list: Список ключевых слов.

    Как работает функция:
    1. Проверяет наличие библиотеки `spaCy`. Если библиотека отсутствует, возвращает исходный текст.
    2. Загружает языковую модель `en_core_web_sm`.
    3. Обрабатывает текст с использованием модели.
    4. Извлекает ключевые слова на основе POS-тегов (существительные, прилагательные) и именованных сущностей.
    5. Возвращает список ключевых слов.

    Внутри функции происходят следующие действия и преобразования:
    A: Проверка наличия `spaCy`.
    |
    B: Загрузка языковой модели.
    |
    C: Обработка текста.
    |
    D: Извлечение ключевых слов.
    """
    ...
```

**Описание**: Извлекает ключевые слова из текста с использованием библиотеки `spaCy`.

**Параметры**:

- `text (str)`: Текст для извлечения ключевых слов.

**Возвращает**:

- `list`: Список ключевых слов.

**Как работает функция**:

1. Проверяет наличие библиотеки `spaCy`. Если библиотека отсутствует, возвращает исходный текст.
2. Загружает языковую модель `en_core_web_sm`.
3. Обрабатывает текст с использованием модели.
4. Извлекает ключевые слова на основе POS-тегов (существительные, прилагательные) и именованных сущностей.
5. Возвращает список ключевых слов.

**Внутри функции происходят следующие действия и преобразования**:

A: Проверка наличия `spaCy`.
|
B: Загрузка языковой модели.
|
C: Обработка текста.
|
D: Извлечение ключевых слов.

**Примеры**:

```python
text = "The capital of France is Paris."
keywords = spacy_get_keywords(text)
print(keywords)