# Модуль для экспериментов с OpenAI Bot

## Обзор

Модуль предназначен для экспериментов с моделью OpenAI. Он позволяет обрабатывать исходный код или документацию, отправлять их в модель OpenAI для анализа и получения ответов.
В частности, используется для автоматической генерации документации.

## Подробнее

Модуль использует роль выполнения, установленную в коде, для взаимодействия с моделью.
Для роли `doc_writer` используется модель **OpenAI GPT-4** для генерации документации или других текстов.
Входные данные для модели включают комментарии и код/документацию, которые передаются в модель для обработки.
Ответ модели сохраняется в файл с расширением `.md` в зависимости от роли.

Используемая модель:
- **OpenAI GPT-4**: Используется для создания документации и других текстовых материалов.

Ссылки на документацию модели:
- OpenAI: https://platform.openai.com/docs

## Функции

### `main`

```python
def main() -> None:
    """ Main function to process files and interact with the model.

    This function reads a comment file, iterates over specified files in the source directory,
    and sends the file content to a model for analysis. It then processes the model's response.
    """
```

**Назначение**: Главная функция для обработки файлов и взаимодействия с моделью.

**Как работает функция**:

1.  Определяет роль выполнения (по умолчанию `doc_writer`).
2.  В зависимости от роли, считывает комментарии и системные инструкции из файлов `.md`.
3.  Инициализирует модель `OpenAIModel` с системными инструкциями, именем модели и ID ассистента.
4.  Перебирает файлы в указанной директории (`gs.path.src`) с использованием заданных паттернов (`*.py`, `README.MD`).
5.  Для каждого файла формирует входной контент для модели, включающий комментарий, расположение файла в проекте, роль выполнения и содержимое файла.
6.  Отправляет контент в модель для анализа и получает ответ.
7.  Сохраняет ответ модели в файл с расширением `.md`, используя функцию `save_response`.
8.  Обрабатывает исключения, логируя ошибки.
9.  Делает паузу в 20 секунд, чтобы избежать ограничений API.

```
Начало
   ↓
Определение роли (doc_writer)
   ↓
Чтение комментариев и инструкций
   ↓
Инициализация OpenAIModel
   ↓
Перебор файлов (*.py, README.MD)
   ↓
Формирование контента для модели
   ↓
Отправка контента в OpenAIModel
   ↓
Сохранение ответа (save_response)
   ↓
Обработка исключений
   ↓
Пауза (20 секунд)
   ↓
Конец
```

**Примеры**:
```python
# Пример вызова функции main
main()
```

### `save_response`

```python
def save_response(file_path: Path, response: str, from_model: str) -> None:
    """ Save the model's response to a markdown file with updated path based on role.

    Args:
        file_path (Path): The original file path being processed.
        response (str): The response from the model to be saved.
    """
```

**Назначение**: Сохраняет ответ модели в файл Markdown с обновленным путем на основе роли.

**Параметры**:

*   `file_path` (Path): Исходный путь к обрабатываемому файлу.
*   `response` (str): Ответ от модели, который нужно сохранить.
*   `from_model` (str): Название модели, от которой получен ответ.

**Как работает функция**:

1.  Определяет директорию для сохранения файла на основе роли (в данном случае, `doc_writer` соответствует директории `docs/{from_model}/raw_rst_from_ai`).
2.  Формирует новый путь к файлу, заменяя часть пути `src` на директорию, соответствующую роли.
3.  Изменяет суффикс файла на `.md`.
4.  Создает директорию, если она не существует.
5.  Сохраняет ответ модели в новый файл с кодировкой UTF-8.
6.  Выводит сообщение в консоль с путем к сохраненному файлу.

```
Начало
   ↓
Определение директории сохранения на основе роли
   ↓
Формирование нового пути к файлу
   ↓
Изменение суффикса файла на .md
   ↓
Создание директории (если не существует)
   ↓
Сохранение ответа в файл
   ↓
Вывод сообщения о сохранении
   ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции save_response
from pathlib import Path
file_path = Path('src/some/module/file.py')
response = 'This is a test response from the model.'
save_response(file_path, response, from_model='openai')
```

### `yield_files_content`

```python
def yield_files_content(
    src_path: Path, patterns: list[str]
) -> Iterator[tuple[Path, str]]:
    """ Yield file content based on patterns from the source directory, excluding certain patterns and directories.

    Args:
        src_path (Path): The base directory to search for files.
        patterns (list[str]): List of file patterns to include (e.g., ['*.py', '*.txt']).

    Yields:
        Iterator[tuple[Path, str]]: A tuple of file path and its content as a string.
    """
```

**Назначение**: Генерирует содержимое файлов, соответствующих заданным паттернам, из исходной директории, исключая определенные паттерны и директории.

**Параметры**:

*   `src_path` (Path): Базовая директория для поиска файлов.
*   `patterns` (list[str]): Список файловых паттернов для включения (например, `['*.py', '*.txt']`).

**Возвращает**:

*   `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортеж, содержащий путь к файлу и его содержимое в виде строки.

**Как работает функция**:

1.  Определяет регулярные выражения для исключаемых файлов и директорий (файлы и директории, содержащие круглые скобки, начинающиеся с трех и более подчеркиваний).
2.  Определяет список служебных директорий, которые необходимо исключить (`.ipynb_checkpoints`, `_experiments`, `__pycache__`, `.git`, `.venv`).
3.  Перебирает заданные файловые паттерны.
4.  Для каждого паттерна выполняет рекурсивный поиск файлов в исходной директории.
5.  Пропускает файлы, находящиеся в исключаемых директориях.
6.  Пропускает файлы, соответствующие исключаемым паттернам.
7.  Читает содержимое файла с кодировкой UTF-8.
8.  Возвращает путь к файлу и его содержимое в виде кортежа.

```
Начало
   ↓
Определение исключаемых паттернов и директорий
   ↓
Перебор файловых паттернов
   ↓
Поиск файлов в директории
   ↓
Проверка на исключение директорий
   ↓
Проверка на исключение паттернов
   ↓
Чтение содержимого файла
   ↓
Возврат (путь к файлу, содержимое)
   ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции yield_files_content
from pathlib import Path
src_path = Path('src')
patterns = ['*.py', '*.txt']
for file_path, content in yield_files_content(src_path, patterns):
    print(f"File: {file_path}")
    print(f"Content: {content[:100]}...")  # Вывод первых 100 символов содержимого