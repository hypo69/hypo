## <algorithm>

1. **הגדרת פונקציית `compare_fruits`:**
   - הפונקציה מקבלת שני פריטים מסוג `Tuple[str, int]` (פירות) כקלט, כאשר כל פריט מכיל סוג פרי (מחרוזת) ומזהה (מספר שלם).
   - מגדירה מילון `order` שממפה את סוגי הפרי לגודל יחסי (🍎:0, 🍐:1, 🍉:2, 🧺:3).
   - משווה את גודל הפירות לפי המיפוי במילון:
     - אם גודל הפרי הראשון קטן מגודל הפרי השני, הפונקציה מחזירה -1.
     - אם גודל הפרי הראשון גדול מגודל הפרי השני, הפונקציה מחזירה 1.
     - אם גדלי הפירות שווים, הפונקציה מחזירה 0.

   *דוגמאות:*
    - `compare_fruits(('🍎', 1), ('🍐', 2))` תחזיר -1.
    - `compare_fruits(('🍉', 3), ('🍐', 4))` תחזיר 1.
    - `compare_fruits(('🍎', 5), ('🍎', 6))` תחזיר 0.

2. **הגדרת פונקציית `bubble_sort` (מיון בועות):**
   - הפונקציה מקבלת רשימה של פירות מסוג `List[Tuple[str, int]]`.
   - עוברת על הרשימה שוב ושוב, ובכל מעבר:
     - משווה בין כל זוג פירות סמוכים.
     - אם הפרי השמאלי גדול מהפרי הימני, הפונקציה מחליפה ביניהם.
   - התהליך נמשך עד שהרשימה ממוינת.
  
   *דוגמה:*
    - עבור רשימה `[('🍉', 1), ('🍎', 2), ('🍐', 3)]`, לאחר מעבר אחד יכול להיות `[('🍎', 2), ('🍉', 1), ('🍐', 3)]`. התהליך ממשיך עד שהרשימה ממוינת.
   
3. **הגדרת פונקציית `insertion_sort` (מיון הכנסה):**
   - הפונקציה מקבלת רשימה של פירות מסוג `List[Tuple[str, int]]`.
   - מתחילה מהפריט השני ברשימה (האינדקס 1), ומתייחסת לחלק הראשון של הרשימה כאל חלק ממוין.
   - לוקחת את הפריט הנוכחי (key) ומשווה אותו עם הפריטים שלפניו בחלק הממוין.
   - אם הפריט הנוכחי קטן מהפריט שלפניו, היא מעבירה את הפריט שלפניו מקום אחד ימינה, עד שהיא מוצאת את המקום הנכון לפריט הנוכחי.
   - מחדירה את הפריט הנוכחי למקומו ברשימה הממוינת.

   *דוגמה:*
    - עבור רשימה `[('🍉', 1), ('🍎', 2), ('🍐', 3)]`,
      - '🍎' נלקח, מושווה עם '🍉', ומוכנס לפניו: `[('🍎', 2), ('🍉', 1), ('🍐', 3)]`.
      - '🍐' נלקח, מושווה עם '🍉' ואחר כך '🍎' ומוכנס בסוף: `[('🍎', 2), ('🍉', 1), ('🍐', 3)]`.

4. **הגדרת פונקציית `selection_sort` (מיון בחירה):**
   - הפונקציה מקבלת רשימה של פירות מסוג `List[Tuple[str, int]]`.
   - עוברת על הרשימה, ובכל מעבר:
     - מוצאת את הפריט הקטן ביותר בחלק הלא ממוין של הרשימה.
     - מחליפה את הפריט הקטן ביותר עם הפריט הראשון בחלק הלא ממוין.
   - התהליך נמשך עד שהרשימה ממוינת.
  
    *דוגמה:*
     - עבור רשימה `[('🍉', 1), ('🍎', 2), ('🍐', 3)]`,
      - '🍎' נמצא כקטן ביותר, ומוחלף עם '🍉': `[('🍎', 2), ('🍉', 1), ('🍐', 3)]`.
      -  '🍐' נשאר במקומו כי הוא הכי קטן מחלק הלא ממוין.
5. **הגדרת פונקציית `display_fruits`:**
   - מקבלת רשימה של פירות ומחזירה מחרוזת המייצגת את הפירות ברשימה.

6. **דוגמת שימוש:**
   - רשימה של פירות נוצרת.
   - הרשימה המקורית מוצגת.
   - מבוצעות העתקים של הרשימה לצורך שימוש בפונקציות מיון שונות.
   - כל אחת משיטות המיון (bubble_sort, insertion_sort, selection_sort) מופעלת על העתק של הרשימה, והתוצאות מוצגות.

## <mermaid>

```mermaid
flowchart TD
    subgraph compare_fruits
        A[התחלה] --> B{הגדרת מילון סדר};
        B --> C[קבלת גודל פרי ראשון];
        C --> D[קבלת גודל פרי שני];
        D --> E{גודל פרי ראשון < גודל פרי שני?};
        E -- כן --> F[החזר -1];
        E -- לא --> G{גודל פרי ראשון > גודל פרי שני?};
        G -- כן --> H[החזר 1];
        G -- לא --> I[החזר 0];
        F --> J[סוף];
        H --> J;
        I --> J;
    end
    subgraph bubble_sort
      A1[התחלה] --> B1[קבלת רשימת פירות];
      B1 --> C1{יש פירות לא ממוינים?};
      C1 -- כן --> D1[סריקת כל הפירות];
      D1 --> E1[השוואת פירות סמוכים];
      E1 --> F1{הפרי השמאלי > הפרי הימני?};
      F1 -- כן --> G1[החלפת פירות];
      G1 --> H1[סיום סריקה];
      F1 -- לא --> H1;
      H1 --> I1{האם בוצע שינוי בסריקה?};
      I1 -- כן --> C1;
      I1 -- לא --> J1[החזר רשימה ממוינת];
      C1 -- לא --> J1;
      J1 --> K1[סוף];
    end
    subgraph insertion_sort
        A2[התחלה] --> B2[קבלת רשימת פירות];
        B2 --> C2[מעבר על הרשימה החל מהפריט השני];
        C2 --> D2[לקיחת פריט נוכחי (key)];
        D2 --> E2[השוואת הפריט הנוכחי עם הפריטים לפניו בחלק הממוין];
        E2 --> F2{הפריט הנוכחי קטן מהפריט הקודם?};
        F2 -- כן --> G2[הזזת הפריט הקודם מקום ימינה];
        G2 --> H2[האם הגענו לתחילת החלק הממוין?];
          H2 -- כן --> I2[החדרת הפריט הנוכחי];
          H2 -- לא --> E2;
        F2 -- לא --> I2;
        I2 --> J2{האם סיימנו לעבור על כל הרשימה?};
         J2 -- לא --> C2;
         J2 -- כן --> K2[החזר רשימה ממוינת];
        K2 --> L2[סוף];
    end
    subgraph selection_sort
        A3[התחלה] --> B3[קבלת רשימת פירות];
        B3 --> C3[מעבר על הרשימה];
        C3 --> D3[בחירת פריט מינימלי בחלק הלא ממוין];
        D3 --> E3[החלפת הפריט המינימלי עם הפריט הראשון בחלק הלא ממוין];
        E3 --> F3{האם סיימנו לעבור על כל הרשימה?};
        F3 -- לא --> C3;
        F3 -- כן --> G3[החזר רשימה ממוינת];
        G3 --> H3[סוף];
    end
    subgraph display_fruits
        A4[התחלה] --> B4[קבלת רשימת פירות];
        B4 --> C4[יצירת מחרוזת פלט מפורמטת];
        C4 --> D4[החזרת מחרוזת];
        D4 --> E4[סוף];
    end
    compare_fruits --> bubble_sort
    compare_fruits --> insertion_sort
    compare_fruits --> selection_sort
    bubble_sort --> display_fruits
    insertion_sort --> display_fruits
    selection_sort --> display_fruits
```

## <explanation>

**ייבוא (Imports):**

-   `from typing import List, Tuple`: מייבא את הטיפוסים `List` ו- `Tuple` מודול ה- `typing`. משמשים לצורך הגדרת טיפוסי נתונים (type hints) לפונקציות ולמשתנים, מה שמגביר את קריאות הקוד ואת היכולת לזהות שגיאות בזמן פיתוח.

**פונקציות (Functions):**

1.  **`compare_fruits(fruit1, fruit2)`:**
    -   **פרמטרים:**
        -   `fruit1`:  `Tuple[str, int]` - פריט ראשון (סוג פרי, מזהה).
        -   `fruit2`:  `Tuple[str, int]` - פריט שני (סוג פרי, מזהה).
    -   **ערך מוחזר:** `int` - ערך המשווה בין גודל הפירות:
        -   `-1`: אם גודל `fruit1` קטן מ-`fruit2`.
        -   `1`: אם גודל `fruit1` גדול מ-`fruit2`.
        -   `0`: אם גודל `fruit1` שווה לגודל `fruit2`.
    -   **מטרה:** משמשת להשוואת גדלי פירות שונים (🍎, 🍐, 🍉, 🧺), תוך שימוש במילון `order` למיפוי גדלי הפירות למספרים. הפונקציה חיונית עבור כל אלגוריתמי המיון שבהם משתמשים להשוואת איברי הרשימה.
    -   **דוגמה לשימוש:** `compare_fruits(('🍎', 1), ('🍐', 2))` תחזיר `-1` כי תפוח קטן מאגס.

2.  **`bubble_sort(fruits)`:**
    -   **פרמטרים:**
        -   `fruits`:  `List[Tuple[str, int]]` - רשימה של פירות.
    -   **ערך מוחזר:** `List[Tuple[str, int]]` - רשימה ממוינת של פירות.
    -   **מטרה:** ממיינת את רשימת הפירות באמצעות אלגוריתם מיון בועות. האלגוריתם פועל על ידי השוואה בין זוגות פירות סמוכים והחלפתם אם הם לא בסדר הנכון.
    -   **דוגמה לשימוש:** `bubble_sort([('🍉', 1), ('🍎', 2), ('🍐', 3)])` תחזיר `[('🍎', 2), ('🍐', 3), ('🍉', 1)]`.

3.  **`insertion_sort(fruits)`:**
    -   **פרמטרים:**
        -   `fruits`:  `List[Tuple[str, int]]` - רשימה של פירות.
    -   **ערך מוחזר:** `List[Tuple[str, int]]` - רשימה ממוינת של פירות.
    -   **מטרה:** ממיינת את רשימת הפירות באמצעות אלגוריתם מיון הכנסה. האלגוריתם פועל על ידי מעבר על הרשימה והכנסת כל איבר למקומו הנכון בחלק הממוין של הרשימה.
    -   **דוגמה לשימוש:** `insertion_sort([('🍉', 1), ('🍎', 2), ('🍐', 3)])` תחזיר `[('🍎', 2), ('🍐', 3), ('🍉', 1)]`.

4.  **`selection_sort(fruits)`:**
    -   **פרמטרים:**
        -   `fruits`:  `List[Tuple[str, int]]` - רשימה של פירות.
    -   **ערך מוחזר:** `List[Tuple[str, int]]` - רשימה ממוינת של פירות.
    -   **מטרה:** ממיינת את רשימת הפירות באמצעות אלגוריתם מיון בחירה. האלגוריתם פועל על ידי מציאת האיבר הקטן ביותר בחלק הלא ממוין והחלפתו עם האיבר הראשון בחלק זה.
    -   **דוגמה לשימוש:** `selection_sort([('🍉', 1), ('🍎', 2), ('🍐', 3)])` תחזיר `[('🍎', 2), ('🍐', 3), ('🍉', 1)]`.

5. **`display_fruits(fruits)`:**
    - **פרמטרים:**
        - `fruits`:  `List[Tuple[str, int]]` - רשימה של פירות.
    - **ערך מוחזר:** `str` - מחרוזת המייצגת את רשימת הפירות.
    - **מטרה:** מקבלת רשימה של פירות ויוצרת מהם מחרוזת קריאה, שמציגה את הפירות אחד אחרי השני, כאשר כל פרי מיוצג ע"י סוגו ומזהה שלו.
    - **דוגמא לשימוש:** `display_fruits([('🍎', 1), ('🍐', 2)])` תחזיר "🍎1, 🍐2".

**משתנים (Variables):**

-   `order`: מילון הממפה סוגי פירות לגודלם היחסי (`{"🍎": 0, "🍐": 1, "🍉": 2, "🧺": 3}`).
-   `fruits`: רשימה של פירות (כל פרי מיוצג כטופל של סוג הפרי והמזהה שלו).
-   `sorted_fruits_bubble`, `sorted_fruits_insertion`, `sorted_fruits_selection`: משתנים המכילים את הרשימות הממוינות לאחר הפעלת אלגוריתמי המיון השונים.

**בעיות אפשריות או תחומים לשיפור:**

-   **יעילות:** אלגוריתמים מיון כמו מיון בועות, הכנסה ובחירה אינם יעילים במיוחד עבור רשימות גדולות. למיון רשימות גדולות, ניתן להשתמש באלגוריתמי מיון יעילים יותר כמו מיון מיזוג או מיון מהיר.
-   **קריאות הקוד:** ניתן לשפר את קריאות הקוד על ידי שימוש בשמות משתנים יותר ברורים.
-   **גמישות:** הקוד בנוי ספציפית לפירות ולא ניתן להשתמש בו ללא שינוי עבור סוגי נתונים אחרים.
-  **בדיקות:** אין בדיקות אוטומטיות ליחידות קוד, דבר שעשוי להקשות על שינוי או הוספה של תכונות.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

-   הקוד מהווה דוגמה לאלגוריתמי מיון בסיסיים ואינו קשור ישירות לחלקים אחרים של פרויקט `hypotez`.
-   הוא יכול לשמש כמודול בסיסי להבנת מיון נתונים, שניתן להשתמש בו במקומות שונים בפרויקט, אם צריך למיין נתונים מסוג מסוים.

הקוד מספק מבוא טוב לאלגוריתמי מיון שונים וכיצד הם עובדים על נתונים בפועל, תוך שימוש בדוגמה קונקרטית של מיון פירות לפי גודל.