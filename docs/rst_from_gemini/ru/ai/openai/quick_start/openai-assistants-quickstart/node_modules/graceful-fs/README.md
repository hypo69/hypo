```markdown
# graceful-fs

graceful-fs działa jako bezpośrednie zastąpienie modułu `fs`, wprowadzając liczne ulepszenia.

Ulepszenia mają na celu znormalizowanie zachowania na różnych platformach i środowiskach oraz zwiększenie odporności dostępu do systemu plików na błędy.

## Ulepszenia w stosunku do modułu `fs`

* Kolejkuje wywołania `open` i `readdir` oraz powtarza je po zamknięciu czegoś, jeśli wystąpi błąd `EMFILE` z powodu zbyt wielu deskryptorów plików.
* Poprawia `lchmod` dla wersji Node wcześniejszych niż 0.6.2.
* Wdraża `fs.lutimes`, jeśli to możliwe. W przeciwnym razie staje się bezczynny.
* Ignoruje błędy `EINVAL` i `EPERM` w `chown`, `fchown` lub `lchown`, jeśli użytkownik nie jest root'em.
* Sprawia, że `lchmod` i `lchown` stają się bezczynne, jeśli nie są dostępne.
* Powtarza odczyt pliku, jeśli `read` zwróci błąd `EAGAIN`.

W systemie Windows powtarza przechwytywanie pliku do jednej sekundy, jeśli wystąpi błąd `EACCESS` lub `EPERM`, prawdopodobnie z powodu blokady oprogramowania antywirusowego.

## ZASTOSOWANIE

```javascript
// Użyj jak modułu fs
const fs = require('graceful-fs')

// Teraz możesz użyć go w swoich operacjach...
fs.readFile('jakiś_plik_lub_cokolwiek', (err, data) => {
  // Wykonaj tutaj operacje.
})
```

## Metody synchroniczne

Ten moduł nie może przechwytywać ani obsługiwać błędów `EMFILE` lub `ENFILE` z metod synchronicznych. Jeśli używasz metod synchronicznych, które otwierają deskryptory plików, to musisz sam zająć się potencjalnymi błędami.

Jest to znana ograniczona funkcjonalność, a nie błąd.

## Globalne zaktualizowanie

Jeśli chcesz zaktualizować globalny moduł `fs` (lub inny moduł podobny do `fs`), możesz to zrobić w następujący sposób:

```javascript
// Upewnij się, że przeczytałeś uwage poniżej.
const realFs = require('fs')
const gracefulFs = require('graceful-fs')
gracefulFs.gracefulify(realFs)
```

Należy to robić tylko na poziomie aplikacji, aby opóźnić błędy `EMFILE` od zależności wykorzystujących `fs`. **Nie** należy tego robić w bibliotece, ponieważ może to spowodować nieoczekiwane opóźnienia w innych częściach programu.

## Zmiany

Ten moduł jest w tym momencie dość stabilny i jest używany przez wiele rzeczy. Pomimo tego, ponieważ implementuje subtelną zmianę zachowania w rdzennej części API Node.js, nawet niewielkie zmiany mogą być bardzo destrukcyjne, a wersjonowanie jest więc nastawione na zwiększanie głównej wersji w razie wątpliwości.

Najważniejszą zmianą między większymi wersjami było przełączanie się między pełnym zaktualizowaniem modułu `fs` a nakładaniem łat na rdzeniowy moduł wbudowany w Node.js oraz metoda tworzenia modułu `fs` bez takich łat.

Celem jest wymiana błędów `EMFILE` na wolniejsze operacje na systemie plików. Oznacza to, że jeśli próbujesz otworzyć miliony plików, zamiast awarii, operacje `open` będą kolejkowane i będą czekały na coś innego, co wykona `close`.

Każda z metod ma swoje wady i zalety. Nakładanie łat na moduł `fs` oznacza, że żaden błąd `EMFILE` nie może wystąpić w aplikacji, ponieważ wszystko korzysta z tego samego modułu `fs`, który został zmodyfikowany. Jednak może to także prowadzić do niepożądanych skutków ubocznych, szczególnie jeśli moduł jest ładowany wiele razy.

Implementacja osobnego, ale identycznego, zmodyfikowanego modułu `fs` jest bardziej precyzyjna (i nie stwarza ryzyka wielokrotnego nakładania łat), ale stwarza również wyzwanie w utrzymywaniu synchronizacji z modułem rdzeniowym.

Obecne podejście polega na załadowaniu modułu `fs` i utworzeniu podobnego obiektu, który ma wszystkie te same metody, z wyjątkiem kilku, które zostały zmodyfikowane. Jest to bezpieczne w użyciu we wszystkich wersjach Node od 0.8 do 7.0.

### v4

* Nie nakładaj łat na moduł `fs`. Moduł ten można teraz używać jako moduł drop-in, a użytkownicy mogą zdecydować się na nakładanie łat na wbudowany moduł `fs`, jeśli wymaga tego ich aplikacja.

### v3

* Nakładanie łat na moduł `fs`, ponieważ podejście z `eval` nie działa w najnowszych wersjach Node.js.
* Naprawiono możliwy błąd typu, jeśli przechwytywanie plików nie powiodło się w systemie Windows.
* Sprawdź, że *nigdy* nie wystąpi błąd `EMFILE`.
* Ignoruj `ENOSYS` z `chmod`/`chown`.
* Podaj jasno, że graceful-fs musi być używany jako moduł drop-in.

### v2.1.0

* Użyj `eval` zamiast nakładania łat na `fs`.
* `readdir`: Zawsze sortuj wyniki.
* `win32`: Ponownie wstaw plik, jeśli błąd ma status OK.

### v2.0

* Powrót do nakładania łat.
* Otoczenie `process.cwd()`.

### v1.1

* Otoczenie `readFile`.
* Otoczenie `fs.writeFile`.
* Ochrona `readdir`.
* Nie nadpisuj wbudowanego `fs`.
* Obsługa błędów `fs.read EAGAIN` poprzez ponowne próby.
* Dostęp do licznika `curOpen`.
* Nieopcjonalne `lchown`/`lchmod`, jeśli nie są zaimplementowane.
* Zaktualizowanie łat do `fs.rename` tylko dla `win32`.
* Łaty do `fs.rename` dla obsługi oprogramowania antywirusowego w systemie Windows.
* Zamknięcie problemu #4 Chown nie powinien zawieszać się na `einval` lub `eperm`, jeśli użytkownik nie jest root'em.
* Naprawa problemu isaacs/fstream#1: tylko raz zaktualizuj `fs`.
* Naprawa problemu #3: Początkowa wartość maksymalnej liczby plików to 1024, a następnie redukcja w przypadku `EMFILE`.
* `lutimes` nie powodujący awarii w systemie Linux.
* Pełna przebudowa z użyciem kolejki zamiast po prostu ignorowania błędu `EMFILE`.
* Otoczenie strumieni Read/Write.

### 1.0

* Zaktualizuj wymagania dla Node.js 0.6.
* Bądź `lstat`-łagodny w systemie Windows.
* Pierwsza wersja
```
