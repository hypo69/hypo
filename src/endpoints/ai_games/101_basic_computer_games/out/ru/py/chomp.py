"""
CHOMP:
=================
Сложность: 5
-----------------
Игра "CHOMP" - это игра для двух игроков, в которой они по очереди "съедают" (выбирают) ячейку на прямоугольной доске. При этом, если ячейка выбрана, то и все ячейки справа и снизу от неё тоже считаются "съеденными". Цель игры - заставить противника выбрать "отравленную" ячейку в левом верхнем углу (1,1).

Правила игры:
1. Игроки по очереди выбирают ячейки на доске.
2. При выборе ячейки, все ячейки справа и снизу от неё, также становятся "съеденными".
3. Игрок, выбравший ячейку в левом верхнем углу (1,1), проигрывает.

-----------------
Алгоритм:
1.  Инициализация доски: создание доски заданного размера, где каждая ячейка изначально "не съедена".
2.  Начало цикла "пока игра не закончена":
    2.1  Вывод текущего состояния доски.
    2.2  Запрос ввода координат ячейки от текущего игрока.
    2.3  Проверка корректности ввода координат (находятся ли они в пределах доски).
    2.4  Если координаты некорректны, повторить ввод.
    2.5  "Съедание" выбранной ячейки и всех ячеек справа и снизу от нее.
    2.6  Проверка, выбрана ли "отравленная" ячейка (1,1). Если да, то текущий игрок проиграл, игра заканчивается.
    2.7  Переход к следующему игроку.
3. Конец игры. Вывод сообщения о победе другого игрока.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["Инициализация доски"]
    InitializeBoard --> GameLoopStart{"Начало цикла: пока не конец игры"}
    GameLoopStart --> DisplayBoard["Вывод доски"]
    DisplayBoard --> GetMove["Ввод координат ячейки игроком"]
    GetMove --> ValidateMove{"Проверка: корректность ввода координат?"}
    ValidateMove -- Да --> EatCells["'Съедение' ячеек"]
    EatCells --> CheckWin{"Проверка: выбрана отравленная ячейка?"}
    CheckWin -- Да --> OutputLose["Вывод сообщения: Игрок проиграл"]
    OutputLose --> End["Конец"]
    CheckWin -- Нет --> SwitchPlayer["Переход хода"]
    SwitchPlayer --> GameLoopStart
    ValidateMove -- Нет --> GetMove

```

Legenda:
    Start - Начало программы.
    InitializeBoard - Инициализация игрового поля.
    GameLoopStart - Начало основного игрового цикла, который продолжается до конца игры.
    DisplayBoard - Вывод текущего состояния игрового поля на экран.
    GetMove - Запрос у текущего игрока ввода координат ячейки.
    ValidateMove - Проверка корректности введенных координат.
    EatCells - "Съедение" выбранной ячейки и всех ячеек справа и снизу от нее.
    CheckWin - Проверка, выбрана ли "отравленная" ячейка (1, 1).
    OutputLose - Вывод сообщения о проигрыше текущего игрока.
    End - Конец игры.
    SwitchPlayer - Переход хода к другому игроку.
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
# licence:MIT(../licence)
"""
Пояснения:
1.  **Инициализация переменных**:
    -   `board_height` и `board_width`: задают размеры доски.
    -   `board`: двумерный список, представляющий игровое поле. Изначально все ячейки заполнены `0`, что означает "не съедены".
    -   `current_player`: переменная, отслеживающая текущего игрока (1 или 2).
    -   `game_over`: флаг, который становится `True`, когда игра заканчивается.

2.  **Функция `display_board()`**:
    -   Выводит текущее состояние игрового поля в консоль. `X` обозначает съеденные ячейки, а `0` - не съеденные.

3.  **Функция `get_player_move()`**:
    -   Запрашивает у текущего игрока координаты ячейки, которую он хочет "съесть".
    -   Выполняет проверки ввода (корректный формат, в пределах доски).
    -   Возвращает координаты в виде кортежа `(row, col)`.

4.  **Функция `eat_cells(row, col)`**:
    -   Помечает выбранную ячейку и все ячейки справа и снизу от неё как "съеденные" (`X`).

5.  **Функция `check_win(row, col)`**:
    -   Проверяет, была ли выбрана "отравленная" ячейка `(1, 1)`. Если да, то игра завершается, и текущий игрок проигрывает.

6.  **Основной игровой цикл**:
    -   Выводит текущее состояние доски.
    -   Получает ввод от игрока.
    -   "Съедает" выбранные ячейки.
    -   Проверяет, не выиграл ли игрок (съел отравленную ячейку).
    -   Переключает текущего игрока.
    -   Цикл продолжается, пока игра не закончится.

7.  **Вывод результатов**:
    -   После окончания игры выводится сообщение, какой игрок проиграл.
"""
def play_chomp():
    board_height = 8
    board_width = 8
    board = [['0' for _ in range(board_width)] for _ in range(board_height)]
    current_player = 1
    game_over = False

    def display_board():
        for row in board:
            print(' '.join(row))

    def get_player_move():
        while True:
            try:
                move = input(f"Игрок {current_player}, введите координаты ячейки (строка, столбец через пробел): ").split()
                row, col = int(move[0]) - 1, int(move[1]) - 1
                if 0 <= row < board_height and 0 <= col < board_width:
                     return row, col
                else:
                   print("Некорректные координаты. Попробуйте еще раз.")
            except (ValueError, IndexError):
              print("Некорректный ввод. Попробуйте еще раз.")

    def eat_cells(row, col):
        for i in range(row, board_height):
            for j in range(col, board_width):
                board[i][j] = 'X'

    def check_win(row, col):
         return row == 0 and col == 0
    
    while not game_over:
        display_board()
        row, col = get_player_move()
        eat_cells(row, col)

        if check_win(row, col):
            print(f"Игрок {current_player} проиграл!")
            game_over = True
        else:
            current_player = 3 - current_player  # Переключение игрока

if __name__ == "__main__":
    play_chomp()
"""
Пояснения:
1.  **Инициализация переменных**:
    -   `board_height` и `board_width`: задают размеры доски.
    -   `board`: двумерный список, представляющий игровое поле. Изначально все ячейки заполнены `0`, что означает "не съедены".
    -   `current_player`: переменная, отслеживающая текущего игрока (1 или 2).
    -   `game_over`: флаг, который становится `True`, когда игра заканчивается.

2.  **Функция `display_board()`**:
    -   Выводит текущее состояние игрового поля в консоль. `X` обозначает съеденные ячейки, а `0` - не съеденные.

3.  **Функция `get_player_move()`**:
    -   Запрашивает у текущего игрока координаты ячейки, которую он хочет "съесть".
    -   Выполняет проверки ввода (корректный формат, в пределах доски).
    -   Возвращает координаты в виде кортежа `(row, col)`.

4.  **Функция `eat_cells(row, col)`**:
    -   Помечает выбранную ячейку и все ячейки справа и снизу от неё как "съеденные" (`X`).

5.  **Функция `check_win(row, col)`**:
    -   Проверяет, была ли выбрана "отравленная" ячейка `(1, 1)`. Если да, то игра завершается, и текущий игрок проигрывает.

6.  **Основной игровой цикл**:
    -   Выводит текущее состояние доски.
    -   Получает ввод от игрока.
    -   "Съедает" выбранные ячейки.
    -   Проверяет, не выиграл ли игрок (съел отравленную ячейку).
    -   Переключает текущего игрока.
    -   Цикл продолжается, пока игра не закончится.

7.  **Вывод результатов**:
    -   После окончания игры выводится сообщение, какой игрок проиграл.
"""
