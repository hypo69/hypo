# Анализ кода модуля `boxing.py`

**Качество кода**
    
-   **Соответствие требованиям к формату кода (1-10):** 
    -  **1/10** Исходный код не соответствует требованиям.
-  **Преимущества**
    - Код игры в бокс, который работает, по крайней мере, в базовом функционале.
    - Есть блок-схема в формате Mermaid, что делает понимание логики кода наглядным.
    - Код достаточно простой и его легко понять даже без детальных комментариев.
-  **Недостатки**
    - Код не имеет документации в стиле reStructuredText (RST).
    - Отсутствуют необходимые импорты из `src.utils.jjson` и `src.logger.logger`.
    - Обработка ошибок выполняется не через `logger.error`, а с помощью стандартных блоков `try-except`.
    - Код не структурирован в виде функций, что делает его менее модульным и переиспользуемым.
    - Нет разделения на логику игры и интерфейс пользователя.

**Рекомендации по улучшению**

1.  **Документирование кода**:
    - Добавить docstring в стиле RST для модуля, функций и переменных.
2.  **Импорты**:
    - Добавить импорты для `j_loads`, `j_loads_ns` из `src.utils.jjson` и `logger` из `src.logger.logger`.
3.  **Обработка ошибок**:
    - Заменить стандартные блоки `try-except` на использование `logger.error` для логирования ошибок.
4.  **Структурирование кода**:
    - Разбить код на функции для инициализации игры, хода игрока, проверки попадания и определения победителя.
5.  **Улучшение читаемости**:
    - Добавить понятные комментарии к коду, поясняющие его логику и работу.
    - Использовать осмысленные имена переменных.
6.  **Интерфейс пользователя**:
    - Рассмотреть возможность улучшения интерфейса пользователя, чтобы сделать игру более интерактивной.

**Улучшенный код**

```python
"""
Модуль представляет собой текстовую имитацию боксерского поединка между двумя игроками.
=========================================================================================

В игре два игрока по очереди наносят удары, выбирая их силу (слабый, средний, сильный),
и компьютер случайным образом определяет, попал ли удар. Игра продолжается до тех пор,
пока один из боксеров не будет нокаутирован (его счетчик здоровья не достигнет 0).

Пример использования
--------------------

.. code-block:: python

    from src.endpoints.ai_games.101_basic_computer_games.ru.GAMES.BOXING import boxing
    boxing.play_boxing_game()

"""
import random  # Импортируется модуль random для генерации случайных чисел.
from src.logger.logger import logger # Импортируется logger для логирования ошибок.


def initialize_game() -> tuple[int, int, int]:
    """
    Инициализирует начальное состояние игры.

    :return: Кортеж с начальным здоровьем первого игрока, начальным здоровьем второго игрока и номером текущего игрока.
    :rtype: tuple[int, int, int]
    """
    player1_health = 10  # Устанавливает начальное здоровье первого игрока.
    player2_health = 10  # Устанавливает начальное здоровье второго игрока.
    current_player = 1  # Устанавливает первого игрока как текущего.
    return player1_health, player2_health, current_player


def get_player_attack(current_player: int) -> int:
    """
    Запрашивает у игрока выбор типа удара.

    :param current_player: Номер текущего игрока.
    :type current_player: int
    :return: Выбранный тип удара (1 - слабый, 2 - средний, 3 - сильный).
    :rtype: int
    """
    while True:  # Запускает бесконечный цикл, пока не будет введен корректный вариант.
        try:
            attack_type = int(input(f"Игрок {current_player}, выберите силу удара (1-слабый, 2-средний, 3-сильный): ")) # Запрашивает у текущего игрока выбор силы удара.
            if attack_type in [1, 2, 3]: # Проверяет корректность введенных данных.
                return attack_type # Возвращает введенный тип удара.
            else:
                print("Некорректный ввод. Пожалуйста, выберите 1, 2 или 3.") # Выводит сообщение об ошибке.
        except ValueError:
             logger.error(f'Некорректный ввод {attack_type=}, ожидается целое число 1,2,3', exc_info=True) # Записывает ошибку в лог.
             print("Некорректный ввод. Пожалуйста, введите число.") # Выводит сообщение об ошибке.
         
def check_hit(attack_type: int) -> bool:
     """
     Проверяет, попал ли удар, в зависимости от типа удара и случайного числа.

     :param attack_type: Тип удара, выбранный игроком.
     :type attack_type: int
     :return: True, если удар попал, False, если нет.
     :rtype: bool
     """
     random_num = random.randint(1, 100) # Генерирует случайное число от 1 до 100.
     if attack_type == 1 and random_num <= 80: # Проверяет условия для слабого удара.
         return True
     elif attack_type == 2 and random_num <= 60: # Проверяет условия для среднего удара.
        return True
     elif attack_type == 3 and random_num <= 40: # Проверяет условия для сильного удара.
         return True
     return False # Возвращает False, если условия для попадания не выполнены.

def update_health(player1_health: int, player2_health: int, current_player: int, hit: bool) -> tuple[int, int]:
     """
     Обновляет здоровье игроков в зависимости от того, попал ли удар.

     :param player1_health: Текущее здоровье первого игрока.
     :type player1_health: int
     :param player2_health: Текущее здоровье второго игрока.
     :type player2_health: int
     :param current_player: Номер текущего игрока.
     :type current_player: int
     :param hit: True, если удар попал, False, если нет.
     :type hit: bool
     :return: Кортеж с обновленным здоровьем первого и второго игроков.
     :rtype: tuple[int, int]
     """
     if hit:  # Проверяет, попал ли удар.
         print("Удар достиг цели!") # Выводит сообщение об успехе.
         if current_player == 1: # Проверяет, какой игрок нанес удар.
             player2_health -= 1  # Уменьшает здоровье второго игрока.
         else:
             player1_health -= 1  # Уменьшает здоровье первого игрока.
     else:
         print("Удар не достиг цели.") # Выводит сообщение о неудаче.
     return player1_health, player2_health

def switch_player(current_player: int) -> int:
    """
    Переключает ход на следующего игрока.

    :param current_player: Номер текущего игрока.
    :type current_player: int
    :return: Номер следующего игрока.
    :rtype: int
    """
    return 3 - current_player  # Переключает текущего игрока (если был 1, то станет 2 и наоборот).

def determine_winner(player1_health: int, player2_health: int) -> None:
     """
     Определяет победителя игры и выводит сообщение о результате.

     :param player1_health: Здоровье первого игрока на момент окончания игры.
     :type player1_health: int
     :param player2_health: Здоровье второго игрока на момент окончания игры.
     :type player2_health: int
     """
     if player1_health <= 0: # Проверяет, если здоровье первого игрока стало 0 или меньше.
         print("Игрок 2 победил!") # Выводит сообщение о победе второго игрока.
     else:
         print("Игрок 1 победил!") # Выводит сообщение о победе первого игрока.

def play_boxing_game() -> None:
    """
    Запускает основной игровой цикл.
    """
    player1_health, player2_health, current_player = initialize_game() # Инициализация начальных параметров игры.
    while player1_health > 0 and player2_health > 0: # Запускает основной игровой цикл, который продолжается, пока здоровье обоих игроков больше 0.
         print(f"Здоровье игрока 1: {player1_health}, Здоровье игрока 2: {player2_health}") # Выводит текущее здоровье игроков.
         attack_type = get_player_attack(current_player)  # Запрашивает выбор типа удара у текущего игрока.
         hit = check_hit(attack_type) # Проверяет, попал ли удар.
         player1_health, player2_health = update_health(player1_health, player2_health, current_player, hit) # Обновляет здоровье игроков в зависимости от попадания.
         current_player = switch_player(current_player) # Переключает ход на следующего игрока.
    determine_winner(player1_health, player2_health) # Выводит сообщение о победителе.

if __name__ == '__main__':
    play_boxing_game() # Запускает игру, если скрипт запущен как основная программа.
```