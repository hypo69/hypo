## Ответ на Задачу No 274: Сумма обратных модульных остатков

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Необходимо вычислить функцию $f(n)$, которая находит обратное по модулю $10^9 + 7$ для числа $n$. Если обратного элемента не существует, $f(n) = 0$.
*   Далее, нужно вычислить функцию $g(n)$, которая является суммой значений $f(i)$ для всех $i$ от 1 до $n$.
*   Финальная задача - найти $g(10^7) \mod (10^9 + 7)$.

**Решение:**

1.  **Обратный элемент по модулю:**
    *   Для нахождения обратного по модулю числа $n$ относительно модуля $m$, мы ищем число $x$, такое что $nx \equiv 1 \pmod{m}$.
    *   Если НОД$(n, m) = 1$, то обратный элемент существует и его можно найти с помощью расширенного алгоритма Евклида или с помощью малой теоремы Ферма (если $m$ - простое). В нашем случае модуль $10^9 + 7$ является простым, поэтому можем использовать малую теорему Ферма. Она гласит, что если $p$ - простое число, то для любого целого $a$, не кратного $p$, верно $a^{p-1} \equiv 1 \pmod{p}$. Отсюда следует, что обратный элемент к $n$ по модулю $p$ можно найти как $n^{p-2} \pmod{p}$.
    *   Если НОД$(n, m) \ne 1$, обратного элемента не существует, и в этом случае $f(n) = 0$. В нашем случае, это означает, что если `n` делится на $10^9+7$, то `f(n) = 0`.

2.  **Вычисление g(n):**
    *   Итерируем по всем числам от 1 до $n$.
    *   Для каждого $i$ вычисляем $f(i)$, используя обратное по модулю (или 0, если его нет).
    *   Накапливаем сумму этих значений.
    *   Берем остаток от деления на $10^9 + 7$.

3.  **Оптимизации:**
    *   Так как $n = 10^7$, и нужно выполнять $10^7$ раз возведение в степень по модулю, то можно использовать бинарное возведение в степень, чтобы сократить время вычислений.

### 2. Алгоритм решения

1.  Начать
2.  Задать модуль `mod = 10^9 + 7`
3.  Инициализировать переменную `total_sum` со значением 0
4.  Для каждого числа `i` от 1 до `limit = 10^7`
    *   Если `i` делится на `mod` без остатка
        *   `inverse = 0`
    *   Иначе
        *   Вычислить обратный элемент `inverse`  по модулю `mod` как `i^(mod-2) mod mod` (используя бинарное возведение в степень)
    *   Прибавить `inverse` к `total_sum`
    *   Взять остаток от деления `total_sum` на `mod`
5.  Вернуть `total_sum`
6.  Конец

### 3. Реализация на Python 3.12

```python
def power(base, exp, mod):
    """Calculates (base^exp) % mod using binary exponentiation."""
    res = 1
    base %= mod
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2
    return res

def modular_inverse(n, mod):
    """Calculates the modular inverse using Fermat's Little Theorem."""
    if n % mod == 0:
        return 0
    return power(n, mod - 2, mod)


def sum_of_modular_inverses(limit, mod):
    """Calculates the sum of modular inverses modulo mod."""
    total_sum = 0
    for i in range(1, limit + 1):
        inverse = modular_inverse(i, mod)
        total_sum = (total_sum + inverse) % mod
    return total_sum

# Example usage:
MOD = 10**9 + 7
LIMIT = 10**7
result = sum_of_modular_inverses(LIMIT, MOD)
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeModAndSum((Инициализировать mod = 10^9 + 7, total_sum = 0))
    InitializeModAndSum --> LoopStart((Начать цикл: i от 1 до 10^7))
    LoopStart --> CheckDivisibility((Проверить: i делится на mod?))
    CheckDivisibility -- Да --> AssignInverseZero((inverse = 0))
    AssignInverseZero --> AddToSum((total_sum = (total_sum + inverse) % mod))
    CheckDivisibility -- Нет --> CalculateInverse((Вычислить inverse = (i^(mod-2)) mod mod))
    CalculateInverse --> AddToSum
    AddToSum --> LoopStart
    LoopStart --> End((Конец))
    
```
**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать mod и total_sum:** Задаем константу mod и переменную для хранения результата,  `total_sum`,  равной 0.
*  **Начать цикл:** Определяет начало цикла перебора чисел от 1 до 10^7.
*  **Проверить: i делится на mod?:** Проверяем, делится ли текущее число `i` на модуль.
*   **inverse = 0:** Если i делится на mod, то обратный элемент не существует,  `inverse = 0`.
*   **Вычислить inverse = (i^(mod-2)) mod mod:** Вычисление обратного элемента по модулю с использованием бинарного возведения в степень.
* **total_sum = (total_sum + inverse) % mod**: Суммируем полученный обратный элемент и берём остаток по модулю.
*  **Конец цикла:** Завершение цикла.
