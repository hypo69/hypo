# Анализ кода модуля `revrse.py`

**Качество кода**
8
-  Плюсы
    - Код хорошо структурирован и разбит на логические функции, что улучшает читаемость.
    - Используются осмысленные имена переменных и функций.
    - Код содержит подробные комментарии, объясняющие логику работы.
    - Присутствует блок-схема, описывающая алгоритм игры.
-  Минусы
    - Отсутствует документация в формате RST, как это было запрошено в инструкции.
    - Не используется `j_loads` или `j_loads_ns` из `src.utils.jjson`, хотя это не требуется, так как нет работы с json файлами.
    - Отсутствует логирование ошибок с использованием `from src.logger.logger import logger`.
    - Присутствуют избыточные try-except блоки для обработки ошибок ввода, что можно улучшить.
    - В комментариях используются слова "получаем" и т.п.
    - Код не соответствует PEP8 по длине строк.

**Рекомендации по улучшению**

1.  **Документация RST:**
    - Необходимо переписать все комментарии и docstring в формате reStructuredText (RST), как указано в инструкции.

2.  **Логирование ошибок:**
    -   Использовать `from src.logger.logger import logger` и добавить логирование ошибок вместо `print` для лучшей отладки и мониторинга.

3.  **Улучшение обработки ошибок**:
    -  Избавиться от `try-except` для проверки ввода данных и вынести проверку на валидность данных в отдельную функцию, либо упростить.

4.  **Стиль кода**:
    -   Соблюдать PEP8, особенно длину строк.
    - Переписать комментарии, избегая слов "получаем", "делаем" и т.п.

**Оптимизированный код**
```python
"""
Модуль для реализации игры REVRSE.
===================================

Игра REVRSE - это игра, в которой игрок должен угадать
последовательность из 4 цифр, сгенерированных компьютером.

Описание игры
-------------
Компьютер генерирует последовательность из 4 случайных цифр от 1 до 6.
Игрок вводит свою последовательность, также из 4 цифр.
После каждой попытки компьютер сообщает количество прямых и косвенных
попаданий.
Игра продолжается до тех пор, пока игрок не угадает последовательность
или не исчерпает 10 попыток.

Пример использования
--------------------
.. code-block:: python

    play_reverse_game()
"""
import random
# from src.logger.logger import logger # TODO: Добавить импорт логгера

def generate_target_sequence() -> list[int]:
    """
    Генерирует случайную последовательность из 4 цифр от 1 до 6.

    :return: Список из 4 случайных целых чисел.
    :rtype: list[int]
    """
    return [random.randint(1, 6) for _ in range(4)]

def compare_sequences(target: list[int], user: list[int]) -> tuple[int, int]:
    """
    Сравнивает две последовательности и подсчитывает прямые и косвенные попадания.

    :param target: Загаданная последовательность.
    :type target: list[int]
    :param user: Последовательность, введенная пользователем.
    :type user: list[int]
    :return: Кортеж, содержащий количество прямых и косвенных попаданий.
    :rtype: tuple[int, int]
    """
    direct_hits = 0
    indirect_hits = 0
    target_copy = list(target)

    for i in range(4):
        if user[i] == target_copy[i]:
            direct_hits += 1
            target_copy[i] = None
            user[i] = None

    for i in range(4):
      if user[i] is not None:
        for j in range(4):
            if user[i] == target_copy[j]:
                indirect_hits += 1
                target_copy[j] = None
                break
    return direct_hits, indirect_hits

def is_valid_input(user_input: str) -> list[int] | None:
    """
    Проверяет корректность ввода пользователя.

    :param user_input: Строка ввода пользователя.
    :type user_input: str
    :return: Список целых чисел, если ввод корректен, иначе None.
    :rtype: list[int] | None
    """
    try:
        user_sequence = [int(x) for x in user_input.split()]
        if len(user_sequence) != 4 or not all(1 <= x <= 6 for x in user_sequence):
            print('Пожалуйста, введите ровно 4 цифры от 1 до 6, разделенные пробелами.')
            return None
        return user_sequence
    except ValueError:
        print('Пожалуйста, введите целые числа.')
        return None
# TODO: Добавить логирование ошибок в функции
def play_reverse_game():
    """
    Основная функция игры REVRSE.
    """
    number_of_guesses = 0
    target_sequence = generate_target_sequence()

    print('Добро пожаловать в игру REVRSE!')
    print('Я загадал последовательность из 4 цифр (от 1 до 6).')
    print('Попробуй ее отгадать. У тебя есть 10 попыток.')

    while number_of_guesses < 10:
        number_of_guesses += 1
        user_input = input(f'Попытка {number_of_guesses}. Введите 4 цифры через пробел (например, 1 2 3 4): ')
        user_sequence = is_valid_input(user_input)
        if user_sequence is None:
            continue
        
        direct_hits, indirect_hits = compare_sequences(target_sequence, user_sequence)
        print(f'Прямые попадания: {direct_hits}, Косвенные попадания: {indirect_hits}')
        if direct_hits == 4:
            print('Поздравляю! Ты угадал последовательность!')
            return

    print('Увы, попытки закончились. Ты не угадал последовательность.')
    print(f'Правильная последовательность: {target_sequence}')

if __name__ == '__main__':
    play_reverse_game()
"""
Объяснение кода:
1.  **Импорт модуля `random`**:
    -  `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел.
2.  **Функция `generate_target_sequence()`**:
    -   `def generate_target_sequence():`: Определяет функцию для генерации случайной последовательности из 4 цифр от 1 до 6.
    -   `return [random.randint(1, 6) for _ in range(4)]`: Использует генератор списков для создания списка из 4 случайных целых чисел, каждое из которых находится в диапазоне от 1 до 6.
3.  **Функция `compare_sequences(target, user)`**:
    -   `def compare_sequences(target, user):`: Определяет функцию для сравнения двух последовательностей и подсчета прямых и косвенных попаданий.
    -   `direct_hits = 0`: Инициализирует переменную для подсчета прямых попаданий.
    -   `indirect_hits = 0`: Инициализирует переменную для подсчета косвенных попаданий.
    -  `target_copy = list(target)`: Создает копию загаданной последовательности, чтобы не изменять исходный список.
    -   **Подсчет прямых попаданий**:
        -  `for i in range(4):`: Цикл для прохода по каждой позиции в последовательности.
        -  `if user[i] == target_copy[i]:`: Проверяет, совпадает ли цифра на текущей позиции в обеих последовательностях.
        -  `direct_hits += 1`: Увеличивает количество прямых попаданий на 1.
        -  `target_copy[i] = None` и `user[i] = None`: Помечает цифру как использованную, чтобы не учитывать ее повторно при подсчете косвенных попаданий.
    -   **Подсчет косвенных попаданий**:
        -   `for i in range(4):`: Цикл для прохода по каждой позиции в пользовательской последовательности.
        -  `if user[i] is not None:`: Проверяет, что цифра не была использована в прямых попаданиях
        - `for j in range(4):`: Цикл для прохода по каждой позиции в копии загаданной последовательности.
        -`if user[i] == target_copy[j]:`: Проверяет, есть ли цифра из пользовательской последовательности в копии загаданной последовательности
        -`indirect_hits += 1`: увеличивает количество косвенных попаданий на 1
        - `target_copy[j] = None`: помечает цифру как использованную, чтобы не считать повторно.
        -  `break`: Переходит к следующей цифре в пользовательской последовательности.
    -   `return direct_hits, indirect_hits`: Возвращает количество прямых и косвенных попаданий.
4.  **Функция `is_valid_input(user_input)`**:
    -  `def is_valid_input(user_input):`: Определяет функцию для проверки корректности ввода пользователя.
    -  `try ... except ValueError`: Блок для обработки возможных ошибок ввода.
    -  `user_sequence = [int(x) for x in user_input.split()]`: Преобразует введенную строку в список целых чисел.
    - `if len(user_sequence) != 4 or not all(1 <= x <= 6 for x in user_sequence):`: Проверяет, правильно ли введены данные.
    -  `return None`: Возвращает None если ввод некорректный
    -   `return user_sequence`: Возвращает список введенных чисел, если ввод корректный.
5.  **Функция `play_reverse_game()`**:
    -   `def play_reverse_game():`: Определяет основную функцию игры.
    -   `number_of_guesses = 0`: Инициализирует количество попыток.
    -   `target_sequence = generate_target_sequence()`: Генерирует загаданную последовательность.
    -  Вывод приветственного сообщения и инструкций.
    -   **Основной цикл `while number_of_guesses < 10:`**:
        -  `number_of_guesses += 1`: Увеличивает счетчик попыток на 1.
        -  `user_input = input(f'Попытка {number_of_guesses}. Введите 4 цифры через пробел (например, 1 2 3 4): ')`: Запрашивает у пользователя ввод последовательности из 4 чисел через пробел.
        -  `user_sequence = is_valid_input(user_input)`: Вызывает функцию для проверки валидности ввода
        -  `if user_sequence is None:`: Проверяет, если ввод не валиден, пропускает итерацию.
        -  `direct_hits, indirect_hits = compare_sequences(target_sequence, user_sequence)`: Вызывает функцию для сравнения последовательностей.
        - `print(f'Прямые попадания: {direct_hits}, Косвенные попадания: {indirect_hits}')`: Выводит результаты сравнения.
        -`if direct_hits == 4`: Проверяет, угадана ли последовательность.
        -   `print('Поздравляю! Ты угадал последовательность!')`: Выводит сообщение о победе.
        - `return`: Завершает игру.
    -   **Если попытки закончились**:
        -   `print('Увы, попытки закончились. Ты не угадал последовательность.')`: Выводит сообщение о проигрыше.
        -   `print(f'Правильная последовательность: {target_sequence}')`: Выводит загаданную последовательность.
6.  **Запуск игры**:
    -   `if __name__ == '__main__':`: Проверяет, запущен ли файл как основная программа.
    -   `play_reverse_game()`: Вызывает функцию для начала игры.
"""
```