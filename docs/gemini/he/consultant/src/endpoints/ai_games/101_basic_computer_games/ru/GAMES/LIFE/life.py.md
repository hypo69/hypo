# Анализ кода модуля `life.py`

**Качество кода**
- **Соблюдение требований к формату кода (1-10):**
  - **Преимущества:**
    - Код хорошо структурирован и разбит на отдельные функции, что делает его легко читаемым и поддерживаемым.
    - Используются описательные имена функций и переменных.
    - Присутствуют комментарии, объясняющие основные шаги алгоритма.
    - Код соответствует PEP 8 в отношении форматирования (некоторые места требуют доработки).
    - Присутствуют docstrings для функций (требуют переработки в reStructuredText).
  - **Недостатки:**
    -  Не используется reStructuredText (RST) для комментариев и docstrings.
    -  Отсутствует импорт `logger` для регистрации ошибок.
    -  Не используется `j_loads` или `j_loads_ns` для чтения данных из файлов (в данном коде нет чтения данных, но нужно учесть для будущих изменений).
    -  Используются стандартные блоки `try-except` без обработки через `logger.error`.
    -  В некоторых местах комментарии используют "делает" и т.п.
    -  Нет примеров использования в docstring.

**Рекомендации по улучшению**
1.  **Формат документации**:
    -   Перевести все комментарии и docstrings в формат reStructuredText (RST).
    -   Добавить подробное описание каждого модуля, функции, метода и переменной.
2.  **Импорт**:
    -   Добавить импорт `from src.logger.logger import logger` для логирования ошибок.
3.  **Обработка ошибок**:
    -   Заменить стандартные блоки `try-except` на использование `logger.error` для логирования ошибок.
4.  **Чтение данных**:
    -  Заменить стандартный `json.load` на `j_loads` или `j_loads_ns` при необходимости.
5.  **Комментарии**:
    -  Переписать комментарии, избегая использования слов вроде "делает", "принимает", и т.д., заменив их на более точные описания действий.
6.  **Примеры использования**:
     - Добавить примеры использования в docstring в формате RST.
7.  **Форматирование**:
    -  Улучшить форматирование кода в соответствии с PEP 8 (например, пробелы вокруг операторов).

**Улучшенный код**
```python
"""
Модуль для симуляции игры "Жизнь"
=========================================================================================

Этот модуль реализует симуляцию клеточного автомата "Жизнь", разработанную Джоном Конвеем.
Игровое поле представляет собой сетку из клеток, каждая из которых может быть в одном из двух состояний:
"живая" или "мертвая".

Правила игры:
1. Живая клетка с менее чем двумя живыми соседями умирает от одиночества.
2. Живая клетка с двумя или тремя живыми соседями выживает.
3. Живая клетка с более чем тремя живыми соседями умирает от перенаселения.
4. Мертвая клетка с ровно тремя живыми соседями оживает.

Пример использования
--------------------

.. code-block:: python

    play_game_of_life()

"""
import random
import time
from src.logger.logger import logger # импортируем logger для логирования ошибок #

def get_grid_size() -> tuple[int, int]:
    """
    Запрашивает у пользователя размеры сетки.

    :return: Кортеж, содержащий количество строк и столбцов.
    :rtype: tuple[int, int]
    """
    while True:
        try:
            rows = int(input("Введите количество строк: ")) # Запрашивает у пользователя количество строк. #
            cols = int(input("Введите количество столбцов: ")) # Запрашивает у пользователя количество столбцов. #
            if rows > 0 and cols > 0:
                return rows, cols
            else:
                print("Пожалуйста, введите положительные значения для строк и столбцов.") # Выводит сообщение, если введены некорректные значения. #
        except ValueError:
            print("Пожалуйста, введите целое число.") # Выводит сообщение, если ввод не является целым числом. #


def get_generations() -> int:
    """
    Запрашивает у пользователя количество поколений.

    :return: Количество поколений для симуляции.
    :rtype: int
    """
    while True:
        try:
            generations = int(input("Введите количество поколений: ")) # Запрашивает у пользователя количество поколений. #
            if generations > 0:
                return generations
            else:
                print("Пожалуйста, введите положительное количество поколений.")  # Выводит сообщение, если введено некорректное значение. #
        except ValueError:
            print("Пожалуйста, введите целое число.") # Выводит сообщение, если ввод не является целым числом. #


def get_initial_config(rows: int, cols: int) -> list[str]:
    """
    Запрашивает у пользователя ввод начальной конфигурации или использует случайную.

    :param rows: Количество строк в сетке.
    :type rows: int
    :param cols: Количество столбцов в сетке.
    :type cols: int
    :return: Список строк, представляющих начальную конфигурацию.
    :rtype: list[str]
    """
    use_random = input("Использовать случайную конфигурацию (y/n)? ").lower() # Запрашивает у пользователя, использовать ли случайную конфигурацию. #
    if use_random != 'y':
        print("Введите начальную конфигурацию, используя '*' для живых клеток и ' ' для мертвых.") # Выводит запрос на ввод начальной конфигурации. #
        print("Введите каждую строку отдельно:") # Уточняет формат ввода. #
        initial_config = []
        for _ in range(rows):
            while True:
              row_input = input() # Запрашивает ввод строки. #
              if len(row_input) == cols and all(cell in ['*', ' '] for cell in row_input): # Проверяет корректность ввода строки. #
                  initial_config.append(row_input)
                  break
              else:
                print(f"Неверный ввод. Введите строку длиной {cols} символов '*' или ' '") # Выводит сообщение об ошибке, если ввод не соответствует требованиям. #
        return initial_config
    else:
        return  [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)] # Создает и возвращает случайную конфигурацию. #


def create_grid(rows: int, cols: int, initial_config: list[str] = None) -> list[list[str]]:
    """
    Создает сетку на основе заданных размеров и начальной конфигурации.

    :param rows: Количество строк в сетке.
    :type rows: int
    :param cols: Количество столбцов в сетке.
    :type cols: int
    :param initial_config: Начальная конфигурация (список строк), по умолчанию None.
    :type initial_config: list[str], optional
    :return: Сетка (список списков) с начальной конфигурацией.
    :rtype: list[list[str]]
    """
    if initial_config:
        return [list(row) for row in initial_config] # Создает сетку из предоставленной начальной конфигурации. #
    else:
        return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)] # Создает сетку со случайной начальной конфигурацией. #


def print_grid(grid: list[list[str]]) -> None:
    """
    Выводит сетку на экран.

    :param grid: Сетка для вывода (список списков).
    :type grid: list[list[str]]
    """
    for row in grid:
        print(''.join(row)) # Выводит строку сетки. #
    print("-" * len(grid[0])) # Выводит разделительную линию. #


def count_live_neighbours(grid: list[list[str]], row: int, col: int) -> int:
    """
    Подсчитывает количество живых соседей для заданной клетки.

    :param grid: Сетка, в которой ведется подсчет.
    :type grid: list[list[str]]
    :param row: Строка клетки.
    :type row: int
    :param col: Столбец клетки.
    :type col: int
    :return: Количество живых соседей.
    :rtype: int
    """
    rows = len(grid)
    cols = len(grid[0])
    count = 0
    for i in range(max(0, row - 1), min(rows, row + 2)): # Проходит по строкам соседей. #
        for j in range(max(0, col - 1), min(cols, col + 2)): # Проходит по столбцам соседей. #
            if (i, j) != (row, col) and grid[i][j] == '*': # Проверяет, является ли сосед живым и не является ли он самой клеткой. #
                count += 1 # Увеличивает счетчик живых соседей. #
    return count


def apply_rules(grid: list[list[str]], row: int, col: int) -> str:
    """
    Применяет правила игры "Жизнь" для определения состояния клетки в следующем поколении.

    :param grid: Текущая сетка.
    :type grid: list[list[str]]
    :param row: Строка клетки.
    :type row: int
    :param col: Столбец клетки.
    :type col: int
    :return: Новое состояние клетки ('*' или ' ').
    :rtype: str
    """
    live_neighbours = count_live_neighbours(grid, row, col) # Подсчитывает количество живых соседей. #
    if grid[row][col] == '*':
        if live_neighbours < 2 or live_neighbours > 3:
            return ' '  # Клетка умирает #
        else:
            return '*'  # Клетка выживает #
    else:
        if live_neighbours == 3:
            return '*'  # Клетка оживает #
        else:
            return ' '  # Клетка остается мертвой #


def next_generation(grid: list[list[str]]) -> list[list[str]]:
    """
    Создает следующее поколение сетки.

    :param grid: Текущая сетка.
    :type grid: list[list[str]]
    :return: Сетка следующего поколения.
    :rtype: list[list[str]]
    """
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [[' ' for _ in range(cols)] for _ in range(rows)] # Создает новую пустую сетку. #
    for row in range(rows):
        for col in range(cols):
            new_grid[row][col] = apply_rules(grid, row, col) # Применяет правила игры к каждой клетке. #
    return new_grid


def play_game_of_life() -> None:
    """
    Основная функция, управляющая симуляцией игры "Жизнь".
    """
    rows, cols = get_grid_size() # Получает размеры сетки от пользователя. #
    generations = get_generations() # Получает количество поколений от пользователя. #
    initial_config = get_initial_config(rows, cols) # Получает начальную конфигурацию от пользователя. #
    grid = create_grid(rows, cols, initial_config) # Создает игровую сетку. #

    for generation in range(generations):
        print(f"Поколение: {generation + 1}") # Выводит номер текущего поколения. #
        print_grid(grid) # Выводит текущее состояние поля. #
        grid = next_generation(grid) # Вычисляет следующее поколение. #
        time.sleep(0.5) # Задержка между поколениями. #

    print("Симуляция завершена") # Выводит сообщение о завершении симуляции. #
    print("Финальное состояние поля:") # Выводит сообщение о финальном состоянии. #
    print_grid(grid) # Выводит финальное состояние поля. #

if __name__ == "__main__":
    play_game_of_life() # Запускает игру, если скрипт запущен напрямую. #
```