## <algorithm>

1. **התחלה**:
   - המשחק מתחיל בלולאה אינסופית.
   - **דוגמה**: הלולאה `while True:` בתוך הפונקציה `main()`.

2. **קבלת קלט מהמשתמש**:
   - המשתמש מתבקש להזין את רוחב וגובה המבוך.
   - **דוגמה**: השימוש בפונקציה `input()` לקבלת רוחב וגובה, וההמרה שלהם למספרים שלמים באמצעות `int()`.
   - **זרימת נתונים**:
     - קלט מהמשתמש -> משתנה `width` (רוחב)
     - קלט מהמשתמש -> משתנה `height` (גובה)

3. **בדיקת תקינות קלט**:
   - בדיקה האם הרוחב והגובה חיוביים.
   - בדיקה האם הרוחב והגובה לא גדולים מדי (מוגבל ל-50).
   - אם הקלט לא תקין, מוצגת הודעת שגיאה והלולאה ממשיכה לסיבוב הבא (חוזרת לשלב 2).
   - **דוגמה**: תנאי `if width <= 0 or height <= 0:` ו-`if width > 50 or height > 50:`

4. **יצירת המבוך**:
   - קריאה לפונקציה `create_maze(width, height)` ליצירת המבוך.
   - **זרימת נתונים**:
      - `width`, `height` -> הפונקציה `create_maze()` -> `maze` (מטריצת המבוך)

   - בתוך הפונקציה `create_maze()`:
     - **אתחול מטריצה**: יוצר מטריצה דו-ממדית המייצגת את המבוך, כאשר כל התאים מאותחלים בסימן `+` (קיר).
     - **דוגמה**: השורה `maze = [['+' for _ in range(2 * width + 1)] for _ in range(2 * height + 1)]`.
     - **פונקציה `is_valid(x, y)`**: פונקציה בודקת האם קואורדינטות `x` ו-`y` נמצאות בתוך גבולות המבוך.
     - **פונקציה `carve_path(x, y)`**:
       - אלגוריתם DFS (חיפוש לעומק) לכריית נתיבים:
          -  מערבב באקראי את רשימת הכיוונים האפשריים (`directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]`).
          -  עובר על כל כיוון ומנסה להתקדם לשכן חדש.
          - בודק אם השכן נמצא בתוך המבוך ולא נבקר עדיין (`if is_valid(nx, ny) and maze[2 * nx + 1][2 * ny + 1] == '+'`).
          - אם השכן חוקי:
            - מסיר את הקיר בין התא הנוכחי לשכן (`maze[2 * x + 1 + dx][2 * y + 1 + dy] = ' '`).
            - מסמן את השכן כביקור (`maze[2 * nx + 1][2 * ny + 1] = ' '`).
            - קורא רקורסיבית לפונקציה `carve_path` עם קואורדינטות השכן (`carve_path(nx, ny)`).
     - **בחירת נקודת התחלה**: בחירת קואורדינטות התחלה אקראיות וסימון שלה כתא ביקור (`maze[2 * start_x + 1][2 * start_y + 1] = ' '`).
     - **תחילת חיפוש לעומק**: קורא לפונקציה `carve_path` עם קואורדינטות ההתחלה.
     - **החזרת המבוך**: מחזיר את מטריצת המבוך המעודכנת.

5. **הדפסת המבוך**:
   - קריאה לפונקציה `print_maze(maze)` להצגת המבוך.
   - **זרימת נתונים**:
     - `maze` -> הפונקציה `print_maze()` -> פלט למסך.
   - בתוך הפונקציה `print_maze()`:
     - עובר על כל שורה במטריצת המבוך ומדפיס אותה למסך.
     - **דוגמה**: לולאת `for row in maze:` והשימוש בפונקציה `print(''.join(row))`.

6. **שאלה על מבוך חדש**:
   - המשתמש נשאל האם ליצור מבוך חדש.
   - אם התשובה אינה "כן", המשחק מסתיים.
   - **זרימת נתונים**:
     - קלט מהמשתמש -> משתנה `new_maze`.

7. **סיום המשחק**:
   - מוצגת הודעת סיום והלולאה מסתיימת (`break`).
   - אם התשובה היא "כן" - המשחק חוזר לשלב 2.
   - **דוגמה**: התנאי `if new_maze != 'да':` ושימוש ב-`break`.

## <mermaid>

```mermaid
flowchart TD
    Start[התחלה] --> InputWidthHeight[קבלת רוחב וגובה מהמשתמש]
    InputWidthHeight --> ValidateInput[בדיקת תקינות קלט]
    ValidateInput -- קלט לא תקין --> InputWidthHeight
    ValidateInput -- קלט תקין --> CreateMaze[יצירת המבוך]
    CreateMaze --> PrintMaze[הדפסת המבוך]
    PrintMaze --> AskNewMaze[שאלה על יצירת מבוך חדש]
    AskNewMaze -- תשובה: כן --> InputWidthHeight
    AskNewMaze -- תשובה: לא --> End[סיום]
    
    subgraph create_maze
        direction LR
        StartCreateMaze[התחלת יצירת המבוך] --> InitMazeMatrix[אתחול מטריצת המבוך בסימני "+"]
        InitMazeMatrix --> ValidCoordinatesCheck[פונקציית בדיקת קואורדינטות תקינות]
        ValidCoordinatesCheck -->  RecursiveCarvePath[פונקציית כריית נתיבים רקורסיבית (DFS)]
        RecursiveCarvePath --> RandomStartPoint[בחירת נקודת התחלה אקראית]
        RandomStartPoint --> StartDFSTraversal[תחילת מעבר DFS]
        StartDFSTraversal --> ReturnMaze[החזרת המבוך]
        
        subgraph carve_path
            direction LR
            StartCarvePath[תחילת כריית נתיב] --> ShuffleDirections[ערבוב רשימת כיוונים]
            ShuffleDirections --> LoopDirections[מעבר על כל כיוון]
             LoopDirections --> CheckNeighbor[בדיקת שכן]
            CheckNeighbor --שכן לא חוקי/נבקר --> LoopDirections
            CheckNeighbor --שכן חוקי ולא נבקר --> RemoveWall[הסרת קיר]
            RemoveWall --> MarkNeighborVisited[סימון השכן כנבקר]
            MarkNeighborVisited --> RecursiveCall[קריאה רקורסיבית לכריית נתיב]
            RecursiveCall --> LoopDirections
            LoopDirections -- סיום המעבר על כל הכיוונים --> EndCarvePath[סיום כריית נתיב]
         end
    end

    subgraph print_maze
        direction LR
        StartPrintMaze[תחילת הדפסת המבוך] --> LoopRows[מעבר על שורות המבוך]
        LoopRows --> PrintRow[הדפסת שורה]
        PrintRow --> LoopRows
        LoopRows -- סיום המעבר על כל השורות --> EndPrintMaze[סיום הדפסת המבוך]
    end
```

**הסבר תלויות לייבוא**:

- `random`: הספרייה `random` משמשת לערבוב אקראי של כיווני התנועה באלגוריתם ה-DFS, מה שמוביל למבוכים שונים בכל הרצה. בנוסף, משמש לבחירת קואורדינטות התחלה אקראיות בתוך המבוך.

## <explanation>

**ייבואים (Imports)**:

- `import random`: ייבוא מודול `random` משמש לצרכי יצירת רנדומליות בתהליך הגנרציה של המבוך. הוא משמש לערבוב כיווני תנועה בתוך האלגוריתם ה-DFS וכן לבחירת תא התחלה אקראי. אין תלות בחבילות `src.` אחרות.

**פונקציות (Functions)**:

- `create_maze(width, height)`:
  - **פרמטרים**:
    - `width`: רוחב המבוך כמספר שלם.
    - `height`: גובה המבוך כמספר שלם.
  - **ערך מוחזר**:
    - `maze`: מטריצה דו-ממדית (רשימה של רשימות) המייצגת את המבוך שנוצר. כל תא במטריצה מכיל תו (`+`, `-`, `|` או ` `).
  - **מטרה**: הפונקציה יוצרת מבוך על פי גודל נתון בעזרת אלגוריתם רקורסיבי DFS (חיפוש לעומק).
  - **דוגמה לשימוש**:
    ```python
    maze = create_maze(10, 8) # יוצר מבוך בגודל 10x8
    ```
  - **הסבר**:
     - הפונקציה יוצרת מטריצה מאותחלת כקירות (`+`).
     - הפונקציה `carve_path` (מוגדרת בתוך הפונקציה `create_maze`) משמשת לכריית מעברים (סימון באמצעות רווחים) בתוך המטריצה בעזרת אלגוריתם חיפוש לעומק רקורסיבי.
     - הפונקציה מחזירה את המטריצה המלאה לאחר כריית הנתיבים.

- `print_maze(maze)`:
  - **פרמטרים**:
    - `maze`: מטריצה דו-ממדית המייצגת את המבוך.
  - **ערך מוחזר**: אין (None).
  - **מטרה**: הפונקציה מדפיסה את המבוך למסך בצורה קריאה.
  - **דוגמה לשימוש**:
    ```python
    print_maze(maze) # מדפיס את המבוך
    ```
  - **הסבר**: הפונקציה עוברת על כל שורה במטריצת המבוך ומדפיסה אותה למסך.

- `main()`:
  - **פרמטרים**: אין.
  - **ערך מוחזר**: אין (None).
  - **מטרה**: הפונקציה הראשית של המשחק. היא מקבלת את מימדי המבוך מהמשתמש, קוראת לפונקציות ליצירה והדפסה, ומנהלת את הלולאה הראשית של המשחק.
  - **דוגמה לשימוש**:
    ```python
    main() # מפעיל את המשחק
    ```
  - **הסבר**:
     - הפונקציה נמצאת בתוך לולאת `while True` שמריצה את המשחק שוב ושוב עד שהמשתמש מחליט להפסיק.
     - מקבלת את הרוחב והגובה מהמשתמש ובודקת את תקינותם.
     - קוראת לפונקציה `create_maze` כדי ליצור את המבוך.
     - קוראת לפונקציה `print_maze` כדי להדפיס את המבוך.
     - שואלת את המשתמש אם ליצור מבוך חדש או לסיים את המשחק.
  - **בעיות אפשריות**:
      - ניתן להרחיב את הפונקציה כדי לבדוק תקינות נוספת לקלט (למשל, שהקלט הוא מספר שלם)
      - כדאי להוסיף אפשרות לשינוי סימני הקירות, המעברים וכו'.
**משתנים (Variables)**:

- `width`: משתנה מסוג int המכיל את רוחב המבוך.
- `height`: משתנה מסוג int המכיל את גובה המבוך.
- `maze`: משתנה מסוג רשימה של רשימות (מטריצה) המכיל את המבוך שנוצר.
- `new_maze`: משתנה מסוג string המכיל את התשובה של המשתמש לשאלה "האם ליצור מבוך חדש?".
- `directions`: רשימה של זוגות של מספרים (tuple) שמייצגים את הכיוונים האפשריים לתנועה בתוך הפונקציה `carve_path`.
- `start_x`, `start_y`: משתנים שלמים המכילים את קואורדינטות התא ההתחלתי.
- `dx`, `dy`: משתנים שלמים המכילים את השינוי בקואורדינטות עבור כיוון ספציפי בתוך `directions`.
- `nx`, `ny`: משתנים שלמים המכילים את הקואורדינטות של השכן הבא.

**בעיות אפשריות או תחומים לשיפור**:

- **טיפול בשגיאות קלט**: הקוד מטפל בשגיאות `ValueError` אך ניתן להוסיף בדיקות נוספות על מנת להבטיח שהקלט תקין.
- **מגבלת גודל מבוך**: הקוד מגביל את גודל המבוך ל-50x50. ניתן לשקול שימוש במבני נתונים יעילים יותר כדי לאפשר גדלים גדולים יותר, או לממש אלגוריתם גנרציה יעיל יותר.
- **ממשק משתמש**: ממשק המשתמש הוא טקסטואלי בלבד. אפשר לשקול שימוש בממשק גרפי.
- **שיפור אלגוריתם**: אפשר לשקול שימוש באלגוריתמים אחרים ליצירת מבוכים, כמו Kruskal או Prim.
- **תחזוקה**: לשקול פיצול לפונקציות קטנות יותר.
- **קריאות**: הערות ושימוש בשמות משתנים משמעותיים מקלים על הקריאות.
- **קונסיסטנטיות**: שמות המשתנים עקביים ומשקפים את השימוש שלהם.

**שרשרת קשרים עם חלקים אחרים בפרויקט**:

- הקוד עומד בפני עצמו ולא תלוי ישירות בחלקים אחרים בפרויקט. הוא יכול להיות חלק מתוך משחק גדול יותר. אין לו תלות ישירה בקבצים אחרים בתיקיית `src`.