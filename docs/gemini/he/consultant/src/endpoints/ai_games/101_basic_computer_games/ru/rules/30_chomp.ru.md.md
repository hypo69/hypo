# Анализ кода модуля `30_chomp.ru.md`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10)**:
    - **Преимущества**:
        - Документ предоставляет ясное описание правил игры CHOMP (Печенька) и пошаговую инструкцию для её реализации.
        - Присутствует пример работы программы, что облегчает понимание игрового процесса.
        - Описаны ограничения игры, что помогает понять её возможности и границы.
    - **Недостатки**:
        - Документ не содержит кода Python, поэтому невозможно оценить соответствие требованиям к форматированию кода и использования библиотек.
        - Отсутствуют reStructuredText (RST) комментарии и docstrings.
        - Нет примеров использования `j_loads` или `j_loads_ns`.
        - Не определены конкретные функции, методы или классы, которые нужно комментировать в стиле RST.
        - Отсутствует обработка ошибок через `logger.error`.

**Рекомендации по улучшению**
1. Необходимо добавить код на языке Python для реализации игры CHOMP (Печенька) в соответствии с описанными правилами.
2. В коде нужно использовать reStructuredText (RST) для всех комментариев и docstring.
3. Код должен включать необходимые импорты.
4. Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` для чтения файлов.
5. Код должен быть структурирован с использованием функций и классов.
6. В функции и методы добавить комментарии в формате RST.
7. Для отладки и обработки ошибок использовать `logger.error` из `src.logger.logger`.
8. Добавить примеры использования функций и классов.

**Улучшенный код**
```python
"""
Модуль для реализации игры CHOMP (Печенька).
=========================================================================================

Модуль содержит функции для инициализации игры,
реализации ходов игроков, определения победителя
и завершения игры.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    if __name__ == '__main__':
        game = ChompGame()
        game.start_game()

"""
import sys # импортируем модуль sys для обработки исключений
from src.utils.jjson import j_loads_ns # импортируем функцию j_loads_ns для работы с json
from src.logger.logger import logger # импортируем logger для логирования ошибок

class ChompGame:
    """
    Класс, представляющий игру CHOMP.

    Содержит методы для инициализации игрового поля, обработки ходов игроков
    и определения победителя.

    :ivar rows: Количество рядов игрового поля.
    :vartype rows: int
    :ivar cols: Количество столбцов игрового поля.
    :vartype cols: int
    :ivar board: Двумерный список, представляющий игровое поле.
    :vartype board: list[list[str]]
    :ivar current_player: Номер текущего игрока (1 или 2).
    :vartype current_player: int
    """
    def __init__(self):
        """
        Инициализирует игру CHOMP.

        Устанавливает начальные значения для размеров поля,
        игрового поля и текущего игрока.
        """
        self.rows = 0  # Инициализируем количество рядов нулем
        self.cols = 0  # Инициализируем количество столбцов нулем
        self.board = [] # Инициализируем игровое поле пустым списком
        self.current_player = 1 # Инициализируем текущего игрока 1

    def initialize_board(self, rows: int, cols: int):
        """
        Инициализирует игровое поле заданного размера.

        :param rows: Количество рядов игрового поля.
        :type rows: int
        :param cols: Количество столбцов игрового поля.
        :type cols: int
        """
        self.rows = rows
        self.cols = cols
        self.board = [['O' for _ in range(cols)] for _ in range(rows)]  # Заполняем игровое поле символом 'O'
        self.board[0][0] = 'P'  # Ставим отравленную клетку в верхний левый угол

    def print_board(self):
        """
        Выводит текущее состояние игрового поля в консоль.
        """
        for row in self.board:
            print(' '.join(row))

    def get_move(self) -> tuple[int, int]:
        """
        Запрашивает у текущего игрока координаты хода.

        :return: Кортеж с координатами хода (ряд, колонка).
        :rtype: tuple[int, int]
        """
        while True:
            try:
                move_str = input(f'Игрок {self.current_player}, введите координаты клетки для съедения (ряд, колонка): ') # запрос координат хода у игрока
                row, col = map(int, move_str.split(',')) # преобразуем введенные координаты в целые числа
                if 0 <= row < self.rows and 0 <= col < self.cols: # проверка корректности ввода координат
                   return row, col
                else:
                     logger.error(f'Некорректный ввод координат: {row=}, {col=}. Попробуйте снова.') # если координаты не корректны выводим ошибку
            except ValueError:
                logger.error('Некорректный формат ввода. Введите два числа, разделенных запятой.') # если формат ввода не корректный выводим ошибку
            except Exception as e:
                 logger.error(f'Произошла ошибка: {e}. Попробуйте снова.') # выводим ошибку если возникла непредвиденная ситуация
        
    def make_move(self, row: int, col: int) -> bool:
        """
        Выполняет ход игрока, удаляя клетки с игрового поля.

        :param row: Ряд выбранной клетки.
        :type row: int
        :param col: Колонка выбранной клетки.
        :type col: int
        :return: True, если игрок не съел отравленную клетку, False иначе.
        :rtype: bool
        """
        if self.board[row][col] == 'P':  # проверка на съедение отравленной клетки
            return False # если съели отравленную клетку, возвращаем False
        for i in range(row, self.rows): # перебираем строки, начиная со строки выбранной клетки до конца
            for j in range(col, self.cols): # перебираем столбцы, начиная со столбца выбранной клетки до конца
                self.board[i][j] = ' ' # заменяем символы на пробелы
        return True # если не съели отравленную клетку, возвращаем True

    def switch_player(self):
        """
        Переключает текущего игрока.
        """
        self.current_player = 3 - self.current_player # меняем текущего игрока на противоположного

    def start_game(self):
        """
        Запускает игровой процесс CHOMP.

        Запрашивает у пользователя размеры игрового поля,
        организует основной цикл игры, обрабатывает ходы
        и определяет победителя.
        """
        try: # обрабатываем исключения
            num_players = int(input('Введите количество игроков: ')) # запрос количества игроков
            if num_players != 2:
                logger.error('Игра предназначена только для двух игроков.') # если количество игроков не равно 2 выводим ошибку
                return
            rows = int(input('Введите количество рядов: ')) # запрос количества рядов
            cols = int(input('Введите количество столбцов: ')) # запрос количества столбцов
            self.initialize_board(rows, cols) # инициализируем игровое поле

            while True:
                 self.print_board() # выводим текущее состояние доски
                 row, col = self.get_move()  # получаем координаты от игрока
                 if not self.make_move(row, col): # делаем ход и проверяем не съели ли отравленную клетку
                      print(f'Игрок {self.current_player} съел отравленную клетку! Игра завершена.') # выводим сообщение о проигрыше
                      break # завершаем игру если съели отравленную клетку
                 self.switch_player() # переключаем игрока
            self.play_again() # предлагаем сыграть еще раз

        except ValueError:
            logger.error('Некорректный формат ввода. Введите целое число.') # если формат ввода не корректный выводим ошибку
        except Exception as e:
            logger.error(f'Произошла ошибка: {e}')  # если возникла непредвиденная ситуация выводим ошибку
    
    def play_again(self):
        """
        Предлагает пользователю сыграть еще раз после завершения игры.
        """
        while True:
            play_again = input('Хотите сыграть снова? (да/нет): ').lower() # спрашиваем у пользователя хочет ли он сыграть еще раз
            if play_again == 'да':
                self.__init__()  # создаем новую игру
                self.start_game()
                break  # выходим из цикла
            elif play_again == 'нет':
               print('Спасибо за игру!') # выводим сообщение благодарности за игру
               break # выходим из цикла
            else:
                logger.error('Некорректный ввод. Введите "да" или "нет".') # если пользователь ввел не корректный формат, выводим ошибку
if __name__ == '__main__':
    game = ChompGame() # создаем объект игры
    game.start_game() # запускаем игру

```