# Модуль для организации троттлинга сообщений в Telegram боте
=================================================================

Модуль содержит класс `ThrottlingMiddleware`, который используется для ограничения частоты отправки сообщений от пользователей в Telegram боте.

Пример использования
----------------------

```python
from aiogram import Dispatcher

dp = Dispatcher()
dp.message.middleware(ThrottlingMiddleware(time_limit=2))
```

## Обзор

Модуль `throttling.py` реализует механизм защиты от спама в Telegram боте. Он использует `aiogram.BaseMiddleware` для перехвата и обработки входящих сообщений, а также `cachetools.TTLCache` для хранения информации о пользователях и времени их последнего сообщения.

## Подробнее

Данный модуль предназначен для предотвращения злоупотребления ботом путем ограничения частоты отправки сообщений от одного и того же пользователя. Это достигается путем использования кэша с автоматическим истечением срока действия (TTL), который хранит информацию об активности каждого пользователя. Если пользователь отправляет сообщение слишком часто, middleware прерывает обработку сообщения, предотвращая перегрузку бота.

## Классы

### `ThrottlingMiddleware`

**Описание**: Middleware для ограничения частоты отправки сообщений от пользователей.

**Принцип работы**:
Класс `ThrottlingMiddleware` инициализируется с параметром `time_limit`, который определяет время в секундах, в течение которого сообщения от одного пользователя будут ограничены. При каждом входящем сообщении middleware проверяет, находится ли идентификатор чата пользователя в кэше. Если да, сообщение не обрабатывается. Если нет, идентификатор чата добавляется в кэш, и сообщение передается для дальнейшей обработки.

**Атрибуты**:
- `limit` (TTLCache): Кэш для хранения идентификаторов чатов и времени их последнего сообщения.

**Методы**:
- `__init__(self, time_limit: int = 2) -> None`: Инициализирует middleware с заданным временным ограничением.
- `__call__(self, handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]], event: Message, data: Dict[str, Any]) -> Any`: Перехватывает и обрабатывает входящие сообщения.

## Функции

### `__init__`

```python
def __init__(self, time_limit: int = 2) -> None:
    """
    Инициализирует middleware с заданным временным ограничением.

    Args:
        time_limit (int, optional): Время в секундах, в течение которого сообщения от одного пользователя будут ограничены. По умолчанию 2.
    """
    ...
```

**Назначение**: Инициализация экземпляра класса `ThrottlingMiddleware`.

**Параметры**:
- `time_limit` (int): Время в секундах, в течение которого сообщения от одного пользователя будут ограничены. По умолчанию 2 секунды.

**Как работает функция**:
1. Функция `__init__` принимает параметр `time_limit`, который определяет временной интервал, в течение которого сообщения от одного и того же пользователя будут подвергаться троттлингу.
2. Создается экземпляр `TTLCache` с максимальным размером 10 000 элементов и временем жизни (TTL), равным `time_limit`. Этот кэш будет использоваться для хранения идентификаторов чатов пользователей, чтобы отслеживать их активность и ограничивать частоту отправки сообщений.

**Примеры**:

```python
middleware = ThrottlingMiddleware(time_limit=3)
```

### `__call__`

```python
async def __call__(
        self,
        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
        event: Message,
        data: Dict[str, Any]
) -> Any:
    """
    Перехватывает и обрабатывает входящие сообщения.

    Args:
        handler (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Функция-обработчик сообщения.
        event (Message): Объект сообщения, которое необходимо обработать.
        data (Dict[str, Any]): Дополнительные данные, которые могут быть переданы обработчику.

    Returns:
        Any: Результат обработки сообщения.
    """
    ...
```

**Назначение**: Перехват и обработка входящих сообщений для реализации логики троттлинга.

**Параметры**:
- `handler` (Callable[[Message, Dict[str, Any]], Awaitable[Any]]): Функция-обработчик сообщения.
- `event` (Message): Объект сообщения, которое необходимо обработать.
- `data` (Dict[str, Any]): Дополнительные данные, которые могут быть переданы обработчику.

**Возвращает**:
- `Any`: Результат обработки сообщения.

**Как работает функция**:

1. Функция `__call__` является основной точкой входа для middleware. Она принимает функцию-обработчик `handler`, объект сообщения `event` и дополнительные данные `data`.
2. Проверяется, находится ли идентификатор чата пользователя (`event.chat.id`) в кэше `self.limit`.
3. Если идентификатор чата уже есть в кэше, это означает, что пользователь недавно отправлял сообщение, и обработка текущего сообщения прерывается (функция возвращает `None`).
4. Если идентификатора чата нет в кэше, он добавляется в кэш (с произвольным значением `None`), и сообщение передается для дальнейшей обработки путем вызова функции `handler` с объектом сообщения `event` и данными `data`.

**Примеры**:

```python
async def my_handler(event: Message, data: Dict[str, Any]) -> None:
    print(f"Received message: {event.text}")

middleware = ThrottlingMiddleware(time_limit=2)
result = await middleware(my_handler, event, data)
```
```
A: Проверка наличия ID чата в кэше
|
B: ID чата в кэше?
| Да: C (return)
| Нет: D
|
D: Добавление ID чата в кэш
|
E: Вызов обработчика сообщения
|
F: Завершение