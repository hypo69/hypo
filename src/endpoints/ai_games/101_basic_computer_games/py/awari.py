"""
<AWARI>:
=================
Сложность: 4
-----------------
Авари - это игра для двух игроков, имитирующая африканскую игру с теми же названием.
Игровое поле состоит из 14 лунок, 12 из которых расположены по кругу и содержат в начале игры по 4 камня, 
две лунки для сбора камней, принадлежащие игрокам.  Игроки по очереди выбирают одну из своих лунок и
раскладывают ее содержимое по одной в следующие лунки по часовой стрелке. Если последняя положенная фишка попадает в свою "копилку", игрок делает ещё ход.  Если последняя положенная фишка попадает в пустую лунку, 
камни из этой лунки и лунки напротив (лунки противника) попадают к игроку.
Игра заканчивается, когда у одного из игроков не остаётся камней. 
Победителем считается игрок, собравший наибольшее количество камней.
Правила игры: 
-----------------
1. Игровое поле состоит из 14 лунок, расположенных по кругу (12 игровых и 2 накопительных).
2. В начале игры в каждой из 12 игровых лунок находится по 4 камня. Накопительные лунки пусты.
3. Игроки ходят по очереди.
4. В свой ход игрок выбирает одну из своих игровых лунок (с 1 по 6 или с 7 по 12) и забирает из нее все камни.
5. Затем игрок раскладывает эти камни по одному в каждую следующую лунку по часовой стрелке, начиная со следующей за выбранной. 
6. Если последний камень попадает в накопительную лунку игрока, игрок получает дополнительный ход.
7. Если последний камень попадает в пустую лунку на стороне игрока, игрок забирает этот камень и все камни из противоположной лунки на стороне противника в свою накопительную лунку.
8. Если при каком-либо ходе все камни одного из игроков заканчиваются, игра завершается.
9. Победителем считается игрок, у которого в накопительной лунке окажется больше камней.
-----------------
Алгоритм:
-----------------
1.  Инициализация:
    a. Создать массив board (игровое поле) из 14 элементов (лунок).
    b. Присвоить первым 12 элементам массива board значение 4 (начальное количество камней в лунках).
    c. Присвоить 13 и 14 элементам массива board значение 0 (накопительные лунки игроков).
    d. Установить turn (номер текущего игрока) в 1.
2.  Игровой цикл:
    a. Вывести на экран текущее состояние игрового поля.
    b. Вывести сообщение о том, что сейчас ход игрока turn.
    c. Запросить у игрока номер лунки (move), из которой он хочет взять камни.
    d. Если выбранная лунка пуста или не принадлежит текущему игроку, вернуться к шагу 2с.
    e. Сохранить количество камней из выбранной лунки в stones. Присвоить выбранной лунке 0.
    f. Раскладывать камни по одному в каждую следующую лунку по часовой стрелке, пока не закончатся камни.
       i.   Увеличить номер текущей лунки по кругу.
       ii.  Увеличить на 1 количество камней в текущей лунке.
    g. Если последний камень попал в накопительную лунку игрока, вернуться к шагу 2a.
    h. Если последний камень попал в пустую лунку игрока, забрать камни из этой лунки и противоположной в свою накопительную лунку.
    i.  Если у текущего игрока не осталось камней на его половине поля, завершить игру, и перейти к шагу 3.
    j.  Переключить ход на следующего игрока ( turn = 3 - turn). Перейти к шагу 2a.
3.  Определение победителя:
    a.  Сложить все камни с игрового поля в накопительные лунки.
    b.  Вывести результат. Если у первого игрока больше камней, чем у второго, то первый игрок победил, иначе - победил второй. Если количество камней равно, то ничья.
    c.  Завершить игру.
-----------------
Блок-схема:
```mermaid
graph TD
    Start(Start) --> Initialize(Initialize Board and Players);
    Initialize --> DisplayBoard(Display Board);
    DisplayBoard --> PlayerTurn(Get Player Turn);
    PlayerTurn --> GetMove(Get Player Move);
    GetMove -- Invalid Move --> PlayerTurn;
    GetMove -- Valid Move --> TakeStones(Take Stones from Selected Pit);
    TakeStones --> DistributeStones(Distribute Stones);
    DistributeStones --> LastStoneOwnStore(Last Stone in Own Store?);
    LastStoneOwnStore -- Yes --> DisplayBoard;
    LastStoneOwnStore -- No --> LastStoneEmptyPit(Last Stone in Empty Pit?);
    LastStoneEmptyPit -- Yes --> CaptureStones(Capture Stones);
    CaptureStones --> CheckEndGame(Check if game is over);
    LastStoneEmptyPit -- No --> CheckEndGame;
    CheckEndGame -- Game Over --> CalculateWinner(Calculate Winner);
    CheckEndGame -- Game Not Over --> SwitchPlayer(Switch Player);
    SwitchPlayer --> DisplayBoard;
    CalculateWinner --> DisplayWinner(Display Winner);
    DisplayWinner --> End(End);
    
    style Start fill:#f9f,stroke:#333,stroke-width:2px
    style End fill:#f9f,stroke:#333,stroke-width:2px
```
"""
def initialize_board():
    """
    Инициализирует игровое поле.

    Создает список из 14 элементов, представляющих лунки.
    Первые 12 лунок содержат по 4 камня, а последние 2 лунки (накопительные) - 0 камней.
    
    Returns:
        list: Список, представляющий игровое поле.
    """
    board = [4] * 12 + [0, 0]
    return board

def display_board(board):
    """
    Выводит текущее состояние игрового поля на экран.

    Args:
        board (list): Список, представляющий игровое поле.
    """
    print("-----------------------------------")
    print("     ", end="")
    for i in range(11, 6, -1):
      print(f"{i:2}", end=" ")
    print("\n",board[13], " ", end="  ")
    for i in range(0, 12):
      print(f"{board[i]:2}", end=" ")
    print("  ", board[12])
    print("     ", end="")
    for i in range(0,6):
        print(f"{i+1:2}", end=" ")
    print("\n-----------------------------------")


def get_player_move(board, player_turn):
    """
    Запрашивает у игрока номер лунки для хода и проверяет корректность ввода.

    Args:
        board (list): Список, представляющий игровое поле.
        player_turn (int): Номер текущего игрока (1 или 2).

    Returns:
        int: Номер выбранной лунки (от 1 до 6 для каждого игрока), либо -1 при некорректном вводе.
    """
    while True:
        try:
            if player_turn == 1:
                move = int(input(f"Игрок {player_turn}, выберите лунку (1-6): "))
                if 1 <= move <= 6 and board[move - 1] > 0:
                    return move - 1
                else:
                    print("Некорректный выбор. Попробуйте еще раз.")
            else:
                move = int(input(f"Игрок {player_turn}, выберите лунку (7-12): "))
                if 7 <= move <= 12 and board[move - 1] > 0:
                     return move-1
                else:
                     print("Некорректный выбор. Попробуйте еще раз.")

        except ValueError:
            print("Некорректный ввод. Введите число.")

def distribute_stones(board, start_pit, player_turn):
    """
    Распределяет камни из выбранной лунки по следующим лункам.

    Args:
        board (list): Список, представляющий игровое поле.
        start_pit (int): Индекс лунки, из которой берутся камни.
        player_turn (int): Номер текущего игрока (1 или 2).

    Returns:
        int: Индекс лунки, в которую был положен последний камень.
    """
    stones = board[start_pit]
    board[start_pit] = 0
    current_pit = start_pit
    
    while stones > 0:
        current_pit = (current_pit + 1) % 14
        if player_turn == 1 and current_pit == 12:
           continue
        if player_turn == 2 and current_pit == 13:
           continue
        board[current_pit] += 1
        stones -= 1
    
    return current_pit

def capture_stones(board, last_pit, player_turn):
  """
    Захватывает камни из последней лунки и противоположной лунки, если это возможно.

    Args:
        board (list): Список, представляющий игровое поле.
        last_pit (int): Индекс лунки, в которую был положен последний камень.
        player_turn (int): Номер текущего игрока (1 или 2).
  """
  if player_turn == 1 and 0 <= last_pit <= 5 and board[last_pit] == 1:
      opposite_pit = 11 - last_pit
      board[12] += board[last_pit] + board[opposite_pit]
      board[last_pit] = 0
      board[opposite_pit] = 0
  elif player_turn == 2 and 6 <= last_pit <= 11 and board[last_pit] == 1:
      opposite_pit = 11 - last_pit
      board[13] += board[last_pit] + board[opposite_pit]
      board[last_pit] = 0
      board[opposite_pit] = 0

def check_end_game(board,player_turn):
  """
    Проверяет, закончилась ли игра.
    Игра заканчивается, если все лунки одного из игроков пусты.

    Args:
        board (list): Список, представляющий игровое поле.
        player_turn (int): Номер текущего игрока (1 или 2).

    Returns:
        bool: True, если игра закончилась, False в противном случае.
  """
  if player_turn == 1:
      return all(board[i] == 0 for i in range(0, 6))
  else:
      return all(board[i] == 0 for i in range(6, 12))


def calculate_winner(board):
    """
    Определяет победителя игры.
    Складывает все камни с игровых лунок в накопительные лунки и определяет победителя.

    Args:
       board (list): Список, представляющий игровое поле.

    Returns:
        str: Сообщение о результате игры и имя победителя.
    """
    for i in range(0,12):
        if i < 6:
            board[12] += board[i]
            board[i] = 0
        else:
            board[13] += board[i]
            board[i] = 0

    if board[12] > board[13]:
        return f"Игрок 1 победил со счетом {board[12]} - {board[13]}"
    elif board[13] > board[12]:
        return f"Игрок 2 победил со счетом {board[13]} - {board[12]}"
    else:
        return f"Ничья со счетом {board[12]} - {board[13]}"

def play_awari():
    """
    Запускает игровой процесс.

    Инициализирует игру, запускает игровой цикл и выводит результаты.
    """
    board = initialize_board()
    player_turn = 1
    
    while True:
        display_board(board)
        print(f"Ход игрока {player_turn}")
        
        move = get_player_move(board, player_turn)
        last_pit = distribute_stones(board, move, player_turn)

        if (player_turn == 1 and last_pit == 12) or (player_turn == 2 and last_pit == 13):
          continue
        
        capture_stones(board, last_pit, player_turn)
        
        if check_end_game(board,player_turn):
            display_board(board)
            print(calculate_winner(board))
            break
        
        player_turn = 3 - player_turn
      
play_awari()
"""
Пояснения:
Игровое поле представлено списком `board` из 14 элементов. Первые 12 элементов (индексы 0-11) соответствуют игровым лункам, а последние два элемента (индексы 12 и 13) — накопительным лункам для игроков 1 и 2 соответственно.
Функция `initialize_board` создает и инициализирует этот список, присваивая 4 камня каждой игровой лунке и 0 накопительным лункам.
Функция `display_board` выводит текущее состояние игрового поля в консоль.
Функция `get_player_move` запрашивает у игрока номер лунки для хода и проверяет корректность ввода.
Функция `distribute_stones` берет камни из выбранной лунки и распределяет их по следующим лункам.
Функция `capture_stones` захватывает камни из последней лунки и противоположной лунки, если это возможно, согласно правилам игры.
Функция `check_end_game` проверяет, закончилась ли игра, то есть, когда у одного из игроков нет камней на его половине поля.
Функция `calculate_winner` складывает все оставшиеся камни с игровых лунок в накопительные, после чего определяет победителя.
Функция `play_awari` запускает основной игровой процесс.
В цикле `while True:` игра продолжается, пока не будет выявлен победитель.
В каждой итерации цикла отображается доска, запрашивается ход игрока, выполняются действия, связанные с ходом.
После каждого хода проверяется, закончилась ли игра. Если да, то выводится сообщение о результате.
Номер текущего игрока переключается (1<->2).
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
```