# Модуль `src.endpoints.emil.minibot`

## Обзор

Модуль предоставляет реализацию простого Telegram-бота, предназначенного для обработки запросов, связанных с веб-сайтом emil-design.com. Он включает в себя обработку текстовых команд, URL-адресов, голосовых сообщений и документов.

## Подробней

Этот модуль содержит классы и функции для управления Telegram-ботом, который может отвечать на текстовые запросы, обрабатывать URL-адреса, отправлять ответы, понимать команды и перенаправлять PDF-файлы. Он использует Google Gemini AI для обработки текста и модуль `telebot` для взаимодействия с Telegram API.

## Классы

### `BotHandler`

**Описание**: Класс `BotHandler` предназначен для обработки различных типов сообщений, получаемых от Telegram-бота.

**Как работает класс**:
Класс инициализируется с использованием сценария, модели Google Gemini AI и списка вопросов. Он содержит методы для обработки текстовых сообщений, URL-адресов, команды `--next` и отправки `user_flowchart`.

**Методы**:

#### `__init__`

```python
def __init__(self):
    """Инициализация обработчика событий телеграм-бота."""
    ...
```

**Назначение**: Инициализирует экземпляр класса `BotHandler`.

**Как работает метод**:
1. Инициализирует атрибут `scenario` экземпляром класса `Scenario`.
2. Инициализирует атрибут `model` экземпляром класса `GoogleGenerativeAI`, передавая ему значение переменной окружения `GEMINI_API`.
3. Инициализирует атрибут `questions_list` списком строк, содержащих вопросы.

#### `handle_message`

```python
def handle_message(self, bot: telebot, message: 'message'):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении.

**Как работает метод**:
1. Извлекает текст сообщения из объекта `message`.
2. Проверяет, является ли текст сообщения командой "?". Если да, вызывает метод `_send_user_flowchart` для отправки схемы user_flowchart.
3. Проверяет, является ли текст сообщения URL-адресом. Если да, вызывает метод `_handle_url` для обработки URL-адреса.
4. Проверяет, является ли текст сообщения одной из команд ("--next", "-next", "__next", "-n", "-q"). Если да, вызывает метод `_handle_next_command` для обработки команды.
5. Если текст сообщения не является ни командой, ни URL-адресом, пытается обработать его с помощью модели Google Gemini AI и отправить ответ пользователю.

#### `_send_user_flowchart`

```python
def _send_user_flowchart(self, bot, chat_id):
    """Отправка схемы user_flowchart."""
    ...
```

**Назначение**: Отправляет пользователю схему user_flowchart.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `chat_id`: Идентификатор чата, в который нужно отправить схему.

**Как работает метод**:
1. Определяет путь к файлу с изображением схемы `user_flowchart.png`.
2. Открывает файл изображения в режиме чтения байтов (`'rb'`).
3. Использует метод `send_photo` объекта `bot` для отправки фотографии в указанный чат.
4. В случае, если файл не найден, логирует ошибку и отправляет сообщение об ошибке в чат.

#### `_handle_url`

```python
def _handle_url(self, bot, message: 'message'):
    """Обработка URL, присланного пользователем."""
    ...
```

**Назначение**: Обрабатывает URL-адрес, присланный пользователем.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении.

**Как работает метод**:
1. Извлекает URL-адрес из текста сообщения.
2. Проверяет, начинается ли URL-адрес с "https://one-tab.com" или "https://www.one-tab.com". Если нет, отправляет сообщение об ошибке пользователю и завершает работу.
3. Извлекает цену, название и список URL-адресов, используя функцию `fetch_target_urls_onetab`.
4. Отправляет сообщение пользователю с информацией о полученном мехироне и цене.
5. Проверяет, был ли получен список URL-адресов. Если нет, отправляет сообщение об ошибке пользователю и завершает работу.
6. Запускает сценарий обработки URL-адресов с использованием асинхронной функции `self.scenario.run_scenario`.
7. В случае возникновения ошибки в процессе обработки URL-адреса, логирует ошибку и отправляет сообщение об ошибке пользователю.

#### `_handle_next_command`

```python
def _handle_next_command(self, bot, message):
    """Обработка команды '--next' и её аналогов."""
    ...
```

**Назначение**: Обрабатывает команду '--next' и её аналоги, отправляя случайный вопрос из списка и ответ на него.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает метод**:
1. Выбирает случайный вопрос из списка `self.questions_list`.
2. Отправляет выбранный вопрос пользователю.
3. Получает ответ на вопрос от модели, используя метод `self.model.ask(question)`.
4. Отправляет полученный ответ пользователю.
5. В случае возникновения ошибки при чтении вопросов, логирует ошибку и отправляет сообщение об ошибке пользователю.

#### `help_command`

```python
def help_command(self, bot, message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, отправляя пользователю список доступных команд.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает метод**:
Отправляет пользователю сообщение со списком доступных команд и их описанием.

#### `send_pdf`

```python
def send_pdf(self, bot, message, pdf_file):
    """Обработка команды /sendpdf для отправки PDF."""
    ...
```

**Назначение**: Обрабатывает команду `/sendpdf`, отправляя пользователю PDF-файл.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message`: Объект сообщения, содержащий информацию о сообщении.
- `pdf_file`: Путь к PDF-файлу, который нужно отправить.

**Как работает метод**:
1. Открывает PDF-файл в режиме чтения байтов (`'rb'`).
2. Использует метод `send_document` объекта `bot` для отправки PDF-файла пользователю.
3. В случае возникновения ошибки при отправке PDF-файла, логирует ошибку и отправляет сообщение об ошибке пользователю.

#### `handle_voice`

```python
def handle_voice(self, bot, message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message`: Объект сообщения, содержащий информацию о голосовом сообщении.

**Как работает метод**:
1. Получает информацию о файле голосового сообщения, используя метод `get_file` объекта `bot`.
2. Скачивает файл голосового сообщения, используя метод `download_file` объекта `bot`.
3. Определяет путь для сохранения скачанного файла во временной директории.
4. Сохраняет скачанный файл во временной директории.
5. Транскрибирует голосовое сообщение, используя метод `_transcribe_voice`.
6. Отправляет распознанный текст пользователю.
7. В случае возникновения ошибки при обработке голосового сообщения, логирует ошибку и отправляет сообщение об ошибке пользователю.

#### `_transcribe_voice`

```python
def _transcribe_voice(self, file_path):
    """Транскрибирование голосового сообщения (заглушка)."""
    ...
```

**Назначение**: Транскрибирует голосовое сообщение в текст. В текущей реализации является заглушкой.

**Параметры**:
- `file_path`: Путь к файлу голосового сообщения.

**Как работает метод**:
Возвращает строку "Распознавание голоса ещё не реализовано.".

#### `handle_document`

```python
def handle_document(self, bot, message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Параметры**:
- `bot`: Экземпляр Telegram-бота.
- `message`: Объект сообщения, содержащий информацию о документе.

**Как работает метод**:
1. Получает информацию о файле документа, используя метод `bot.get_file(message.document.file_id)`.
2. Скачивает файл документа, используя метод `bot.download_file(file_info.file_path)`.
3. Формирует путь для сохранения файла во временной директории.
4. Сохраняет файл во временной директории.
5. Отправляет пользователю сообщение об успешном сохранении файла.
6. В случае возникновения ошибки при обработке документа, логирует ошибку и отправляет сообщение об ошибке пользователю.

### `Config`

**Описание**: Класс `Config` предназначен для хранения конфигурационных параметров бота.

**Как работает класс**:
Класс определяет параметры, такие как токен бота, идентификатор канала, директорию с фотографиями, информацию о боте, сообщения для неизвестных команд, приветственное сообщение и сообщение справки.

**Атрибуты**:
- `BOT_TOKEN` (str): Токен Telegram-бота, получаемый из переменной окружения `TELEGRAM_BOT_TOKEN` или из `gs.credentials.telegram.hypo69_emil_design_bot` в зависимости от значения `USE_ENV`.
- `CHANNEL_ID` (str): Идентификатор канала Telegram.
- `PHOTO_DIR` (Path): Путь к директории с фотографиями.
- `COMMAND_INFO` (str): Информация о боте.
- `UNKNOWN_COMMAND_MESSAGE` (str): Сообщение для неизвестных команд.
- `START_MESSAGE` (str): Приветственное сообщение.
- `HELP_MESSAGE` (str): Сообщение справки.

## Функции

### `command_start`

```python
@bot.message_handler(commands=['start'])
def command_start(message):
    """Обработка команды /start."""
    ...
```

**Назначение**: Обрабатывает команду `/start`, отправляя пользователю приветственное сообщение.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает функция**:
1. Логирует информацию об использовании команды `/start` пользователем.
2. Отправляет пользователю приветственное сообщение, используя `config.START_MESSAGE`.

### `command_help`

```python
@bot.message_handler(commands=['help'])
def command_help(message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, вызывая метод `help_command` класса `BotHandler`.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает функция**:
1. Логирует информацию об использовании команды `/help` пользователем.
2. Вызывает метод `help_command` объекта `handler`, передавая ему объект `bot` и объект `message`.

### `command_info`

```python
@bot.message_handler(commands=['info'])
def command_info(message):
    """Обработка команды /info."""
    ...
```

**Назначение**: Обрабатывает команду `/info`, отправляя пользователю информацию о боте.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает функция**:
1. Логирует информацию об использовании команды `/info` пользователем.
2. Отправляет пользователю информацию о боте, используя `config.COMMAND_INFO`.

### `command_time`

```python
@bot.message_handler(commands=['time'])
def command_time(message):
    """Обработка команды /time."""
    ...
```

**Назначение**: Обрабатывает команду `/time`, отправляя пользователю текущее время.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает функция**:
1. Логирует информацию об использовании команды `/time` пользователем.
2. Получает текущее время, используя модуль `datetime`.
3. Форматирует текущее время в строку.
4. Отправляет пользователю сообщение с текущим временем.

### `command_photo`

```python
@bot.message_handler(commands=['photo'])
def command_photo(message):
    """Обработка команды /photo."""
    ...
```

**Назначение**: Обрабатывает команду `/photo`, отправляя пользователю случайную фотографию из директории.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о сообщении.

**Как работает функция**:
1. Логирует информацию об использовании команды `/photo` пользователем.
2. Получает список файлов в директории с фотографиями.
3. Если список файлов не пуст, выбирает случайную фотографию из списка.
4. Открывает файл фотографии в режиме чтения байтов (`'rb'`).
5. Отправляет фотографию пользователю.
6. Если список файлов пуст, отправляет пользователю сообщение об отсутствии фотографий в директории.
7. В случае, если директория с фотографиями не найдена, отправляет пользователю сообщение об ошибке.

### `handle_voice_message`

```python
@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, вызывая метод `handle_voice` класса `BotHandler`.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о голосовом сообщении.

**Как работает функция**:
1. Логирует информацию об отправке голосового сообщения пользователем.
2. Вызывает метод `handle_voice` объекта `handler`, передавая ему объект `bot` и объект `message`.

### `handle_document_message`

```python
@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает сообщения с документами, вызывая метод `handle_document` класса `BotHandler`.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о документе.

**Как работает функция**:
1. Логирует информацию об отправке документа пользователем.
2. Вызывает метод `handle_document` объекта `handler`, передавая ему объект `bot` и объект `message`.

### `handle_text_message`

```python
@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, не начинающиеся с символа `/`, вызывая метод `handle_message` класса `BotHandler`.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о текстовом сообщении.

**Как работает функция**:
1. Логирует информацию об отправке текстового сообщения пользователем.
2. Вызывает метод `handle_message` объекта `handler`, передавая ему объект `bot` и объект `message`.

### `handle_unknown_command`

```python
@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    """Обработка неизвестных команд."""
    ...
```

**Назначение**: Обрабатывает неизвестные команды, отправляя пользователю сообщение о неизвестной команде.

**Параметры**:
- `message`: Объект сообщения, содержащий информацию о команде.

**Как работает функция**:
1. Логирует информацию об отправке неизвестной команды пользователем.
2. Отправляет пользователю сообщение о неизвестной команде, используя `config.UNKNOWN_COMMAND_MESSAGE`.