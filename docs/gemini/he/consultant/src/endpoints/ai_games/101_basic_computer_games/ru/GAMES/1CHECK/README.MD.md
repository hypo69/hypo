# Анализ кода модуля `1CHECK`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10)**
  - **Преимущества:**
        - Код предоставляет реализацию игры в шашки с начальной расстановкой 48 шашек на крайних рядах.
        - Код включает в себя логику проверки допустимости ходов, выполнения прыжков и поиска доступных ходов.
        - Есть функции для отображения доски и отслеживания количества удаленных шашек.
        - Код легко читаем и структурирован.
  - **Недостатки:**
       - Отсутствуют docstring, нет документации reStructuredText.
       - Присутствуют жестко заданные значения, которые можно было бы вынести в константы.
       - Отсутствует обработка исключений.
       - Алгоритм поиска доступных ходов не оптимизирован, выбирается первый доступный ход.
       - Код не поддерживает разные уровни сложности или стратегии.
       - Не используется `src.utils.jjson` для загрузки данных.
       - Нет логгера для записи ошибок.
       - Отсутствует разделение логики игры от пользовательского интерфейса.
       - Код не соответствует pep8.

**Рекомендации по улучшению**

1.  **Документация:**
    - Добавить docstring для всех модулей, классов, методов и функций с использованием формата reStructuredText (RST) для лучшей читаемости и совместимости со Sphinx.
2.  **Управление данными:**
    - Заменить все `json.load` на `j_loads` или `j_loads_ns` из `src.utils.jjson`. В данном коде json не используется.
3.  **Обработка ошибок:**
    - Добавить обработку ошибок с использованием `from src.logger.logger import logger` для логирования ошибок вместо общих блоков `try-except`.
    - Использовать `logger.error` для записи сообщений об ошибках.
4.  **Оптимизация логики:**
    - Оптимизировать `find_possible_jumps` для выбора наиболее выгодного хода, а не первого попавшегося.
    - Реализовать уровни сложности игры.
5.  **Улучшение кода:**
    - Разделить логику игры и интерфейса пользователя.
    - Использовать константы для всех жестко заданных значений.
6.  **Стиль кода:**
    - Привести код к стандартам pep8, например, длина строки и именование переменных.

**Улучшенный код**
```python
"""
Модуль для симуляции игры в шашки с начальной расстановкой шашек на крайних рядах.
===================================================================================
Модуль содержит класс :class:`Checkerboard` для представления игрового поля и выполнения действий над шашками.

Пример использования
--------------------
Пример создания и использования экземпляра класса `Checkerboard`:

.. code-block:: python

   game = Checkerboard()
   game.display_board()
   game.play()
"""
from typing import List, Tuple  #  импортирован  List, Tuple
from src.logger.logger import logger  # импортирован logger


BOARD_SIZE = 8  # Константа для размера доски
CHECKER = 1  # Константа для представления шашки
EMPTY = 0  # Константа для представления пустого поля


class Checkerboard:
    """
    Класс для представления доски шашек и управления игровым процессом.
    """
    def __init__(self):
        """
        Инициализирует доску 8x8 с 48 шашками, расставленными на крайних рядах.
        """
        self.board: List[List[int]] = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]  # 0 = empty, 1 = checker # инициализация доски
        self._initialize_checkers()  # инициализация шашек
        self.removed_checkers: int = 0 # количество удаленных шашек

    def _initialize_checkers(self):
        """
        Размещает 48 шашек на двух крайних рядах (ряды 1 и 8).
        """
        for row in [0, 7]:  # Rows 1 and 8 (0-indexed) #  перебор рядов
            for col in range(BOARD_SIZE): # перебор столбцов
                self.board[row][col] = CHECKER  #  размещаем шашку

    def is_valid_jump(self, start: Tuple[int, int], end: Tuple[int, int]) -> bool:
        """
        Проверяет, является ли прыжок допустимым.

        :param start: Кортеж (row, col) начальной позиции.
        :param end: Кортеж (row, col) конечной позиции.
        :return: True, если прыжок допустим, иначе False.
        """
        start_row, start_col = start #  начальные координаты
        end_row, end_col = end #  конечные координаты

        # Проверяем, находится ли конечная позиция в пределах доски # проверка на выход за границы доски
        if not (0 <= end_row < BOARD_SIZE and 0 <= end_col < BOARD_SIZE):
            return False #  если нет, то возврат False

        # Проверяем, пусто ли место посадки # проверка на пустоту конечной позиции
        if self.board[end_row][end_col] != EMPTY:
            return False # если нет, то возврат False

        # Вычисляем координаты середины (шашка, которую перепрыгивают) #  вычисляем координаты прыгаемой шашки
        mid_row = (start_row + end_row) // 2 #  вычисляем строку прыгаемой шашки
        mid_col = (start_col + end_col) // 2 #  вычисляем столбец прыгаемой шашки

        # Проверяем, есть ли шашка для перепрыгивания # проверка на наличие прыгаемой шашки
        if self.board[mid_row][mid_col] != CHECKER:
            return False # если нет, то возврат False

        # Проверяем, является ли прыжок диагональным #  проверка что прыжок диагональный
        if abs(start_row - end_row) != 2 or abs(start_col - end_col) != 2:
            return False # если нет, то возврат False

        return True # если все проверки пройдены, то возврат True

    def perform_jump(self, start: Tuple[int, int], end: Tuple[int, int]):
        """
        Выполняет прыжок и удаляет перепрыгнутую шашку.

        :param start: Кортеж (row, col) начальной позиции.
        :param end: Кортеж (row, col) конечной позиции.
        """
        start_row, start_col = start #  начальные координаты
        end_row, end_col = end #  конечные координаты

        # Перемещаем шашку #  обнуляем начальную позицию
        self.board[start_row][start_col] = EMPTY #  обнуляем начальную позицию
        self.board[end_row][end_col] = CHECKER #  ставим шашку в конечную позицию

        # Удаляем перепрыгнутую шашку #  удаляем прыгаемую шашку
        mid_row = (start_row + end_row) // 2 #  вычисляем строку прыгаемой шашки
        mid_col = (start_col + end_col) // 2 #  вычисляем столбец прыгаемой шашки
        self.board[mid_row][mid_col] = EMPTY #  обнуляем прыгаемую шашку

        # Увеличиваем счетчик удаленных шашек #  увеличиваем счетчик удаленных шашек
        self.removed_checkers += 1 #  увеличиваем счетчик удаленных шашек

    def find_possible_jumps(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """
        Находит все возможные прыжки на доске.

        :return: Список кортежей, где каждый кортеж содержит (start, end) позиции для допустимых прыжков.
        """
        jumps: List[Tuple[Tuple[int, int], Tuple[int, int]]] = []  #  создаем пустой список прыжков
        for row in range(BOARD_SIZE): # перебираем строки
            for col in range(BOARD_SIZE): # перебираем столбцы
                if self.board[row][col] == CHECKER: #  если текущая клетка - шашка
                    # Проверяем все четыре диагональных направления #  перебираем диагональные направления
                    for dr, dc in [(-2, -2), (-2, 2), (2, -2), (2, 2)]:
                        start = (row, col) #  начальная позиция
                        end = (row + dr, col + dc) #  конечная позиция
                        if self.is_valid_jump(start, end): #  если прыжок возможен
                            jumps.append((start, end)) # добавляем прыжок в список
        return jumps  #  возвращаем список прыжков

    def play(self):
        """
        Симулирует игру, выполняя прыжки до тех пор, пока это возможно.
        """
        while True: #  запускаем бесконечный цикл
            jumps = self.find_possible_jumps()  # ищем возможные прыжки
            if not jumps:
                break  # если нет доступных прыжков, то выходим из цикла

            # Выполняем первый допустимый прыжок (можно оптимизировать дальше) # выполняем первый доступный прыжок
            start, end = jumps[0] # получаем начальную и конечную позиции
            try:
                self.perform_jump(start, end) # выполняем прыжок
            except Exception as ex:
                logger.error(f'ошибка при выполнении прыжка {start=} {end=}', ex)
                break # если при выполнении прыжка возникает ошибка, то выходим из цикла

        print(f"Total checkers removed: {self.removed_checkers}") # выводим количество удаленных шашек

    def display_board(self):
        """
        Отображает текущее состояние доски.
        """
        for row in self.board:
            print(" ".join("•" if cell == CHECKER else "." for cell in row)) # выводим строку доски, где шашки это '•', а пустые клетки это '.'
        print()  #  пустая строка для разделения досок


# Main program
if __name__ == "__main__":
    print("Initial Board:")
    game = Checkerboard()
    game.display_board()

    print("Playing the game...")
    game.play()

    print("Final Board:")
    game.display_board()
```