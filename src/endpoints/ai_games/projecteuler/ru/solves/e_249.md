## Ответ на Задачу No 249: Подмножества с простыми суммами

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Дано множество `S` простых чисел меньше 5000.
*   Необходимо найти количество подмножеств `S`, сумма элементов которых также является простым числом.
*   Результат нужно вывести по модулю 50000000.

**Решение:**
1. **Генерация простых чисел:** Сначала необходимо сгенерировать все простые числа меньше 5000. Можно использовать алгоритм "Решето Эратосфена".
2. **Перебор подмножеств:**  Нужно рассмотреть все возможные подмножества множества S. Для этого можно использовать битовые маски. Для каждого элемента множества `S` есть два варианта: либо он входит в подмножество, либо нет. Таким образом, если в `S` `n` элементов, всего будет `2^n` подмножеств.
3. **Проверка суммы:** Для каждого подмножества вычисляем сумму его элементов.
4. **Проверка на простоту:** Проверяем, является ли сумма простым числом. Для этого можно использовать функцию проверки на простоту.
5. **Счетчик:** Если сумма является простым числом, увеличиваем счетчик.
6. **Модуль:** После обработки каждого подмножества берем остаток от деления счетчика на 50000000.

**Оптимизация:**
*   **Проверка простоты:** Можно ускорить проверку на простоту, используя кэширование уже найденных простых чисел. 
*   **Избегание переполнения:**  Накапливать сумму по модулю заданного значения (50000000) для избежания переполнения при вычислении суммы подмножеств.

### 2. Алгоритм решения

1.  **Начало**
2.  **Генерация простых чисел:**
    *   Создать список `primes` и заполнить его простыми числами меньше 5000.
3.  **Инициализация счетчика:**
    *   Создать переменную `count` и присвоить ей 0.
4.  **Перебор подмножеств:**
    *   Для каждого `i` от 0 до `2^len(primes) - 1`:
        *   Инициализировать сумму подмножества `subset_sum` = 0.
        *   Для каждого `j` от 0 до `len(primes) - 1`:
             *    Если `(i >> j) & 1 == 1`:
                   * Добавить `primes[j]` к `subset_sum`.
        *   **Проверка на простоту:**
            *  Если `subset_sum` > 1:
               *  Если `subset_sum` простое число:
                  *  Увеличить `count` на 1.
                
        *  Присвоить `count` значение `count % 50000000`
5.  **Возврат результата:**
    *   Вернуть `count`.
6.  **Конец**

### 3. Реализация на Python 3.12

```python
def is_prime(n):
    """
    Проверяет, является ли число простым.
    """
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_primes(limit):
    """
    Генерирует список простых чисел меньше заданного предела.
    """
    primes = []
    for num in range(2, limit):
        if is_prime(num):
            primes.append(num)
    return primes

def solve():
    """
    Решает задачу поиска количества подмножеств с простыми суммами.
    """
    limit = 5000
    primes = generate_primes(limit)
    count = 0
    modulo = 50000000
    
    for i in range(2**len(primes)):
        subset_sum = 0
        for j in range(len(primes)):
            if (i >> j) & 1:
                subset_sum = (subset_sum + primes[j])
        if subset_sum > 1 and is_prime(subset_sum):
             count += 1
        count = count % modulo
    return count


# Пример использования:
result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> GeneratePrimes((Сгенерировать простые числа < 5000))
    GeneratePrimes --> InitializeCount((Инициализировать count = 0))
    InitializeCount --> LoopSubsetsStart((Начать цикл: i от 0 до 2^len(primes) - 1))
    LoopSubsetsStart --> InitializeSum((Инициализировать subset_sum = 0))
    InitializeSum --> LoopElementsStart((Начать цикл: j от 0 до len(primes) - 1))
    LoopElementsStart --> CheckBit((Проверить: (i >> j) & 1 == 1?))
    CheckBit -- Да --> AddToSum((Добавить primes[j] к subset_sum))
    AddToSum --> LoopElementsStart
    CheckBit -- Нет --> LoopElementsStart
    LoopElementsStart --> CheckSubsetSum((subset_sum > 1?))
    CheckSubsetSum -- Да --> CheckPrimeSum((Проверить: subset_sum простое?))
    CheckPrimeSum -- Да --> IncrementCount((Увеличить count на 1))
    IncrementCount --> LoopSubsetsStart
    CheckPrimeSum -- Нет --> LoopSubsetsStart
    CheckSubsetSum -- Нет --> LoopSubsetsStart
    LoopSubsetsStart --> ModuloCount((count = count % 50000000))
    ModuloCount --> End((Конец: вернуть count))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Сгенерировать простые числа < 5000:** Создаем список простых чисел меньше 5000.
*   **Инициализировать count = 0:** Инициализируем счетчик для подсчета подмножеств с простой суммой.
*   **Начать цикл: i от 0 до 2^len(primes) - 1:** Начало цикла для перебора всех подмножеств, используя битовые маски.
*   **Инициализировать subset_sum = 0:** Обнуляем сумму для каждого подмножества.
*   **Начать цикл: j от 0 до len(primes) - 1:** Начало цикла для перебора элементов в множестве простых чисел для каждого подмножества.
*   **Проверить: (i >> j) & 1 == 1?:** Проверяем, входит ли j-й элемент в текущее подмножество, используя битовую маску.
*   **Добавить primes[j] к subset_sum:**  Добавляем простой элемент к сумме подмножества.
*   **subset_sum > 1?:** Проверяем, что сумма подмножества больше 1.
*   **Проверить: subset_sum простое?:** Проверяем, является ли сумма подмножества простым числом.
*    **Увеличить count на 1:** Увеличиваем счетчик подмножеств с простой суммой.
*   **count = count % 50000000:** Берем остаток от деления count на 50000000.
*   **Конец: вернуть count:** Завершаем программу и возвращаем искомый результат.
