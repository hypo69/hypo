"""
<DICE>:
=================
Сложность: 2
-----------------
Игра DICE имитирует бросание двух кубиков. Компьютер "бросает" два кубика, генерируя два случайных числа от 1 до 6, и выводит результат. Игра продолжается до тех пор, пока пользователь не решит остановиться.

Правила игры:
1. Компьютер генерирует два случайных числа от 1 до 6, имитируя бросок двух кубиков.
2. Результат броска (значения обоих кубиков) выводится на экран.
3. Пользователю предлагается сыграть ещё раз или завершить игру.
4. Игра продолжается, пока пользователь не решит завершить игру.
-----------------
Алгоритм:
1. Начать цикл "пока игра не окончена":
   1.1. Сгенерировать два случайных числа от 1 до 6 (имитация броска двух кубиков).
   1.2. Вывести на экран значения обоих кубиков.
   1.3. Спросить у пользователя, хочет ли он сыграть ещё раз.
   1.4. Если пользователь не хочет играть ещё раз, завершить цикл.
2. Конец игры.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> LoopStart{"Начало цикла: игра продолжается"}
    LoopStart -- Да --> RollDice["<p align='left'>Сгенерировать два случайных числа:
    <code><b>
    dice1 = random(1, 6)
    dice2 = random(1, 6)
    </b></code></p>"]
    RollDice --> OutputResult["Вывести результат: <b>Dice 1: {dice1}, Dice 2: {dice2}</b>"]
    OutputResult --> AskPlayAgain["Спросить пользователя: <b>Play again? (y/n)</b>"]
    AskPlayAgain --> CheckPlayAgain{"Проверка: <code><b>answer == 'y'?</b></code>"}
    CheckPlayAgain -- Да --> LoopStart
    CheckPlayAgain -- Нет --> End["Конец"]
    LoopStart -- Нет --> End
```
Legenda:
    Start - Начало программы.
    LoopStart - Начало цикла, который повторяется, пока пользователь хочет играть.
    RollDice - Генерация двух случайных чисел в диапазоне от 1 до 6, имитирующих бросок двух кубиков.
    OutputResult - Вывод на экран результатов броска двух кубиков.
    AskPlayAgain - Запрос у пользователя, хочет ли он сыграть еще раз.
    CheckPlayAgain - Проверка ответа пользователя. Если ответ 'y', то цикл продолжается, иначе - завершается.
    End - Конец программы.
"""


__author__ = 'hypo69 (hypo69@davidka.net)'
import random

# Игровой цикл
while True:
    # Имитация броска двух кубиков
    dice1 = random.randint(1, 6) # Генерируем случайное число от 1 до 6 для первого кубика
    dice2 = random.randint(1, 6) # Генерируем случайное число от 1 до 6 для второго кубика

    # Вывод результата броска
    print(f"Dice 1: {dice1}, Dice 2: {dice2}") # Выводим значения обоих кубиков

    # Запрос у пользователя, хочет ли он сыграть ещё раз
    play_again = input("Play again? (y/n): ").lower() # Запрашиваем у пользователя, хочет ли он сыграть еще раз и приводим ввод к нижнему регистру

    # Проверка ответа пользователя
    if play_again != 'y': # Если пользователь ввел что-то отличное от 'y'
        break  # Завершаем цикл, и игра заканчивается

"""
Пояснения:
1. **Импорт модуля `random`**:
   - `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел.
2. **Основной цикл `while True:`**:
   - Бесконечный цикл, который продолжается до тех пор, пока пользователь не решит выйти.
3. **Имитация броска кубиков**:
   - `dice1 = random.randint(1, 6)`: Генерирует случайное целое число от 1 до 6 (включительно) и присваивает его переменной `dice1`, имитируя бросок первого кубика.
   - `dice2 = random.randint(1, 6)`: Генерирует случайное целое число от 1 до 6 и присваивает его переменной `dice2`, имитируя бросок второго кубика.
4. **Вывод результатов**:
   - `print(f"Dice 1: {dice1}, Dice 2: {dice2}")`: Выводит на экран результаты бросков обоих кубиков.
5. **Запрос на повторную игру**:
   - `play_again = input("Play again? (y/n): ").lower()`: Запрашивает у пользователя, хочет ли он сыграть ещё раз, и преобразует ввод в нижний регистр для упрощения проверки.
6. **Условие выхода из игры**:
   - `if play_again != 'y':`: Проверяет, не равно ли введенное значение `'y'`. Если это так, то пользователь не хочет продолжать игру.
   - `break`: Выходит из цикла `while True`, завершая игру.
"""
```