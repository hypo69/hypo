# Анализ кода модуля `gomoko.py`

**Качество кода**
8
-   Плюсы
    - Код хорошо структурирован и логически понятен.
    -  Присутствуют комментарии, объясняющие основные этапы игры.
    -  Реализация основной логики игры (ходы игроков, проверка победы и ничьей) выполнена корректно.
    -  Используются функции для разделения логики игры, что повышает читаемость и поддерживаемость кода.
-   Минусы
    -   Отсутствует документация в формате reStructuredText (RST).
    -   Используется стандартный `print` для вывода сообщений, что затрудняет интеграцию с системой логирования.
    -   Не обрабатываются некорректные значения ввода от пользователя (ожидается целое число, но пользователь может ввести текст).
    -   Отсутствует обработка исключений при вводе координат игроком.
    -   Компьютер делает рандомные ходы без какой либо логики.

**Рекомендации по улучшению**

1.  **Документация**:
    -   Добавить docstring в формате RST для модуля, функций и методов. Это улучшит читаемость и документированность кода, что важно для дальнейшей поддержки и модификации.
2.  **Логирование**:
    -   Использовать `from src.logger.logger import logger` для логирования ошибок и отладочной информации. Заменить `print` на `logger.info`, `logger.error` и `logger.debug` для вывода сообщений. Это позволит более эффективно отслеживать работу программы и выявлять проблемы.
3.  **Обработка ошибок**:
    -   Добавить обработку исключений, чтобы избежать падения программы при некорректном вводе пользователя. Использовать `try-except` блоки для перехвата `ValueError` при преобразовании ввода пользователя в целое число и `IndexError` при доступе к неверному индексу массива.
4.  **Улучшение логики компьютера**:
    -  Внедрить более продвинутую логику для хода компьютера, например, проверять на выигрышные комбинации или блокировать ходы пользователя. Это повысит сложность и интерес игры.
5. **Структура кода**
    -   Код не использует классов и поэтому является процедурным. Для лучшей читаемости и масштабируемости, логично будет создать класс `Gomoko`
6.  **Комментарии в коде**
   - Комментарии `#` должны содержать подробное объяснение следующего за ними блока кода.

**Оптимизированный код**

```python
"""
Модуль для реализации игры Гомоку (Пять в ряд).
=========================================================================================

Этот модуль реализует игру Гомоку (также известную как "Пять в ряд") - стратегическую настольную игру для двух игроков.
Игроки по очереди ставят свои фишки (крестики и нолики) на игровое поле, стремясь выстроить непрерывную линию из пяти
своих фишек по вертикали, горизонтали или диагонали. Игра заканчивается, когда один из игроков достигает этого условия,
или когда все поле заполнено, и в этом случае объявляется ничья.

Пример использования
--------------------

.. code-block:: python

    game = Gomoku()
    game.play()
"""
__author__ = 'hypo69 (hypo69@davidka.net)'

import random
from src.logger.logger import logger

class Gomoku:
    """
    Реализует логику игры Гомоку.

    :ivar board: Игровое поле, представляющее собой матрицу 15x15.
    :vartype board: list[list[str]]
    :ivar game_on: Флаг, указывающий, продолжается ли игра.
    :vartype game_on: bool
    :ivar current_player: Номер текущего игрока (1 или 2).
    :vartype current_player: int
    """
    def __init__(self):
        """
        Инициализирует игру Гомоку.
        Создает пустую доску 15x15, устанавливает флаг игры и текущего игрока.
        """
        # 1. Инициализация:
        # 1.1. Создаем пустую доску 15x15
        self.board = [[' ' for _ in range(15)] for _ in range(15)]
        # 1.2. Устанавливаем флаг начала игры G = True
        self.game_on = True
        # 1.3. Устанавливаем флаг игрока, P = 1 (игрок 1 ходит первым)
        self.current_player = 1

    def print_board(self):
        """
        Выводит текущее состояние доски в консоль.
        """
        logger.info("Вывод текущего состояния доски")
        print("   ", end="")
        for i in range(15):
            print(f"{i:2}", end=" ")
        print()
        print("  " + "----" * 15)
        for i, row in enumerate(self.board):
            print(f"{i:2}|", end=" ")
            for cell in row:
                print(f"{cell:2}", end=" ")
            print()
        print()

    def check_winner(self, player):
        """
        Проверяет наличие победной линии на доске.

        :param player: Номер игрока (1 или 2).
        :type player: int
        :return: True, если есть победитель, иначе False.
        :rtype: bool
        """
        symbol = 'X' if player == 1 else 'O'
        # Проверка горизонтальных линий
        for row in self.board:
            for i in range(len(row) - 4):
                if row[i] == row[i + 1] == row[i + 2] == row[i + 3] == row[i + 4] == symbol:
                    return True
        # Проверка вертикальных линий
        for col in range(15):
            for i in range(15 - 4):
                if self.board[i][col] == self.board[i + 1][col] == self.board[i + 2][col] == self.board[i + 3][col] == self.board[i + 4][col] == symbol:
                    return True
        # Проверка диагоналей (сверху-слева направо-вниз)
        for row in range(15 - 4):
            for col in range(15 - 4):
                if self.board[row][col] == self.board[row + 1][col + 1] == self.board[row + 2][col + 2] == self.board[row + 3][col + 3] == self.board[row + 4][col + 4] == symbol:
                    return True
        # Проверка диагоналей (сверху-справа налево-вниз)
        for row in range(15 - 4):
            for col in range(4, 15):
                if self.board[row][col] == self.board[row + 1][col - 1] == self.board[row + 2][col - 2] == self.board[row + 3][col - 3] == self.board[row + 4][col - 4] == symbol:
                    return True
        return False

    def check_full_board(self):
        """
        Проверяет, заполнено ли игровое поле.

        :return: True, если поле заполнено, иначе False.
        :rtype: bool
        """
        for row in self.board:
            for cell in row:
                if cell == ' ':
                    return False  # Если есть хотя бы одна свободная ячейка, то игра не окончена
        return True  # Если нет пустых ячеек - ничья

    def player_move(self):
        """
        Обрабатывает ход игрока.
        Запрашивает координаты хода и обновляет доску.
        """
        while True:
            try:
                # 2.2.1. Запрашиваем координаты хода X, Y
                x = int(input("Игрок 1 (X) введите x (0-14): "))
                y = int(input("Игрок 1 (X) введите y (0-14): "))

                # 2.2.2. Проверяем допустимость хода:
                if 0 <= x < 15 and 0 <= y < 15 and self.board[x][y] == ' ':
                    # 2.2.3. Ставим на доску символ хода текущего игрока (X)
                    self.board[x][y] = 'X'
                    break
                else:
                    logger.info("Недопустимый ход. Попробуйте еще раз.")
                    print("Недопустимый ход. Попробуйте еще раз.")
            except ValueError:
                logger.error("Некорректный ввод. Пожалуйста, введите целые числа")
                print("Некорректный ввод. Пожалуйста, введите целые числа")
            except IndexError as e:
                logger.error(f"Недопустимый ввод. Пожалуйста, введите числа от 0 до 14 {e}")
                print(f"Недопустимый ввод. Пожалуйста, введите числа от 0 до 14")
        # 2.2.4. Меняем флаг игрока
        self.current_player = 2
    def computer_move(self):
        """
        Обеспечивает ход компьютера.
        Компьютер выбирает случайный ход и обновляет доску.
        """
        logger.info("Ход компьютера:")
        while True:
            # 2.3.1. Компьютер выбирает случайный ход
            x = random.randint(0, 14)
            y = random.randint(0, 14)
            if self.board[x][y] == ' ':
                # 2.3.2. Ставим на доску символ хода текущего игрока (O)
                self.board[x][y] = 'O'
                break
        # 2.3.3. Меняем флаг игрока
        self.current_player = 1

    def play(self):
        """
        Запускает основной игровой цикл.
        """
        # 2. Основной игровой цикл
        while self.game_on:
            # 2.1. Выводим текущее состояние доски
            self.print_board()

            # 2.2. Ход игрока (P = 1)
            if self.current_player == 1:
                 self.player_move()
            # 2.3. Ход компьютера (P = 2)
            else:
                self.computer_move()

            # 2.4. Проверка на победителя или ничью
            if self.check_winner(self.current_player):
                self.print_board()
                logger.info(f"Победил игрок {'1 (X)' if self.current_player == 2 else '2 (O)'}!")
                print(f"Победил игрок {'1 (X)' if self.current_player == 2 else '2 (O)'}!")
                self.game_on = False  # Завершаем игру
            elif self.check_full_board():
                self.print_board()
                logger.info("Ничья!")
                print("Ничья!")
                self.game_on = False  # Завершаем игру
if __name__ == '__main__':
    game = Gomoku()
    game.play()
"""
Объяснение кода:
1.  **Инициализация**:
    -   `board = [[\' \' for _ in range(15)] for _ in range(15)]`: Создает игровое поле 15x15, заполненное пробелами (пустые ячейки).
    -   `game_on = True`: Устанавливает флаг, сигнализирующий, что игра продолжается.
    -   `current_player = 1`: Устанавливает текущего игрока на первого (игрок 1).

2.  **Функция `print_board(board)`**:
    -   Выводит текущее состояние игрового поля в консоль. Нумерация строк и столбцов для удобства.

3.  **Функция `check_winner(board, player)`**:
    -   Проверяет, есть ли победитель.
    -   Символ текущего игрока (\'X\' для игрока 1, \'O\' для игрока 2).
    -   Проверяет горизонтальные, вертикальные и обе диагональные линии на наличие пяти подряд идущих символов.
    -   Возвращает `True`, если победитель найден, иначе `False`.

4. **Функция `check_full_board(board)`**:
    - Проверяет, заполнено ли игровое поле.
    - Возвращает `True`, если нет пустых клеток, иначе `False`.

5.  **Основной цикл игры `while game_on:`**:
    -   Продолжается, пока `game_on` равно `True`.
    -   Выводит текущую доску.
    -   **Ход игрока**:
        -   Если `current_player` равен 1, то это ход первого игрока.
        -   Запрашивает ввод координат x и y.
         -   Проверяет, что координаты в допустимых пределах и ячейка пуста. Если нет, повторяет запрос.
        -   Устанавливает символ \'X\' в выбранную ячейку.
        -   Переключает текущего игрока на второго (`current_player = 2`).
    -   **Ход компьютера**:
        -   Если `current_player` равен 2, то это ход компьютера.
        -   Компьютер выбирает случайные координаты x и y.
        -   Проверяет, что ячейка не занята.
        -   Устанавливает символ \'O\' в выбранную ячейку.
        -   Переключает текущего игрока на первого (`current_player = 1`).
    -   **Проверка на победу или ничью**:
        -   Вызывает `check_winner()` для проверки наличия победителя, и если он есть выводит на консоль сообщение о победе, и устанавливает `game_on` в `False`.
        -   Вызывает `check_full_board()` для проверки, заполнено ли поле. Если поле заполнено, то выводит сообщение о ничьей и завершает игру.

"""