# Модуль `aiohttp`

## Обзор

Модуль `aiohttp` предоставляет инструменты для организации асинхронных HTTP-запросов с использованием библиотеки `aiohttp`. Включает в себя классы для обработки потоковых ответов и сессий, а также функции для настройки прокси-соединений.

## Подробней

Этот модуль предназначен для облегчения работы с асинхронными HTTP-запросами, особенно когда требуется потоковая обработка данных. Он предоставляет специализированные классы `StreamResponse` и `StreamSession`, которые расширяют возможности стандартных классов `aiohttp`. `StreamResponse` позволяет итерировать по строкам и контенту ответа, а также обрабатывать Server-Sent Events (SSE). `StreamSession` упрощает создание сессий с поддержкой прокси и пользовательскими заголовками.

## Классы

### `StreamResponse`

**Описание**: Класс `StreamResponse` расширяет `aiohttp.ClientResponse` для предоставления удобных методов итерации по содержимому ответа и обработки Server-Sent Events.

**Наследует**:

- `aiohttp.ClientResponse`

**Методы**:

- `iter_lines()`: Асинхронно итерирует по строкам ответа.
- `iter_content()`: Асинхронно итерирует по частям содержимого ответа.
- `json(content_type: str = None)`: Асинхронно преобразует ответ в JSON.
- `sse()`: Асинхронно итерирует по Server-Sent Events ответа.

#### `iter_lines`

```python
    async def iter_lines(self) -> AsyncIterator[bytes]:
        """Асинхронно итерирует по строкам ответа."""
        ...
```

**Назначение**: Асинхронно итерирует по строкам ответа, удаляя завершающие символы новой строки.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[bytes]`: Асинхронный итератор по строкам ответа в байтах.

**Как работает функция**:

1.  Функция асинхронно итерирует по содержимому ответа, полученному из `self.content`.
2.  Для каждой строки удаляются завершающие символы новой строки (`\r\n`).
3.  Полученная строка возвращается через асинхронный итератор.

```
A: Начало
│
B: Асинхронная итерация по self.content
│
C: Удаление завершающих символов новой строки
│
D: Возврат строки через асинхронный итератор
│
E: Завершение
```

#### `iter_content`

```python
    async def iter_content(self) -> AsyncIterator[bytes]:
        """Асинхронно итерирует по частям содержимого ответа."""
        ...
```

**Назначение**: Асинхронно итерирует по частям содержимого ответа.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[bytes]`: Асинхронный итератор по частям содержимого ответа в байтах.

**Как работает функция**:

1.  Функция асинхронно итерирует по частям содержимого ответа, полученным из `self.content.iter_any()`.
2.  Каждая часть содержимого возвращается через асинхронный итератор.

```
A: Начало
│
B: Асинхронная итерация по self.content.iter_any()
│
C: Возврат части содержимого через асинхронный итератор
│
D: Завершение
```

#### `json`

```python
    async def json(self, content_type: str = None) -> Any:
        """Асинхронно преобразует ответ в JSON."""
        ...
```

**Назначение**: Асинхронно преобразует тело ответа в формат JSON.

**Параметры**:

- `content_type` (str, optional): Указание ожидаемого типа контента. По умолчанию `None`.

**Возвращает**:

- `Any`: Преобразованное содержимое ответа в формате JSON.

**Как работает функция**:

1.  Функция вызывает метод `super().json(content_type=content_type)` для преобразования тела ответа в JSON, используя функциональность базового класса `ClientResponse`.
2.  Возвращает преобразованное содержимое.

```
A: Начало
│
B: Вызов super().json(content_type=content_type)
│
C: Возврат преобразованного содержимого
│
D: Завершение
```

#### `sse`

```python
    async def sse(self) -> AsyncIterator[dict]:
        """Асинхронно итерирует по Server-Sent Events ответа."""
        ...
```

**Назначение**: Асинхронно итерирует по Server-Sent Events (SSE) ответа.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[dict]`: Асинхронный итератор по событиям SSE, представленным в виде словарей.

**Как работает функция**:

1.  Функция асинхронно итерирует по строкам содержимого ответа.
2.  Для каждой строки проверяется, начинается ли она с префикса `b"data: "`.
3.  Если строка начинается с `b"data: "`, извлекается содержимое после префикса.
4.  Если извлеченное содержимое начинается с `b"[DONE]"`, итерация прекращается.
5.  Извлеченное содержимое пытается быть преобразовано в JSON.
6.  В случае успешного преобразования, результат возвращается через асинхронный итератор.
7.  Если происходит ошибка JSONDecodeError, она игнорируется, и итерация продолжается.

```
A: Начало
│
B: Асинхронная итерация по строкам содержимого ответа
│
C: Проверка, начинается ли строка с b"data: "
├─── Нет ───> G: Продолжение итерации
│
D: Извлечение содержимого после b"data: "
│
E: Проверка, начинается ли содержимое с b"[DONE]"
├─── Да ───> H: Прекращение итерации
│
F: Попытка преобразования содержимого в JSON
├─── Успех ───> I: Возврат результата через асинхронный итератор
├─── JSONDecodeError ───> G: Продолжение итерации
│
G: Продолжение итерации
│
H: Прекращение итерации
│
I: Возврат результата через асинхронный итератор
│
J: Завершение
```

### `StreamSession`

**Описание**: Класс `StreamSession` расширяет `aiohttp.ClientSession` для предоставления сессий с поддержкой потоковых ответов, прокси и пользовательских заголовков.

**Наследует**:

- `aiohttp.ClientSession`

**Атрибуты**:

- `headers` (dict): Заголовки по умолчанию для сессии.
- `timeout` (int): Время ожидания для сессии.
- `connector` (BaseConnector): Коннектор для сессии.
- `proxy` (str): URL прокси-сервера для сессии.
- `proxies` (dict): Словарь URL прокси-серверов для сессии.
- `impersonate`: Параметр для имитации.

**Методы**:

- `__init__(self, headers: dict = {}, timeout: int = None, connector: BaseConnector = None, proxy: str = None, proxies: dict = {}, impersonate = None, \*\*kwargs)`: Инициализирует экземпляр класса `StreamSession`.

#### `__init__`

```python
    def __init__(
        self,
        headers: dict = {},\n        timeout: int = None,\n        connector: BaseConnector = None,\n        proxy: str = None,\n        proxies: dict = {},\n        impersonate = None,\n        **kwargs
    ):
        """Инициализирует экземпляр класса `StreamSession`."""
        ...
```

**Назначение**: Инициализирует экземпляр класса `StreamSession`, настраивая заголовки, время ожидания, коннектор и прокси.

**Параметры**:

- `headers` (dict, optional): Заголовки по умолчанию для сессии. По умолчанию `{}`.
- `timeout` (int, optional): Время ожидания для сессии. Может быть кортежем (connect, read). По умолчанию `None`.
- `connector` (BaseConnector, optional): Коннектор для сессии. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера для сессии. По умолчанию `None`.
- `proxies` (dict, optional): Словарь URL прокси-серверов для сессии. По умолчанию `{}`.
- `impersonate`: Параметр для имитации.
- `**kwargs`: Дополнительные аргументы, передаваемые в `aiohttp.ClientSession`.

**Как работает класс**:

1.  При инициализации проверяется наличие параметра `impersonate`. Если он указан, заголовки объединяются с `DEFAULT_HEADERS`.
2.  Обрабатывается параметр `timeout`. Если он является кортежем, то разделяется на `connect` и `timeout`.
3.  Определяется URL прокси-сервера из параметров `proxy` или `proxies`.
4.  Вызывается конструктор базового класса `aiohttp.ClientSession` с передачей настроек, включая время ожидания, класс ответа `StreamResponse`, коннектор и заголовки.
5.  Коннектор получается с помощью функции `get_connector`.

```
A: Начало
│
B: Проверка наличия impersonate
├─── Да ───> C: Объединение заголовков с DEFAULT_HEADERS
│   │
├─── Нет ───> D: Обработка timeout
│
C: Объединение заголовков с DEFAULT_HEADERS
│
D: Обработка timeout
│
E: Определение URL прокси-сервера
│
F: Вызов конструктора aiohttp.ClientSession
│
G: Получение коннектора с помощью get_connector
│
H: Завершение
```

**Примеры**:

```python
session = StreamSession(headers={'Custom-Header': 'value'}, timeout=30)
session_with_proxy = StreamSession(proxy='http://proxy:8080')
```

## Функции

### `get_connector`

```python
def get_connector(connector: BaseConnector = None, proxy: str = None, rdns: bool = False) -> Optional[BaseConnector]:
    """Получает коннектор для aiohttp с поддержкой прокси."""
    ...
```

**Назначение**: Возвращает коннектор для `aiohttp` с поддержкой прокси, если указан `proxy`.

**Параметры**:

- `connector` (BaseConnector, optional): Существующий коннектор. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `rdns` (bool, optional): Флаг для использования удаленного DNS при подключении через SOCKS5. По умолчанию `False`.

**Возвращает**:

- `Optional[BaseConnector]`: Коннектор для `aiohttp` или `None`, если `proxy` не указан.

**Вызывает исключения**:

- `MissingRequirementsError`: Если `proxy` указан, но не установлен пакет `aiohttp_socks`.

**Как работает функция**:

1.  Функция проверяет, указан ли `proxy` и отсутствует ли `connector`.
2.  Если `proxy` указан и `connector` отсутствует, функция пытается импортировать `ProxyConnector` из пакета `aiohttp_socks`.
3.  Если `proxy` начинается с `socks5h://`, он заменяется на `socks5://`, и устанавливается флаг `rdns = True`.
4.  Создается экземпляр `ProxyConnector` на основе URL прокси-сервера и флага `rdns`.
5.  Если импорт `ProxyConnector` не удался, выбрасывается исключение `MissingRequirementsError` с рекомендацией установить пакет `aiohttp_socks`.
6.  Если `proxy` не указан, возвращается исходный `connector` или `None`.

```
A: Начало
│
B: Проверка, указан ли proxy и отсутствует ли connector
├─── Да ───> C: Импорт ProxyConnector из aiohttp_socks
│   │
├─── Нет ───> G: Возврат connector
│
C: Импорт ProxyConnector из aiohttp_socks
│
D: Проверка, начинается ли proxy с socks5h://
├─── Да ───> E: Замена socks5h:// на socks5:// и установка rdns = True
│   │
├─── Нет ───> F: Создание экземпляра ProxyConnector
│
E: Замена socks5h:// на socks5:// и установка rdns = True
│
F: Создание экземпляра ProxyConnector
│
G: Возврат connector
│
H: Завершение
```

**Примеры**:

```python
connector = get_connector(proxy='http://proxy:8080')
connector_socks5 = get_connector(proxy='socks5://proxy:1080', rdns=True)
```