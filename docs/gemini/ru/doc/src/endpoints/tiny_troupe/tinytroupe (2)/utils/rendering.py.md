# Модуль для рендеринга и разметки в Tiny Troupe
=========================================================

Модуль содержит функции и класс :class:`RichTextStyle`, предназначенные для стилизации и форматирования текста, а также для внедрения HTML и CSS стилей.

## Обзор

Этот модуль предоставляет инструменты для улучшения визуального представления текста, используемого в приложении Tiny Troupe. Он включает функции для внедрения стилей, обрезки текста, форматирования даты и времени, а также класс для управления стилями текста.

## Подробней

Модуль предназначен для работы с текстом, отображаемым в интерфейсе пользователя Tiny Troupe. Он предоставляет функции для стилизации, форматирования и обрезки текста, чтобы он выглядел аккуратно и соответствовал дизайну приложения. Также модуль включает класс `RichTextStyle`, который позволяет задавать различные стили для разных типов событий.

## Функции

### `inject_html_css_style_prefix`

**Назначение**: Внедряет префикс стиля ко всем атрибутам стиля в заданной HTML строке.

**Параметры**:
- `html` (str): HTML строка, в которую нужно внедрить префикс стиля.
- `style_prefix_attributes` (str): Префикс стиля, который нужно внедрить.

**Возвращает**:
- `str`: HTML строка с внедренным префиксом стиля.

**Как работает функция**:
1. Функция заменяет все вхождения `style="` в HTML строке на `style="{style_prefix_attributes};`, добавляя префикс стиля к существующим стилям.

```
HTML строка -> Замена 'style="' на 'style="{style_prefix_attributes};' -> HTML строка с префиксом стиля
```

**Примеры**:
```python
html = '<div style="color: red;">Hello</div>'
style_prefix_attributes = 'font-size: 20px;'
result = inject_html_css_style_prefix(html, style_prefix_attributes)
print(result)  # Вывод: <div style="font-size: 20px;;color: red;">Hello</div>
```

### `break_text_at_length`

**Назначение**: Обрезает текст (или JSON) до указанной длины, вставляя строку "(...)" в точке обрыва.

**Параметры**:
- `text` (str | dict): Текст или JSON, который нужно обрезать.
- `max_length` (int, optional): Максимальная длина текста. Если `None`, контент возвращается без изменений. По умолчанию `None`.

**Возвращает**:
- `str`: Обрезанный текст или JSON.

**Как работает функция**:
1. Проверяется, является ли входной текст словарем. Если да, он преобразуется в JSON строку с отступами.
2. Если `max_length` не указана или длина текста меньше или равна `max_length`, возвращается исходный текст.
3. Иначе текст обрезается до `max_length`, и к нему добавляется строка "(...)".

```
Входной текст -> Проверка типа (словарь?) -> Преобразование в JSON (если словарь) -> Проверка длины -> Обрезка и добавление " (...)" (если необходимо) -> Возвращаемый текст
```

**Примеры**:
```python
text = "This is a long text that needs to be truncated."
max_length = 20
result = break_text_at_length(text, max_length)
print(result)  # Вывод: This is a long text (...)

data = {"name": "John", "age": 30, "city": "New York"}
max_length = 50
result = break_text_at_length(data, max_length)
print(result)
```

### `pretty_datetime`

**Назначение**: Возвращает строковое представление объекта datetime в формате "YYYY-MM-DD HH:MM".

**Параметры**:
- `dt` (datetime): Объект datetime, который нужно преобразовать.

**Возвращает**:
- `str`: Строковое представление даты и времени.

**Как работает функция**:
1. Функция форматирует объект `datetime` в строку, используя формат "%Y-%m-%d %H:%M".

```
Объект datetime -> Форматирование в строку -> Строковое представление даты и времени
```

**Примеры**:
```python
now = datetime.now()
result = pretty_datetime(now)
print(result)  # Вывод: 2024-07-26 10:00 (пример)
```

### `dedent`

**Назначение**: Удаляет все начальные пробелы и отступы из заданной строки.

**Параметры**:
- `text` (str): Строка, из которой нужно удалить отступы.

**Возвращает**:
- `str`: Строка без начальных пробелов и отступов.

**Как работает функция**:
1. Функция использует `textwrap.dedent` для удаления общих начальных пробелов из каждой строки в тексте.
2. Затем удаляются начальные и конечные пробелы с помощью `strip()`.

```
Входной текст -> Удаление отступов -> Удаление начальных и конечных пробелов -> Очищенный текст
```

**Примеры**:
```python
text = """
    This is a
    multiline string
    with indentation.
"""
result = dedent(text)
print(result)
# Вывод:
# This is a
# multiline string
# with indentation.
```

### `wrap_text`

**Назначение**: Переносит текст на указанную ширину.

**Параметры**:
- `text` (str): Текст, который нужно перенести.
- `width` (int, optional): Ширина, на которую нужно перенести текст. По умолчанию 100.

**Возвращает**:
- `str`: Перенесенный текст.

**Как работает функция**:
1. Функция использует `textwrap.fill` для переноса текста на указанную ширину.

```
Входной текст -> Перенос текста на указанную ширину -> Перенесенный текст
```

**Примеры**:
```python
text = "This is a long text that needs to be wrapped to a specific width."
width = 40
result = wrap_text(text, width)
print(result)
# Вывод:
# This is a long text that needs to be
# wrapped to a specific width.
```

## Классы

### `RichTextStyle`

**Описание**: Класс, содержащий предопределенные стили для различных типов событий.

**Аттрибуты**:
- `STIMULUS_CONVERSATION_STYLE` (str): Стиль для реплик в разговоре.
- `STIMULUS_THOUGHT_STYLE` (str): Стиль для мыслей.
- `STIMULUS_DEFAULT_STYLE` (str): Стиль по умолчанию для стимулов.
- `ACTION_DONE_STYLE` (str): Стиль для завершенных действий.
- `ACTION_TALK_STYLE` (str): Стиль для речи.
- `ACTION_THINK_STYLE` (str): Стиль для мыслей.
- `ACTION_DEFAULT_STYLE` (str): Стиль по умолчанию для действий.
- `INTERVENTION_DEFAULT_STYLE` (str): Стиль по умолчанию для вмешательств.

**Методы**:
- `get_style_for(kind: str, event_type: str = None) -> str`: Возвращает стиль для указанного типа события.

#### `get_style_for`

**Назначение**: Возвращает стиль для указанного типа события.

**Параметры**:
- `kind` (str): Тип события ("stimulus", "action", "intervention").
- `event_type` (str, optional): Подтип события ("CONVERSATION", "THOUGHT", "DONE", "TALK", "THINK"). По умолчанию `None`.

**Возвращает**:
- `str`: Стиль для указанного типа события.

**Как работает функция**:
1. Функция проверяет тип события (`kind`) и подтип события (`event_type`).
2. В зависимости от типа и подтипа возвращается соответствующий стиль из предопределенных атрибутов класса.
3. Если подтип не указан, возвращается стиль по умолчанию для данного типа события.

```
Тип события (kind) -> Подтип события (event_type) -> Выбор стиля -> Возвращаемый стиль
```

**Примеры**:
```python
style = RichTextStyle.get_style_for("stimulus", "CONVERSATION")
print(style)  # Вывод: bold italic cyan1

style = RichTextStyle.get_style_for("action", "DONE")
print(style)  # Вывод: grey82

style = RichTextStyle.get_style_for("intervention")
print(style)  # Вывод: bright_magenta
```