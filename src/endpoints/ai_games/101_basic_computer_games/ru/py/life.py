"""
LIFE:
=================
Сложность: 7
-----------------
Игра "Жизнь" (Conway's Game of Life) - это клеточный автомат, созданный математиком Джоном Конвеем. 
В этой игре вы наблюдаете за эволюцией популяции клеток, где каждая клетка может быть живой или мертвой. 
Игровое поле представляет собой сетку, и состояние каждой клетки меняется в зависимости от состояния её соседних клеток по определённым правилам. 
Цель игры – наблюдать и анализировать, как популяция клеток изменяется со временем, образуя различные узоры и структуры. 
Это не игра в обычном понимании, где есть цель выиграть или проиграть, а скорее симуляция, демонстрирующая интересные математические и биологические концепции.

Правила игры:
1. Игровое поле состоит из сетки клеток, каждая из которых может находиться в двух состояниях: живая или мертвая.
2. Состояние каждой клетки на следующем шаге зависит от количества живых соседей:
    * Живая клетка с 2 или 3 живыми соседями остается живой.
    * Живая клетка с менее чем 2 или более чем 3 живыми соседями становится мертвой.
    * Мертвая клетка с ровно 3 живыми соседями становится живой.
3. Игра начинается с начальной конфигурации клеток, и в каждом следующем шаге все клетки одновременно обновляют своё состояние.
4. Игра продолжается, пока не будет принято решение остановить или пока не установится стабильная конфигурация.
-----------------
Алгоритм:
1. Инициализировать игровое поле (сетку клеток) заданного размера.
2. Установить начальное состояние клеток (случайно или по заданному шаблону).
3. Начать основной цикл:
   3.1 Для каждой клетки на поле:
        3.1.1 Подсчитать количество живых соседей.
        3.1.2 Применить правила игры для определения нового состояния клетки:
               - Если клетка жива и имеет 2 или 3 живых соседей, то клетка остается живой.
               - Если клетка жива и имеет меньше 2 или больше 3 живых соседей, то клетка умирает.
               - Если клетка мертва и имеет ровно 3 живых соседей, то клетка оживает.
   3.2 Обновить состояние всех клеток на поле.
   3.3 Вывести текущее состояние поля.
   3.4 Подождать некоторое время (например, 1 секунду).
   3.5 Повторять цикл, пока не будет прервано пользователем.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeGrid["<p align='left'>Инициализация сетки: 
    <code><b>
    grid = create_grid(rows, cols)
    </b></code></p>"]
    InitializeGrid --> SetInitialState["<p align='left'>Установка начального состояния клеток:
    <code><b>
    set_initial_state(grid)
    </b></code></p>"]
    SetInitialState --> GameLoopStart{"Начало игрового цикла"}
    GameLoopStart --> CalculateNextGen{"<p align='left'>Вычисление следующего поколения:
    <code><b>
    next_grid = calculate_next_generation(grid)
    </b></code></p>"}
    CalculateNextGen --> UpdateGrid["<p align='left'>Обновление сетки:
    <code><b>
    grid = next_grid
    </b></code></p>"]
    UpdateGrid --> DisplayGrid["<p align='left'>Отображение сетки:
    <code><b>
    display_grid(grid)
    </b></code></p>"]
    DisplayGrid --> Wait["Пауза"]
    Wait --> GameLoopStart
    GameLoopStart -- Прервать? --> End["Конец"]

```
Legenda:
    Start - Начало программы.
    InitializeGrid - Инициализация сетки: создает двумерный массив (список списков) для представления игрового поля.
    SetInitialState - Установка начального состояния клеток:  определяет начальную конфигурацию живых и мертвых клеток.
    GameLoopStart - Начало игрового цикла:  цикл продолжается, пока игра не будет прервана.
    CalculateNextGen - Вычисление следующего поколения:  вычисляет новое состояние каждой клетки на основе текущего состояния и правил игры "Жизнь".
    UpdateGrid - Обновление сетки:  применяет рассчитанное следующее поколение к текущей сетке.
    DisplayGrid - Отображение сетки:  выводит текущее состояние сетки на экран.
    Wait - Пауза:  задержка перед следующим шагом, чтобы наблюдать эволюцию.
    End - Конец программы.
"""
import time
import random

__author__ = 'hypo69 (hypo69@davidka.net)'

# Размер сетки
ROWS = 20
COLS = 40

def create_grid(rows, cols):
    """Создает сетку заданного размера, заполненную мертвыми клетками."""
    return [[' ' for _ in range(cols)] for _ in range(rows)]


def set_initial_state(grid):
    """Устанавливает случайное начальное состояние клеток."""
    for i in range(len(grid)):
        for j in range(len(grid[0])):
           if random.random() > 0.8: # Вероятность 20% для появления живой клетки
              grid[i][j] = '*' # * - живая клетка
    

def count_live_neighbors(grid, row, col):
    """Подсчитывает количество живых соседей у клетки."""
    live_neighbors = 0
    for i in range(row - 1, row + 2):
        for j in range(col - 1, col + 2):
            if (i == row and j == col) or i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):
                continue  # Исключаем саму клетку и выходы за границы
            if grid[i][j] == '*':
                live_neighbors += 1
    return live_neighbors


def calculate_next_generation(grid):
    """Вычисляет состояние сетки для следующего поколения."""
    rows = len(grid)
    cols = len(grid[0])
    next_grid = create_grid(rows, cols) # Создаем новую сетку

    for i in range(rows):
        for j in range(cols):
            live_neighbors = count_live_neighbors(grid, i, j)
            if grid[i][j] == '*':  # Клетка жива
                if live_neighbors == 2 or live_neighbors == 3:
                    next_grid[i][j] = '*'  # Остается живой
            else: #Клетка мертва
                if live_neighbors == 3:
                    next_grid[i][j] = '*' # Оживает
    return next_grid


def display_grid(grid):
    """Выводит сетку на экран."""
    for row in grid:
        print(''.join(row))
    print("-" * len(grid[0]))

def game_loop():
    """Основной игровой цикл."""
    grid = create_grid(ROWS, COLS)
    set_initial_state(grid)

    while True:
        display_grid(grid)
        grid = calculate_next_generation(grid)
        time.sleep(0.3)  # Задержка для удобства наблюдения
        #  можно добавить условие выхода из цикла, нажатие на клавишу например

if __name__ == "__main__":
    game_loop()

"""
Пояснения:
1. **Импорт модулей**:
   - `import time`: Импортирует модуль `time` для управления задержками (паузами).
   - `import random`: Импортирует модуль `random` для генерации случайных чисел, используется при инициализации сетки.

2. **Константы**:
    - `ROWS = 20`: Задает количество строк в сетке.
    - `COLS = 40`: Задает количество столбцов в сетке.

3. **Функция `create_grid(rows, cols)`**:
   -  Создает и возвращает сетку, представленную в виде списка списков, заполненную пробелами (пустыми клетками).
     - `rows` и `cols` — количество строк и столбцов соответственно.
     -  Возвращает сетку.

4.  **Функция `set_initial_state(grid)`**:
     - Заполняет сетку случайными живыми клетками (символ `*`) с определенной вероятностью.
     - `grid` — сетка, которую нужно инициализировать.
     - Живые клетки появляются в случайном порядке.

5. **Функция `count_live_neighbors(grid, row, col)`**:
    -  Подсчитывает количество живых соседей клетки.
     -  `grid` — сетка игрового поля.
     -  `row` и `col` — координаты клетки, для которой нужно подсчитать соседей.
     -  Обходит соседние клетки (включая диагональные) и подсчитывает живые.

6. **Функция `calculate_next_generation(grid)`**:
    -  Рассчитывает состояние сетки для следующего поколения в соответствии с правилами игры «Жизнь».
     -  `grid` — текущая сетка игрового поля.
    - Создает новую сетку, проходя по каждой ячейке, и применяет правила игры, чтобы определить состояние новой ячейки.
    - Если клетка жива, то она остается живой только при наличии 2 или 3 живых соседей.
    - Если клетка мертва, то она становится живой только при наличии 3 живых соседей.

7. **Функция `display_grid(grid)`**:
    - Выводит сетку в терминал.
    -  `grid` — сетка, которую нужно вывести на экран.
     - Выводит каждую строку сетки и разделитель после каждой итерации.

8. **Функция `game_loop()`**:
    -  Организует основной игровой цикл.
     - Инициализирует сетку, устанавливает начальное состояние, и затем в цикле выводит сетку, вычисляет следующее поколение и делает паузу, для наблюдения.
     - Пауза реализована с помощью `time.sleep(0.3)`
    
9. **Точка входа `if __name__ == "__main__":`**:
    -  Запускает основной игровой цикл, если скрипт запущен непосредственно, а не как импортированный модуль.
     - `game_loop()`: Вызывает функцию, запускающую игру "Жизнь"
"""
```