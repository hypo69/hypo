# Модуль Qwen_Qwen_2_5_Max

## Обзор

Модуль `Qwen_Qwen_2_5_Max` предоставляет асинхронный генератор для взаимодействия с моделью Qwen Qwen-2.5-Max через API.
Он реализует функциональность для стриминговой передачи данных, поддержки системных сообщений и работы с историей сообщений.

## Подробней

Модуль предназначен для интеграции с API Qwen Qwen-2.5-Max, обеспечивая асинхронный режим генерации текста. Он использует `aiohttp` для выполнения HTTP-запросов и `json` для обработки данных в формате JSON.
Модуль поддерживает потоковую передачу данных, что позволяет получать ответы по частям, а также поддерживает использование системных сообщений для задания контекста.

## Классы

### `Qwen_Qwen_2_5_Max`

**Описание**: Класс `Qwen_Qwen_2_5_Max` реализует функциональность для взаимодействия с моделью Qwen Qwen-2.5-Max через API.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию данных.
- `ProviderModelMixin`: Предоставляет общие методы для работы с моделями.

**Атрибуты**:
- `label` (str): Метка провайдера, отображаемая пользователю.
- `url` (str): URL базового домена API.
- `api_endpoint` (str): URL API для присоединения к очереди запросов.
- `working` (bool): Флаг, указывающий на работоспособность провайдера.
- `supports_stream` (bool): Флаг, указывающий на поддержку стриминговой передачи данных.
- `supports_system_message` (bool): Флаг, указывающий на поддержку системных сообщений.
- `supports_message_history` (bool): Флаг, указывающий на поддержку истории сообщений.
- `default_model` (str): Модель, используемая по умолчанию.
- `model_aliases` (dict): Словарь псевдонимов моделей.
- `models` (list): Список поддерживаемых моделей.

**Методы**:
- `create_async_generator()`: Создает асинхронный генератор для получения ответов от модели.

## Функции

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    **kwargs
) -> AsyncResult:
    """
    Создает асинхронный генератор для получения ответов от модели Qwen Qwen-2.5-Max.

    Args:
        model (str): Имя используемой модели.
        messages (Messages): Список сообщений для отправки в модель.
        proxy (str, optional): Прокси-сервер для использования при подключении. По умолчанию `None`.
        **kwargs: Дополнительные аргументы.

    Returns:
        AsyncResult: Асинхронный генератор, возвращающий текстовые фрагменты от модели.

    Raises:
        aiohttp.ClientError: При ошибках HTTP-запросов.
        json.JSONDecodeError: При ошибках декодирования JSON.

    """
```

**Назначение**: Функция `create_async_generator` создает асинхронный генератор, который взаимодействует с API Qwen Qwen-2.5-Max для получения ответов от модели.

**Параметры**:
- `cls` (type): Ссылка на класс `Qwen_Qwen_2_5_Max`.
- `model` (str): Имя используемой модели.
- `messages` (Messages): Список сообщений для отправки в модель. Сообщения должны быть в формате, ожидаемом API Qwen.
- `proxy` (str, optional): Прокси-сервер для использования при подключении. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы, которые могут потребоваться для настройки запроса.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий текстовые фрагменты от модели. Генератор выдает части ответа по мере их поступления, что позволяет реализовать потоковую передачу данных.

**Вызывает исключения**:
- `aiohttp.ClientError`: Возникает при ошибках, связанных с HTTP-запросами, например, при недоступности сервера или проблемах с сетью.
- `json.JSONDecodeError`: Возникает при невозможности декодировать JSON-ответ от сервера, что может указывать на проблемы с форматом данных.

**Как работает функция**:

1.  **Генерация уникального идентификатора сессии**:
    -   Функция вызывает внутреннюю функцию `generate_session_hash()`, чтобы сгенерировать уникальный идентификатор сессии. Этот идентификатор используется для связывания всех запросов в рамках одной сессии.

2.  **Подготовка заголовков и полезной нагрузки для запроса**:
    -   Формируются заголовки (`headers_join`) для HTTP-запроса, включая User-Agent, Accept, Referer и другие необходимые параметры. Эти заголовки сообщают серверу информацию о клиенте и типе запроса.
    -   Из списка сообщений извлекается системное сообщение (`system_prompt`), которое используется для задания контекста модели. Если системное сообщение отсутствует, устанавливается сообщение по умолчанию "You are a helpful assistant.".
    -   Формируется полезная нагрузка (`payload_join`) для запроса, включающая промпт, системное сообщение, индекс функции и идентификатор сессии. Эта полезная нагрузка содержит данные, которые будут отправлены на сервер для генерации ответа.

3.  **Отправка запроса на присоединение к очереди**:
    -   Используется `aiohttp.ClientSession` для выполнения асинхронного HTTP-запроса типа POST к API-endpoint (`cls.api_endpoint`). Запрос отправляется с заголовками (`headers_join`) и полезной нагрузкой (`payload_join`).
    -   Полученный ответ от сервера преобразуется в JSON, и из него извлекается идентификатор события (`event_id`). Этот идентификатор используется для дальнейшего отслеживания процесса генерации.

4.  **Подготовка к стриминговой передаче данных**:
    -   Формируется URL (`url_data`) для запроса на получение данных в режиме реального времени.
    -   Формируются заголовки (`headers_data`) для запроса на получение данных, включая Accept и User-Agent.
    -   Формируются параметры (`params_data`) для запроса на получение данных, включающие идентификатор сессии.

5.  **Получение данных в режиме реального времени и генерация фрагментов ответа**:
    -   Выполняется асинхронный HTTP-запрос типа GET к URL (`url_data`) с заголовками (`headers_data`) и параметрами (`params_data`).
    -   Полученные данные обрабатываются построчно. Каждая строка декодируется из UTF-8.
    -   Если строка начинается с "data: ", то она содержит JSON-данные, которые пытаются быть декодированы.
    -   Из JSON-данных извлекаются фрагменты текста, которые соответствуют стадиям генерации ("process_generating").
    -   Фрагменты текста фильтруются для удаления дубликатов и игнорирования специальных символов.
    -   Полученные фрагменты текста передаются в генератор (`yield fragment`), что позволяет получать ответ от модели по частям.

6.  **Обработка завершения генерации**:
    -   Когда приходит сообщение о завершении процесса ("process_completed"), из JSON-данных извлекается полный ответ.
    -   Полный ответ очищается от начальных фрагментов, которые уже были переданы ранее.
    -   Оставшаяся часть полного ответа передается в генератор (`yield final_full_response`).

7.  **Обработка ошибок**:
    -   Если при декодировании JSON-данных возникает ошибка (`json.JSONDecodeError`), она логируется с использованием модуля `debug`.

```
A: generate_session_hash()
|
B: Подготовка HTTP заголовков и Payload
|
C: Отправка POST запроса для присоединения к очереди
|
D: Получение event_id из ответа
|
E: Подготовка URL, HTTP заголовков и параметров для стриминга
|
F: Отправка GET запроса для получения стриминговых данных
|
G: Обработка каждой строки ответа
|   |
|   H: Проверка на начало с "data: "
|   |
|   I: Декодирование JSON данных
|   |
|   J: Извлечение фрагментов текста при "process_generating"
|   |
|   K: Фильтрация и удаление дубликатов
|   |
|   L: Выдача фрагмента текста (yield fragment)
|   |
|   M: Проверка на сообщение о завершении "process_completed"
|   |
|   N: Извлечение полного ответа
|   |
|   O: Очистка полного ответа от уже переданных фрагментов
|   |
|   P: Выдача оставшейся части полного ответа (yield final_full_response)
|
Q: Обработка ошибок JSONDecodeError
```

**Примеры**:

Пример 1: Базовый вызов функции с минимальным набором параметров.

```python
model = "qwen-2-5-max"
messages = [{"role": "user", "content": "Hello, Qwen!"}]
async def main():
    async for fragment in Qwen_Qwen_2_5_Max.create_async_generator(model=model, messages=messages):
        print(fragment, end="")

import asyncio
asyncio.run(main())
```

Пример 2: Вызов функции с использованием прокси-сервера.

```python
model = "qwen-2-5-max"
messages = [{"role": "user", "content": "Tell me a joke."}]
proxy = "http://your_proxy_address:your_proxy_port"

async def main():
    async for fragment in Qwen_Qwen_2_5_Max.create_async_generator(model=model, messages=messages, proxy=proxy):
        print(fragment, end="")

import asyncio
asyncio.run(main())
```

Пример 3: Вызов функции с системным сообщением для задания контекста.

```python
model = "qwen-2-5-max"
messages = [
    {"role": "system", "content": "You are a helpful assistant."},
    {"role": "user", "content": "What is the capital of France?"}
]

async def main():
    async for fragment in Qwen_Qwen_2_5_Max.create_async_generator(model=model, messages=messages):
        print(fragment, end="")

import asyncio
asyncio.run(main())
```

### `generate_session_hash`

```python
def generate_session_hash():
    """Generate a unique session hash."""
    return str(uuid.uuid4()).replace('-', '')[:8] + str(uuid.uuid4()).replace('-', '')[:4]
```

**Назначение**: Функция `generate_session_hash` генерирует уникальный идентификатор сессии.

**Параметры**:
-   Отсутствуют.

**Возвращает**:
-   `str`: Уникальный идентификатор сессии, сгенерированный на основе UUID.

**Вызывает исключения**:
-   Отсутствуют.

**Как работает функция**:

1.  **Генерация UUID**:
    -   Функция использует модуль `uuid` для генерации UUID (Universally Unique Identifier). UUID - это 128-битный идентификатор, который гарантированно является уникальным в пределах пространства и времени.

2.  **Удаление дефисов**:
    -   Из сгенерированного UUID удаляются все дефисы (`-`) с использованием метода `replace('-', '')`. Это делается для упрощения идентификатора и соответствия требованиям API.

3.  **Получение подстроки**:
    -   Из полученной строки берутся первые 8 символов и добавляются к первым 4 символам, генерируя уникальный идентификатор сессии.

**Примеры**:

```python
session_hash = generate_session_hash()
print(session_hash)  # Пример вывода: 1a2b3c4d5e6f