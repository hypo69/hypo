## Ответ на Задачу No 325: Каменная куча

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Дана игра, в которой два игрока по очереди забирают камни из кучи.
*   На каждом ходу игрок может взять от 1 до половины текущего размера кучи.
*   Если в начале хода в куче 1 камень, игрок проигрывает.
*   *M(n)* - минимальное количество камней, которые должен взять первый игрок, чтобы гарантированно выиграть.
*   Нужно найти сумму всех *M(n)* для *n* от 1 до 10^7.

**Решение:**
1. **Определение выигрышных позиций:** Позиция, где в куче 1 камень, является проигрышной. Если игрок оставил сопернику 1 камень, то он победил. Рассмотрим, какие позиции являются выигрышными для первого игрока.
2. **Динамическое программирование (снизу вверх):**  Будем строить таблицу выигрышных ходов, начиная с малых значений *n*. Для каждого *n* перебираем ходы первого игрока (от 1 до n//2) и проверяем, может ли первый игрок выиграть, если выберет этот ход. 
3. **Оптимальный ход:**  Минимальный ход, который ведет к выигрышу, и будет *M(n)*. Если ни один ход не ведет к выигрышу, то *M(n) = 0*.

**Оптимизации:**
*   Будем использовать динамическое программирование для того, чтобы не пересчитывать выигрышные позиции.
*   Вместо рекурсии будем использовать итеративный подход для большей производительности.

### 2. Алгоритм решения

1.  Начать.
2.  Инициализировать массив `winning_moves` размером 10^7 + 1 нулями, где `winning_moves[n]` будет хранить минимальный выигрышный ход для кучи размера *n*.
3.  Инициализировать переменную `total_sum` нулем.
4.  Для каждого размера кучи `n` от 2 до 10^7 включительно:
    *   Инициализировать `min_winning_move` значением 0.
    *   Для каждого количества камней `move`, которое может взять первый игрок (от 1 до `n // 2` включительно):
        *   Определить, является ли позиция `n - move` проигрышной для следующего игрока (то есть `winning_moves[n-move] == 0`):
            * Если позиция `n - move` проигрышная, значит текущий ход выигрышный.
             *Если `min_winning_move == 0` или `move < min_winning_move`, то присваиваем `min_winning_move = move`
    *   `winning_moves[n] = min_winning_move`.
    *   Прибавить `min_winning_move` к `total_sum`.
5. Вывести `total_sum`.
6. Конец.

### 3. Реализация на Python 3.12
```python
def solve():
  limit = 10**7
  winning_moves = [0] * (limit + 1)
  total_sum = 0

  for n in range(2, limit + 1):
    min_winning_move = 0
    for move in range(1, n // 2 + 1):
        if winning_moves[n-move] == 0:
            if min_winning_move == 0 or move < min_winning_move:
                min_winning_move = move

    winning_moves[n] = min_winning_move
    total_sum += min_winning_move

  print(total_sum)

solve()
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeArrays((Инициализировать winning_moves[0...limit]=0, total_sum=0))
    InitializeArrays --> LoopStart((Начать цикл: n от 2 до limit))
    LoopStart --> InitializeMinMove((Инициализировать min_winning_move = 0))
    InitializeMinMove --> InnerLoopStart((Начать цикл: move от 1 до n // 2))
    InnerLoopStart --> CheckWinning((Проверить: winning_moves[n - move] == 0))
    CheckWinning -- Да --> UpdateMinMove((Если min_winning_move == 0 или move < min_winning_move, то min_winning_move = move))
    UpdateMinMove --> InnerLoopStart
    CheckWinning -- Нет --> InnerLoopStart
    InnerLoopStart --> UpdateWinningMoves((winning_moves[n] = min_winning_move))
    UpdateWinningMoves --> UpdateTotalSum((total_sum += min_winning_move))
    UpdateTotalSum --> LoopStart
    LoopStart --> OutputSum((Вывести total_sum))
    OutputSum --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать winning_moves[0...limit]=0, total_sum=0:** Инициализируем массив для хранения минимальных выигрышных ходов и переменную для суммы.
*   **Начать цикл: n от 2 до limit:** Внешний цикл для перебора всех возможных размеров куч.
*   **Инициализировать min_winning_move = 0:** Инициализируем переменную для хранения минимального выигрышного хода.
*   **Начать цикл: move от 1 до n // 2:** Внутренний цикл для перебора всех возможных ходов первого игрока.
*   **Проверить: winning_moves[n - move] == 0:** Проверяем, является ли позиция после хода проигрышной для второго игрока.
*   **Если min_winning_move == 0 или move < min_winning_move, то min_winning_move = move:** Обновляем минимальный выигрышный ход, если найден лучший вариант.
*   **winning_moves[n] = min_winning_move:** Записываем минимальный выигрышный ход для кучи размера `n`.
*   **total_sum += min_winning_move:** Обновляем общую сумму минимальных ходов.
*   **Вывести total_sum:** Выводим результат.
