Автор оридинального кода:
https://github.com/Mstislav95/CashFlow_101/blob/main/CashFlow_model.ipynb

https://ok4u.club/cashflow101-rules/

https://www.youtube.com/watch?v=sG_RWsvYT7k&ab_channel=MstislavEfimov


# Dream Game: Симулятор сбора "Мечт"

## Описание

Симуляция игры, в которой игрок перемещается по игровому полю, бросая два шестигранных кубика. 
На некоторых ячейках поля расположены "мечты", которые игрок может "собирать". 
Цель игры - понять, какие "мечты" являются наиболее вероятными для сбора при заданных правилах.

## Правила игры

1.  Игрок начинает игру на начальной позиции (считаем, что она равна 0).
2.  За один ход игрок бросает два шестигранных кубика и перемещается на количество ячеек, равное сумме выпавших значений.
3.  Игровое поле имеет 48 ячеек. Если игрок перемещается за пределы 48 ячейки, он возвращается в начало, "зацикливаясь" по полю (например, если текущая позиция 47 и выпало 4, то новая позиция будет 3).
4.  На некоторых ячейках (заданных в списке `dream_numbers`) находятся "мечты".
5.  Если игрок попадает на ячейку с "мечтой" и еще не посещал ее в текущей итерации, то "мечта" считается собранной.
6.  Игра продолжается заданное количество ходов (`moves`).
7.  Игра симулируется заданное количество раз (`num_iterations`).
8.  В результате работы программы подсчитывается частота сбора каждой "мечты" и вероятность ее сбора.

## Особенности кода

*   **Моделирование**: Код моделирует перемещение игрока по игровому полю с использованием бросков кубиков.
*   **Сбор "Мечт"**: Код отслеживает, когда игрок попадает на ячейки с "мечтами" и считает их количество.
*   **Анализ**: Программа анализирует результаты симуляции и рассчитывает частоту и вероятность сбора каждой "мечты".
*   **Класс `DreamGame`**: Код инкапсулирован в класс `DreamGame`, что делает его более структурированным и переиспользуемым.
*   **Генерация названий мечт**: Названия "мечт" генерируются с помощью модели Gemini, что делает каждую игру уникальной.
*   **Оптимизация**: Код оптимизирован с использованием `collections.Counter` для подсчета частот и генераторов для итерации по симуляциям.

## Возможности

*   **Настройка параметров**: Можно легко настроить количество ходов за одну игру (`moves`) и количество симуляций игры (`num_iterations`).
*   **Динамические названия**: Названия "мечт" генерируются динамически с помощью модели Gemini, что добавляет разнообразия в игру.
*   **Анализ вероятностей**: Получение вероятности сбора каждой "мечты" позволяет анализировать и сравнивать их доступность.
*   **Расширяемость**: Код легко расширяется и может быть модифицирован для добавления новых механик игры.

## Разбор кода

### Класс `DreamGame`

Класс `DreamGame` инкапсулирует всю логику игры.

#### `__init__(self, dream_numbers: List[int], moves: int = 3, num_iterations: int = 100_000)`

Конструктор класса, который инициализирует игру:

*   `dream_numbers`: Список чисел, представляющих позиции "мечт".
*   `moves`: Количество ходов за одну игру.
*   `num_iterations`: Количество симуляций игры.
*   `self.dreams`: Словарь, связывающий номера мечт с их названиями. Заполняется при помощи `_generate_dream_names`.

#### `_generate_dream_names(self) -> None`

Метод, который генерирует названия "мечт" с помощью модели Gemini.

*   Формирует запрос к модели Gemini на генерацию заданного количества уникальных названий "мечт".
*   Обрабатывает ответ и создает словарь `self.dreams`, связывающий номер "мечты" с ее названием.
*   Вызывает ошибку, если модель не возвращает текст или не может сгенерировать необходимое количество названий.

#### `_simulate_game(self) -> Counter[str]`

Метод, который симулирует одну игру:

*   Инициализирует счетчик `dreams_frequency` для отслеживания частоты сбора "мечт".
*   Инициализирует переменную `square`, представляющую текущую позицию игрока на поле, и `visited_dreams` для учета собранных мечт.
*   Проводит заданное количество ходов (`moves`), перемещая игрока по игровому полю.
*   Если игрок попадает на ячейку с "мечтой" и еще не посещал ее, увеличивает счетчик для этой "мечты".
*   Возвращает объект `Counter` с частотой сбора "мечт".

#### `run_experiment(self) -> pd.DataFrame`

Метод, который запускает симуляцию игры несколько раз и возвращает DataFrame с результатами:

*   Запускает симуляцию игры заданное количество раз (`num_iterations`).
*   Суммирует частоты сбора "мечт" из каждой симуляции.
*   Преобразует результаты в DataFrame, где столбцы - "Мечта" и "Частота".
*   Сортирует DataFrame по убыванию частоты.
*   Добавляет столбец "Вероятность", рассчитываемый как отношение "Частоты" к общему количеству симуляций.
*   Возвращает DataFrame с результатами.

### Использование

В конце скрипта создается экземпляр класса `DreamGame` и запускается эксперимент. Результат выводится на экран в виде DataFrame.

```python
if __name__ == '__main__':
    dream_numbers = [1, 3, 5, 7, 10, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47]
    game = DreamGame(dream_numbers, moves=3, num_iterations=10_000)
    df_result = game.run_experiment()
    print(df_result)
```

## Требования

*   Python 3.6+
*   Библиотеки: `pandas`, `google-generativeai`
*   Переменная окружения `GOOGLE_API_KEY` с вашим API ключом Gemini

## Установка

1.  Установите Python 3.6+
2.  Установите библиотеки: `pip install pandas google-generativeai`
3.  Установите переменную окружения `GOOGLE_API_KEY` с вашим API ключом Gemini.
4.  Запустите скрипт `python your_script_name.py`

## Примеры использования
```python
    dream_numbers = [1, 3, 5, 7, 10, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47]
    game = DreamGame(dream_numbers, moves=3, num_iterations=10_000)
    df_result = game.run_experiment()
    print(df_result)
```
В данном примере: 
 * Создается игровой обьект
 * Симулируется 10 000 игр с тремя ходами
 * Выводится результат симуляции в виде pandas DataFrame.

```python
    dream_numbers = [2,4,8,16,32,44]
    game = DreamGame(dream_numbers, moves=5, num_iterations=1000)
    df_result = game.run_experiment()
    print(df_result)
```
В данном примере: 
 * Создается игровой обьект с другими номерами мечт
 * Симулируется 1000 игр с пятью ходами
 * Выводится результат симуляции в виде pandas DataFrame.

## Лицензия

MIT
