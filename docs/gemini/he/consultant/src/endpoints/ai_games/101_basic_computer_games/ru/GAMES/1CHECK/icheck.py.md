# Анализ кода модуля `icheck.py`

**Качество кода**
- Соответствие требованиям к формату кода: 8 из 10
    -  **Преимущества**:
        - Код хорошо структурирован и разбит на классы и функции, что повышает читаемость.
        - Используются аннотации типов, что улучшает понимание кода и упрощает отладку.
        - Присутствует базовая документация в виде docstring.
        - Логика игры реализована корректно и соответствует правилам.
    -  **Недостатки**:
        - Отсутствует обработка исключений и логирование ошибок.
        - Не используется `j_loads` или `j_loads_ns` для чтения данных (в данном коде не требуется, но следует помнить об этом).
        - Документация не полностью соответствует reStructuredText (RST) формату.
        - Отсутствуют импорты из `src.logger.logger`.

**Рекомендации по улучшению**
1.  **Формат документации**:
    - Переписать docstring в формате reStructuredText (RST).
2.  **Логирование**:
    - Добавить импорт `from src.logger.logger import logger` и использовать `logger.error` для записи ошибок.
3.  **Обработка исключений**:
    - Убрать общие блоки `try-except` и использовать `logger.error` для логирования ошибок, если они возникнут.
4.  **Импорты**:
    - Добавить необходимые импорты для `src.utils.jjson` если это необходимо в будущих итерациях.
5.  **Стиль**:
    -  Улучшить стиль кода, следуя PEP 8.
6.  **Сообщения**:
   -  Заменить простые принты на `logger.info` или `logger.debug`.

**Улучшенный код**

```python
"""
Решатель головоломки с шашками
=========================================================================================

Правила головоломки:
1. Доска представляет собой сетку 8x8 (стандартная шахматная доска).
2. Изначально 48 шашек размещаются на двух крайних рядах (ряды 1 и 8).
3. Шашки могут двигаться только по диагонали.
4. Шашка может "перепрыгнуть" через соседнюю шашку по диагонали, если посадочная клетка пуста.
5. Перепрыгнутая шашка удаляется с доски.
6. Цель состоит в том, чтобы убрать как можно больше шашек, выполняя допустимые прыжки.
7. Игра заканчивается, когда больше нет возможных допустимых прыжков.

Пример использования
--------------------

Пример использования класса `Checkerboard`:

.. code-block:: python

    initial_board = [[0 for _ in range(8)] for _ in range(8)]
    game = Checkerboard(board=initial_board)
    game.display_board()
    game.play()

"""
from dataclasses import dataclass
from typing import List, Tuple
from src.logger.logger import logger # импорт logger для логирования ошибок

@dataclass
class Checkerboard:
    """
    Представляет собой доску и ее состояние.

    :ivar board: Список списков, представляющий доску. 0 = пусто, 1 = шашка.
    :vartype board: List[List[int]]
    :ivar removed_checkers: Счетчик удаленных шашек.
    :vartype removed_checkers: int
    """
    board: List[List[int]]  # 0 = empty, 1 = checker
    removed_checkers: int = 0  # Counter for removed checkers

    def __post_init__(self) -> None:
        """
        Инициализирует доску 48 шашками на крайних рядах.
        """
        for row in [0, 7]:  # Rows 1 and 8 (0-indexed) # установка шашек на крайние ряды
            for col in range(8):
                self.board[row][col] = 1

    def is_valid_jump(self, start: Tuple[int, int], end: Tuple[int, int]) -> bool:
        """
        Проверяет, является ли прыжок допустимым.
        Правила:
        - Конечная позиция должна быть в пределах доски.
        - Конечная позиция должна быть пустой.
        - Должна быть шашка для перепрыгивания.
        - Прыжок должен быть диагональным (2 клетки в строке и столбце).

        :param start: Кортеж (строка, столбец) начальной позиции.
        :type start: Tuple[int, int]
        :param end: Кортеж (строка, столбец) конечной позиции.
        :type end: Tuple[int, int]
        :return: True, если прыжок допустим, False в противном случае.
        :rtype: bool
        """
        start_row, start_col = start # получение координат начальной позиции
        end_row, end_col = end # получение координат конечной позиции

        # Проверка, находится ли конечная позиция в пределах доски
        if not (0 <= end_row < 8 and 0 <= end_col < 8): # проверка границ
            return False

        # Проверка, является ли конечная позиция пустой
        if self.board[end_row][end_col] != 0: # проверка на пустоту клетки
            return False

        # Вычисление средней позиции (шашка для перепрыгивания)
        mid_row = (start_row + end_row) // 2 # вычисление средней позиции по строке
        mid_col = (start_col + end_col) // 2 # вычисление средней позиции по столбцу

        # Проверка, есть ли шашка для перепрыгивания
        if self.board[mid_row][mid_col] != 1: # проверка на наличие шашки посередине
            return False

        # Проверка, является ли прыжок диагональным
        if abs(start_row - end_row) != 2 or abs(start_col - end_col) != 2: # проверка диагонального перемещения
            return False

        return True

    def perform_jump(self, start: Tuple[int, int], end: Tuple[int, int]) -> None:
        """
        Выполняет прыжок и удаляет перепрыгнутую шашку.
        Правила:
        - Перемещает шашку из начальной позиции в конечную позицию.
        - Удаляет шашку в средней позиции.
        - Увеличивает счетчик удаленных шашек.

        :param start: Кортеж (строка, столбец) начальной позиции.
        :type start: Tuple[int, int]
        :param end: Кортеж (строка, столбец) конечной позиции.
        :type end: Tuple[int, int]
        """
        start_row, start_col = start # получение координат начальной позиции
        end_row, end_col = end # получение координат конечной позиции

        # Перемещение шашки
        self.board[start_row][start_col] = 0 # установка начальной позиции в 0
        self.board[end_row][end_col] = 1 # установка конечной позиции в 1

        # Удаление перепрыгнутой шашки
        mid_row = (start_row + end_row) // 2 # вычисление средней позиции по строке
        mid_col = (start_col + end_col) // 2 # вычисление средней позиции по столбцу
        self.board[mid_row][mid_col] = 0 # установка средней позиции в 0

        # Увеличение счетчика удаленных шашек
        self.removed_checkers += 1 # увеличение счетчика удаленных шашек

    def find_possible_jumps(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """
        Находит все возможные прыжки на доске.
        Правила:
        - Сканирует доску на наличие шашек.
        - Для каждой шашки проверяет все четыре диагональных направления на наличие допустимых прыжков.

        :return: Список кортежей, где каждый кортеж содержит (начальную, конечную) позиции для допустимых прыжков.
        :rtype: List[Tuple[Tuple[int, int], Tuple[int, int]]]
        """
        jumps: List[Tuple[Tuple[int, int], Tuple[int, int]]] = [] # список для хранения возможных прыжков
        for row in range(8): # проход по всем строкам
            for col in range(8): # проход по всем столбцам
                if self.board[row][col] == 1: # если клетка содержит шашку
                    # Проверка всех четырех диагональных направлений
                    for dr, dc in [(-2, -2), (-2, 2), (2, -2), (2, 2)]: # перебор всех возможных диагональных смещений
                        start = (row, col) # установка начальной позиции
                        end = (row + dr, col + dc) # установка конечной позиции
                        if self.is_valid_jump(start, end): # если прыжок возможен
                            jumps.append((start, end)) # добавление прыжка в список
        return jumps

    def play(self) -> None:
        """
        Моделирует игру, выполняя прыжки, пока больше нет возможных прыжков.
        Правила:
        - Повторно находит и выполняет допустимые прыжки.
        - Останавливается, когда больше нет возможных прыжков.
        """
        while True: # основной цикл игры
            jumps = self.find_possible_jumps() # поиск возможных прыжков
            if not jumps: # если прыжков нет, то выход из цикла
                break  # No more jumps possible # нет больше возможных прыжков

            # Выполнение первого допустимого прыжка (можно оптимизировать)
            start, end = jumps[0] # берется первый прыжок из списка
            self.perform_jump(start, end) # выполнение прыжка

        logger.info(f"Total checkers removed: {self.removed_checkers}") # вывод количества удаленных шашек

    def display_board(self) -> None:
        """
        Отображает текущее состояние доски.
        Правила:
        - Выводит доску с символом '•' для шашек и '.' для пустых клеток.
        """
        for row in self.board: # проход по всем строкам
            print(" ".join("•" if cell == 1 else "." for cell in row)) # вывод строки с шашками и пустыми клетками
        print()


# Main program
if __name__ == "__main__":
    logger.info("Initial Board:") # вывод сообщения о начале игры
    # Initialize the board with empty squares
    initial_board = [[0 for _ in range(8)] for _ in range(8)] # инициализация доски пустыми клетками
    game = Checkerboard(board=initial_board) # создание объекта игры
    game.display_board() # отображение начальной доски

    logger.info("Playing the game...") # вывод сообщения о начале игры
    game.play() # запуск игры

    logger.info("Final Board:") # вывод сообщения о конце игры
    game.display_board()# отображение конечной доски
```