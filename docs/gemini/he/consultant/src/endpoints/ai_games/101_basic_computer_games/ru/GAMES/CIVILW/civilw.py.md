## Анализ кода модуля civilw

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):** 6
    -  **Преимущества:**
        - Код выполняет поставленную задачу симуляции сражения.
        - Использованы циклы `while` и `if` для логики игры.
        - Присутствует проверка на корректный ввод данных.
    - **Недостатки:**
        -  Отсутствует структурированное документирование кода в формате reStructuredText (RST).
        -  Используется стандартный `print` для вывода сообщений, что усложняет локализацию и тестирование.
        -  Код не использует логгер для фиксации ошибок, что затрудняет отладку.
        -  Отсутствует обработка крайних случаев, кроме ввода неверных данных.
        -  Не используются константы для магических чисел (например, 0.4, 0.2, 0.3).
        -  Код не следует стандартам PEP 8 в части именования переменных (например, camelCase вместо snake_case).

**Рекомендации по улучшению**

1.  **Документирование:**
    -   Добавить docstring в формате RST для модуля, функций, и переменных.
    -   Использовать комментарии для объяснения сложных частей кода.

2.  **Обработка ошибок:**
    -   Использовать `logger.error` вместо стандартного `print` для вывода ошибок.
    -   Добавить обработку других возможных ошибок (например, некорректные данные).

3.  **Использование констант:**
    -   Заменить магические числа константами с понятными именами.

4.  **Стиль кода:**
    -   Привести именование переменных к snake_case.

5.  **Рефакторинг:**
    - Разбить код на функции для улучшения читаемости и переиспользования.
    - Вынести ввод данных в отдельные функции, чтобы упростить тестирование.

**Улучшенный код**

```python
"""
Модуль для симуляции гражданской войны.
======================================

Модуль имитирует сражение между армиями Конфедерации и Союза.
Игрок управляет Конфедерацией, принимая решения о количестве войск
для атаки и типе атаки. Цель игры - победить армию Союза.

Пример использования:
--------------------

.. code-block:: python

    python civilw.py

"""

import random  # Импортируем модуль random для генерации случайных чисел.
from src.logger.logger import logger  # Импортируем логгер для записи ошибок.
from src.utils.jjson import j_loads  # Импортируем j_loads для загрузки данных из JSON (не используется, но добавлено согласно инструкции)

# Константы для параметров игры.
UNION_STARTING_FORCE = 1000  # Начальная численность армии Союза.
CONFEDERATE_STARTING_FORCE = 800  # Начальная численность армии Конфедерации.
DIRECT_ATTACK_LOSS_FACTOR = 0.4  # Фактор потерь при прямой атаке.
FLANK_ATTACK_LOSS_FACTOR = 0.2  # Фактор потерь при обходной атаке.
UNION_LOSS_FACTOR = 0.3  # Фактор потерь Союза.
FLANK_ATTACK_UNION_BONUS = 100  # Бонус к потерям Союза при обходной атаке.


def get_attack_force(confederate_force: int) -> int:
    """
    Запрашивает у игрока количество солдат для атаки.

    :param confederate_force: Текущая численность армии Конфедерации.
    :return: Количество солдат для атаки.
    :raises ValueError: Если ввод не является целым числом.
    """
    while True:
        try:
            attack_force = int(input('Введите количество солдат для атаки (Конфедерация): ')) # Запрашиваем ввод количества солдат.
            if attack_force > confederate_force:
                print('Недостаточно сил! Попробуйте еще раз.') # Выводим сообщение, если недостаточно сил.
                logger.debug(f'Попытка атаковать {attack_force} солдатами, при наличии {confederate_force}.') # Записываем ошибку в лог.
            else:
                return attack_force # Возвращаем количество солдат для атаки.
        except ValueError:
            print('Пожалуйста, введите целое число.') # Выводим сообщение, если ввод некорректный.
            logger.error('Введен некорректный формат числа для количества атакующих.') # Записываем ошибку в лог.


def get_attack_type() -> int:
    """
    Запрашивает у игрока тип атаки.

    :return: Тип атаки (1 - прямая, 2 - обходная).
    :raises ValueError: Если ввод не является целым числом 1 или 2.
    """
    while True:
        try:
            attack_type = int(input('Выберите тип атаки (1 - прямая, 2 - обходная): ')) # Запрашиваем тип атаки.
            if attack_type in [1, 2]:
                return attack_type # Возвращаем тип атаки.
            else:
                print('Неверный тип атаки, попробуйте еще раз') # Выводим сообщение, если тип атаки некорректный.
                logger.debug(f'Введен неверный тип атаки: {attack_type}.') # Записываем ошибку в лог.
        except ValueError:
            print('Пожалуйста, введите целое число 1 или 2.') # Выводим сообщение, если ввод некорректный.
            logger.error('Введен некорректный формат числа для типа атаки.') # Записываем ошибку в лог.


def calculate_confederate_losses(attack_force: int, attack_type: int) -> int:
    """
    Рассчитывает потери Конфедерации в зависимости от типа атаки.

    :param attack_force: Количество солдат для атаки.
    :param attack_type: Тип атаки (1 - прямая, 2 - обходная).
    :return: Потери Конфедерации.
    """
    if attack_type == 1:  # Прямая атака.
        confederate_losses = int(attack_force * random.random() * DIRECT_ATTACK_LOSS_FACTOR) # Расчет потерь при прямой атаке.
    else:  # Обходной маневр.
        confederate_losses = int(attack_force * random.random() * FLANK_ATTACK_LOSS_FACTOR) # Расчет потерь при обходном маневре.

    if confederate_losses > attack_force: # Проверка, что потери не превышают атакующие силы.
        confederate_losses = attack_force # Если потери превышают атакующие силы, то приравниваем потери к атакующим силам.

    return confederate_losses # Возвращаем потери Конфедерации.


def calculate_union_losses(attack_force: int, attack_type: int) -> int:
    """
    Рассчитывает потери Союза в зависимости от типа атаки.

    :param attack_force: Количество солдат для атаки.
    :param attack_type: Тип атаки (1 - прямая, 2 - обходная).
    :return: Потери Союза.
    """
    union_losses = int(attack_force * random.random() * UNION_LOSS_FACTOR) # Расчет потерь Союза.
    if attack_type == 2: # Если тип атаки обходной, то добавляем бонус к потерям.
        union_losses += random.randint(0, FLANK_ATTACK_UNION_BONUS) # Добавляем случайный бонус к потерям Союза.
    return union_losses # Возвращаем потери Союза.


def print_forces(confederate_force: int, union_force: int) -> None:
    """
    Выводит текущую численность армий.

    :param confederate_force: Текущая численность армии Конфедерации.
    :param union_force: Текущая численность армии Союза.
    """
    print(f'Конфедерация: {confederate_force} солдат') # Выводим текущую численность армии Конфедерации.
    print(f'Союз: {union_force} солдат') # Выводим текущую численность армии Союза.


def check_victory(confederate_force: int, union_force: int) -> bool:
    """
    Проверяет условия победы.

    :param confederate_force: Текущая численность армии Конфедерации.
    :param union_force: Текущая численность армии Союза.
    :return: True, если игра завершена, False в противном случае.
    """
    if union_force <= 0: # Проверяем, если численность армии Союза стала меньше или равна 0, то выводим сообщение о победе Конфедерации.
        print('Конфедерация победила!') # Выводим сообщение о победе Конфедерации.
        return True # Возвращаем True, так как игра завершена.
    elif confederate_force <= 0: # Проверяем, если численность армии Конфедерации стала меньше или равна 0, то выводим сообщение о победе Союза.
        print('Союз победил!') # Выводим сообщение о победе Союза.
        return True # Возвращаем True, так как игра завершена.
    return False # Возвращаем False, так как игра не завершена.


def main():
    """
    Основная функция игры.

    Инициализирует армии, запускает игровой цикл, и проверяет условия победы.
    """
    union_force = UNION_STARTING_FORCE # Инициализация начальной численности армии Союза.
    confederate_force = CONFEDERATE_STARTING_FORCE # Инициализация начальной численности армии Конфедерации.

    while union_force > 0 and confederate_force > 0: # Игровой цикл продолжается, пока обе армии имеют численность больше 0.
        attack_force = get_attack_force(confederate_force) # Получаем количество солдат для атаки.
        attack_type = get_attack_type() # Получаем тип атаки.

        confederate_losses = calculate_confederate_losses(attack_force, attack_type) # Рассчитываем потери Конфедерации.
        union_losses = calculate_union_losses(attack_force, attack_type) # Рассчитываем потери Союза.

        confederate_force -= confederate_losses # Обновляем численность армии Конфедерации.
        union_force -= union_losses # Обновляем численность армии Союза.

        print_forces(confederate_force, union_force) # Выводим текущую численность армий.

        if check_victory(confederate_force, union_force): # Проверяем условия победы.
            break # Завершаем игру, если условия победы выполнены.


if __name__ == '__main__':
    main()