# Анализ кода модуля `59_life_2.ru.md`

**Качество кода: 7/10**
-  Плюсы:
    - Документ содержит подробное описание правил игры "LIFE-2" для двух игроков.
    - Описание игры включает все необходимые аспекты: правила, пошаговую инструкцию, пример работы программы, ограничения и рекомендации по реализации.
    - Присутствует логичная структура с разделением на разделы, что облегчает понимание.
    - Включены примеры работы программы и возможные ограничения.
- Минусы:
    - Документ не содержит исполняемого кода, а только описание правил и структуры игры.
    - Отсутствует документация в формате reStructuredText (RST), что требуется согласно инструкции.
    - Нет примеров кода на Python, которые можно было бы проверить на соответствие инструкциям.
    - Не используются `j_loads` или `j_loads_ns`, а также `from src.logger.logger import logger`.

**Рекомендации по улучшению**
1.  **Преобразование в RST:** Переписать весь документ в формате RST, включая заголовки, параграфы, списки и блоки кода.
2.  **Добавление примеров кода:** Добавить примеры кода на Python, демонстрирующие основные моменты реализации игры (инициализация, обновление поля, ввод данных).
3.  **Использование `j_loads` и `logger`:** В примерах кода использовать `j_loads` или `j_loads_ns` для загрузки данных (если необходимо) и `from src.logger.logger import logger` для логирования.
4.  **Внедрение reStructuredText:** Комментировать функции и методы с использованием reStructuredText (RST) формата, включая описания параметров, возвращаемых значений и т.д.
5.  **Соблюдение стандартов PEP 8:** Привести код в соответствие со стандартами PEP 8, включая форматирование, имена переменных и функций.
6.  **Обработка ошибок:** Избегать избыточного использования `try-except`, обрабатывая ошибки с помощью `logger.error`.

**Оптимизированный код**
```markdown
# Анализ игры: LIFE-2 (Игра жизни для двух игроков)
====================================================

:module:  LIFE-2
:description: Адаптация игры "Жизнь" Джона Конвея для двух игроков.

Описание
--------

**LIFE-2** — это адаптация игры "Игра жизни" Джона Конвея для двух игроков.
На игровом поле 5x5 каждый игрок управляет своей "жизнью", представленную символами `*` (для первого игрока) и `#` (для второго игрока).
Цель игры — уничтожить все клетки жизни противника, следуя правилам, подобным классической игре "Жизнь".

Каждый игрок может размещать свои клетки на поле, стараясь создавать условия для их воспроизведения или уничтожения клеток соперника.

Правила игры
------------

1. **Основные элементы:**
    - Поле размером 5x5.
    - Живые клетки первого игрока обозначаются как ``*``.
    - Живые клетки второго игрока обозначаются как ``#``.

2. **Начало игры:**
    - На первом ходу каждый игрок размещает по 3 клетки на поле, вводя их координаты.
    - Если оба игрока пытаются разместить клетку в одной и той же ячейке, ячейка остаётся пустой.

3. **Правила жизни:**
    - Каждая клетка (независимо от символа) имеет 8 соседей (по горизонтали, вертикали и диагоналям).
    - **Выживание:** Клетка остаётся живой, если у неё ровно 2 или 3 соседа.
    - **Смерть:** Клетка умирает, если у неё меньше 2 или больше 3 соседей.
    - **Рождение:** Если пустая ячейка окружена ровно 3 живыми клетками, в ней появляется новая клетка:
        - Если большинство соседей принадлежит первому игроку, создаётся ``*``.
        - Если большинство соседей принадлежит второму игроку, создаётся ``#``.

4. **Игровой процесс:**
    - После начального размещения игроки по очереди добавляют по одной клетке на поле, вводя её координаты.
    - После каждого хода игрока проводится обновление поля, следуя вышеописанным правилам.

5. **Завершение игры:**
    - Игра заканчивается, когда у одного из игроков не остаётся живых клеток.
    - Побеждает игрок, чьи клетки остались на поле.

Пошаговая инструкция для реализации
-----------------------------------

1. **Инициализация игры**
    - Программа выводит приветствие и объясняет правила:

      .. code-block:: none

          Добро пожаловать в LIFE-2 — двухпользовательскую адаптацию Игры жизни!
          Игроки по очереди будут размещать клетки на поле 5x5.
          Цель игры — уничтожить клетки соперника, следуя правилам жизни. Удачи!

    - Игроки выбирают свои начальные клетки (по 3 клетки каждый).

2. **Основной процесс игры**
    - **Размещение клеток:**
        - Каждый игрок вводит координаты клетки (строка и столбец).
        - Если координаты выходят за пределы поля или ячейка уже занята, программа запрашивает ввод повторно.
        - Если оба игрока выбрали одну и ту же ячейку, она остаётся пустой.

    - **Обновление поля:**
        - После каждого хода игрока программа вычисляет новое состояние поля.
        - Применяются правила выживания, смерти и рождения клеток.
        - Поле обновляется и выводится на экран.

    - **Ход игры:**
        - Игроки по очереди добавляют по одной клетке на поле.

3. **Завершение игры**
    - Игра продолжается, пока на поле остаются клетки обоих игроков.
    - Если у одного из игроков не остаётся клеток, программа завершает игру, выводит итоговое состояние поля и объявляет победителя.

Пример работы программы
-----------------------

1. **Начало игры:**

   .. code-block:: none

      Добро пожаловать в LIFE-2!
      Игрок 1 размещает 3 клетки. Введите координаты:
      > 1,2
      > 2,3
      > 3,3
      Игрок 2 размещает 3 клетки. Введите координаты:
      > 2,2
      > 3,2
      > 4,4

      Поле после начального размещения:
        1  2  3  4  5
      1  .  *  .  .  .
      2  .  #  *  .  .
      3  .  #  #  .  .
      4  .  .  .  #  .
      5  .  .  .  .  .

2. **Игровой процесс:**

   .. code-block:: none

      Игрок 1 добавляет клетку. Введите координаты:
      > 4,3

      Поле после обновления:
        1  2  3  4  5
      1  .  *  .  .  .
      2  .  #  *  .  .
      3  .  #  #  .  .
      4  .  .  *  *  .
      5  .  .  .  .  .

      Игрок 2 добавляет клетку. Введите координаты:
      > 5,5

      Поле после обновления:
        1  2  3  4  5
      1  .  *  .  .  .
      2  .  #  *  .  .
      3  .  #  #  .  .
      4  .  .  *  #  .
      5  .  .  .  .  #

3. **Завершение игры:**

   .. code-block:: none

       Игрок 2 уничтожил все клетки Игрока 1!
       Победитель: Игрок 2!

Возможные ограничения
---------------------

- Поле фиксировано (5x5), клетки за его пределами не могут быть размещены.
- Если игрок вводит некорректные координаты, программа должна сообщать об ошибке и запрашивать повторный ввод.
- При размещении клеток в одной и той же ячейке она остаётся пустой.

Реализация
----------

Игра может быть реализована на Python с использованием следующих возможностей:

- **Массивы или списки** для хранения состояния поля.
- **Циклы и условия** для проверки корректности ввода и обновления состояния поля.
- Логика для обработки правил жизни, включая проверку соседей и рождение новых клеток.

Рекомендуемые улучшения
-----------------------

- Добавить возможность увеличивать размер поля (например, 10x10) для более сложных партий.
- Реализовать графический интерфейс с использованием библиотеки ``pygame`` для визуализации.
- Ввести режим против компьютера с базовым искусственным интеллектом.

Примеры кода
------------

.. code-block:: python

    from src.logger.logger import logger
    from src.utils.jjson import j_loads_ns
    
    def initialize_board():
        """
        Инициализирует игровое поле 5x5, заполняя его пустыми клетками.

        :return: Двумерный список, представляющий игровое поле.
        """
        board = [['.' for _ in range(5)] for _ in range(5)]
        return board

    def place_initial_cells(board, player, coordinates):
        """
        Размещает начальные клетки игроков на поле.

        :param board: Игровое поле.
        :param player: Символ игрока ('*' или '#').
        :param coordinates: Список координат в формате [(row1, col1), (row2, col2), (row3, col3)].
        :return: Обновленное игровое поле.
        """
        for row, col in coordinates:
          if board[row][col] == '.':
             board[row][col] = player
          else:
            logger.debug(f"Ячейка {row},{col} занята, пропуск установки")
        return board

    def update_board(board):
        """
        Обновляет состояние игрового поля на основе правил игры "Жизнь".

        :param board: Текущее состояние игрового поля.
        :return: Обновленное игровое поле.
        """
        rows, cols = len(board), len(board[0])
        new_board = [['.' for _ in range(cols)] for _ in range(rows)]
        
        for row in range(rows):
          for col in range(cols):
            live_neighbors = count_live_neighbors(board, row, col)
            current_cell = board[row][col]
            if current_cell == '*':
                if live_neighbors == 2 or live_neighbors == 3:
                    new_board[row][col] = '*'
                else:
                  new_board[row][col] = '.'
            elif current_cell == '#':
                 if live_neighbors == 2 or live_neighbors == 3:
                    new_board[row][col] = '#'
                 else:
                    new_board[row][col] = '.'
            else:
                if live_neighbors == 3:
                    new_board[row][col] = determine_new_cell(board, row, col)
                else:
                     new_board[row][col] = '.'
        return new_board

    def count_live_neighbors(board, row, col):
        """
        Подсчитывает количество живых соседей у клетки на заданных координатах.

        :param board: Игровое поле.
        :param row: Строка клетки.
        :param col: Столбец клетки.
        :return: Количество живых соседей.
        """
        rows, cols = len(board), len(board[0])
        live_count = 0
        for i in range(max(0, row-1), min(rows, row+2)):
            for j in range(max(0, col-1), min(cols, col+2)):
              if (i, j) != (row, col) and board[i][j] != '.':
                live_count += 1
        return live_count
    
    def determine_new_cell(board, row, col):
        """
        Определяет символ новой клетки по большинству соседей.
        
        :param board: Игровое поле.
        :param row: Строка клетки.
        :param col: Столбец клетки.
        :return: Символ новой клетки ('*' или '#').
        """
        rows, cols = len(board), len(board[0])
        star_count = 0
        hash_count = 0
        for i in range(max(0, row - 1), min(rows, row + 2)):
            for j in range(max(0, col - 1), min(cols, col + 2)):
                if (i, j) != (row, col):
                    if board[i][j] == '*':
                        star_count += 1
                    elif board[i][j] == '#':
                        hash_count += 1
        
        if star_count > hash_count:
            return '*'
        elif hash_count > star_count:
            return '#'
        else:
            return '.'


    def print_board(board):
        """
        Выводит текущее состояние игрового поля в консоль.
        
        :param board: Игровое поле.
        """
        print("   ", end="")
        for i in range(len(board[0])):
            print(i+1, end="  ")
        print()
        for i, row in enumerate(board):
            print(i + 1, " ", '  '.join(row))
    
    def is_game_over(board):
      """
      Проверяет, закончена ли игра.
      
      :param board: Игровое поле.
      :return: True, если у одного из игроков нет клеток, False в противном случае.
      """
      star_exists = any('*' in row for row in board)
      hash_exists = any('#' in row for row in board)
      
      return not star_exists or not hash_exists
    
    def get_player_input(player):
        """
        Получает ввод координат от игрока и проводит валидацию.
         
        :param player: Символ игрока ('*' или '#').
        :return: Кортеж с валидными координатами (row, col).
        """
        while True:
           try:
               coords_str = input(f"Игрок {player}, введите координаты (строка, столбец через запятую): ")
               row, col = map(int, coords_str.split(','))
               if 1 <= row <= 5 and 1 <= col <= 5:
                   return row -1, col -1
               else:
                   logger.error("Некорректные координаты. Пожалуйста, введите значения от 1 до 5.")
           except ValueError as ex:
               logger.error(f"Некорректный ввод, повторите {ex}")
               
    def play_game():
      """
      Запускает основную логику игры LIFE-2.
      """
      print("Добро пожаловать в LIFE-2 — двухпользовательскую адаптацию Игры жизни!")
      print("Игроки по очереди будут размещать клетки на поле 5x5.")
      print("Цель игры — уничтожить клетки соперника, следуя правилам жизни. Удачи!")
      
      board = initialize_board()
      
      for player in ['*', '#']:
          print(f"Игрок {player} размещает 3 клетки:")
          coords_list = []
          for _ in range(3):
            row, col = get_player_input(player)
            coords_list.append((row, col))
          board = place_initial_cells(board, player, coords_list)
      
      print_board(board)
      
      current_player = '*'
      
      while not is_game_over(board):
          row, col = get_player_input(current_player)
          if board[row][col] == '.':
             board[row][col] = current_player
          else:
             logger.debug(f"Ячейка {row + 1},{col + 1} занята, пропуск установки")
          board = update_board(board)
          print_board(board)
          current_player = '#' if current_player == '*' else '*'
        
      winner = '*' if any('*' in row for row in board) else '#'
      print(f"Игрок {winner} уничтожил все клетки противника!")
      print(f"Победитель: Игрок {winner}!")
    
    if __name__ == "__main__":
        play_game()
```