# Модуль `report_generator.py`

## Обзор

Модуль предназначен для генерации отчетов в формате HTML, PDF и DOCX на основе данных в формате JSON для мехиронов Казаринова. Он предоставляет класс `ReportGenerator`, который выполняет загрузку данных, генерацию контента и сохранение отчетов в указанных форматах.

## Подробней

Этот модуль является частью системы обработки и представления данных в проекте `hypotez`. Он использует шаблонизатор Jinja2 для генерации HTML-контента, библиотеку `pdfkit` для конвертации HTML в PDF, а также вспомогательные функции из других модулей проекта для чтения/записи файлов и конвертации форматов.

## Классы

### `ReportGenerator`

**Описание**: Класс предназначен для генерации отчетов в различных форматах (HTML, PDF, DOCX) на основе данных JSON.

**Принцип работы**:
Класс инициализируется с параметрами, определяющими необходимость генерации отчетов в формате PDF и DOCX. Основной метод `create_reports_async` координирует процесс создания отчетов, вызывая методы для генерации HTML, PDF и DOCX. Данные для отчетов загружаются из JSON, а шаблоны Jinja2 используются для формирования HTML-контента.

**Атрибуты**:

- `if_need_html` (bool): Флаг, указывающий на необходимость генерации HTML-отчета.
- `if_need_pdf` (bool): Флаг, указывающий на необходимость генерации PDF-отчета.
- `if_need_docx` (bool): Флаг, указывающий на необходимость генерации DOCX-отчета.
- `storage_path` (Path): Путь к директории, где будут сохранены сгенерированные отчеты.
- `html_path` (Path | str): Путь к HTML-файлу.
- `pdf_path` (Path | str): Путь к PDF-файлу.
- `docs_path` (Path | str): Путь к DOCX-файлу.
- `html_content` (str): Сгенерированный HTML-контент.
- `data` (dict): Данные для генерации отчета.
- `lang` (str): Язык, на котором генерируется отчет.
- `mexiron_name` (str): Имя мехирона, для которого генерируется отчет.
- `env` (Environment): Объект окружения Jinja2 для работы с шаблонами.

**Методы**:

- `__init__`: Инициализирует экземпляр класса `ReportGenerator`.
- `create_reports_async`: Координирует создание всех типов отчетов (HTML, PDF, DOCX).
- `service_apendix`:  Возвращает словарь с данными для сервисного приложения.
- `create_html_report_async`: Генерирует HTML-контент на основе данных и шаблона.
- `create_pdf_report_async`: Создает PDF-отчет из HTML-контента.
- `create_docx_report_async`: Создает DOCX-отчет из HTML-файла.

### `ReportGenerator.__init__`

```python
def __init__(self, 
                 if_need_pdf:Optional[bool] = True, 
                 if_need_docx:Optional[bool] = True, 
            ):
    """Определение, какие форматы данных требуется вернуть"""
```

**Назначение**: Инициализирует объект `ReportGenerator`, определяя, какие типы отчетов необходимо генерировать (PDF и/или DOCX).

**Параметры**:

- `if_need_pdf` (Optional[bool], optional): Флаг, указывающий на необходимость генерации PDF-отчета. По умолчанию `True`.
- `if_need_docx` (Optional[bool], optional): Флаг, указывающий на необходимость генерации DOCX-отчета. По умолчанию `True`.

**Возвращает**:
- None

**Как работает функция**:

1.  Функция сохраняет значения флагов `if_need_pdf` и `if_need_docx` в соответствующие атрибуты объекта. Это определяет, какие типы отчетов будут генерироваться при вызове метода `create_reports_async`.

**Примеры**:

```python
report_generator = ReportGenerator(if_need_pdf = True, if_need_docx = False)
print(report_generator.if_need_pdf, report_generator.if_need_docx)
# True, False
```

```python
report_generator = ReportGenerator(if_need_pdf = False)
print(report_generator.if_need_pdf, report_generator.if_need_docx)
# False, True
```

### `ReportGenerator.create_reports_async`

```python
async def create_reports_async(self,
                             bot: telebot.TeleBot,
                             chat_id: int,
                             data:dict,
                             lang:str,
                             mexiron_name:str,
                             ) -> tuple:
    """Create ALL types: HTML, PDF, DOCX"""
    ...
```

**Назначение**: Асинхронно создает отчеты во всех указанных форматах (HTML, PDF, DOCX) для заданного мехирона.

**Параметры**:

- `bot` (telebot.TeleBot): Объект бота Telebot для отправки уведомлений и отчетов.
- `chat_id` (int): ID чата в Telegram, куда будут отправляться уведомления и отчеты.
- `data` (dict): Данные для генерации отчетов.
- `lang` (str): Язык, на котором генерируются отчеты.
- `mexiron_name` (str): Имя мехирона, для которого генерируются отчеты.

**Возвращает**:

- `tuple`: Возвращает кортеж, содержащий результаты генерации отчетов.

**Как работает функция**:

1.  Устанавливает имя мехирона (`self.mexiron_name`) из переданного параметра.
2.  Определяет пути для сохранения HTML, PDF и DOCX файлов на основе имени мехирона и языка.
3.  Вызывает метод `create_html_report_async` для генерации HTML-контента.
4.  Если HTML-контент не создан, возвращает `False`.
5.  Если необходимо создать PDF-отчет (`self.if_need_pdf`), вызывает метод `create_pdf_report_async`.
6.  Если необходимо создать DOCX-отчет (`self.if_need_docx`), вызывает метод `create_pdf_report_async`.

```
create_reports_async
│
├───> Установить имя мехирона (mexiron_name)
│
├───> Определить пути сохранения (HTML, PDF, DOCX)
│
├───> create_html_report_async (Генерировать HTML)
│   │
│   └───> Если HTML создан?
│       │   └───> Да: Продолжить
│       │   └───> Нет: Вернуть False
│       │
│
├───> Если нужно PDF (if_need_pdf):
│   │   └───> create_pdf_report_async (Генерировать PDF)
│   │
│
├───> Если нужно DOCX (if_need_docx):
│   │   └───> create_pdf_report_async (Генерировать DOCX)
│   │
│
└───> Вернуть результат
```

### `ReportGenerator.service_apendix`

```python
 def service_apendix(self, lang:str) -> dict:
        return  {
                "product_id":"00000",
                "product_name":"Сервис" if lang == \'ru\' else "שירות",
                "specification":Path(__root__ / \'src\' / \'endpoints\' / ENDPOINT / \'report_generator\' / \'templates\' / f\'service_as_product_{lang}.html\').read_text(encoding=\'UTF-8\').replace(\'/n\',\'<br>\'),
                "image_local_saved_path":random_image(self.storage_path / \'converted_images\' )
                }
```

**Назначение**: Формирует словарь с данными для сервисного приложения, включая ID продукта, название, спецификацию и путь к изображению.

**Параметры**:

- `lang` (str): Язык, на котором формируется информация (русский или иврит).

**Возвращает**:

- `dict`: Словарь с данными для сервисного приложения.

**Как работает функция**:

1.  Определяет название продукта в зависимости от языка (`"Сервис"` для русского и `"שירות"` для иврита).
2.  Считывает спецификацию продукта из HTML-файла, расположенного в каталоге шаблонов. Заменяет символы новой строки (`\n`) на теги `<br>`, чтобы корректно отображать спецификацию в HTML.
3.  Генерирует случайное изображение с помощью функции `random_image` и получает путь к этому изображению.
4.  Формирует словарь, содержащий ID продукта, название продукта, спецификацию и путь к изображению.
5.  Возвращает сформированный словарь.

### `ReportGenerator.create_html_report_async`

```python
async def create_html_report_async(self, data:dict, lang:str, html_path:Optional[ str|Path] ) -> str | None:
    """
    Генерирует HTML-контент на основе шаблона и данных.

    Args:
        lang (str): Язык отчёта.

    Returns:
        str: HTML-контент.
    """
```

**Назначение**: Асинхронно генерирует HTML-контент для отчета на основе предоставленных данных и шаблона.

**Параметры**:

- `data` (dict): Данные, используемые для заполнения шаблона HTML.
- `lang` (str): Язык, на котором генерируется отчет.
- `html_path` (Optional[str | Path], optional): Путь для сохранения сгенерированного HTML-файла. Если не указан, используется путь по умолчанию.

**Возвращает**:

- `str | None`: HTML-контент в виде строки, если генерация прошла успешно, или `None` в случае ошибки.

**Как работает функция**:

1.  Устанавливает путь для сохранения HTML-файла, используя предоставленный путь, если он указан, или путь по умолчанию.
2.  Извлекает данные для сервисного приложения с помощью метода `service_apendix`.
3.  Добавляет данные сервисного приложения в общий набор данных для отчета.
4.  Определяет имя шаблона HTML в зависимости от языка отчета (`template_table_he.html` для иврита и `template_table_ru.html` для русского).
5.  Формирует путь к шаблону HTML.
6.  Считывает содержимое шаблона из файла.
7.  Создает объект шаблона Jinja2 из строки.
8.  Генерирует HTML-контент, объединяя шаблон и данные.
9.  Пытается сохранить HTML-контент в файл.
10. В случае успеха логирует информацию о сохранении файла и возвращает HTML-контент.
11. В случае ошибки логирует информацию об ошибке и возвращает `None`.

```
create_html_report_async
│
├───> Установить путь HTML (html_path)
│
├───> service_apendix (Получить данные сервисного приложения)
│
├───> Добавить сервисные данные в общие данные
│
├───> Определить имя шаблона (в зависимости от языка)
│
├───> Считать содержимое шаблона
│
├───> Создать объект шаблона Jinja2
│
├───> Сгенерировать HTML-контент
│
├───> Попытаться сохранить HTML в файл
│   │
│   ├───> Успех: Логировать, Вернуть HTML
│   │
│   └───> Ошибка: Логировать, Вернуть None
│
└───> Вернуть результат
```

### `ReportGenerator.create_pdf_report_async`

```python
async def create_pdf_report_async(self, 
                                data: dict, 
                                lang:str, 
                                pdf_path:str |Path) -> bool:
    """
    Полный цикл генерации отчёта.

    Args:
        lang (str): Язык отчёта.
    """
```

**Назначение**: Асинхронно генерирует PDF-отчет из предоставленного HTML-контента.

**Параметры**:

- `data` (dict): Данные для отчета (HTML-контент).
- `lang` (str): Язык отчета.
- `pdf_path` (str | Path): Путь для сохранения PDF-файла.

**Возвращает**:

- `bool`: `True`, если PDF-отчет успешно создан и отправлен (если указан бот), иначе `False`.

**Как работает функция**:

1.  Устанавливает путь для сохранения PDF-файла, используя предоставленный путь, если он указан, или путь по умолчанию.
2.  Устанавливает HTML-контент из входных данных или использует сохраненный HTML-контент объекта.
3.  Инициализирует объект `PDFUtils` для работы с PDF.
4.  Сохраняет PDF-файл с использованием метода `save_pdf_pdfkit` из `PDFUtils`.
5.  Если сохранение не удалось, логирует ошибку и отправляет сообщение об ошибке в Telegram, если объект бота указан.
6.  Если сохранение прошло успешно и указан объект бота, пытается отправить PDF-файл в Telegram.
7.  В случае успеха отправки возвращает `True`, в случае ошибки отправки отправляет сообщение об ошибке в Telegram и возвращает `False`.

```
create_pdf_report_async
│
├───> Установить путь PDF (pdf_path)
│
├───> Установить HTML-контент (из данных или объекта)
│
├───> Инициализировать PDFUtils
│
├───> Сохранить PDF с помощью save_pdf_pdfkit
│   │
│   ├───> Успех:
│   │   │   └───> Если есть бот:
│   │   │       │   ├───> Отправить PDF в Telegram
│   │   │       │   │   ├───> Успех: Вернуть True
│   │   │       │   │   └───> Ошибка: Отправить сообщение об ошибке, Вернуть False
│   │   │       │   └───> Если нет бота: Вернуть None
│   │   │
│   │   └───> Ошибка: Логировать ошибку, Отправить сообщение об ошибке (если есть бот), Вернуть False
│   │
└───> Вернуть результат
```

### `ReportGenerator.create_docx_report_async`

```python
async def create_docx_report_async(self, html_path:str|Path, docx_path:str|Path) -> bool :
    """Создаю docx файл """
```

**Назначение**: Асинхронно создает DOCX-файл из HTML-файла.

**Параметры**:

- `html_path` (str | Path): Путь к HTML-файлу.
- `docx_path` (str | Path): Путь для сохранения DOCX-файла.

**Возвращает**:

- `bool`: `True`, если DOCX-файл успешно создан, иначе `False`.

**Как работает функция**:

1.  Вызывает функцию `html_to_docx` для преобразования HTML-файла в DOCX-файл.
2.  Если преобразование не удалось, логирует ошибку и возвращает `False`.
3.  В случае успеха возвращает `True`.

## Функции

### `main`

```python
def main(maxiron_name:str, lang:str) ->bool:
    
    external_storage: Path =  gs.path.external_storage / ENDPOINT / 'mexironim' /  maxiron_name
    data: dict = j_loads(external_storage / f'{maxiron_name}_{lang}.json')
    html_path: Path =  external_storage / f'{maxiron_name}_{lang}.html' 
    pdf_path: Path = external_storage / f'{maxiron_name}_{lang}.pdf'
    docx_path: Path = external_storage / f'{maxiron_name}_{lang}.docx'
    if_need_html: bool = True
    if_need_pdf: bool = True
    if_need_docx: bool = True 
    r = ReportGenerator(if_need_html, if_need_pdf, if_need_docx, html_path, pdf_path, docx_path)

    asyncio.run( r.create_reports_async( data,
                                    maxiron_name,
                                    lang, 
                                    html_path, 
                                    pdf_path, 
                                    docx_path, )   
                )
```

**Назначение**: Главная функция модуля, которая координирует процесс генерации отчетов.

**Параметры**:

- `maxiron_name` (str): Имя мехирона, для которого генерируются отчеты.
- `lang` (str): Язык, на котором генерируются отчеты.

**Возвращает**:

- `bool`: Возвращает `True`, если процесс генерации отчетов завершился успешно, иначе `False`.

**Как работает функция**:

1.  Определяет путь к директории, где хранятся данные и отчеты для данного мехирона.
2.  Загружает данные из JSON-файла.
3.  Определяет пути для HTML, PDF и DOCX файлов.
4.  Создает экземпляр класса `ReportGenerator`.
5.  Запускает асинхронную операцию `create_reports_async` для генерации отчетов.

```
main
│
├───> Определить путь к данным (external_storage)
│
├───> Загрузить данные из JSON (j_loads)
│
├───> Определить пути файлов (HTML, PDF, DOCX)
│
├───> Создать экземпляр ReportGenerator
│
└───> Запустить асинхронную операцию create_reports_async