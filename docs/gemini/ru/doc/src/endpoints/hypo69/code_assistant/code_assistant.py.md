# Модуль для работы с ассистентом программиста
=================================================

Модуль содержит класс :class:`CodeAssistant`, который используется для взаимодействия с различными AI-моделями
(например, Google Gemini и OpenAI) и выполнения задач обработки кода.

Пример использования
----------------------

>>> assistant = CodeAssistant(role='code_checker', lang='ru', model=['gemini'])
>>> assistant.process_files()

## Обзор

Модуль `code_assistant.py` предназначен для обучения модели машинного обучения на основе кодовой базы,
создания документации к проекту, примеров кода и тестов. Он содержит класс `CodeAssistant`, который читает файлы кода,
передает код в модели, обрабатывает полученные результаты и сохраняет их в директории `docs/gemini`.
В зависимости от роли, файлы сохраняются в разные поддиректории.

## Подробнее

Модуль предоставляет функциональность для автоматической генерации документации, примеров кода и тестов с использованием AI-моделей.
Основной класс `CodeAssistant` инициализирует модели, отправляет им код, получает ответы и сохраняет результаты.
Конфигурация модуля загружается из файла `code_assistant.json`, что позволяет гибко настраивать параметры работы ассистента.
Документация генерируется в формате Markdown и сохраняется в соответствующих директориях.

## Классы

### `Config`

**Описание**: Класс `Config` предназначен для хранения и управления конфигурацией ассистента программиста.

**Принцип работы**:
Класс использует статические переменные для хранения конфигурационных параметров, таких как пути к файлам,
списки ролей и языков, а также параметры для доступа к моделям Gemini и OpenAI. Конфигурация загружается из файла `code_assistant.json`
и может быть переопределена через переменные окружения. Класс также предоставляет методы для чтения инструкций для кода и системы.

**Атрибуты**:
- `base_path` (Path): Базовый путь к директории `code_assistant`.
- `config` (SimpleNamespace): Объект, содержащий конфигурационные параметры, загруженные из `code_assistant.json`.
- `roles_list` (list): Список ролей.
- `languages_list` (list): Список языков.
- `role` (str): Роль по умолчанию (`doc_writer_md`).
- `lang` (str): Язык по умолчанию (`ru`).
- `process_dirs` (list[Path]): Список директорий для обработки.
- `exclude_dirs` (list[Path]): Список исключенных директорий.
- `exclude_files_patterns` (list[Path]): Список шаблонов исключенных файлов.
- `include_files_patterns` (list[Path]): Список шаблонов включаемых файлов.
- `exclude_files` (list[Path]): Список исключенных файлов.
- `response_mime_type` (str): MIME-тип ответа.
- `output_directory_patterns` (list): Список шаблонов выходных директорий.
- `gemini` (SimpleNamespace): Объект, содержащий параметры для доступа к модели Gemini.

**Методы**:
- `code_instruction`: Инструкция для кода. Читает файл с инструкцией при каждом вызове.
- `system_instruction`: Инструкция для модели. Читает файл с инструкцией при каждом вызове.

### `CodeAssistant`

**Описание**: Класс `CodeAssistant` предназначен для взаимодействия с моделями ИИ (например, Gemini и OpenAI)
с целью автоматической генерации документации, примеров кода и тестов.

**Принцип работы**:
Класс инициализирует модели ИИ, отправляет им код из файлов, получает ответы и сохраняет результаты в файлы.
Он использует конфигурацию, определенную в классе `Config`, для управления параметрами работы.
Класс также предоставляет методы для чтения файлов, создания запросов к моделям и сохранения ответов.

**Атрибуты**:
- `role` (str): Роль для выполнения задачи.
- `lang` (str): Язык выполнения.
- `gemini` (GoogleGenerativeAI): Экземпляр класса `GoogleGenerativeAI` для взаимодействия с моделью Gemini.
- `openai` (OpenAIModel): Экземпляр класса `OpenAIModel` для взаимодействия с моделью OpenAI.

**Методы**:
- `__init__`: Инициализация ассистента с заданными параметрами.
- `_initialize_models`: Инициализация моделей на основе заданных параметров.
- `send_file`: Отправка файла в модель.
- `process_files`: Компиляция, отправка запроса и сохранение результата.
- `_create_request`: Создание запроса с учетом роли и языка.
- `_yield_files_content`: Генерация путей файлов и их содержимого по указанным шаблонам.
- `_save_response`: Сохранение ответа модели в файл с добавлением суффикса.
- `_remove_outer_quotes`: Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.
- `run`: Запуск процесса обработки файлов.
- `_signal_handler`: Обработка прерывания выполнения.

## Функции

### `parse_args`

```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
    ...
```

**Назначение**: Разбирает аргументы командной строки, переданные при запуске скрипта.

**Параметры**:
- Нет.

**Возвращает**:
- `dict`: Словарь, содержащий аргументы командной строки и их значения.

**Как работает функция**:
1. Создает объект `ArgumentParser` для описания аргументов командной строки.
2. Добавляет аргументы `--role`, `--lang`, `--model`, `--start-dirs` и `--start-file-number` с описаниями и значениями по умолчанию.
3. Разбирает аргументы командной строки с помощью метода `parse_args()`.
4. Преобразует результат в словарь с помощью функции `vars()`.

```
Аргументы командной строки
│
└───> Создание парсера аргументов
│
└───> Определение аргументов (роль, язык, модель, директории, номер файла)
│
└───> Разбор аргументов
│
└───> Преобразование в словарь
│
Словарь аргументов
```

**Примеры**:

```python
# Запуск скрипта с аргументами командной строки
# python code_assistant.py --role doc_writer_md --lang ru --model gemini --start-dirs ./src --start-file-number 1
```

### `main`

```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
    ...
```

**Назначение**: Запускает бесконечный цикл обработки файлов с использованием различных ролей и языков, указанных в конфигурации.

**Параметры**:
- Нет.

**Возвращает**:
- `None`: Функция ничего не возвращает.

**Как работает функция**:
1. Входит в бесконечный цикл `while True`.
2. Для каждого языка и роли из `Config.languages_list` и `Config.roles_list` соответственно:
    - Устанавливает `Config.lang` и `Config.role`.
    - Создает экземпляр класса `CodeAssistant` с заданными параметрами.
    - Запускает процесс обработки файлов с помощью метода `process_files`.
3. Повторяет цикл, позволяя динамически изменять конфигурацию во время работы программы.

```
Бесконечный цикл
│
└───> Итерация по языкам из Config.languages_list
│   │
│   └───> Установка Config.lang
│   │
│   └───> Итерация по ролям из Config.roles_list
│       │
│       └───> Установка Config.role
│       │
│       └───> Создание экземпляра CodeAssistant с текущими ролью и языком
│       │
│       └───> Запуск обработки файлов (process_files) для созданного экземпляра
│
Повторение цикла
```

**Примеры**:

```python
# Запуск функции main
# python code_assistant.py
```
```python
from typing import Generator, Optional, List
from pathlib import Path


def read_text_file(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[List[str]] = None,
    chunk_size: int = 8192,
) -> Generator[str, None, None] | str | None:
    """
    Считывает содержимое файла (или файлов из каталога) с использованием генератора для экономии памяти.

    Args:
        file_path (str | Path): Путь к файлу или каталогу.
        as_list (bool): Если `True`, возвращает генератор строк.
        extensions (Optional[List[str]]): Список расширений файлов для чтения из каталога.
        chunk_size (int): Размер чанков для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или `None` в случае ошибки.

    Raises:
        Exception: Если возникает ошибка при чтении файла.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> content = read_text_file(file_path)
        >>> if content:
        ...    print(f'File content: {content[:100]}...')
        File content: Example text...
    """
    ...