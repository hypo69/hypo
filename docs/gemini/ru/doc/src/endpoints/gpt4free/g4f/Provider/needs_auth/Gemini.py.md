# Модуль Gemini для работы с Google Gemini API
## Обзор

Модуль `Gemini.py` предназначен для взаимодействия с API Google Gemini. Он предоставляет асинхронные функции для генерации текста, обработки изображений и выполнения других задач, связанных с Gemini API. Модуль поддерживает авторизацию через cookies, автоматическое обновление cookies и работу через прокси.

## Подробней

Этот модуль является частью проекта `hypotez` и обеспечивает интеграцию с Google Gemini API. Он использует асинхронные запросы для взаимодействия с API и предоставляет удобные методы для выполнения различных задач, таких как генерация текста, обработка изображений и т.д. Модуль предназначен для использования внутри проекта `hypotez` и обеспечивает необходимую функциональность для работы с Google Gemini API.

## Классы

### `Gemini`

**Описание**: Класс `Gemini` является основным классом для взаимодействия с Google Gemini API. Он наследует функциональность от `AsyncGeneratorProvider` и `ProviderModelMixin` и предоставляет методы для отправки запросов к API, обработки ответов и выполнения других задач.

**Принцип работы**:
1.  Инициализация класса с необходимыми параметрами, такими как модель, cookies и т.д.
2.  Авторизация через cookies или nodriver.
3.  Отправка запросов к API с использованием асинхронных методов.
4.  Обработка ответов от API и возврат результатов.

**Наследует**:

*   `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию ответов.
*   `ProviderModelMixin`: Предоставляет функциональность для работы с моделями.

**Аттрибуты**:

*   `label` (str): Метка провайдера (Google Gemini).
*   `url` (str): URL API Google Gemini.
*   `needs_auth` (bool): Требуется ли авторизация (True).
*   `working` (bool): Указывает, работает ли провайдер (True).
*   `use_nodriver` (bool): Использовать ли nodriver для авторизации (True).
*   `default_model` (str): Модель по умолчанию (пустая строка).
*    `default_image_model` (str): Модель для обработки изображений по умолчанию (пустая строка).
*   `default_vision_model` (str): Модель для обработки изображений и текста по умолчанию (пустая строка).
*   `image_models` (list): Список поддерживаемых моделей для обработки изображений.
*   `models` (list): Список поддерживаемых моделей.
*   `model_aliases` (dict): Алиасы моделей.
*   `synthesize_content_type` (str): Тип контента для синтеза речи (audio/vnd.wav).
*   `_cookies` (Cookies): Cookies для авторизации.
*   `_snlm0e` (str): Значение параметра `SNlM0e`, необходимого для запросов.
*   `_sid` (str): Значение параметра `SID`, необходимого для запросов.
*   `auto_refresh` (bool): Автоматически обновлять cookies (True).
*   `refresh_interval` (int): Интервал обновления cookies в секундах (540).
*   `rotate_tasks` (dict): Словарь для хранения задач обновления cookies.

**Методы**:

*   `nodriver_login(proxy: str = None) -> AsyncIterator[str]`: Асинхронный генератор для авторизации через nodriver.
*   `start_auto_refresh(proxy: str = None) -> None`: Запускает фоновую задачу для автоматического обновления cookies.
*   `create_async_generator(model: str, messages: Messages, proxy: str = None, cookies: Cookies = None, connector: BaseConnector = None, media: MediaListType = None, return_conversation: bool = False, conversation: Conversation = None, language: str = "en", **kwargs) -> AsyncResult`: Создает асинхронный генератор для отправки запросов к API.
*   `synthesize(params: dict, proxy: str = None) -> AsyncIterator[bytes]`: Асинхронный генератор для синтеза речи.
*   `build_request(prompt: str, language: str, conversation: Conversation = None, uploads: list[list[str, str]] = None, tools: list[list[str]] = []) -> list`: Строит запрос к API.
*   `upload_images(connector: BaseConnector, media: MediaListType) -> list`: Загружает изображения на сервер.
*   `fetch_snlm0e(session: ClientSession, cookies: Cookies)`: Получает значение параметра `SNlM0e` из cookies.

### `Conversation`

**Описание**: Класс `Conversation` представляет собой структуру данных для хранения информации о разговоре с Gemini API.

**Наследует**:

*   `JsonConversation`: базовый класс для представления истории разговора в формате JSON.

**Аттрибуты**:

*   `conversation_id` (str): Идентификатор разговора.
*   `response_id` (str): Идентификатор ответа.
*   `choice_id` (str): Идентификатор выбора.
*   `model` (str): Используемая модель.

## Функции

### `nodriver_login`

```python
@classmethod
async def nodriver_login(cls, proxy: str = None) -> AsyncIterator[str]:
    """
    Асинхронный генератор для авторизации через nodriver.

    Args:
        proxy (str, optional): Прокси для подключения. По умолчанию `None`.

    Yields:
        AsyncIterator[str]: Части ответа от сервера.

    Raises:
        ImportError: Если не установлен модуль `nodriver`.
    """
    ...
```

**Назначение**:
Функция `nodriver_login` выполняет авторизацию через `nodriver` для получения cookies, необходимых для работы с Gemini API.

**Как работает функция**:

1.  Проверяет, установлен ли модуль `nodriver`. Если нет, то пропускает авторизацию.
2.  Получает инстанс браузера и функцию для его остановки с помощью `get_nodriver`.
3.  Переходит на страницу авторизации Gemini API.
4.  Выполняет действия для авторизации, такие как ввод логина и пароля, если это необходимо.
5.  Извлекает cookies из браузера.
6.  Закрывает браузер.
7.  Возвращает cookies.

```ascii
    Проверка наличия nodriver
    │
    ├───►  Получение инстанса браузера и функции остановки
    │       │
    │       ├───►  Переход на страницу авторизации Gemini API
    │       │   │
    │       │   ├───►  Выполнение действий для авторизации
    │       │   │   │
    │       │   │   ├───►  Извлечение cookies из браузера
    │       │   │   │   │
    │       │   │   │   └───►  Закрытие браузера
    │       │   │   │       │
    │       │   │   │       └───►  Возврат cookies
    │       │   │   │
    │       │   │   └───►  Обработка ошибок авторизации
    │       │   │
    │       │   └───►  Возврат результата авторизации
    │       │
    │       └───►  Обработка ошибок при работе с браузером
    │
    └───►  Завершение
```

**Примеры**:

```python
async for chunk in Gemini.nodriver_login(proxy="http://proxy.example.com"):
    print(chunk)
```

### `start_auto_refresh`

```python
@classmethod
async def start_auto_refresh(cls, proxy: str = None) -> None:
    """
    Запускает фоновую задачу для автоматического обновления cookies.
    """
    ...
```

**Назначение**:
Функция `start_auto_refresh` запускает фоновую задачу, которая периодически обновляет cookies для Gemini API, чтобы сессия оставалась активной.

**Как работает функция**:

1.  Запускается бесконечный цикл.
2.  Внутри цикла вызывается функция `rotate_1psidts` для обновления cookies.
3.  Если обновление прошло успешно, новые cookies сохраняются.
4.  Если произошла ошибка при обновлении cookies, она логируется.
5.  Задача приостанавливается на `refresh_interval` секунд.

```ascii
    Запуск бесконечного цикла
    │
    ├──►  Вызов функции rotate_1psidts для обновления cookies
    │   │
    │   ├──►  Успешное обновление cookies
    │   │   │
    │   │   └──►  Сохранение новых cookies
    │   │
    │   └──►  Ошибка при обновлении cookies
    │       │
    │       └──►  Логирование ошибки
    │
    └──►  Приостановка задачи на refresh_interval секунд
    │
    └──►  Повтор цикла
```

**Примеры**:

```python
async def main():
    asyncio.create_task(Gemini.start_auto_refresh())
    await asyncio.sleep(600)  # Запустить на 10 минут

asyncio.run(main())
```

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    cookies: Cookies = None,
    connector: BaseConnector = None,
    media: MediaListType = None,
    return_conversation: bool = False,
    conversation: Conversation = None,
    language: str = "en",
    **kwargs
) -> AsyncResult:
    """
    Создает асинхронный генератор для отправки запросов к API.
    """
    ...
```

**Назначение**:
Функция `create_async_generator` создает асинхронный генератор, который отправляет запросы к Gemini API и возвращает ответы.

**Как работает функция**:

1.  Инициализирует cookies, если они не были переданы.
2.  Форматирует запрос на основе переданных сообщений.
3.  Создает сессию `ClientSession` с необходимыми заголовками и cookies.
4.  Получает значение параметра `SNlM0e`, если оно еще не было получено.
5.  Загружает изображения, если они были переданы.
6.  Отправляет запрос к API и обрабатывает ответ.
7.  Возвращает асинхронный генератор, который выдает части ответа.

```ascii
    Инициализация cookies
    │
    ├──►  Форматирование запроса
    │   │
    │   ├──►  Создание сессии ClientSession
    │   │   │
    │   │   ├──►  Получение значения параметра SNlM0e
    │   │   │   │
    │   │   │   ├──►  Загрузка изображений
    │   │   │   │   │
    │   │   │   │   ├──►  Отправка запроса к API
    │   │   │   │   │   │
    │   │   │   │   │   ├──►  Обработка ответа
    │   │   │   │   │   │   │
    │   │   │   │   │   │   └──►  Возврат асинхронного генератора
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Обработка ошибок
    │   │   │   │   │
    │   │   │   │   └──►  Обработка ошибок при загрузке изображений
    │   │   │   │
    │   │   │   └──►  Обработка ошибок при получении SNlM0e
    │   │   │
    │   │   └──►  Обработка ошибок при создании сессии
    │   │
    │   └──►  Обработка ошибок при форматировании запроса
    │
    └──►  Обработка ошибок при инициализации cookies
```

**Параметры**:

*   `model` (str): Используемая модель.
*   `messages` (Messages): Список сообщений для отправки.
*   `proxy` (str, optional): Прокси для подключения. По умолчанию `None`.
*   `cookies` (Cookies, optional): Cookies для авторизации. По умолчанию `None`.
*   `connector` (BaseConnector, optional): Коннектор для сессии. По умолчанию `None`.
*   `media` (MediaListType, optional): Список медиафайлов для отправки. По умолчанию `None`.
*   `return_conversation` (bool, optional): Возвращать ли информацию о разговоре. По умолчанию `False`.
*   `conversation` (Conversation, optional): Объект разговора. По умолчанию `None`.
*   `language` (str, optional): Язык ответа. По умолчанию "en".

**Возвращает**:

*   `AsyncResult`: Асинхронный генератор, выдающий части ответа.

**Вызывает исключения**:

*   `MissingAuthError`: Если отсутствует или недействителен cookie `__Secure-1PSID`.
*   `RuntimeError`: Если не удалось получить значение параметра `SNlM0e`.

**Примеры**:

```python
messages = [{"role": "user", "content": "Hello, Gemini!"}]
async for chunk in Gemini.create_async_generator(model="gemini-2.0-flash", messages=messages):
    print(chunk)
```

### `synthesize`

```python
@classmethod
async def synthesize(cls, params: dict, proxy: str = None) -> AsyncIterator[bytes]:
    """
    Асинхронный генератор для синтеза речи.
    """
    ...
```

**Назначение**:
Функция `synthesize` создает асинхронный генератор, который синтезирует речь на основе переданного текста.

**Как работает функция**:

1.  Проверяет наличие параметра `text` в переданных параметрах.
2.  Создает сессию `ClientSession` с необходимыми заголовками и cookies.
3.  Получает значение параметра `SNlM0e`, если оно еще не было получено.
4.  Формирует данные для запроса и отправляет запрос к API.
5.  Обрабатывает ответ и возвращает асинхронный генератор, который выдает части синтезированной речи.

```ascii
    Проверка наличия параметра text
    │
    ├──►  Создание сессии ClientSession
    │   │
    │   ├──►  Получение значения параметра SNlM0e
    │   │   │
    │   │   ├──►  Формирование данных для запроса
    │   │   │   │
    │   │   │   ├──►  Отправка запроса к API
    │   │   │   │   │
    │   │   │   │   ├──►  Обработка ответа
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Возврат асинхронного генератора
    │   │   │   │   │
    │   │   │   │   └──►  Обработка ошибок
    │   │   │   │
    │   │   │   └──►  Обработка ошибок при получении SNlM0e
    │   │   │
    │   │   └──►  Обработка ошибок при создании сессии
    │   │
    │   └──►  Обработка ошибок при отсутствии параметра text
    │
    └──►  Завершение
```

**Параметры**:

*   `params` (dict): Словарь с параметрами для синтеза речи. Обязательно должен содержать ключ `text` с текстом для синтеза.
*   `proxy` (str, optional): Прокси для подключения. По умолчанию `None`.

**Возвращает**:

*   `AsyncIterator[bytes]`: Асинхронный генератор, выдающий части синтезированной речи в формате `bytes`.

**Вызывает исключения**:

*   `ValueError`: Если отсутствует параметр `text` в переданных параметрах.

**Примеры**:

```python
params = {"text": "Hello, Gemini! Synthesize this."}
async for chunk in Gemini.synthesize(params):
    print(chunk)
```

### `build_request`

```python
def build_request(
    prompt: str,
    language: str,
    conversation: Conversation = None,
    uploads: list[list[str, str]] = None,
    tools: list[list[str]] = []
) -> list:
    """
    Строит запрос к API.
    """
    ...
```

**Назначение**:
Функция `build_request` строит запрос к Gemini API на основе переданных параметров.

**Как работает функция**:

1.  Формирует список изображений для загрузки, если они были переданы.
2.  Создает структуру запроса с использованием переданных параметров, таких как текст запроса, язык, информация о разговоре и список изображений.
3.  Возвращает структуру запроса.

```ascii
    Формирование списка изображений для загрузки
    │
    ├──►  Создание структуры запроса
    │   │
    │   ├──►  Добавление текста запроса
    │   │   │
    │   │   ├──►  Добавление языка
    │   │   │   │
    │   │   │   ├──►  Добавление информации о разговоре
    │   │   │   │   │
    │   │   │   │   ├──►  Добавление списка изображений
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Возврат структуры запроса
    │   │   │   │   │
    │   │   │   │   └──►  Обработка ошибок
    │   │   │   │
    │   │   │   └──►  Обработка ошибок
    │   │   │
    │   │   └──►  Обработка ошибок
    │   │
    │   └──►  Обработка ошибок
    │
    └──►  Завершение
```

**Параметры**:

*   `prompt` (str): Текст запроса.
*   `language` (str): Язык запроса.
*   `conversation` (Conversation, optional): Объект разговора. По умолчанию `None`.
*   `uploads` (list[list[str, str]], optional): Список изображений для загрузки. По умолчанию `None`.
*    `tools` (list[list[str]], optional): Список инструментов для использования. По умолчанию `[]`.

**Возвращает**:

*   `list`: Структура запроса в формате списка.

**Примеры**:

```python
prompt = "Hello, Gemini!"
language = "en"
request = Gemini.build_request(prompt, language)
print(request)
```

### `upload_images`

```python
async def upload_images(connector: BaseConnector, media: MediaListType) -> list:
    """
    Загружает изображения на сервер.
    """
    ...
```

**Назначение**:
Функция `upload_images` загружает изображения на сервер Gemini API.

**Как работает функция**:

1.  Определяет асинхронную функцию `upload_image`, которая загружает одно изображение.
2.  Внутри `upload_image` создается сессия `ClientSession` с необходимыми заголовками.
3.  Выполняется запрос `OPTIONS` к URL загрузки, чтобы получить URL для загрузки.
4.  Выполняется загрузка изображения на полученный URL.
5.  Возвращается URL загруженного изображения.
6.  Функция `upload_images` вызывает `upload_image` для каждого изображения в списке `media` и возвращает список URL загруженных изображений.

```ascii
    Определение асинхронной функции upload_image
    │
    ├──►  Создание сессии ClientSession
    │   │
    │   ├──►  Выполнение запроса OPTIONS
    │   │   │
    │   │   ├──►  Получение URL для загрузки
    │   │   │   │
    │   │   │   ├──►  Загрузка изображения на полученный URL
    │   │   │   │   │
    │   │   │   │   ├──►  Возврат URL загруженного изображения
    │   │   │   │   │
    │   │   │   │   └──►  Обработка ошибок
    │   │   │   │
    │   │   │   └──►  Обработка ошибок
    │   │   │
    │   │   └──►  Обработка ошибок
    │   │
    │   └──►  Обработка ошибок
    │
    └──►  Вызов upload_image для каждого изображения в списке media
    │
    └──►  Возврат списка URL загруженных изображений
```

**Параметры**:

*   `connector` (BaseConnector): Коннектор для сессии.
*   `media` (MediaListType): Список медиафайлов для загрузки.

**Возвращает**:

*   `list`: Список URL загруженных изображений.

**Примеры**:

```python
media = [("image1.jpg", b"image data 1"), ("image2.jpg", b"image data 2")]
urls = await Gemini.upload_images(connector, media)
print(urls)
```

### `fetch_snlm0e`

```python
@classmethod
async def fetch_snlm0e(cls, session: ClientSession, cookies: Cookies):
    """
    Получает значение параметра `SNlM0e` из cookies.
    """
    ...
```

**Назначение**:
Функция `fetch_snlm0e` получает значение параметра `SNlM0e`, необходимого для запросов к Gemini API.

**Как работает функция**:

1.  Выполняет GET-запрос к URL Gemini API.
2.  Извлекает значение параметра `SNlM0e` из ответа с использованием регулярного выражения.
3.  Сохраняет значение параметра `SNlM0e` в атрибуте класса `_snlm0e`.
4.  Извлекает значение параметра `FdrFJe` (sid) из ответа с использованием регулярного выражения.
5.  Сохраняет значение параметра `sid` в атрибуте класса `_sid`.

```ascii
    Выполнение GET-запроса к URL Gemini API
    │
    ├──►  Извлечение значения параметра SNlM0e из ответа
    │   │
    │   ├──►  Сохранение значения параметра SNlM0e в атрибуте класса _snlm0e
    │   │   │
    │   │   ├──►  Извлечение значения параметра FdrFJe (sid) из ответа
    │   │   │   │
    │   │   │   ├──►  Сохранение значения параметра sid в атрибуте класса _sid
    │   │   │   │   │
    │   │   │   │   └──►  Завершение
    │   │   │   │
    │   │   │   └──►  Обработка ошибок
    │   │   │
    │   │   └──►  Обработка ошибок
    │   │
    │   └──►  Обработка ошибок
    │
    └──►  Завершение
```

**Параметры**:

*   `session` (ClientSession): Сессия `aiohttp.ClientSession` для выполнения запросов.
*   `cookies` (Cookies): Cookies для авторизации.

**Примеры**:

```python
async with ClientSession() as session:
    await Gemini.fetch_snlm0e(session, cookies)
    print(Gemini._snlm0e)
```

### `iter_filter_base64`

```python
async def iter_filter_base64(chunks: AsyncIterator[bytes]) -> AsyncIterator[bytes]:
    """

    """
    ...
```

**Назначение**:
Функция `iter_filter_base64` фильтрует асинхронный итератор байтовых чанков, выделяя только те части, которые содержат данные в формате base64.

**Как работает функция**:

1.  Определяет байтовые строки `search_for` и `end_with`, которые используются для поиска начала и конца данных base64.
2.  Инициализирует флаг `is_started` в `False`, чтобы указать, что начало данных base64 еще не найдено.
3.  Перебирает чанки в асинхронном итераторе `chunks`.
4.  Если `is_started` равно `True`, то есть начало данных base64 уже найдено:
    *   Если `end_with` содержится в текущем чанке, то извлекает данные до `end_with`, возвращает их и завершает итерацию.
    *   В противном случае возвращает текущий чанк.
5.  Если `search_for` содержится в текущем чанке, то устанавливает `is_started` в `True`, извлекает данные после `search_for` и возвращает их.
6.  Если `search_for` не содержится в текущем чанке, то вызывает исключение `ValueError`.

```ascii
    Определение строк для поиска начала и конца данных base64
    │
    ├──►  Инициализация флага is_started в False
    │   │
    │   ├──►  Перебор чанков в асинхронном итераторе chunks
    │   │   │
    │   │   ├──►  Если is_started равно True
    │   │   │   │
    │   │   │   ├──►  Если end_with содержится в текущем чанке
    │   │   │   │   │
    │   │   │   │   ├──►  Извлечение данных до end_with
    │   │   │   │   │   │
    │   │   │   │   │   ├──►  Возврат данных
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Завершение итерации
    │   │   │   │   │
    │   │   │   │   └──►  В противном случае
    │   │   │   │       │
    │   │   │   │       └──►  Возврат текущего чанка
    │   │   │   │
    │   │   │   └──►  Если search_for содержится в текущем чанке
    │   │   │   │   │
    │   │   │   │   ├──►  Установка is_started в True
    │   │   │   │   │   │
    │   │   │   │   │   ├──►  Извлечение данных после search_for
    │   │   │   │   │   │   │
    │   │   │   │   │   │   └──►  Возврат данных
    │   │   │   │   │   │
    │   │   │   │   │   └──►  В противном случае
    │   │   │   │   │       │
    │   │   │   │   │       └──►  Вызов исключения ValueError
    │   │   │   │   │
    │   │   │   │   └──►  Завершение
    │   │   │   │
    │   │   │   └──►  Завершение
    │   │   │
    │   │   └──►  Завершение
    │   │
    │   └──►  Завершение
    │
    └──►  Завершение
```

**Параметры**:

*   `chunks` (AsyncIterator[bytes]): Асинхронный итератор байтовых чанков.

**Возвращает**:

*   `AsyncIterator[bytes]`: Асинхронный итератор отфильтрованных байтовых чанков.

**Вызывает исключения**:

*   `ValueError`: Если `search_for` не содержится в чанке.

**Примеры**:

```python
async def process_chunks(chunks: AsyncIterator[bytes]):
    async for chunk in chunks:
        print(chunk)

async def main():
    #  Пример использования с фиктивным асинхронным итератором
    async def fake_chunks():
        yield b'some data before [["wrb.fr","XqA3Ic","[\\\\"base64data\\\\"'
        yield b'more base64data\\\\end'
        yield b' the end'

    filtered_chunks = iter_filter_base64(fake_chunks())
    await process_chunks(filtered_chunks)

asyncio.run(main())
```

### `iter_base64_decode`

```python
async def iter_base64_decode(chunks: AsyncIterator[bytes]) -> AsyncIterator[bytes]:
    """

    """
    ...
```

**Назначение**:
Функция `iter_base64_decode` декодирует base64 данные из асинхронного итератора байтовых чанков.

**Как работает функция**:

1.  Инициализирует буфер `buffer` как пустую байтовую строку.
2.  Инициализирует `rest` как 0 для отслеживания остатка от деления длины чанка на 4 (необходимо для base64).
3.  Перебирает чанки в асинхронном итераторе `chunks`.
4.  Объединяет текущий чанк с содержимым буфера.
5.  Вычисляет остаток от деления длины объединенного чанка на 4.
6.  Обновляет буфер, сохраняя в нем последние `rest` байт объединенного чанка.
7.  Декодирует base64 данные из объединенного чанка, исключая последние `rest` байт.
8.  Возвращает декодированные данные.
9.  После завершения итерации, если `rest` больше 0, то добавляет необходимое количество символов `=` в буфер, чтобы длина была кратна 4, и декодирует base64 данные из буфера.

```ascii
    Инициализация буфера и остатка
    │
    ├──►  Перебор чанков в асинхронном итераторе chunks
    │   │
    │   ├──►  Объединение текущего чанка с буфером
    │   │   │
    │   │   ├──►  Вычисление остатка от деления длины чанка на 4
    │   │   │   │
    │   │   │   ├──►  Обновление буфера
    │   │   │   │   │
    │   │   │   │   ├──►  Декодирование base64 данных
    │   │   │   │   │   │
    │   │   │   │   │   ├──►  Возврат декодированных данных
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Обработка ошибок
    │   │   │   │   │
    │   │   │   │   └──►  Завершение
    │   │   │   │
    │   │   │   └──►  Завершение
    │   │   │
    │   │   └──►  Завершение
    │   │
    │   └──►  После завершения итерации
    │       │
    │       ├──►  Если rest больше 0
    │       │   │
    │       │   ├──►  Добавление символов "=" в буфер
    │       │   │   │
    │       │   │   ├──►  Декодирование base64 данных из буфера
    │       │   │   │   │
    │       │   │   │   ├──►  Возврат декодированных данных
    │   │   │   │   │   │
    │   │   │   │   │   └──►  Обработка ошибок
    │   │   │   │   │
    │   │   │   │   └──►  Завершение
    │       │   │
    │       │   └──►  Завершение
    │       │
    │       └──►  Завершение
    │
    └──►  Завершение
```

**Параметры**:

*   `chunks` (AsyncIterator[bytes]): Асинхронный итератор байтовых чанков.

**Возвращает**:

*   `AsyncIterator[bytes]`: Асинхронный итератор декодированных байтовых чанков.

**Примеры**:

```python
import base64

async def process_decoded_chunks(chunks: AsyncIterator[bytes]):
    async for chunk in chunks:
        print(chunk)

async def main():
    #  Пример использования с фиктивным асинхронным итератором
    async def fake_chunks():
        encoded_data = base64.b64encode(b"Hello, world!").decode()
        chunk_size = 10
        for i in range(0, len(encoded_data), chunk_size):
            yield encoded_data[i:i + chunk_size].encode()

    decoded_chunks = iter_base64_decode(fake_chunks())
    await process_decoded_chunks(decoded_chunks)

asyncio.run(main())
```

### `rotate_1psidts`

```python
async def rotate_1psidts(url, cookies: dict, proxy: str | None = None) -> str:
    """

    """
    ...
```

**Назначение**:
Функция `rotate_1psidts` обновляет cookie `__Secure-1PSIDTS`, чтобы поддерживать активную сессию с Gemini API.

**Как работает функция**:

1.  Формирует путь к файлу для кэширования cookie.
2.  Проверяет, не был ли файл кэша изменен в течение последней минуты, чтобы избежать ошибки `429 Too Many Requests`.
3.  Создает сессию `ClientSession` с использованием опционального прокси.
4.  Выполняет POST-запрос к URL `ROTATE_COOKIES_URL` с cookie и заголовками.
5.  Если получен статус `401`, вызывает исключение `MissingAuthError`.
6.  Обновляет cookie в словаре `cookies` на основе ответа.
7.  Извлекает новое значение `__Secure-1PSIDTS` из ответа.
8.  Записывает обновленные cookie в файл кэша в формате JSON.
9.  Возвращает новое значение `__Secure-1PSIDTS`.

```ascii
    Формирование пути к файлу для кэширования cookie
    │
    ├──►  Проверка времени изменения файла кэша
    │   │
    │   ├──►  Создание сессии ClientSession
    │   │   │
    │   │   ├──►  Выполнение POST-за