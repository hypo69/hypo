"""
<ROCKET>:
=================
Сложность: 4
-----------------
Ракетный симулятор. Игрок управляет ракетой, задавая угол наклона и начальную скорость, и пытается посадить ее на целевую площадку. Игра предоставляет обратную связь после каждой попытки, отображая траекторию полета и расстояние до цели.
Правила игры:
1. Игрок вводит угол наклона ракеты в градусах.
2. Игрок вводит начальную скорость ракеты.
3. Ракета летит, пока не достигнет земли (y = 0) или не пролетит слишком далеко (x > 200).
4. После каждой попытки выводится траектория полета ракеты в виде точек ".".
5. После каждой попытки выводится расстояние ракеты до целевой площадки.
6. Игрок повторяет попытки, пока не посадит ракету или не захочет выйти из игры.
-----------------
Алгоритм:
1. Инициализация: установить координаты цели target_x = 150, установить начальное значение y = 16. 
2. Цикл:
   2.1. Ввод: Запросить у пользователя угол наклона angle и начальную скорость velocity.
   2.2. Перевод угла angle в радианы angle_rad = angle * 0.01745.
   2.3. Инициализация: установить начальные координаты ракеты rocket_x = 0, rocket_y = 16.
   2.4. Цикл полета:
       2.4.1. Вычислить изменение координат x и y:
            delta_x = velocity * cos(angle_rad).
            delta_y = velocity * sin(angle_rad).
       2.4.2. Применить гравитацию: delta_y = delta_y - 1.
       2.4.3. Обновить координаты ракеты: rocket_x = rocket_x + delta_x, rocket_y = rocket_y + delta_y.
       2.4.4. Вывод: Вывести на экран текущую позицию ракеты в виде точки ".".
       2.4.5. Проверка:
            Если rocket_y <= 0, то выход из цикла полета.
            Если rocket_x > 200, то выход из цикла полета.
   2.5. Расчет расстояния до цели distance = abs(rocket_x - target_x).
   2.6. Вывод: Вывести расстояние до цели distance.
   2.7. Выбор: Если игрок ввел 0 градусов, то выход из основного цикла.
3. Конец игры.
-----------------
Блок-схема:
```mermaid
graph TD
    Start(Start) --> Init(Инициализация: target_x = 150, rocket_y = 16);
    Init --> Input(Ввод: angle, velocity);
    Input --> AngleToRadians(Преобразование angle в радианы);
    AngleToRadians --> InitRocket(Инициализация: rocket_x = 0, rocket_y = 16);
    InitRocket --> FlightLoopStart(Начало цикла полета);
    FlightLoopStart --> CalculateDelta(Вычисление: delta_x, delta_y);
    CalculateDelta --> ApplyGravity(Применение гравитации к delta_y);
    ApplyGravity --> UpdateRocketPosition(Обновление координат rocket_x, rocket_y);
    UpdateRocketPosition --> OutputRocketPosition(Вывод позиции ракеты ".");
    OutputRocketPosition --> CheckFlightEnd(Проверка: rocket_y <= 0 или rocket_x > 200);
    CheckFlightEnd -- Yes --> CalculateDistance(Расчет расстояния до цели);
    CheckFlightEnd -- No --> FlightLoopStart;
    CalculateDistance --> OutputDistance(Вывод расстояния до цели);
    OutputDistance --> CheckAngleZero(Проверка: angle = 0);
    CheckAngleZero -- Yes --> End(Конец);
    CheckAngleZero -- No --> Input;
    
```
"""
import math

def rocket_simulation():
    """
    Запускает симуляцию ракеты.
    """
    target_x = 150  # Координата цели по оси X
    rocket_y = 16   # Начальная высота ракеты
    
    while True:
        # Запрашиваем у пользователя угол наклона и начальную скорость
        angle = float(input("Введите угол наклона ракеты в градусах (0 для выхода): "))
        if angle == 0:
            print("Игра окончена.")
            break

        velocity = float(input("Введите начальную скорость ракеты: "))

        # Преобразуем угол в радианы
        angle_rad = angle * 0.01745

        rocket_x = 0  # Начальная координата X ракеты
        rocket_y = 16 # Начальная координата Y ракеты

        # Цикл полета ракеты
        while True:
            # Вычисляем изменения координат
            delta_x = velocity * math.cos(angle_rad)
            delta_y = velocity * math.sin(angle_rad)
            
            # Применяем гравитацию
            delta_y -= 1
            
            # Обновляем координаты ракеты
            rocket_x += delta_x
            rocket_y += delta_y
            
            # Выводим текущую позицию ракеты
            print(".", end="")

            # Проверяем условия окончания полета
            if rocket_y <= 0 or rocket_x > 200:
                break

        print()  # Переход на новую строку после завершения полета
        
        # Вычисляем расстояние до цели
        distance = abs(rocket_x - target_x)
        print(f"Расстояние до цели: {distance:.2f}")


if __name__ == "__main__":
    rocket_simulation()
"""
Пояснения:
1. **Импорт math:** Импортируем модуль math для использования функций sin и cos.

2. **Функция rocket_simulation():**
   - `target_x = 150`: Координата цели по оси X.
   - `rocket_y = 16`: Начальная высота ракеты.
   - **Основной цикл while True:** Позволяет игроку делать несколько запусков ракеты.
   - `angle = float(input(...))`: Запрашивает у пользователя угол наклона ракеты в градусах.
   - `if angle == 0:`: Условие для выхода из игры, если угол равен 0.
   - `velocity = float(input(...))`: Запрашивает у пользователя начальную скорость ракеты.
   - `angle_rad = angle * 0.01745`: Преобразует угол из градусов в радианы.
   - `rocket_x = 0`: Начальная координата X ракеты.
   - `rocket_y = 16`: Начальная координата Y ракеты.
   - **Цикл полета while True:** Моделирует полет ракеты.
   - `delta_x = velocity * math.cos(angle_rad)`: Вычисляет изменение координаты X.
   - `delta_y = velocity * math.sin(angle_rad)`: Вычисляет изменение координаты Y.
   - `delta_y -= 1`: Моделирует гравитацию, уменьшая скорость по вертикали.
   - `rocket_x += delta_x`: Обновляет координату X ракеты.
   - `rocket_y += delta_y`: Обновляет координату Y ракеты.
   - `print(".", end="")`: Выводит на экран точку, отмечающую положение ракеты.
   - **Проверка условий окончания полета:**
     - `if rocket_y <= 0 or rocket_x > 200`: Если ракета упала на землю или улетела слишком далеко, то выходим из цикла полета.
   - `print()`: Переход на новую строку после завершения полета.
   - `distance = abs(rocket_x - target_x)`: Вычисление расстояния до цели.
   - `print(f"Расстояние до цели: {distance:.2f}")`: Вывод расстояния до цели с точностью до двух знаков после запятой.

3. **if __name__ == "__main__":**  
   - `rocket_simulation()`: Запускает игру, когда скрипт выполняется напрямую.

licence:MIT(../licence)
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
```