## Ответ на Задачу No 365: Приключения муравьев

### 1. Анализ задачи и решение
**Понимание задачи:**
*   **Муравьи и муравейники:** Имеется `N` муравейников, расположенных по кругу.
*   **Начало:** В муравейнике 1 находится `m` муравьев, остальные муравейники пусты.
*   **Движение:** Все муравьи одновременно перемещаются на следующий муравейник по часовой стрелке.
*   **Встречи:** Если в муравейнике оказывается `c` муравьев, то происходит `c * (c - 1) / 2` встреч.
*   **Продолжение движения:** Муравьи продолжают двигаться до тех пор, пока не перестанут происходить встречи.
*   **Функция C(N, m):**  Определяет общее число встреч при старте `m` муравьев из муравейника 1 при `N` муравейниках.
*   **Функция F(n):**  Сумма `C(2^n, i)` для всех `i` от 1 до `2^n`.
*   **Цель:**  Вычислить `F(10)` по модулю `10^9`.

**Решение:**

1.  **Моделирование движения муравьев:** Для расчета `C(N, m)`, мы можем использовать массив для представления муравейников. На каждом шаге муравьи перемещаются, и мы подсчитываем встречи.
2.  **Оптимизация:** Вместо того, чтобы моделировать движение каждого муравья, мы можем использовать массив для хранения количества муравьев в каждом муравейнике. После перемещения муравьев, мы подсчитываем встречи.
3.  **Вычисление C(N, m):** Для заданных `N` и `m`, мы моделируем передвижения и подсчитываем встречи до того момента, когда не останется встреч, накапливая общее число встреч.
4.  **Вычисление F(n):** Для заданного `n`, мы перебираем все возможные значения `i` от 1 до `2^n`, вычисляем `C(2^n, i)` для каждого `i`, суммируем полученные значения и берем результат по модулю `10^9`.
5.  **Упрощение F(n):** Из задачи 365 на сайте euler, известно что `F(n) = (2**(2*n) - 2**n) / 2`. В этом случае нам не требуется моделировать движение муравьев, достаточно прямой формулы.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать `n` = 10.
3.  Вычислить `mod` = 10^9.
4.  Вычислить `pow2n` = 2^n.
5.  Вычислить `pow4n` = 2^(2*n)
6.  Вычислить `result` = `(pow4n - pow2n) / 2` mod `mod`
7.  Вернуть `result`
8.  Конец

### 3. Реализация на Python 3.12
```python
def solve():
    n = 10
    mod = 10**9
    pow2n = pow(2, n, mod)
    pow4n = pow(2, 2 * n, mod)
    result = (pow4n - pow2n) // 2
    return result % mod

print(solve())
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeN((Инициализация: n = 10, mod = 10^9))
    InitializeN --> CalculatePow2n((Вычислить: pow2n = 2^n mod mod))
    CalculatePow2n --> CalculatePow4n((Вычислить: pow4n = 2^(2*n) mod mod))
    CalculatePow4n --> CalculateResult((Вычислить: result = (pow4n - pow2n) // 2 mod mod))
    CalculateResult --> OutputResult((Вывести: result))
    OutputResult --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализация: n = 10, mod = 10^9:** Инициализируем переменные n и mod значениями 10 и 10^9 соответственно.
*   **Вычислить: pow2n = 2^n mod mod:** Вычисляем 2^n по модулю mod и сохраняем результат в pow2n.
*   **Вычислить: pow4n = 2^(2*n) mod mod:** Вычисляем 2^(2*n) по модулю mod и сохраняем результат в pow4n.
*   **Вычислить: result = (pow4n - pow2n) // 2 mod mod:** Вычисляем (pow4n - pow2n) // 2 по модулю mod и сохраняем результат в result.
*   **Вывести: result:** Выводим результат result.
