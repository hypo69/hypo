# Анализ кода модуля hmrabi

**Качество кода**

-  **Преимущества**
    - Код достаточно структурирован и логичен, следуя алгоритму игры.
    - Используются понятные имена переменных, что облегчает чтение кода.
    - Присутствуют комментарии, описывающие основные шаги игры.
    - Логика проверки ввода пользователя организована в циклах `while True` с обработкой ошибок `ValueError`.
    - Наличие подробного описания алгоритма и блок-схемы в начале файла помогает понять логику игры.
-  **Недостатки**
    - Отсутствует использование reStructuredText (RST) для комментариев и docstring.
    - Не используется `j_loads` или `j_loads_ns` из `src.utils.jjson`.
    - Нет обработки ошибок с помощью `logger.error`, используются стандартные блоки `try-except`.
    - Код не соответствует заданным требованиям по форматированию и стилю комментариев.

**Рекомендации по улучшению**

1.  **Форматирование комментариев:**
    - Переписать все комментарии в формате reStructuredText (RST).
    - Добавить docstring для модуля, функций и методов (если таковые будут).
2.  **Обработка ошибок:**
    - Использовать `logger.error` для обработки ошибок и исключить избыточное использование блоков `try-except`.
3.  **Использование `j_loads`:**
    - В данном коде нет работы с файлами, поэтому использование `j_loads` или `j_loads_ns` не требуется.
4.  **Логирование:**
    - Добавить логирование важных событий и ошибок с использованием `logger.debug` и `logger.error`.
5.  **Разделение на функции:**
    - Разбить код на более мелкие функции для повышения читаемости и возможности повторного использования. Например, можно выделить функции для запроса ввода пользователя, обновления игровых параметров, расчета урожая и т.д.

**Улучшенный код**

```python
"""
Модуль для реализации текстовой экономической игры "Хамурапи".
==============================================================

Игра "Хамурапи" - это текстовая экономическая игра, в которой игрок управляет древним городом,
пытаясь выжить и процветать в условиях ограниченных ресурсов.

Пример использования
--------------------

.. code-block:: python

    # Запуск игры
    if __name__ == '__main__':
        play_game()

"""
import random
from src.logger.logger import logger # Импорт модуля logger для логирования ошибок

def get_integer_input(prompt: str) -> int:
    """
    Запрашивает у пользователя целое число и обрабатывает исключение ValueError.

    :param prompt: Сообщение для пользователя.
    :return: Введенное пользователем целое число.
    """
    while True:
        try:
            return int(input(prompt)) # Запрашивает у пользователя ввод и преобразует в целое число
        except ValueError:
             logger.error('Введено некорректное значение, пожалуйста, введите целое число.')#  логирует ошибку ввода

def handle_land_trade(land: int, grain: int, land_price: int) -> tuple[int, int]:
    """
    Обрабатывает покупку или продажу земли.

    :param land: Текущее количество земли.
    :param grain: Текущее количество зерна.
    :param land_price: Цена за акр земли.
    :return: Обновленные значения земли и зерна.
    """
    while True:
        land_trade = get_integer_input("Сколько земли купить (+) или продать (-)? ") # Запрашивает у пользователя ввод для покупки/продажи земли
        if land_trade > 0 and grain < land_trade * land_price: # Проверяет, достаточно ли зерна для покупки земли
            logger.error('Недостаточно зерна для покупки земли.')# Логирует ошибку недостатка зерна
            continue
        if land_trade < 0 and land < abs(land_trade): # Проверяет, достаточно ли земли для продажи
            logger.error('Недостаточно земли для продажи.')# Логирует ошибку недостатка земли
            continue
        break # Выход из цикла, если ввод корректен

    land += land_trade # Обновляет количество земли
    grain -= land_trade * land_price # Обновляет количество зерна
    return land, grain # Возвращает обновленные значения земли и зерна

def handle_planting(grain: int) -> tuple[int, int]:
    """
    Обрабатывает посев зерна.

    :param grain: Текущее количество зерна.
    :return: Обновленное значение зерна и урожай.
    """
    while True:
        grain_to_plant = get_integer_input("Сколько зерна использовать для посева? ")# Запрашивает у пользователя ввод количества зерна для посева
        if grain < grain_to_plant: # Проверяет, достаточно ли зерна для посева
            logger.error('Недостаточно зерна для посева.') # Логирует ошибку недостатка зерна
            continue
        break # Выход из цикла, если ввод корректен
    yield_per_acre = random.randint(1, 8) # Вычисляет случайный урожай
    harvest = grain_to_plant * yield_per_acre # Вычисляет общий урожай
    grain += harvest # Добавляет урожай к запасу зерна
    return grain, harvest # Возвращает обновленное количество зерна и урожай

def handle_rats_damage(grain: int) -> int:
     """
     Рассчитывает и применяет ущерб от крыс.

     :param grain: Текущее количество зерна.
     :return: Обновленное количество зерна.
     """
     rats_damage = int(random.random() * 0.1 * grain)  # Вычисляет случайный ущерб от крыс
     grain -= rats_damage # Уменьшает количество зерна на величину ущерба
     print(f"Крысы съели {rats_damage} бушелей зерна.") # Выводит сообщение о количестве зерна съеденного крысами
     return grain # Возвращает обновленное количество зерна

def handle_feeding(population: int, grain: int) -> tuple[int, int]:
    """
    Обрабатывает кормление населения.

    :param population: Текущее количество населения.
    :param grain: Текущее количество зерна.
    :return: Обновленные значения населения и зерна.
    """
    grain_to_feed = get_integer_input("Сколько зерна отдать на пропитание? ") # Запрашивает у пользователя ввод количества зерна для пропитания
    if grain_to_feed >= population: # Проверяет, достаточно ли зерна для пропитания
        population = min(1000, int(population * 1.1)) # Увеличивает популяцию на 10%, но не более 1000
        grain -= grain_to_feed # Уменьшает количество зерна
        print("Все сыты, население растёт!") # Выводит сообщение о росте населения
    else:
        starved = int(population * (1 - grain_to_feed / population))# Рассчитывает число умерших от голода
        population -= starved # Уменьшает количество населения
        grain -= grain_to_feed # Уменьшает количество зерна
        print(f"{starved} человек умерло от голода.")# Выводит сообщение о количестве умерших от голода
        if population <= 0: # Проверяет, не умерло ли все население
            print("Вы проиграли, все население вымерло от голода!")# Выводит сообщение о проигрыше
    return population, grain # Возвращает обновленные значения населения и зерна

def play_game():
    """
    Основная функция игры "Хамурапи".
    """
    year = 0 # Текущий год
    population = 100 # Начальное население
    grain = 2800 # Начальное количество зерна
    land = 1000 # Начальная площадь земли

    print("Добро пожаловать в игру Хаммурапи!") # Выводит приветствие

    while year < 10 and population > 0: # Основной игровой цикл
        print(f"\nГод {year + 1}") # Выводит текущий год
        print(f"Население: {population}") # Выводит текущее население
        print(f"Зерно: {grain} бушелей") # Выводит текущее количество зерна
        print(f"Земля: {land} акров") # Выводит текущую площадь земли

        land_price = random.randint(15, 25) # Вычисляет случайную цену земли
        print(f"Цена земли: {land_price} бушелей за акр") # Выводит цену земли

        land, grain = handle_land_trade(land, grain, land_price) # Обрабатывает покупку/продажу земли
        grain, harvest = handle_planting(grain)  # Обрабатывает посев зерна
        grain = handle_rats_damage(grain) # Обрабатывает ущерб от крыс
        population, grain = handle_feeding(population, grain) # Обрабатывает кормление населения

        year += 1 # Увеличивает год на 1

    if year == 10: # Проверяет, прошло ли 10 лет
        print("Игра окончена. Прошло 10 лет.")# Выводит сообщение об окончании игры

if __name__ == '__main__':
    play_game() # Запускает игру
```
```
    """
    Объяснение кода:
    1. **Импорт модулей**:
        - `import random`: импортирует модуль `random` для генерации случайных чисел.
        - `from src.logger.logger import logger`: импортирует логгер из модуля `src.logger.logger` для логирования ошибок.

    2. **Функция `get_integer_input(prompt: str) -> int`**:
        - Запрашивает у пользователя ввод целого числа, обеспечивая корректный ввод.
        - `while True:`: бесконечный цикл, пока не будет введено корректное число.
        - `try...except ValueError`: обрабатывает ошибку, если пользователь введет не целое число.
        - `int(input(prompt))`: запрашивает ввод и преобразует его в целое число.
        - `logger.error('Введено некорректное значение, пожалуйста, введите целое число.')`: логирует ошибку ввода.

    3. **Функция `handle_land_trade(land: int, grain: int, land_price: int) -> tuple[int, int]`**:
        - Обрабатывает операции покупки и продажи земли.
        - `while True:`: бесконечный цикл для ввода корректных данных.
        - `land_trade = get_integer_input("Сколько земли купить (+) или продать (-)? ")`: запрашивает количество земли для покупки или продажи.
        - `if land_trade > 0 and grain < land_trade * land_price:`: проверяет достаточно ли зерна для покупки земли.
        - `if land_trade < 0 and land < abs(land_trade):`: проверяет достаточно ли земли для продажи.
        - `logger.error('Недостаточно зерна для покупки земли.')` и `logger.error('Недостаточно земли для продажи.')`: логируют ошибки.
        - `land += land_trade` и `grain -= land_trade * land_price`: обновляют значения земли и зерна.

    4. **Функция `handle_planting(grain: int) -> tuple[int, int]`**:
        - Обрабатывает посев зерна.
        - `while True:`: бесконечный цикл для ввода корректных данных.
        - `grain_to_plant = get_integer_input("Сколько зерна использовать для посева? ")`: запрашивает количество зерна для посева.
        - `if grain < grain_to_plant:`: проверяет достаточно ли зерна для посева.
        - `logger.error('Недостаточно зерна для посева.')`: логирует ошибку.
        - `yield_per_acre = random.randint(1, 8)`: генерирует случайный урожай.
        - `harvest = grain_to_plant * yield_per_acre`: вычисляет общий урожай.
        - `grain += harvest`: добавляет урожай к запасу зерна.

    5. **Функция `handle_rats_damage(grain: int) -> int`**:
       - Рассчитывает и применяет ущерб от крыс.
       - `rats_damage = int(random.random() * 0.1 * grain)`: вычисляет случайный ущерб от крыс.
       - `grain -= rats_damage`: уменьшает количество зерна на величину ущерба.
       - `print(f"Крысы съели {rats_damage} бушелей зерна.")`: выводит сообщение о количестве зерна, съеденном крысами.

    6. **Функция `handle_feeding(population: int, grain: int) -> tuple[int, int]`**:
        - Обрабатывает процесс кормления населения.
        - `grain_to_feed = get_integer_input("Сколько зерна отдать на пропитание? ")`: запрашивает количество зерна для пропитания.
        - `if grain_to_feed >= population:`: проверяет достаточно ли зерна для пропитания.
        - `population = min(1000, int(population * 1.1))`: увеличивает население на 10%, но не более 1000.
        - `grain -= grain_to_feed`: уменьшает количество зерна на величину отданного на пропитание.
        - `else:`: выполняется, если зерна недостаточно.
        - `starved = int(population * (1 - grain_to_feed / population))`: рассчитывает число умерших от голода.
        - `population -= starved`: уменьшает население на число умерших от голода.
        - `print(f"{starved} человек умерло от голода.")`: выводит сообщение о количестве умерших от голода.
        - `if population <= 0:`: проверяет, не умерло ли все население.
        - `print("Вы проиграли, все население вымерло от голода!")`: выводит сообщение о поражении.

    7. **Функция `play_game()`**:
        - Основная функция игры.
        - Инициализирует начальные значения: `year = 0`, `population = 100`, `grain = 2800`, `land = 1000`.
        - Выводит приветствие `print("Добро пожаловать в игру Хаммурапи!")`.
        - `while year < 10 and population > 0:`: основной цикл игры.
        - Выводит текущий год, население, количество зерна и земли.
        - `land_price = random.randint(15, 25)`: генерирует случайную цену земли.
        - Вызывает функции `handle_land_trade`, `handle_planting`, `handle_rats_damage` и `handle_feeding` для обработки игровых событий.
        - `year += 1`: увеличивает год на 1.
        - `if year == 10:`: проверяет, прошло ли 10 лет.
        - Выводит сообщение об окончании игры.

    8. **Условный запуск `if __name__ == '__main__':`**:
        - `play_game()`: вызывает функцию для запуска игры.
    """
```