# Модуль с утилитами для работы с Mega

## Обзор

Модуль содержит набор утилитных функций, используемых для выполнения различных операций, таких как преобразование данных, шифрование, дешифрование и кодирование/декодирование в формате Base64. Эти функции предназначены для работы с API Mega и обработки данных, передаваемых между клиентом и сервером.

## Подробней

Модуль предоставляет функции для преобразования данных между различными форматами (например, из массива 32-битных целых чисел в строку и обратно), шифрования и дешифрования данных с использованием AES в режиме CBC, а также кодирования и декодирования данных в формате Base64, совместимом с URL. Эти функции необходимы для безопасной и эффективной передачи данных при работе с API Mega.

## Функции

### `a32_to_str`

```python
def a32_to_str(a):
    """
    Преобразует массив 32-битных целых чисел в строку байтов.

    Args:
        a (list[int]): Массив 32-битных целых чисел.

    Returns:
        str: Строка байтов, полученная из массива целых чисел.

    Как работает функция:
        Функция `a32_to_str` принимает массив 32-битных целых чисел и преобразует его в строку байтов, используя формат '>dI', который указывает на упаковку каждого целого числа в 4 байта в сетевом порядке (big-endian).
    """
    ...
```

### `aes_cbc_encrypt`

```python
def aes_cbc_encrypt(data, key):
    """
    Шифрует данные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для шифрования.
        key (bytes): Ключ шифрования.

    Returns:
        bytes: Зашифрованные данные.

    Как работает функция:
        Функция `aes_cbc_encrypt` инициализирует объект шифрования AES в режиме CBC с заданным ключом и нулевым вектором инициализации (IV). Затем она шифрует входные данные с использованием этого объекта и возвращает зашифрованные данные.
    """
    ...
```

### `aes_cbc_encrypt_a32`

```python
def aes_cbc_encrypt_a32(data, key):
    """
    Шифрует данные, представленные в виде массива 32-битных целых чисел, с использованием AES в режиме CBC.

    Args:
        data (list[int]): Массив 32-битных целых чисел, представляющий данные для шифрования.
        key (list[int]): Массив 32-битных целых чисел, представляющий ключ шифрования.

    Returns:
        list[int]: Зашифрованные данные в виде массива 32-битных целых чисел.

    Как работает функция:
        1. Преобразует входные массивы `data` и `key` в строки байтов с помощью функции `a32_to_str`.
        2. Шифрует строку байтов `data` с помощью AES в режиме CBC с ключом `key`, используя функцию `aes_cbc_encrypt`.
        3. Преобразует зашифрованную строку байтов обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.
    """
    ...
```

### `str_to_a32`

```python
def str_to_a32(b):
    """
    Преобразует строку байтов в массив 32-битных целых чисел.

    Args:
        b (bytes): Строка байтов для преобразования.

    Returns:
        list[int]: Массив 32-битных целых чисел, полученный из строки байтов.

    Как работает функция:
        1. Проверяет, кратна ли длина входной строки 4. Если нет, добавляет нулевые байты для дополнения до кратной длины.
        2. Преобразует строку байтов в массив 32-битных целых чисел, используя формат '>dI', который указывает на распаковку каждых 4 байтов в одно целое число в сетевом порядке (big-endian).
    """
    ...
```

### `mpi2int`

```python
def mpi2int(s):
    """
    Преобразует строку, представляющую целое число в формате MPI (Multi-Precision Integer), в целое число Python.

    Args:
        s (bytes): Строка в формате MPI.

    Returns:
        int: Целое число, полученное из строки MPI.

    Как работает функция:
        Функция `mpi2int` принимает строку в формате MPI, удаляет первые два байта (которые содержат информацию о длине), преобразует оставшуюся часть строки в шестнадцатеричное представление и затем преобразует это шестнадцатеричное представление в целое число.
    """
    ...
```

### `aes_cbc_decrypt`

```python
def aes_cbc_decrypt(data, key):
    """
    Дешифрует данные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для дешифрования.
        key (bytes): Ключ дешифрования.

    Returns:
        bytes: Дешифрованные данные.

    Как работает функция:
        Функция `aes_cbc_decrypt` инициализирует объект дешифрования AES в режиме CBC с заданным ключом и нулевым вектором инициализации (IV). Затем она дешифрует входные данные с использованием этого объекта и возвращает дешифрованные данные.
    """
    ...
```

### `aes_cbc_decrypt_a32`

```python
def aes_cbc_decrypt_a32(data, key):
    """
    Дешифрует данные, представленные в виде массива 32-битных целых чисел, с использованием AES в режиме CBC.

    Args:
        data (list[int]): Массив 32-битных целых чисел, представляющий данные для дешифрования.
        key (list[int]): Массив 32-битных целых чисел, представляющий ключ дешифрования.

    Returns:
        list[int]: Дешифрованные данные в виде массива 32-битных целых чисел.

   Как работает функция:
        1. Преобразует входные массивы `data` и `key` в строки байтов с помощью функции `a32_to_str`.
        2. Дешифрует строку байтов `data` с помощью AES в режиме CBC с ключом `key`, используя функцию `aes_cbc_decrypt`.
        3. Преобразует дешифрованную строку байтов обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.
    """
    ...
```

### `base64urldecode`

```python
def base64urldecode(data):
    """
    Декодирует строку Base64, закодированную для использования в URL.

    Args:
        data (str): Строка Base64, закодированная для URL.

    Returns:
        bytes: Декодированные данные.

    Как работает функция:
        1. Дополняет строку `data` символами '=' до тех пор, пока длина строки не станет кратной 4.
        2. Заменяет символы '-', '_' и ',' на '+', '/' и '' соответственно.
        3. Декодирует полученную строку Base64 с помощью функции `base64.b64decode`.
    """
    ...
```

### `base64_to_a32`

```python
def base64_to_a32(s):
    """
    Декодирует строку Base64, закодированную для использования в URL, и преобразует результат в массив 32-битных целых чисел.

    Args:
        s (str): Строка Base64, закодированная для URL.

    Returns:
        list[int]: Массив 32-битных целых чисел, полученный из декодированной строки Base64.

    Как работает функция:
        1. Декодирует входную строку `s` из формата Base64, используя функцию `base64urldecode`.
        2. Преобразует полученную строку байтов в массив 32-битных целых чисел, используя функцию `str_to_a32`.
    """
    ...
```

### `base64urlencode`

```python
def base64urlencode(data):
    """
    Кодирует данные в строку Base64, пригодную для использования в URL.

    Args:
        data (bytes): Данные для кодирования.

    Returns:
        str: Строка Base64, закодированная для URL.

    Как работает функция:
        1. Кодирует входные данные `data` в формат Base64, используя функцию `base64.b64encode`.
        2. Декодирует полученную строку байтов в строку UTF-8.
        3. Заменяет символы '+', '/' и '=' на '-', '_' и '' соответственно.
    """
    ...
```

### `a32_to_base64`

```python
def a32_to_base64(a):
    """
    Преобразует массив 32-битных целых чисел в строку Base64, закодированную для использования в URL.

    Args:
        a (list[int]): Массив 32-битных целых чисел.

    Returns:
        str: Строка Base64, закодированная для URL.

    Как работает функция:
        1. Преобразует входной массив `a` в строку байтов с помощью функции `a32_to_str`.
        2. Кодирует полученную строку байтов в формат Base64, пригодный для использования в URL, с помощью функции `base64urlencode`.
    """
    ...
```

### `get_chunks`

```python
def get_chunks(size):
    """
    Разбивает размер файла на чанки разных размеров, чтобы оптимизировать процесс передачи данных.

    Args:
        size (int): Размер файла в байтах.

    Returns:
        dict: Словарь, где ключи - это начальные позиции чанков, а значения - их размеры.

    Как работает функция:
        Функция `get_chunks` разбивает размер файла на чанки разных размеров для оптимизации передачи данных.
        Функция сначала создает чанки размером, кратным 0x20000, пока это возможно.
        Затем создает чанки размером 0x100000, пока не достигнет конца файла.
        Оставшийся размер файла назначается последнему чанку.
        Возвращает словарь, содержащий начальные позиции и размеры чанков.
    """
    ...