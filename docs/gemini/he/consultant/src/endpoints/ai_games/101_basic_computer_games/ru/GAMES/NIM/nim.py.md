# Анализ кода модуля `nim.py`

**Качество кода**
-  Соответствие требованиям к формату кода (1-10): 8/10
    -  Преимущества:
        -   Код хорошо структурирован, функции и блоки разделены.
        -   Логика игры NIM реализована корректно.
        -   Используется `random` для инициализации кучек камней.
        -   Реализована проверка ввода пользователя.
        -   Присутствует достаточно подробное описание алгоритма и блок-схема в комментариях.
    -  Недостатки:
        -   Отсутствуют docstring в формате reStructuredText.
        -   Не используются `j_loads` или `j_loads_ns` из `src.utils.jjson` (хотя они не нужны в данном контексте).
        -   Отсутствует обработка ошибок с использованием `logger`.
        -   Комментарии после `#` недостаточно подробны и не всегда поясняют логику кода.

**Рекомендации по улучшению**
1. Добавить docstring в формате reStructuredText для всех функций и модуля.
2. Использовать `logger` для обработки ошибок вместо `print`.
3. Уточнить комментарии после `#`, сделав их более информативными и соответствующими стандарту RST.
4. Добавить проверку на пустые кучки перед запросом хода игрока.
5. Перенести логику вывода сообщения об ошибке ввода в отдельную функцию.
6. Использовать константы для значений игроков (например, `PLAYER1 = 1`, `PLAYER2 = 2`).

**Улучшенный код**
```python
"""
Модуль реализует игру NIM.
=========================================================================================

Игра "NIM" - это математическая игра для двух игроков. В начале игры есть несколько кучек камней (или других предметов).
Игроки по очереди берут любое количество камней из одной кучки. Выигрывает игрок, взявший последний камень.

Правила игры:
1. В начале игры есть несколько кучек камней, количество камней в каждой кучке задается.
2. Игроки по очереди берут любое ненулевое количество камней из одной кучки.
3. Игрок, который берет последний камень, выигрывает.

Пример использования:
--------------------

.. code-block:: python

    if __name__ == "__main__":
        play_nim()

"""
import random
from src.logger.logger import logger # Импорт логгера #
# Константы для игроков
PLAYER1 = 1
PLAYER2 = 2


def display_piles(piles: list):
    """
    Выводит текущее состояние кучек камней.

    :param piles: Список, представляющий кучки камней.
    :type piles: list
    """
    print("Текущее состояние кучек:")
    for i, pile in enumerate(piles):
        print(f"Кучка {i + 1}: {pile} камней")


def _validate_player_move(piles: list, pile_number: int, stones_to_remove: int, player: int) -> bool:
     """
     Проверяет корректность ввода игрока.

     :param piles: Список, представляющий кучки камней.
     :type piles: list
     :param pile_number: Номер выбранной кучки (индексация с 0).
     :type pile_number: int
     :param stones_to_remove: Количество камней, которые игрок хочет взять.
     :type stones_to_remove: int
     :param player: Номер текущего игрока.
     :type player: int
     :return: `True`, если ввод корректен, `False` в противном случае.
     :rtype: bool
     """
     if not (0 <= pile_number < len(piles)):
        logger.error(f"Недопустимый номер кучки. Игрок {player} выбрал несуществующую кучку.") # Логирование ошибки #
        print("Недопустимый номер кучки. Пожалуйста, выберите существующую кучку.")
        return False
     if not (0 < stones_to_remove <= piles[pile_number]):
         logger.error(f"Недопустимое количество камней. Игрок {player} выбрал {stones_to_remove} камней из кучки {pile_number + 1}, где есть {piles[pile_number]} камней.") # Логирование ошибки #
         print("Недопустимое количество камней. Пожалуйста, выберите значение от 1 до текущего количества в кучке.")
         return False
     return True

def get_player_move(piles: list, player: int) -> tuple[int, int]:
    """
    Запрашивает у игрока номер кучки и количество камней для удаления.

    :param piles: Список, представляющий кучки камней.
    :type piles: list
    :param player: Номер текущего игрока (1 или 2).
    :type player: int
    :return: Кортеж, содержащий номер кучки и количество камней для удаления.
    :rtype: tuple
    """
    while True:
        try:
            pile_number = int(input(f"Игрок {player}, выберите номер кучки (1-{len(piles)}): ")) - 1
            stones_to_remove = int(input(f"Игрок {player}, сколько камней взять из кучки {pile_number + 1}: "))
            if _validate_player_move(piles, pile_number, stones_to_remove, player):
                return pile_number, stones_to_remove
        except ValueError:
            logger.error(f"Неверный ввод от игрока {player}. Ожидается целое число.") # Логирование ошибки #
            print("Неверный ввод. Пожалуйста, введите целые числа.")

def play_nim():
    """
    Реализует игру NIM.
    """
    piles = [random.randint(1, 10), random.randint(1, 10), random.randint(1, 10)] # Инициализация кучек камней #
    current_player = 0  # 0 - игрок 1, 1 - игрок 2
    while sum(piles) > 0: # Игровой цикл пока есть камни в кучках #
        display_piles(piles) # Отображение текущего состояния кучек #
        pile_number, stones_to_remove = get_player_move(piles, current_player + 1) # Получение хода игрока #
        piles[pile_number] -= stones_to_remove # Вычитание выбранного количества камней из кучки #
        current_player = (current_player + 1) % 2  # Переключение игрока #
    print(f"Игрок {current_player + 1} победил!") # Вывод победителя #

if __name__ == "__main__":
    play_nim()
"""
Объяснение кода:

1.  **Импорт модуля `random` и `logger`**::
    -   `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел (количества камней в кучках).
    -   `from src.logger.logger import logger`: Импортирует логгер для записи ошибок.
2.  **Константы игроков**::
    -  `PLAYER1 = 1`, `PLAYER2 = 2`: Определяет константы для игроков.
3. **Функция `display_piles(piles)`**::
    -   Принимает список `piles`, представляющий кучки камней.
    -   Выводит на экран текущее состояние каждой кучки, используя `enumerate` для отображения номера кучки и количества камней в ней.
4.  **Функция `_validate_player_move(piles, pile_number, stones_to_remove, player)`**::
     -   Проверяет корректность ввода игрока, такого как номер кучки и количество камней.
     -   Возвращает `True`, если ввод корректен, иначе `False`.
     -   Использует `logger.error` для записи ошибок.
5.  **Функция `get_player_move(piles, player)`**::
    -   Запрашивает у текущего игрока `player` номер кучки и количество камней для удаления.
    -   Проверяет корректность ввода, вызывая `_validate_player_move`.
    -   Возвращает номер кучки (с индексом, начиная с 0) и количество камней для удаления.
    -   Использует `logger.error` для логирования ошибок.
6.  **Функция `play_nim()`**::
    -   Инициализирует три кучки камней случайными значениями от 1 до 10.
    -   `current_player = 0`: Устанавливает первого игрока (игрок 1).
    -   Основной игровой цикл `while sum(piles) > 0`: продолжается, пока есть камни в кучках.
    -   Вызывает `display_piles()` для отображения текущего состояния кучек.
    -   Вызывает `get_player_move()` для получения хода текущего игрока.
    -   Обновляет количество камней в выбранной кучке.
    -   Переключает игрока `current_player = (current_player + 1) % 2` (0 -> 1, 1 -> 0).
    -   После завершения цикла (когда все камни забраны) объявляет победителя.
7. **Запуск игры**::
    -   `if __name__ == "__main__":`:  Гарантирует, что игра запустится, только если скрипт запущен напрямую.
    -   `play_nim()`: Вызывает функцию для начала игры.
"""
```