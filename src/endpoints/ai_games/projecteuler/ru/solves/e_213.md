## Ответ на Задачу No 213: Игра с блохами

### 1. Анализ задачи и решение
**Понимание задачи:**
* Имеется доска 30x30 с 900 блохами, по одной на каждой клетке.
* Блохи совершают случайные прыжки вверх, вниз, влево или вправо.
* Нужно найти ожидаемое количество пустых клеток после 10000 прыжков.
* Это классическая задача, которая моделируется с использованием марковских цепей.

**Решение:**
1. **Представление доски:** Доска 30x30 может быть представлена как матрица. Каждая клетка может быть либо занята, либо пуста.
2. **Вероятность перехода:** Для каждой клетки (x, y) вероятность перехода на соседнюю клетку (x', y') зависит от количества соседних клеток, находящихся внутри доски.
3. **Итерационный процесс:** После каждого прыжка нужно обновлять состояние доски. Из-за большого количества прыжков и блох моделирование каждого отдельного прыжка нецелесообразно. Вместо этого мы будем отслеживать вероятность нахождения блохи в каждой клетке.
4. **Сходимость:** С ростом числа прыжков распределение блох по доске будет стремиться к стационарному, то есть, вероятность нахождения блохи в каждой клетке будет становиться постоянной. 
5. **Ожидаемое количество пустых клеток:**  Когда распределение станет стационарным, мы можем посчитать ожидаемое количество пустых клеток, используя вероятность нахождения блохи в каждой клетке.

**Анализ вероятностей:**
* Для внутренних клеток вероятность перемещения в любую из 4 соседних клеток равна 1/4.
* Для клеток на границе доски, вероятность будет зависеть от количества доступных для перемещения соседних клеток (2, 3 или 4). Например, для угловой клетки: вероятность остаться на месте будет 1/2 (т.к. у неё 2 соседа и есть "шанс" на каждый из 4-х прыжков), а вероятность переместиться в каждую из соседних клеток будет 1/4.
* Используя эти вероятности, можно определить вероятность распределения блох после каждого прыжка. При достаточно большом количестве итераций (прыжков) мы получим распределение, близкое к стационарному, из которого мы сможем рассчитать ожидаемое количество пустых клеток.

### 2. Алгоритм решения
1. **Инициализация:**
    - Создать матрицу `board_prob` 30x30 для хранения вероятности нахождения блохи в каждой клетке.
    - Изначально вероятность для каждой клетки равна 1/900.
2. **Итерация:** Выполнить заданное количество прыжков (10000).
    - Для каждого шага создать новую матрицу `new_board_prob` для временного хранения.
    - Для каждой клетки (x, y) на доске:
        - Определить количество соседних клеток, на которые можно прыгнуть (доступные_соседи).
        - Обновить вероятность `new_board_prob[x][y]`, добавляя вероятности из соседних клеток с учетом вероятности перехода в эту клетку.
        - Если клетка не на границе (4 соседа), то это `board_prob[x - 1][y] / 4 + board_prob[x + 1][y] / 4 + board_prob[x][y - 1] / 4 + board_prob[x][y + 1] / 4`
        - Для крайних клеток формулы будут другие, например, для угла `board_prob[x][y] / 2 + board_prob[x][y+1] / 4 + board_prob[x+1][y]/4`, или для стороны `board_prob[x][y] / 3 + board_prob[x+1][y] / 3 + board_prob[x][y-1]/3`. Тут важно учесть, что мы не уходим за пределы доски.
    - Скопировать `new_board_prob` в `board_prob` для следующей итерации.
3. **Ожидаемое количество пустых клеток:**
    - Инициализировать `empty_cells` = 0.
    - Для каждой клетки (x, y):
        - `empty_cells` += (1 - `board_prob[x][y]`)
4. **Возврат:** Вернуть `empty_cells`.

### 3. Реализация на Python 3.12
```python
def expected_empty_cells(board_size, num_steps):
    """
    Calculates the expected number of empty cells after a given number of steps.

    Args:
        board_size: The size of the board (e.g., 30 for a 30x30 board).
        num_steps: The number of steps (jumps).

    Returns:
        The expected number of empty cells.
    """

    board_prob = [[1 / (board_size * board_size) for _ in range(board_size)] for _ in range(board_size)]
    
    for _ in range(num_steps):
        new_board_prob = [[0 for _ in range(board_size)] for _ in range(board_size)]
        for x in range(board_size):
            for y in range(board_size):
                neighbors = []
                if x > 0:
                    neighbors.append((x - 1, y))
                if x < board_size - 1:
                    neighbors.append((x + 1, y))
                if y > 0:
                    neighbors.append((x, y - 1))
                if y < board_size - 1:
                    neighbors.append((x, y + 1))

                num_neighbors = len(neighbors)
                
                for nx, ny in neighbors:
                    new_board_prob[x][y] += board_prob[nx][ny] / 4 
                
                new_board_prob[x][y] +=  board_prob[x][y] * (1 - num_neighbors/4) if num_neighbors < 4 else 0

        board_prob = [row[:] for row in new_board_prob]

    empty_cells = 0
    for x in range(board_size):
      for y in range(board_size):
          empty_cells += (1 - board_prob[x][y])
          
    return empty_cells


board_size = 30
num_steps = 10000
result = expected_empty_cells(board_size, num_steps)
print(f"{result:.6f}")
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeBoardProb((Инициализировать board_prob: 1/900 для всех клеток))
    InitializeBoardProb --> LoopStepsStart((Начать цикл по num_steps))
    LoopStepsStart --> InitializeNewBoardProb((Инициализировать new_board_prob: 0 для всех клеток))
    InitializeNewBoardProb --> LoopCellsStart((Начать цикл по всем клеткам (x, y)))
    LoopCellsStart --> CalculateNeighbors((Вычислить соседей для клетки (x, y)))
    CalculateNeighbors --> UpdateNewBoardProb((Обновить new_board_prob[x][y] с учетом вероятностей соседей и вероятности остаться на месте))
    UpdateNewBoardProb --> LoopCellsEnd((Конец цикла по всем клеткам (x, y)))
     LoopCellsEnd --> UpdateBoardProb((board_prob = new_board_prob))
    UpdateBoardProb --> LoopStepsEnd((Конец цикла по num_steps))
    LoopStepsEnd --> CalculateEmptyCells((Рассчитать ожидаемое количество пустых клеток))
    CalculateEmptyCells --> Output((Вывести ожидаемое количество пустых клеток))
    Output --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать board_prob:** Создаем матрицу вероятностей и присваиваем каждой ячейке значение 1/900 (изначальное распределение).
* **Начать цикл по num_steps, Конец цикла по num_steps:** Запускаем цикл итераций для заданного количества прыжков.
* **Инициализировать new_board_prob:** Создаем новую матрицу вероятностей, чтобы хранить вероятности после одного шага прыжков.
* **Начать цикл по всем клеткам, Конец цикла по всем клеткам:** Цикл по всем клеткам доски.
* **Вычислить соседей для клетки (x, y):** Определяем доступные соседние клетки (верх, низ, лево, право), учитывая границы доски.
* **Обновить new_board_prob[x][y]:**  Обновляем вероятность нахождения блохи в текущей клетке, суммируя вероятности соседних клеток и учитывая вероятность не переместиться.
* **board_prob = new_board_prob:** Обновляем матрицу вероятностей для следующей итерации.
* **Рассчитать ожидаемое количество пустых клеток:**  Считаем количество пустых клеток, используя вероятности нахождения блох, то есть (1 - вероятность блохи в клетке).
* **Вывести ожидаемое количество пустых клеток:** Выводим результат (ожидаемое количество пустых клеток).
