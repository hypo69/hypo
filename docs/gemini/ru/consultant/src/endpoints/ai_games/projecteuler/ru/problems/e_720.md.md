# Анализ кода модуля e_720.md

**Качество кода**
8
- Плюсы
    - Код содержит описание задачи Project Euler.
    - Присутствуют условия задачи и примеры.
- Минусы
    - Отсутствует программный код.
    - Нет анализа сложности и оптимизаций.
    - Не хватает комментариев в формате reStructuredText (RST).

**Рекомендации по улучшению**

1.  Добавить программный код на Python, решающий задачу.
2.  Включить docstring в формате reStructuredText (RST) для всех функций.
3.  Использовать `logger.error` для обработки ошибок.
4.  Включить комментарии, объясняющие логику работы кода.
5.  Провести анализ сложности алгоритма и предложить варианты оптимизации.

**Оптимизированный код**

```python
"""
Модуль для решения задачи 720 Project Euler.
=========================================================================================

Задача заключается в вычислении G(n, k) mod 1,000,000,007, где G(n, k) - это сумма квадратов F(n, k, m)
для всех m от 1 до n, а F(n, k, m) - количество k-элементных размещений с повторениями из набора n элементов,
где m - наибольшее значение в размещении.

Пример использования
--------------------

.. code-block:: python

   result = calculate_g(10**7, 10**12)
   print(result)
"""
from src.logger.logger import logger

MOD = 1000000007


def power(base: int, exp: int) -> int:
    """
    Вычисляет base в степени exp по модулю MOD.

    :param base: Основание.
    :param exp: Показатель степени.
    :return: Результат вычисления (base^exp) % MOD.
    """
    res = 1
    base %= MOD
    while exp > 0:
        # проверка, является ли exp нечетным
        if exp % 2 == 1:
            res = (res * base) % MOD
        base = (base * base) % MOD
        exp //= 2
    return res


def calculate_f(n: int, k: int, m: int) -> int:
    """
    Вычисляет F(n, k, m) - количество k-элементных размещений с повторениями из набора n элементов,
    где m - наибольшее значение.

    :param n: Количество элементов в наборе.
    :param k: Длина размещения.
    :param m: Наибольшее значение в размещении.
    :return: Количество размещений F(n, k, m).
    """
    # Код вычисляет (m^k - (m-1)^k) % MOD
    return (power(m, k) - power(m - 1, k) + MOD) % MOD


def calculate_g(n: int, k: int) -> int:
    """
    Вычисляет G(n, k) = Σ(F(n, k, m)^2) для всех m от 1 до n по модулю MOD.

    :param n: Количество элементов в наборе.
    :param k: Длина размещения.
    :return: Результат G(n, k) % MOD.
    """
    result = 0
    for m in range(1, n + 1):
        # Код вычисляет F(n, k, m) и суммирует их квадраты
        f_value = calculate_f(n, k, m)
        result = (result + (f_value * f_value) % MOD) % MOD
    return result


if __name__ == '__main__':
    try:
        # Код выполняет расчет G(10**7, 10**12) и выводит результат.
        result = calculate_g(10**7, 10**12)
        print(f'G(10^7, 10^12) mod 1,000,000,007 = {result}')
    except Exception as e:
        # Код логирует ошибку в случае возникновения исключения
        logger.error(f"Произошла ошибка: {e}")

```