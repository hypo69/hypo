## Ответ на Задачу No 371: Поездка по автомагистрали

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Имеется бесконечная автомагистраль с N выходами. Мы начинаем с позиции 0.
*   Цель - достичь выхода N.
*   Каждый шаг - бросок кубика. Выпадение 1-5 продвигает нас на 1 выход, 6 возвращает в 0.
*   E(N) - ожидаемое количество бросков для достижения выхода N.
*   Необходимо найти E(10000) с точностью до 10 знаков после запятой.

**Решение:**

Пусть `e(i)` — это ожидаемое количество бросков, чтобы достичь выхода `i`.
*   `e(0) = 0`, так как мы уже находимся в начальной точке.
*   Чтобы достичь выхода 1, с вероятностью `5/6` мы продвинемся на 1 шаг и с вероятностью `1/6` вернемся в начало. То есть `e(1) = 1 + (1/6) * e(0) + (5/6) * 0 = 6/5 + 1 * 1/6 *e(1)
*   Вывод: `e(1) = 1 / (5/6) = 6/5 = 1.2`.
*   Чтобы достичь выхода 2, сначала нужно достичь выхода 1. Оттуда мы имеем ту же вероятность продвинуться на один шаг или вернуться в начало. То есть `e(2) = e(1) + (1/6) * (e(2) + 1) + (5/6) * 1`
*   `e(2) = e(1) + 1/6e(2)+1/6 + 5/6`
*   `5/6e(2)=e(1) + 1`
*   `e(2) = 6/5 * e(1) + 6/5`
    
*   В общем виде, чтобы достичь выхода `i`, нужно сначала достичь выхода `i-1`, а оттуда либо продвинуться на следующий выход (с вероятностью 5/6) либо вернуться в начало (с вероятностью 1/6).
*  Следовательно,  `e(i) = e(i-1) + 1  + (1/6) * e(i)`.
*  `5/6 * e(i) = e(i-1) + 1`
*  `e(i) = (6/5) * (e(i-1) + 1)`

Имеем рекуррентное соотношение: `e(i) = (6/5) * (e(i-1) + 1)`. Для нахождения E(10000) мы можем итеративно вычислять E(i), начиная с E(0) = 0.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать `expected_moves[0]` = 0
3.  Для каждого `i` от 1 до 10000:
    *   Вычислить `expected_moves[i]` = (6/5) * (`expected_moves[i-1]` + 1)
4.  Вернуть `expected_moves[10000]`
5.  Конец

### 3. Реализация на Python 3.12
```python
def calculate_expected_moves(target_exit):
  """
    Calculates the expected number of dice rolls to reach a target exit.

    Args:
      target_exit: The number of the target exit (N).

    Returns:
        The expected number of rolls E(N), rounded to 10 decimal places.
  """
  expected_moves = [0.0] * (target_exit + 1)

  for i in range(1, target_exit + 1):
      expected_moves[i] = (6/5) * (expected_moves[i-1] + 1)
  
  return round(expected_moves[target_exit], 10)


# Пример использования:
target = 10000
result = calculate_expected_moves(target)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeArray((Инициализировать массив expected_moves[0] = 0))
    InitializeArray --> LoopStart((Начать цикл: i от 1 до 10000))
    LoopStart --> CalculateExpected((Вычислить: expected_moves[i] = (6/5) * (expected_moves[i-1] + 1)))
    CalculateExpected --> LoopStart
    LoopStart --> ReturnResult((Вернуть: expected_moves[10000]))
    ReturnResult --> End((Конец))
```

**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать массив:** Создаем массив для хранения ожидаемых значений и инициализируем первый элемент нулем.
*   **Начать цикл:** Определяем начало цикла для вычисления ожидаемых значений до 10000.
*   **Вычислить:** Вычисляем ожидаемое число бросков для текущего выхода используя рекуррентную формулу.
*   **Вернуть:** Возвращаем конечное значение, которое соответствует ожидаемым броскам для выхода 10000.
