## Ответ на Задачу No 310: Игра в ним с кучами

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Игра Ним с кучами: Есть *n* куч камней, игроки по очереди убирают любое ненулевое количество камней из любой кучи. Проигрывает тот, кто убирает последний камень.
*   Функция *f(n)*: Количество начальных позиций с *n* кучами, где размер каждой кучи не превышает *n*, при которых первый игрок (Алиса) выигрывает.
*   Необходимо найти *f(10<sup>7</sup>)* по модулю 1234567891011.

**Решение:**

1.  **Выигрышные позиции в Ниме:** В игре Ним выигрышная позиция для первого игрока - это когда XOR сумма всех куч *не равна* 0. Проигрышная позиция (для первого игрока) - когда XOR сумма равна 0.
2.  **Подсчет выигрышных позиций:** Для каждого *n*, нам нужно посчитать количество наборов куч, где размер каждой кучи от 0 до *n*, таких что XOR сумма этих куч не равна 0. Проще посчитать проигрышные позиции (с XOR суммой 0) и вычесть их из общего количества комбинаций. Общее количество комбинаций - это (*n* + 1)^*n* (где (*n* + 1) это количество камней в одной куче и *n* - количество куч). 
3. **Работа с большими n**: Для больших *n*, прямое вычисление с циклом будет очень медленным. Тут нам надо понять, что количество проигрышных позиций с XOR суммой 0 можно посчитать с помощью рекуррентного соотношения. 
4.  **Рекуррентное соотношение**: Обозначим количество проигрышных позиций с *n* кучами как *g(n)*. Пусть у нас уже есть *g(n - 1)*. Тогда, чтобы создать новую проигрышную позицию с *n* кучами, мы можем добавить к любой проигрышной позиции с *n - 1* кучами новую кучу так, чтобы XOR сумма осталась равной 0. Это достигается путем добавления кучи с числом камней равным XOR сумме уже имеющихся куч. Для каждой проигрышной позиции для *n-1* куч, существует ровно 1 куча которую можно добавить, чтобы получилась проигрышная позиция для *n* куч.
5. **Базовый случай:** g(0) = 1, поскольку пустой набор куч имеет XOR сумму 0.
6. **Вычисление f(n):**
   *  Количество всех возможных позиций равно (n + 1)^n.
   *  Количество проигрышных позиций равно g(n).
   *  Тогда f(n) = (n+1)^n - g(n)

**Уточнения и оптимизации:**

*   Нам нужно вычислять по модулю 1234567891011, используем быстрое возведение в степень по модулю для (n+1)^n.
*   Надо использовать динамическое программирование для вычисления g(n).

### 2. Алгоритм решения

1.  **Начать.**
2.  **Инициализация:**
    *   `modulo` = 1234567891011
    *   `max_n` = 10<sup>7</sup>
    *   `lose_positions` -  массив для хранения проигрышных позиций g(n).
    *   `lose_positions[0]` = 1
3.  **Цикл по n от 1 до max_n:**
    *   `lose_positions[n]` =  (lose_positions[n-1] * (n+1) ) % modulo
4.  **Вычислить f(max_n):**
    *   `total_positions` = (max_n + 1)<sup>max_n</sup> по модулю `modulo`
    *  `win_positions` =  (total_positions - lose_positions[max_n]) % modulo
5.  **Возвратить `win_positions`**
6.  **Конец.**

### 3. Реализация на Python 3.12

```python
def fast_power(base, power, mod):
    """Calculates (base^power) % mod efficiently."""
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        power //= 2
    return result

def solve():
    modulo = 1234567891011
    max_n = 10**7
    lose_positions = [0] * (max_n + 1)
    lose_positions[0] = 1
    
    for n in range(1, max_n + 1):
      lose_positions[n] = (lose_positions[n-1] * (n + 1) ) % modulo

    total_positions = fast_power(max_n + 1, max_n, modulo)
    win_positions = (total_positions - lose_positions[max_n]) % modulo

    print(win_positions)

solve()
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeVars((Инициализация: modulo, max_n, lose_positions))
    InitializeVars --> SetBaseCase((lose_positions[0] = 1))
    SetBaseCase --> LoopStart((Начать цикл: n от 1 до max_n))
    LoopStart --> CalculateLosePositions((lose_positions[n] = (lose_positions[n-1] * (n+1)) % modulo))
    CalculateLosePositions --> LoopStart
    LoopStart -- Цикл завершен --> CalculateTotalPositions((total_positions = (max_n + 1)^max_n % modulo))
    CalculateTotalPositions --> CalculateWinPositions((win_positions = (total_positions - lose_positions[max_n]) % modulo))
    CalculateWinPositions --> OutputResult((Вывести win_positions))
    OutputResult --> End((Конец))
```

**Legenda:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализация:** Задаем значения  `modulo`, `max_n` и  массив для хранения проигрышных позиций `lose_positions`.
*   **lose_positions[0] = 1:** Устанавливаем базовый случай, что 0 куч имеют 1 проигрышную позицию.
*   **Начать цикл, Конец цикла:** Определяет начало и конец цикла для расчета количества проигрышных позиций для каждой кучи.
*   **lose_positions[n] = (lose_positions[n-1] * (n+1)) % modulo:** Расчитываем количество проигрышных позиций для n куч.
*   **total_positions = (max_n + 1)^max_n % modulo:** Вычисляем общее количество позиций.
*   **win_positions = (total_positions - lose_positions[max_n]) % modulo:** Вычисляем количество выигрышных позиций.
*   **Вывести win_positions:** Выводим результат.
