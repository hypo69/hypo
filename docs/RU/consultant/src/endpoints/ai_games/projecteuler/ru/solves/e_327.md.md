# Анализ кода модуля e_327.md

**Качество кода**
8
- Плюсы
    - Код предоставляет реализацию решения задачи Project Euler 327, включая анализ, алгоритм и реализацию на Python.
    - Присутствует блок-схема алгоритма в формате Mermaid.
    - Используется оптимизированная проверка на простоту числа.
- Минусы
    - Отсутствуют docstring для функций и комментарии в формате reStructuredText.
    - Жестко заданный размер массива `probabilities`.
    - Нет обработки исключений или логирования.
    - Отсутствуют импорты из `src.utils.jjson` и `src.logger.logger`.

**Рекомендации по улучшению**
1.  Добавить docstring к функциям, описывая их назначение, параметры и возвращаемые значения в формате reStructuredText.
2.  Импортировать и использовать `logger` из `src.logger.logger` для логирования ошибок.
3.  Обработать возможные ошибки с помощью `try-except` или `logger.error` в функции `calculate_expected_value`.
4.  Удалить жестко заданный размер массива `probabilities` и сделать его динамическим или пересмотреть начальный размер.
5.  Добавить комментарии в формате RST к каждой строке, поясняя логику кода.
6.  Удалить лишние комментарии.

**Оптимизированный код**
```python
"""
Модуль для решения задачи Project Euler 327: Счастливые ящики
=========================================================================================

Этот модуль содержит функции для расчета математического ожидания количества счастливых ящиков
после заданного количества раундов.

Пример использования
--------------------

Пример использования функции calculate_expected_value:

.. code-block:: python

    num_boxes = 10**7
    num_rounds = 10**7
    expected_value = calculate_expected_value(num_boxes, num_rounds)
    print(f"{expected_value:.10f}")
"""
import math
from src.logger.logger import logger # импортируется logger для логирования ошибок

def is_prime(n: int) -> bool:
    """
    Проверяет, является ли число простым.

    :param n: Число для проверки.
    :return: True, если число простое, False в противном случае.
    """
    # Проверяется, если n меньше или равно 1, то это не простое число
    if n <= 1:
        return False
    # Проверяется, если n меньше или равно 3, то это простое число
    if n <= 3:
        return True
    # Проверяется, если n делится на 2 или 3, то это не простое число
    if n % 2 == 0 or n % 3 == 0:
        return False
    # Инициализируется переменная i для проверки делителей
    i = 5
    # Цикл выполняется, пока квадрат i меньше или равен n
    while i * i <= n:
        # Проверяется, делится ли n на i или i + 2
        if n % i == 0 or n % (i + 2) == 0:
            return False
        # Увеличивается i на 6
        i += 6
    # Если не найдено ни одного делителя, то число простое
    return True

def calculate_expected_value(num_boxes: int, num_rounds: int) -> float:
    """
    Вычисляет математическое ожидание количества счастливых ящиков.

    :param num_boxes: Количество ящиков.
    :param num_rounds: Количество раундов.
    :return: Математическое ожидание количества счастливых ящиков.
    """
    # Инициализируется массив вероятностей, начальный размер 1000
    probabilities = [0.0] * 1000
    # Устанавливается начальная вероятность 1 для 1 шара
    probabilities[1] = 1.0
    
    # Цикл для каждого раунда
    for _ in range(num_rounds):
        # Инициализируется новый массив вероятностей
        new_probabilities = [0.0] * len(probabilities)
        # Цикл для каждого количества шаров и вероятности
        for num_balls, probability in enumerate(probabilities):
            # Проверяется, что вероятность больше 0
            if probability > 0:
               # Вычисляется вероятность, что шар не вынут
               probability_no_remove = (1 - 1 / num_boxes)
               # Вычисляется вероятность, что шар вынут
               probability_remove = 1 / num_boxes
               # Проверяется, не выходит ли индекс за границы массива
               if num_balls * 2 - 1 < len(new_probabilities):
                   # Обновляется вероятность для num_balls * 2 - 1
                   new_probabilities[num_balls * 2 - 1] += probability * probability_remove
               # Проверяется, не выходит ли индекс за границы массива
               if num_balls * 2 < len(new_probabilities):
                   # Обновляется вероятность для num_balls * 2
                   new_probabilities[num_balls * 2] += probability * probability_no_remove
        # Присваивается новый массив вероятностей
        probabilities = new_probabilities
    
    # Инициализируется математическое ожидание
    expected_value = 0.0
    # Цикл для каждого количества шаров и вероятности
    for num_balls, probability in enumerate(probabilities):
        # Проверяется, является ли количество шаров простым числом
        if is_prime(num_balls):
            # Увеличивается математическое ожидание
            expected_value += probability

    # Возвращается математическое ожидание, умноженное на количество ящиков
    return expected_value * num_boxes

# Устанавливается количество ящиков
num_boxes = 10**7
# Устанавливается количество раундов
num_rounds = 10**7
# Вычисляется математическое ожидание
try:
    expected_value = calculate_expected_value(num_boxes, num_rounds)
    # Выводится математическое ожидание с 10 знаками после запятой
    print(f"{expected_value:.10f}")
except Exception as e:
    logger.error(f'Произошла ошибка при вычислении математического ожидания: {e}')
```