```markdown
# js-tokens

[![Build Status](https://travis-ci.org/lydell/js-tokens.svg?branch=master)](https://travis-ci.org/lydell/js-tokens)

A regex that tokenizes JavaScript.

```javascript
const jsTokens = require("js-tokens").default;

const jsString = "var foo=opts.foo;\n...";

const matches = jsString.match(jsTokens);
// ["var", " ", "foo", "=", "opts", ".", "foo", ";", "\n", ...]
```

## Installation

```bash
npm install js-tokens
```

```javascript
import jsTokens from "js-tokens";
// or
const jsTokens = require("js-tokens").default;
```

## Usage

### `jsTokens`

A regex with the `g` flag that matches JavaScript tokens.

The regex _always_ matches, even invalid JavaScript and the empty string.

The next match is always directly after the previous.

### `matchToToken(match)`

```javascript
import { matchToToken } from "js-tokens";
// or
const matchToToken = require("js-tokens").matchToToken;
```

This function takes a match returned by `jsTokens.exec(string)` and returns a `{ type: String, value: String }` object.  Possible `type` values include:

- `string`
- `comment`
- `regex`
- `number`
- `name`
- `punctuator`
- `whitespace`
- `invalid`

For comments and strings, there's an additional `closed` property indicating whether the token was closed.

To differentiate comment types, check if the token starts with `//`, `/*`, `'`, `"`, or `` ` ``.

Names are ECMAScript IdentifierNames.  Use a library like `is-keyword-js` to determine if a name is a keyword.

Whitespace includes line terminators and other whitespace characters.


## ECMAScript Support

The library aims to support the latest finalized ECMAScript version.  Major version bumps are used when newer versions require significant changes.  Currently, ECMAScript 2018 is supported.


## Invalid Code Handling

- Unterminated strings are still matched as strings.  Unterminated strings end at the line boundary, since JavaScript strings cannot contain newlines.  Unterminated template strings span the entire input.
- Unterminated multi-line comments are matched as comments and span to the end of the input.
- Unterminated regex literals are likely matched as division and whatever's inside the regex.
- Invalid ASCII characters are captured in their own group.
- Invalid non-ASCII characters (except unicode spaces, which are whitespace) are treated as names for easier matching. (Note: See ES2018 section for more information.)
- Regex literals may have invalid syntax.  They are still matched as regex literals and may contain repeated flags.
- Strings may contain invalid escape sequences.


## Limitations

Tokenizing JavaScript using only a single regex is inherently imperfect.  Compare with `esprima` using `esprima-compare.js` (run `npm run esprima-compare`).

### Template String Interpolation

Template strings are treated as single tokens, including interpolations, whose tokens are not matched individually.  Only one level of nesting is supported due to the limitations of JavaScript regexes.

### Division and Regex Literal Collision

The regex cannot always distinguish between division and regex literals when multiple slashes are present in a single line.  This is a limitation of forward-only matching.

- Simple cases with one slash are correctly identified.
- Regex flags are checked.  Only standard flags are supported.
- Limited lookahead logic is used to distinguish division from regex literals in some cases.

The library attempts to mitigate this issue but is not guaranteed to be perfect.   Refer to the regex source code and test cases for more detailed information.


## ES2018 Improvements

ES2018 introduces improvements:

- Unicode property escapes help distinguish names and invalid characters without significantly increasing regex size.
- Lookbehind assertions could improve the ability to distinguish division and regex literals.
- Named capture groups might simplify the regex.

These improvements may be included in future versions, dependent on Node.js LTS releases supporting these features.



## License

[MIT](LICENSE)
```