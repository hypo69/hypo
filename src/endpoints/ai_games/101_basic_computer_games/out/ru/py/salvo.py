"""
SALVO:
=================
Сложность: 6
-----------------
Игра "SALVO" - это простая игра, в которой игрок пытается потопить корабли противника, стреляя в случайные координаты на игровом поле 10x10. В игре используется упрощенная модель морского боя, где у противника есть несколько кораблей, каждый из которых занимает одну клетку.  Игрок вводит координаты для выстрела, и если выстрел попадает в корабль, то игрок получает очки. Цель игры - потопить все корабли противника за минимальное количество ходов.

Правила игры:
1. Игровое поле представляет собой сетку 10x10.
2. Противник имеет несколько кораблей (в данной реализации - 3), каждый из которых занимает одну клетку на поле. Расположение кораблей выбирается случайным образом.
3. Игрок вводит координаты выстрела (пара чисел от 1 до 10).
4. Если выстрел попадает в корабль, игрок получает сообщение "HIT!" и +100 очков. Если выстрел промахивается, игрок получает сообщение "MISS!".
5. Игра продолжается до тех пор, пока все корабли противника не будут потоплены.
6. В конце игры выводится общее количество очков, набранных игроком.
-----------------
Алгоритм:
1.  Инициализировать количество кораблей (3 корабля)
2.  Инициализировать игровое поле 10x10 (матрица).
3.  Случайно разместить корабли на поле.
4.  Установить счетчик очков в 0.
5.  Начать игровой цикл "пока есть непотопленные корабли":
    5.1. Запросить у игрока координаты выстрела (X и Y).
    5.2. Проверить, есть ли корабль в этих координатах.
    5.3. Если есть корабль:
        5.3.1. Вывести сообщение "HIT!".
        5.3.2. Увеличить счетчик очков на 100.
        5.3.3. Удалить корабль с поля.
    5.4. Если нет корабля:
        5.4.1. Вывести сообщение "MISS!".
6.  Вывести общее количество очков игрока.
7.  Конец игры.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeGame["<p align='left'>Инициализация игры:
    <code><b>
    shipsCount = 3
    gameField = 10x10
    placeShipsRandomly()
    score = 0
    </b></code></p>"]
    InitializeGame --> GameLoopStart{"Начало игрового цикла: пока есть корабли"}
    GameLoopStart -- Да --> InputCoordinates["Ввод координат X, Y"]
    InputCoordinates --> CheckHit{"Проверка: есть корабль в координатах X, Y?"}
    CheckHit -- Да --> Hit["<p align='left'>Попадание:
    <code><b>
    Output: HIT!
    score += 100
    removeShip(X, Y)
    </b></code></p>"]
    Hit --> OutputScore["Вывод: текущий счет"]
    OutputScore --> GameLoopStart
    CheckHit -- Нет --> Miss["Вывод: MISS!"]
    Miss --> OutputScore
    GameLoopStart -- Нет --> GameOver["<p align='left'>Конец игры:
    <code><b>
    Output: Total score is {score}
    </b></code></p>"]
    GameOver --> End["Конец"]
```

Legenda:
    Start - Начало программы.
    InitializeGame - Инициализация игры: устанавливается количество кораблей, создается игровое поле, корабли случайно размещаются на поле, и устанавливается начальный счет.
    GameLoopStart - Начало игрового цикла, который продолжается, пока есть непотопленные корабли.
    InputCoordinates - Запрос у пользователя ввода координат выстрела (X и Y).
    CheckHit - Проверка, есть ли корабль в указанных координатах.
    Hit - Вывод сообщения "HIT!", увеличение счета на 100, и удаление корабля с поля.
    OutputScore - Вывод текущего счета.
    Miss - Вывод сообщения "MISS!".
    GameOver - Вывод общего количества очков игрока после окончания игры.
    End - Конец программы.
"""
import random

__author__ = 'hypo69 (hypo69@davidka.net)'
"""
Пояснения:
    1. Импорт модуля random:
        - `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел при размещении кораблей.
    2. Инициализация игры:
        - `ships_count = 3`: Устанавливает количество кораблей в игре (3 корабля).
        - `grid_size = 10`: Определяет размер игрового поля (10x10).
        - `game_field = [[0 for _ in range(grid_size)] for _ in range(grid_size)]`: Создает двумерный список (матрицу), представляющий игровое поле, заполненное нулями (0 - пустая клетка).
        - `ships_positions = []`: Создает список для хранения координат кораблей.
        - Цикл `while len(ships_positions) < ships_count:`:
            - Запускает цикл, пока не разместит все корабли.
            - `x = random.randint(0, grid_size - 1)`: Генерирует случайную координату X для корабля.
            - `y = random.randint(0, grid_size - 1)`: Генерирует случайную координату Y для корабля.
            - `if (x, y) not in ships_positions:`: Проверяет, не размещен ли корабль в данной позиции.
                - `ships_positions.append((x, y))`: Если позиция свободна, добавляет ее в список координат кораблей.
                - `game_field[x][y] = 1`: Помечает позицию корабля на игровом поле единицей (1).
        - `score = 0`: Инициализирует счетчик очков игрока в ноль.
    3. Игровой цикл:
        - `while ships_count > 0:`: Цикл продолжается до тех пор, пока все корабли не будут уничтожены.
        - `print(f"Осталось кораблей: {ships_count}")`: Выводит информацию о количестве оставшихся кораблей.
        - **Ввод координат от игрока**:
            - `while True:`: Бесконечный цикл для корректного ввода координат.
            - `try:`: Блок try-except для обработки возможных ошибок при вводе.
            - `x = int(input("Введите координату X (от 1 до 10): ")) - 1`: Запрашивает координату X, преобразует ее в целое число и вычитает 1 (так как индексы начинаются с 0).
            - `y = int(input("Введите координату Y (от 1 до 10): ")) - 1`: Запрашивает координату Y, преобразует ее в целое число и вычитает 1.
            - `if 0 <= x < grid_size and 0 <= y < grid_size:`: Проверяет, находятся ли введенные координаты в пределах игрового поля.
                - `break`: Выходит из цикла ввода, если координаты корректны.
            - `except ValueError:`: Выводит сообщение об ошибке, если введенные данные не являются целыми числами.
        - **Проверка попадания**:
            - `if game_field[x][y] == 1:`: Проверяет, есть ли корабль в указанных координатах.
                - `print("HIT!")`: Выводит сообщение о попадании.
                - `score += 100`: Увеличивает счет на 100.
                - `ships_count -= 1`: Уменьшает счетчик кораблей.
                - `game_field[x][y] = 0`: Помечает клетку как пустую, т.к. корабль уничтожен.
            - `else:`: Если в указанных координатах нет корабля.
                - `print("MISS!")`: Выводит сообщение о промахе.
        - `print(f"Текущий счет: {score}")`: Выводит текущий счет игрока.
    4. Конец игры:
        - `print(f"Игра окончена. Общий счет: {score}")`: Выводит сообщение об окончании игры и общем количестве очков.
    5. Запуск игры:
        - `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_salvo()` будет запущена, только если файл исполняется напрямую.
        - `play_salvo()`: Вызывает функцию для начала игры.
"""

def play_salvo():
    # Инициализация параметров игры
    ships_count = 3 # Количество кораблей
    grid_size = 10 # Размер игрового поля (10x10)
    # Создание игрового поля, заполненного нулями (пустые клетки)
    game_field = [[0 for _ in range(grid_size)] for _ in range(grid_size)]
    ships_positions = [] # Список для координат кораблей

    # Размещение кораблей на поле случайным образом
    while len(ships_positions) < ships_count:
        x = random.randint(0, grid_size - 1) # Координата X
        y = random.randint(0, grid_size - 1) # Координата Y
        if (x, y) not in ships_positions: # Проверяем, что корабль не размещен в этой точке
            ships_positions.append((x, y)) # Записываем координаты корабля
            game_field[x][y] = 1 # 1 - корабль на игровом поле

    score = 0 # Начальный счет игрока

    # Основной игровой цикл
    while ships_count > 0: # Пока есть корабли
        print(f"Осталось кораблей: {ships_count}") # Вывод количества оставшихся кораблей

        # Запрос координат у игрока
        while True:
            try:
                # Запрашиваем координаты выстрела и преобразуем в индекс (от 0 до 9)
                x = int(input("Введите координату X (от 1 до 10): ")) - 1
                y = int(input("Введите координату Y (от 1 до 10): ")) - 1
                if 0 <= x < grid_size and 0 <= y < grid_size: # Проверка ввода координат
                    break # Если ввод верный, выходим из цикла
                else:
                    print("Координаты за пределами поля, повторите ввод.") # Сообщение об ошибке ввода
            except ValueError:
                print("Неверный ввод, введите число.") # Сообщение об ошибке ввода

        # Проверка попадания
        if game_field[x][y] == 1: # Если в клетке есть корабль
            print("HIT!") # Сообщение о попадании
            score += 100 # Увеличиваем счет на 100
            ships_count -= 1 # Уменьшаем кол-во кораблей
            game_field[x][y] = 0 # Помечаем клетку, как пустую
        else:
            print("MISS!") # Сообщение о промахе
        print(f"Текущий счет: {score}") # Выводим текущий счет

    print(f"Игра окончена. Общий счет: {score}") # Вывод итогов игры

if __name__ == "__main__":
    play_salvo() # Запуск игры
"""
Пояснения:
    1. Импорт модуля random:
        - `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел при размещении кораблей.
    2. Инициализация игры:
        - `ships_count = 3`: Устанавливает количество кораблей в игре (3 корабля).
        - `grid_size = 10`: Определяет размер игрового поля (10x10).
        - `game_field = [[0 for _ in range(grid_size)] for _ in range(grid_size)]`: Создает двумерный список (матрицу), представляющий игровое поле, заполненное нулями (0 - пустая клетка).
        - `ships_positions = []`: Создает список для хранения координат кораблей.
        - Цикл `while len(ships_positions) < ships_count:`:
            - Запускает цикл, пока не разместит все корабли.
            - `x = random.randint(0, grid_size - 1)`: Генерирует случайную координату X для корабля.
            - `y = random.randint(0, grid_size - 1)`: Генерирует случайную координату Y для корабля.
            - `if (x, y) not in ships_positions:`: Проверяет, не размещен ли корабль в данной позиции.
                - `ships_positions.append((x, y))`: Если позиция свободна, добавляет ее в список координат кораблей.
                - `game_field[x][y] = 1`: Помечает позицию корабля на игровом поле единицей (1).
        - `score = 0`: Инициализирует счетчик очков игрока в ноль.
    3. Игровой цикл:
        - `while ships_count > 0:`: Цикл продолжается до тех пор, пока все корабли не будут уничтожены.
        - `print(f"Осталось кораблей: {ships_count}")`: Выводит информацию о количестве оставшихся кораблей.
        - **Ввод координат от игрока**:
            - `while True:`: Бесконечный цикл для корректного ввода координат.
            - `try:`: Блок try-except для обработки возможных ошибок при вводе.
            - `x = int(input("Введите координату X (от 1 до 10): ")) - 1`: Запрашивает координату X, преобразует ее в целое число и вычитает 1 (так как индексы начинаются с 0).
            - `y = int(input("Введите координату Y (от 1 до 10): ")) - 1`: Запрашивает координату Y, преобразует ее в целое число и вычитает 1.
            - `if 0 <= x < grid_size and 0 <= y < grid_size:`: Проверяет, находятся ли введенные координаты в пределах игрового поля.
                - `break`: Выходит из цикла ввода, если координаты корректны.
            - `except ValueError:`: Выводит сообщение об ошибке, если введенные данные не являются целыми числами.
        - **Проверка попадания**:
            - `if game_field[x][y] == 1:`: Проверяет, есть ли корабль в указанных координатах.
                - `print("HIT!")`: Выводит сообщение о попадании.
                - `score += 100`: Увеличивает счет на 100.
                - `ships_count -= 1`: Уменьшает счетчик кораблей.
                - `game_field[x][y] = 0`: Помечает клетку как пустую, т.к. корабль уничтожен.
            - `else:`: Если в указанных координатах нет корабля.
                - `print("MISS!")`: Выводит сообщение о промахе.
        - `print(f"Текущий счет: {score}")`: Выводит текущий счет игрока.
    4. Конец игры:
        - `print(f"Игра окончена. Общий счет: {score}")`: Выводит сообщение об окончании игры и общем количестве очков.
    5. Запуск игры:
        - `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_salvo()` будет запущена, только если файл исполняется напрямую.
        - `play_salvo()`: Вызывает функцию для начала игры.
"""
```