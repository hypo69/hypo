## Ответ на Задачу No 131: Кубические простые числа

### 1. Анализ задачи и решение
**Понимание задачи:**
* Необходимо найти количество простых чисел `p` меньше 1000000, для которых существует целое число `n`, такое что `n³ + n² + n + 1` делится на `p`.
* Задача сводится к перебору простых чисел `p` и проверке для каждого из них, существует ли соответствующее целое число `n`, такое, что `(n³ + n² + n + 1) % p == 0`.
* При этом можно воспользоваться условием, что если `n` является решением уравнения `n² + n = pq - 1`, то `f(n)` делится на `q`, где `q` это простое число, и для данного q только одна пара (n, p) удовлетворяет этому условию. Из этого следует что, нужно проверять простые числа `q` и для каждого `q` находить соответствующее `p`.

**Решение:**
1. **Генерация простых чисел:** Сгенерируем все простые числа меньше 1000000.
2. **Итерация по простым числам q:** Проходим по всем простым числам `q` из списка простых чисел.
3. **Решение уравнения n² + n = pq - 1 для n:** Для каждого `q` перебираем `p` из списка простых чисел и ищем целое решение уравнения `n² + n = pq - 1` относительно `n`.
4. **Проверка условия:**  Так как `f(n)` должно делиться на `p`, то  `n³+n²+n+1` % `p` == 0  должно выполняться. Если существует такое `n`, то увеличиваем счетчик подходящих простых чисел `p`.
5. **Возврат результата:** Возвращаем счетчик найденных простых чисел.
6. **Оптимизация:** Можно ограничить перебор `n` в диапазоне от 0 до `p-1` в цикле проверки условия, так как `(n³ + n² + n + 1) % p` является периодической функцией.

### 2. Алгоритм решения
1. Начать
2. Инициализировать счетчик `count` со значением 0.
3. Сгенерировать список простых чисел `primes` меньших 1000000.
4. Для каждого простого числа `p` из `primes`:
  *  Для каждого простого числа `q` из `primes`:
     *  Решить уравнение `n² + n = pq - 1` относительно `n`.
     * Если уравнение имеет целое решение `n`, то:
        * Если `(n³ + n² + n + 1) % p == 0`:
             * Увеличить счетчик `count` на 1
             * Прервать цикл перебора `q`
  *   Если `(n³ + n² + n + 1) % p == 0` не выполнилось для всех `q`, то пропустить текущее `p`.
5. Вернуть `count`
6. Конец

### 3. Реализация на Python 3.12
```python
import math

def is_prime(n):
    """Проверка является ли число простым."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_primes(limit):
    """Генерация списка простых чисел до заданного предела."""
    primes = []
    for num in range(2, limit):
        if is_prime(num):
            primes.append(num)
    return primes

def solve_quadratic(a, b, c):
    """Решение квадратного уравнения ax^2 + bx + c = 0."""
    delta = b*b - 4*a*c
    if delta < 0:
        return None
    x1 = (-b + math.sqrt(delta)) / (2*a)
    x2 = (-b - math.sqrt(delta)) / (2*a)
    if x1 == int(x1):
        return int(x1)
    if x2 == int(x2):
      return int(x2)
    return None

def count_cubic_primes(limit):
    """Подсчет количества простых чисел p, для которых существует n,
       такое что n³ + n² + n + 1 делится на p."""
    primes = generate_primes(limit)
    count = 0

    for p in primes:
      found = False
      for q in primes:
        n = solve_quadratic(1, 1, 1 - p*q)
        if n is not None:
          if (n**3 + n**2 + n + 1) % p == 0:
            count+=1
            found=True
            break
      if not found:
          continue
    return count
    
limit = 1000000
result = count_cubic_primes(limit)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeCount((Инициализировать счетчик = 0))
    InitializeCount --> GeneratePrimes((Сгенерировать список простых чисел primes < 1000000))
    GeneratePrimes --> LoopPrimesP((Начать цикл: для каждого p из primes))
    LoopPrimesP --> InitializeFound((found=false))
    InitializeFound --> LoopPrimesQ((Начать цикл: для каждого q из primes))
    LoopPrimesQ --> SolveQuadratic((Решить уравнение n² + n = pq - 1))
    SolveQuadratic --> CheckSolution((Есть целое решение n?))
    CheckSolution -- Да --> CheckDivisible((Проверить: (n³ + n² + n + 1) % p == 0 ?))
    CheckDivisible -- Да --> IncrementCount((Увеличить счетчик))
    IncrementCount --> SetFoundTrue((found = True))
    SetFoundTrue --> BreakLoopQ((Прервать цикл по q))    
    CheckDivisible -- Нет --> LoopPrimesQ
    CheckSolution -- Нет --> LoopPrimesQ
    LoopPrimesQ --> CheckFound((found?))
    CheckFound -- Да --> LoopPrimesP
    CheckFound -- Нет --> LoopPrimesP
    LoopPrimesP --> ReturnCount((Вернуть счетчик))
    ReturnCount --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать счетчик:** Создаем переменную для хранения результата и присваиваем ей значение 0.
*   **Сгенерировать список простых чисел:** Генерируем список всех простых чисел меньше 1000000.
*   **Начать цикл: для каждого p из primes:** Начинаем перебор всех простых чисел p.
*  **found=false:**  Инициализация переменной found, которая показывает, было ли найдено такое n для p.
*   **Начать цикл: для каждого q из primes:** Начинаем перебор всех простых чисел q.
*   **Решить уравнение n² + n = pq - 1:** Решаем квадратное уравнение относительно n.
*   **Есть целое решение n?:** Проверяем, существует ли целое решение уравнения.
*   **Проверить: (n³ + n² + n + 1) % p == 0?:** Проверяем условие делимости.
*   **Увеличить счетчик:** Если условие выполняется, увеличиваем счетчик.
*   **found = True:** Устанавливаем переменную found в True
*   **Прервать цикл по q:** Прерываем цикл по q, так как для текущего p мы нашли нужное q
*   **found?:** Проверяем, было ли найдено n для текущего p
* **Вернуть счетчик:** Возвращаем финальный счетчик.
