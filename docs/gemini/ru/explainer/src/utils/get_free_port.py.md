## ИНСТРУКЦИЯ:

Анализируй предоставленный код подробно и объясни его функциональность. Ответ должен включать три раздела:

1. **<алгоритм>**: Опиши рабочий процесс в виде пошаговой блок-схемы, включая примеры для каждого логического блока, и проиллюстрируй поток данных между функциями, классами или методами.
2. **<mermaid>**: Напиши код для диаграммы в формате `mermaid`, проанализируй и объясни все зависимости,
    которые импортируются при создании диаграммы.
    **ВАЖНО!** Убедитесь, что все имена переменных, используемые в диаграмме `mermaid`,
    имеют осмысленные и описательные имена. Имена переменных вроде `A`, `B`, `C`, и т.д., не допускаются!

    **Дополнительно**: Если в коде есть импорт `import header`, добавьте блок `mermaid` flowchart, объясняющий `header.py`:
    ```mermaid
    flowchart TD
        Start --> Header[<code>header.py</code><br> Determine Project Root]

        Header --> import[Import Global Settings: <br><code>from src import gs</code>]
    ```

3. **<объяснение>**: Предоставьте подробные объяснения:
   - **Импорты**: Их назначение и взаимосвязь с другими пакетами `src.`.
   - **Классы**: Их роль, атрибуты, методы и взаимодействие с другими компонентами проекта.
   - **Функции**: Их аргументы, возвращаемые значения, назначение и примеры.
   - **Переменные**: Их типы и использование.
   - Выделите потенциальные ошибки или области для улучшения.

Дополнительно, постройте цепочку взаимосвязей с другими частями проекта (если применимо).

Это обеспечивает всесторонний и структурированный анализ кода.
## Формат ответа: `.md` (markdown)
**КОНЕЦ ИНСТРУКЦИИ**

## <алгоритм>

**Блок-схема функции `get_free_port`**

```mermaid
graph TD
    A[Начало: get_free_port(host, port_range)] --> B{port_range is None?};
    B -- Yes --> C[port = 1024];
    C --> D{_is_port_in_use(host, port)?};
    D -- Yes --> E[port += 1];
    E --> F{port > 65535?};
    F -- Yes --> G[logger.error("No free port found")];
    G --> H[ValueError("No free port found")];
    H --> I[Конец: Ошибка];
    F -- No --> D;
    D -- No --> J[Return port];
    J --> K[Конец: Порт найден];
    B -- No --> L{Проверка корректности port_range};
    L -- Invalid --> M[logger.error("Invalid port range")];
    M --> N[ValueError("Invalid port range")];
    N --> I;
    L -- Valid --> O[min_port, max_port = port_range];
    O --> P[For port in range(min_port, max_port + 1)];
    P --> Q{_is_port_in_use(host, port)?};
    Q -- Yes --> P;
    Q -- No --> R[Return port];
    R --> K;
    P --> S{Закончен диапазон?};
    S -- Yes --> T[logger.error("No free port in range")];
    T --> U[ValueError("No free port in range")];
     U-->I;
    S -- No --> P;
```

**Примеры:**

1.  **`get_free_port(host="127.0.0.1")`**:
    *   `port_range` is `None`, следовательно, начинается поиск с порта 1024.
    *   Цикл `while` проверяет, занят ли порт.
    *   Если порт не занят, функция возвращает его.
    *   Если все порты заняты, генерируется исключение.
2.  **`get_free_port(host="127.0.0.1", port_range=(8000, 8010))`**:
    *   `port_range` существует, выполняется проверка корректности диапазона.
    *   Цикл `for` перебирает порты в диапазоне 8000-8010.
    *   Если порт не занят, функция возвращает его.
    *   Если все порты в диапазоне заняты, генерируется исключение.
3. **`get_free_port(host="127.0.0.1", port_range=(8010, 8000))`**:
    * `port_range` существует, выполняется проверка корректности диапазона.
    * Диапазон не корректен, выводится сообщение об ошибке и генерируется исключение ValueError.

**Блок-схема функции `_is_port_in_use`**

```mermaid
graph TD
    A[Начало: _is_port_in_use(host, port)] --> B[Создание сокета];
    B --> C[Попытка привязать сокет к (host, port)];
    C -- Успех --> D[Возврат False];
    C -- Ошибка --> E[Возврат True];
    D --> F[Конец: Порт свободен];
    E --> G[Конец: Порт занят];
```

**Поток данных:**

1.  Функция `get_free_port` принимает хост и (опционально) диапазон портов.
2.  Если диапазон портов указан, выполняется проверка его корректности.
3.  В цикле, для каждого порта, вызывается функция `_is_port_in_use` для проверки доступности.
4.  Функция `_is_port_in_use` создает сокет и пытается привязать его к заданному хосту и порту. Если это получается, порт свободен, если нет, порт занят.
5.  `get_free_port` возвращает первый свободный порт или возбуждает исключение, если свободных портов не найдено.

## <mermaid>

```mermaid
graph TD
    A[get_free_port: Функция поиска свободного порта] --> B{Проверка: port_range задан?};
    B -- Нет --> C[Инициализация: port = 1024];
    C --> D{Проверка: _is_port_in_use(host, port)?};
    D -- Да --> E[Увеличение номера порта: port += 1];
    E --> F{Проверка: port > 65535?};
    F -- Да --> G[Логирование ошибки: logger.error("No free port found")];
    G --> H[Исключение: ValueError("No free port found")];
     H --> I[Конец: Ошибка];
    F -- Нет --> D;
    D -- Нет --> J[Возврат: port];
    J --> I;
    B -- Да --> K{Проверка: Корректность port_range};
    K -- Нет --> L[Логирование ошибки: logger.error("Invalid port range")];
    L --> M[Исключение: ValueError("Invalid port range")];
      M --> I;
    K -- Да --> N[Присваивание: min_port, max_port = port_range];
    N --> O[Цикл: for port in range(min_port, max_port + 1)];
    O --> P{Проверка: _is_port_in_use(host, port)?};
    P -- Да --> O;
    P -- Нет --> Q[Возврат: port];
    Q --> I;
    O --> R{Конец цикла диапазона?};
    R -- Да --> S[Логирование ошибки: logger.error("No free port in range")];
    S --> T[Исключение: ValueError("No free port in range")];
    T -->I;
    R--Нет-->O
    subgraph  _is_port_in_use
    AA[Начало: _is_port_in_use(host, port)] --> BB[Создание сокета];
    BB --> CC[Попытка привязки сокета к (host, port)];
    CC -- Успех --> DD[Возврат: False];
    CC -- Ошибка --> EE[Возврат: True];
    end
     style AA fill:#f9f,stroke:#333,stroke-width:2px
    style BB fill:#ccf,stroke:#333,stroke-width:2px
        style CC fill:#ccf,stroke:#333,stroke-width:2px
    style DD fill:#ccf,stroke:#333,stroke-width:2px
    style EE fill:#ccf,stroke:#333,stroke-width:2px
```

**Объяснение зависимостей `mermaid`:**

*   `get_free_port`: Главная функция, которая находит свободный порт. Она вызывает `_is_port_in_use`.
*   `port_range`: Параметр, задающий диапазон портов для поиска.
*   `_is_port_in_use`: Вспомогательная функция для проверки занятости конкретного порта.
*   `logger.error`: Используется для логирования ошибок.
*   `ValueError`: Возбуждается, если не удается найти свободный порт или если диапазон портов не корректен.
*  В блок схему _is_port_in_use показаны внутренние этапы работы функции.
* На блок схеме отображенны все возможные варианты развития событий, с помощью условных операторов.

## <объяснение>

**Импорты:**

*   `socket`: Модуль для работы с сетевыми сокетами. Используется для создания сокета и попытки привязки к определенному адресу и порту, чтобы определить, занят ли порт.
*   `typing.Tuple, Optional`: Модуль для аннотаций типов. `Tuple` используется для обозначения типа `port_range` (кортеж из двух чисел), а `Optional` используется для указания, что `port_range` может быть `None`.
*   `src.logger.logger`: Логирование ошибок. Используется для записи сообщений об ошибках при возникновении проблем с портом.

**Функции:**

1.  **`get_free_port(host: str, port_range: Optional[Tuple[int, int] | Tuple[str, str]] = None) -> int`**:

    *   **Аргументы**:
        *   `host`: `str` - Хост, на котором нужно проверить доступность порта.
        *   `port_range`: `Optional[Tuple[int, int] | Tuple[str, str]] = None` - Опциональный кортеж с диапазоном портов для поиска (начальный и конечный). Может быть `None`, если нужно найти первый свободный порт.
    *   **Возвращает**: `int` - Номер свободного порта.
    *   **Назначение**: Находит свободный TCP-порт на указанном хосте. Если задан `port_range`, то поиск происходит в заданном диапазоне. Если `port_range` равен `None`, то поиск происходит, начиная с порта 1024 до 65535.
    *   **Пример**:
        *   `get_free_port("127.0.0.1")` - вернет первый свободный порт, начиная с 1024
        *   `get_free_port("127.0.0.1", (8000, 9000))` - вернет первый свободный порт в диапазоне от 8000 до 9000.

2.  **`_is_port_in_use(host: str, port: int) -> bool`**:

    *   **Аргументы**:
        *   `host`: `str` - Хост, на котором нужно проверить доступность порта.
        *   `port`: `int` - Номер порта для проверки.
    *   **Возвращает**: `bool` - `True`, если порт занят, `False`, если свободен.
    *   **Назначение**: Проверяет, занят ли указанный порт на заданном хосте. Использует сокет TCP, пытаясь привязаться к указанному адресу и порту. Если попытка привязки успешна, то порт свободен, если нет – занят.
    *   **Пример**:
        *   `_is_port_in_use("127.0.0.1", 8080)` - вернет `True`, если порт 8080 занят, `False` в противном случае.

**Переменные:**

*   `host`: `str` - Хост для проверки портов.
*   `port_range`: `Optional[Tuple[int, int] | Tuple[str, str]]` - Опциональный диапазон портов.
*   `min_port`, `max_port`: `int` - Границы диапазона портов.
*   `port`: `int` - Текущий номер порта для проверки.
*   `sock`: `socket.socket` - Сокет для проверки порта.

**Взаимосвязь с другими частями проекта:**

*   Импорт `src.logger.logger` указывает на использование модуля логирования, который может быть частью общего фреймворка для логирования ошибок и событий приложения.
*   Данная функция может быть частью модуля, отвечающего за сетевые настройки и управление портами.

**Потенциальные ошибки и области для улучшения:**

*   **Обработка ошибок**: В текущем виде, если порт не найден, генерируется `ValueError`.  Можно добавить более специфичные исключения.
*   **Поиск в диапазоне:**  Если `port_range`  передан в виде строк, необходимо явно преобразовать их в целые числа перед сравнением и итерацией. В текущем варианте это реализовано через `int(min_port), int(max_port)`.
*   **Таймаут сокета**:  Для сокета не установлен таймаут. При проблемах с сетью это может привести к долгому ожиданию и не возвращать ошибку.
*   **IPv6**: Код использует `socket.AF_INET`, что означает только IPv4. Можно добавить поддержку IPv6 (`socket.AF_INET6`).
*   **Диапазон портов**: Можно задать диапазон портов по умолчанию.

**Цепочка взаимосвязей:**

1.  Функция `get_free_port` используется для получения свободного порта.
2.  Результат этой функции может использоваться для запуска сетевых сервисов, которые используют порты.
3.  Модуль `logger` может быть использован для записи информации о полученных портах и других событиях.

В заключение, данный код является хорошо структурированным и решает задачу поиска свободного порта. Тем не менее, есть возможности для улучшения, особенно в плане обработки ошибок и расширения функциональности.