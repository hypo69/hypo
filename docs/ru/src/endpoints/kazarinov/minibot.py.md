# Модуль `minibot`

## Обзор

Модуль `minibot` предназначен для обслуживания запросов на создание прайс-листов для Казаринова через Telegram-бота. Он включает в себя обработку текстовых и голосовых сообщений, документов, а также взаимодействие с AI-моделью Google Gemini для генерации ответов на вопросы пользователей.

## Подробнее

Модуль предоставляет функциональность Telegram-бота, способного обрабатывать команды, такие как `/start`, `/help`, `/info`, `/time`, `/photo`, а также текстовые и голосовые сообщения. Он использует AI-модель Google Gemini для ответа на вопросы пользователей и сценарии для обработки URL, присланных пользователем, с целью создания прайс-листов.

## Классы

### `Config`

**Описание**: Класс `Config` предназначен для хранения конфигурационных параметров бота.

**Принцип работы**:
Класс определяет различные параметры, такие как токен бота, ID канала, директории для хранения фотографий, сообщения для команд и режим работы (PRODUCTION или DEV). В зависимости от режима работы выбирается соответствующий токен бота.

**Атрибуты**:
- `ENDPOINT` (str): Имя endpoint, значение `'kazarinov'`.
- `MODE` (str): Режим работы бота (`'PRODUCTION'` или `'DEV'`). Определяет, какой токен бота использовать.
- `BOT_TOKEN` (str): Токен Telegram-бота. Зависит от значения `MODE` и берется из переменных окружения или `gs.credentials`.
- `CHANNEL_ID` (str): ID Telegram-канала, значение `'@onela'`.
- `PHOTO_DIR` (Path): Путь к директории с фотографиями.
- `COMMAND_INFO` (str): Информационное сообщение о боте.
- `UNKNOWN_COMMAND_MESSAGE` (str): Сообщение при получении неизвестной команды.
- `START_MESSAGE` (str): Приветственное сообщение при старте бота.
- `HELP_MESSAGE` (str): Сообщение со списком доступных команд.

### `BotHandler`

**Описание**: Класс `BotHandler` предназначен для обработки команд и сообщений, получаемых от Telegram-бота.

**Принцип работы**:
Класс инициализируется с использованием AI-модели Google Gemini для обработки текстовых сообщений. Он предоставляет методы для обработки различных типов сообщений, таких как текстовые сообщения, URL, голосовые сообщения и документы.

**Атрибуты**:
- `base_dir` (Path): Базовая директория, содержащая ресурсы для endpoint `kazarinov`.
- `questions_list` (List[str]): Список вопросов, используемых при обработке команды `--next`.
- `model` (GoogleGenerativeAI): Инстанс класса `GoogleGenerativeAI` для взаимодействия с моделью Gemini.
- `scenario` (Scenario): Инстанс класса `Scenario` для выполнения сценариев обработки URL.

**Методы**:
- `__init__`: Инициализация обработчика событий телеграм-бота.
- `handle_message`: Обработка текстовых сообщений.
- `_send_user_flowchart`: Отправка схемы user_flowchart.
- `_handle_url`: Обработка URL, присланного пользователем.
- `_handle_next_command`: Обработка команды '--next' и её аналогов.
- `help_command`: Обработка команды /help.
- `send_pdf`: Обработка команды /sendpdf для отправки PDF.
- `handle_voice`: Обработка голосовых сообщений.
- `_transcribe_voice`: Транскрибирование голосового сообщения (заглушка).
- `handle_document`: Обработка полученных документов.

## Функции

### `handle_message`

```python
def handle_message(self, bot:telebot, message:'message'):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, поступающие от пользователя.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки сообщений.
- `message` (message): Объект сообщения, содержащий текст и информацию о чате.

**Как работает функция**:

1.  Извлекает текст сообщения.
2.  Проверяет, является ли текст вопросительным знаком (`?`). Если да, вызывает метод `_send_user_flowchart` для отправки схемы user\_flowchart.
3.  Если текст является URL, вызывает метод `_handle_url` для обработки URL.
4.  Если текст является одной из команд для запроса следующего вопроса (`--next`, `-next`, `__next`, `-n`, `-q`), вызывает метод `_handle_next_command`.
5.  В противном случае пытается отправить текст в модель Gemini для получения ответа и отправляет ответ пользователю. Если происходит ошибка при взаимодействии с моделью, логирует ошибку и отправляет сообщение об ошибке пользователю.

```
  Текст сообщения
     ↓
  [Текст == '?'] - Y -> _send_user_flowchart
     ↓             N
  [Текст == URL] - Y -> _handle_url
     ↓             N
  [Текст in ("--next", ...)] - Y -> _handle_next_command
     ↓                         N
  -> Отправка в Gemini -> Получение ответа -> Отправка ответа
     ↓
  [Ошибка] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример 1: Обработка вопросительного знака
handle_message(bot, message_with_question_mark)

# Пример 2: Обработка URL
handle_message(bot, message_with_url)

# Пример 3: Обработка команды '--next'
handle_message(bot, message_with_next_command)

# Пример 4: Обработка обычного текста
handle_message(bot, message_with_text)
```

### `_send_user_flowchart`

```python
def _send_user_flowchart(self, bot, chat_id):
    """Отправка схемы user_flowchart."""
    ...
```

**Назначение**: Отправляет пользователю схему `user_flowchart` в виде фотографии.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки фотографии.
- `chat_id` (int): ID чата, куда следует отправить фотографию.

**Как работает функция**:

1.  Определяет путь к файлу `user_flowchart.png` в директории `assets`.
2.  Пытается открыть файл и отправить его как фотографию пользователю.
3.  Если файл не найден, логирует ошибку и отправляет сообщение об ошибке пользователю.

```
  Получение пути к файлу user_flowchart.png
     ↓
  [Файл найден] - Y -> Открытие файла -> Отправка фотографии
     ↓             N
  -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример 1: Отправка схемы user_flowchart
_send_user_flowchart(bot, chat_id)
```

### `_handle_url`

```python
def _handle_url(self, bot, message:'message'):
    """Обработка URL, присланного пользователем."""
    ...
```

**Назначение**: Обрабатывает URL, присланный пользователем.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки сообщений.
- `message` (message): Объект сообщения, содержащий URL.

**Как работает функция**:

1.  Извлекает URL из текста сообщения.
2.  Проверяет, начинается ли URL с `https://one-tab.com` или `https://www.one-tab.com`. Если нет, отправляет сообщение об ошибке пользователю.
3.  Извлекает данные о цене и URL комплектующих, используя функцию `fetch_target_urls_onetab`.
4.  Если данные не получены или произошла ошибка при их получении, отправляет сообщение об ошибке пользователю.
5.  Выполняет сценарий обработки URL, используя класс `Scenario`. Если происходит ошибка при выполнении сценария, логирует ошибку и отправляет сообщение об ошибке пользователю.

```
  Получение URL из сообщения
     ↓
  [URL начинается с "https://one-tab.com"] - Y -> Извлечение данных о цене и URL
     ↓                                        N
  -> Отправка сообщения об ошибке
     ↓
  [Данные получены] - Y -> Выполнение сценария
     ↓                N
  -> Отправка сообщения об ошибке
     ↓
  [Ошибка при выполнении сценария] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример 1: Обработка корректного URL
_handle_url(bot, message_with_valid_url)

# Пример 2: Обработка некорректного URL
_handle_url(bot, message_with_invalid_url)
```

### `_handle_next_command`

```python
def _handle_next_command(self, bot, message):
    """Обработка команды '--next' и её аналогов."""
    ...
```

**Назначение**: Обрабатывает команду `--next` и её аналоги, отправляя пользователю случайный вопрос из списка и ответ на него, полученный от AI-модели.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки сообщений.
- `message` (message): Объект сообщения.

**Как работает функция**:

1.  Выбирает случайный вопрос из списка `questions_list`.
2.  Отправляет выбранный вопрос пользователю.
3.  Запрашивает ответ на вопрос у AI-модели Gemini.
4.  Отправляет полученный ответ пользователю.
5.  Если происходит ошибка при чтении вопросов или взаимодействии с моделью, логирует ошибку и отправляет сообщение об ошибке пользователю.

```
  Выбор случайного вопроса
     ↓
  Отправка вопроса пользователю
     ↓
  Запрос ответа у Gemini
     ↓
  Отправка ответа пользователю
     ↓
  [Ошибка] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример 1: Обработка команды '--next'
_handle_next_command(bot, message_with_next_command)
```

### `help_command`

```python
def help_command(self, bot, message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, отправляя пользователю сообщение со списком доступных команд.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки сообщений.
- `message` (message): Объект сообщения.

**Как работает функция**:

1.  Отправляет пользователю сообщение со списком доступных команд: `/start`, `/help`, `/sendpdf`.

```
  Отправка сообщения со списком команд пользователю
```

**Примеры**:
```python
# Пример 1: Обработка команды '/help'
help_command(bot, message_with_help_command)
```

### `send_pdf`

```python
def send_pdf(self, bot, message, pdf_file):
    """Обработка команды /sendpdf для отправки PDF."""
    ...
```

**Назначение**: Обрабатывает команду `/sendpdf`, отправляя пользователю PDF-файл.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота для отправки документа.
- `message` (message): Объект сообщения.
- `pdf_file` (str): Путь к PDF-файлу.

**Как работает функция**:

1.  Пытается открыть PDF-файл.
2.  Отправляет PDF-файл пользователю.
3.  Если происходит ошибка при отправке файла, логирует ошибку и отправляет сообщение об ошибке пользователю.

```
  Открытие PDF-файла
     ↓
  Отправка PDF-файла пользователю
     ↓
  [Ошибка] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример 1: Отправка PDF-файла
send_pdf(bot, message_with_sendpdf_command, 'example.pdf')
```

### `handle_voice`

```python
def handle_voice(self, bot, message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота.
- `message` (telebot.types.Message): Объект сообщения, содержащий голосовое сообщение.

**Как работает функция**:

1.  Получает информацию о файле голосового сообщения.
2.  Скачивает файл голосового сообщения.
3.  Сохраняет файл во временную директорию.
4.  Вызывает метод `_transcribe_voice` для транскрибирования голосового сообщения.
5.  Отправляет распознанный текст пользователю.
6.  В случае возникновения ошибки логирует её и отправляет пользователю сообщение об ошибке.

```
  Получение информации о файле
     ↓
  Скачивание файла
     ↓
  Сохранение файла во временную директорию
     ↓
  Вызов _transcribe_voice
     ↓
  Отправка распознанного текста пользователю
     ↓
  [Ошибка] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример: Обработка голосового сообщения
handle_voice(bot, message_with_voice)
```

### `_transcribe_voice`

```python
def _transcribe_voice(self, file_path):
    """Транскрибирование голосового сообщения (заглушка)."""
    ...
```

**Назначение**: Транскрибирует голосовое сообщение в текст. В текущей реализации является заглушкой и всегда возвращает сообщение о том, что распознавание голоса ещё не реализовано.

**Параметры**:
- `file_path` (str): Путь к файлу голосового сообщения.

**Как работает функция**:

1.  Возвращает строку `'Распознавание голоса ещё не реализовано.'`.

```
  Возврат заглушки
```

**Примеры**:
```python
# Пример: Транскрибирование голосового сообщения
text = _transcribe_voice('/path/to/voice/message.ogg')
print(text)  # Вывод: Распознавание голоса ещё не реализовано.
```

### `handle_document`

```python
def handle_document(self, bot, message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Объект Telegram-бота.
- `message` (telebot.types.Message): Объект сообщения, содержащий документ.

**Как работает функция**:

1.  Получает информацию о файле документа.
2.  Скачивает файл документа.
3.  Сохраняет файл во временную директорию.
4.  Отправляет пользователю сообщение об успешном сохранении файла.
5.  В случае возникновения ошибки логирует её и отправляет пользователю сообщение об ошибке.

```
  Получение информации о файле
     ↓
  Скачивание файла
     ↓
  Сохранение файла во временную директорию
     ↓
  Отправка сообщения об успешном сохранении
     ↓
  [Ошибка] - Y -> Логирование ошибки -> Отправка сообщения об ошибке
```

**Примеры**:
```python
# Пример: Обработка документа
handle_document(bot, message_with_document)
```

### `command_start`

```python
@bot.message_handler(commands=['start'])
def command_start(message):
    """Обрабатывает команду /start."""
    ...
```

**Назначение**: Обрабатывает команду `/start`, отправляя пользователю приветственное сообщение.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1. Логирует информацию об использовании команды `/start` пользователем.
2. Отправляет пользователю приветственное сообщение, хранящееся в `config.START_MESSAGE`.

**Примеры**:
```python
# Пример вызова (вызывается автоматически при получении команды /start)
command_start(message)
```

### `command_help`

```python
@bot.message_handler(commands=['help'])
def command_help(message):
    """Обрабатывает команду /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, вызывая метод `help_command` объекта `handler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1. Логирует информацию об использовании команды `/help` пользователем.
2. Вызывает метод `handler.help_command` для отправки пользователю списка доступных команд.

**Примеры**:
```python
# Пример вызова (вызывается автоматически при получении команды /help)
command_help(message)
```

### `command_info`

```python
@bot.message_handler(commands=['info'])
def command_info(message):
    """Обрабатывает команду /info."""
    ...
```

**Назначение**: Обрабатывает команду `/info`, отправляя пользователю информацию о боте.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1. Логирует информацию об использовании команды `/info` пользователем.
2. Отправляет пользователю информацию о боте, хранящуюся в `config.COMMAND_INFO`.

**Примеры**:
```python
# Пример вызова (вызывается автоматически при получении команды /info)
command_info(message)
```

### `command_time`

```python
@bot.message_handler(commands=['time'])
def command_time(message):
    """Обрабатывает команду /time."""
    ...
```

**Назначение**: Обрабатывает команду `/time`, отправляя пользователю текущее время.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1. Логирует информацию об использовании команды `/time` пользователем.
2. Получает текущее время.
3. Форматирует время в строку `HH:MM:SS`.
4. Отправляет пользователю сообщение с текущим временем.

**Примеры**:
```python
# Пример вызова (вызывается автоматически при получении команды /time)
command_time(message)
```

### `command_photo`

```python
@bot.message_handler(commands=['photo'])
def command_photo(message):
    """Обрабатывает команду /photo."""
    ...
```

**Назначение**: Обрабатывает команду `/photo`, отправляя пользователю случайное фото из директории.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1. Логирует информацию об использовании команды `/photo` пользователем.
2. Пытается получить список файлов в директории с фотографиями.
3. Если файлы найдены, выбирает случайный файл.
4. Открывает файл и отправляет его пользователю как фотографию.
5. Если директория не найдена или в ней нет файлов, отправляет пользователю соответствующее сообщение об ошибке.

**Примеры**:
```python
# Пример вызова (вызывается автоматически при получении команды /photo)
command_photo(message)
```

### `handle_voice_message`

```python
@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    """Обрабатывает голосовые сообщения."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, перенаправляя их в метод `handle_voice` объекта `handler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий голосовое сообщение.

**Как работает функция**:

1.  Логирует информацию об использовании голосового сообщения пользователем.
2.  Вызывает метод `handler.handle_voice` для обработки голосового сообщения.

**Примеры**:
```python
# Пример: Обработка голосового сообщения
handle_voice_message(message_with_voice)
```

### `handle_document_message`

```python
@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    """Обрабатывает сообщения с документами."""
    ...
```

**Назначение**: Обрабатывает сообщения с документами, перенаправляя их в метод `handle_document` объекта `handler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий документ.

**Как работает функция**:

1.  Логирует информацию об отправке документа пользователем.
2.  Вызывает метод `handler.handle_document` для обработки документа.

**Примеры**:
```python
# Пример: Обработка сообщения с документом
handle_document_message(message_with_document)
```

### `handle_text_message`

```python
@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    """Обрабатывает текстовые сообщения."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, не начинающиеся с символа `/`, перенаправляя их в метод `handle_message` объекта `handler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1.  Логирует информацию об отправке текстового сообщения пользователем.
2.  Вызывает метод `handler.handle_message` для обработки текстового сообщения.

**Примеры**:
```python
# Пример: Обработка текстового сообщения
handle_text_message(message_with_text)
```

### `handle_unknown_command`

```python
@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    """Обрабатывает неизвестные команды."""
    ...
```

**Назначение**: Обрабатывает неизвестные команды, отправляя пользователю сообщение о том, что команда неизвестна.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения.

**Как работает функция**:

1.  Логирует информацию об отправке неизвестной команды пользователем.
2.  Отправляет пользователю сообщение об ошибке, хранящееся в `config.UNKNOWN_COMMAND_MESSAGE`.

**Примеры**:
```python
# Пример: Обработка неизвестной команды
handle_unknown_command(message)
```

### `main`

```python
def main(restarts:int = 5):
    """Основная функция для запуска бота."""
    ...
```

**Назначение**: Запускает Telegram-бота и обрабатывает возможные исключения, перезапуская бота в случае необходимости.

**Параметры**:
- `restarts` (int): Количество попыток перезапуска бота в случае ошибки. По умолчанию равно 5.

**Как работает функция**:

1.  Логирует информацию о запуске бота в определенном режиме (`Config.MODE`).
2.  Запускает бота в режиме опроса (`bot.polling`).
3.  В случае возникновения исключения:
    -   Логирует информацию об ошибке.
    -   Пытается остановить бота.
    -   Если количество попыток перезапуска больше 1, ждет 10 секунд и перезапускает бота с уменьшенным количеством попыток.
    -   Если количество попыток перезапуска исчерпано, логирует информацию о превышении количества переподключений.

**Внутренние функции**:

*   В данной функции нет внутренних функций.

```
  Логирование информации о запуске бота
     ↓
  Запуск бота в режиме опроса
     ↓
  [Исключение] - Y -> Логирование информации об ошибке
     ↓            N
  -> Успешная работа бота
     ↓
  [Остановить бота]
     ↓
  [restarts > 1] - Y -> Пауза 10 секунд -> main(restarts - 1)
     ↓              N
  -> Логирование информации о превышении количества переподключений
```

**Примеры**:
```python
# Пример запуска бота
main()