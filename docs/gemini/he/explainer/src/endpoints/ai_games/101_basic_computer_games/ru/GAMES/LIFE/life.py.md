## <algorithm>

1. **קבלת גודל הרשת מהמשתמש:**
   - הפונקציה `get_grid_size()` מבקשת מהמשתמש להזין את מספר השורות והעמודות.
   - דוגמה: המשתמש מזין "5" עבור שורות ו-"10" עבור עמודות.
   - הפונקציה מחזירה את הערכים `rows = 5`, `cols = 10`.

2. **קבלת מספר הדורות מהמשתמש:**
   - הפונקציה `get_generations()` מבקשת מהמשתמש להזין את מספר הדורות.
   - דוגמה: המשתמש מזין "10".
   - הפונקציה מחזירה את הערך `generations = 10`.

3. **קבלת תצורה ראשונית מהמשתמש:**
   - הפונקציה `get_initial_config(rows, cols)` שואלת את המשתמש האם להשתמש בתצורה אקראית (y/n).
   - אם המשתמש בוחר שלא להשתמש בתצורה אקראית:
     - הפונקציה מבקשת מהמשתמש להזין תצורה שורה אחר שורה.
     - דוגמה: עבור `rows = 2`, `cols = 3`, המשתמש מזין שורה ראשונה "\*  ", ושורה שנייה "  \*".
     - הפונקציה מחזירה רשימה של מחרוזות: `['*  ', '  *']`.
   - אם המשתמש בוחר להשתמש בתצורה אקראית:
     - הפונקציה יוצרת רשת אקראית בה כל תא יכול להיות חי ('\*') או מת (' ').
     - דוגמה: `[['*', ' ', '*'], [' ', '*', ' ']]`
   - הפונקציה מחזירה את התצורה ההתחלתית.

4.  **יצירת רשת:**
    - הפונקציה `create_grid(rows, cols, initial_config)` יוצרת רשת משחק (רשימה של רשימות).
    - אם ניתנה תצורה ראשונית (`initial_config`), הרשת תיווצר לפיה.
    - אחרת, תיווצר רשת רנדומלית.
    - דוגמה: עבור `rows = 2`, `cols = 3`, ו-`initial_config = ['*  ', '  *']`, תוחזר הרשת `[['*', ' ', ' '], [' ', ' ', '*']]`.

5.  **לולאה על כל הדורות:**
    - הפונקציה `play_game_of_life()` רצה בלולאה על מספר הדורות שנקבע.
        - דוגמה: עבור `generations = 2`, הלולאה תרוץ פעמיים.
    - בכל איטרציה:
        - הדפסת מספר הדור הנוכחי.
        - הדפסת הרשת הנוכחית באמצעות `print_grid(grid)`.
        - יצירת הדור הבא באמצעות `next_generation(grid)`.
        - עדכון הרשת הנוכחית לרשת החדשה.
        - המתנה של 0.5 שניות.

6.  **יצירת הדור הבא:**
    - הפונקציה `next_generation(grid)` יוצרת רשת חדשה.
    - עבור כל תא ברשת:
        - הפונקציה `apply_rules(grid, row, col)` מוחלת, כדי לחשב מה יהיה מצב התא בדור הבא.
            - הפונקציה `count_live_neighbours(grid, row, col)` מחשבת כמה שכנים חיים יש לתא מסוים.
            - דוגמה: אם תא הוא חי ויש לו 2 או 3 שכנים חיים, הוא נשאר חי. אם הוא מת ויש לו 3 שכנים חיים, הוא הופך לחי.
    - החזרה של הרשת החדשה.

7.  **סיום המשחק:**
    - לאחר כל הדורות, הודעה "סימולציה הסתיימה" מודפסת.
    - הרשת הסופית מודפסת.

## <mermaid>

```mermaid
flowchart TD
    Start[התחלה] --> GetGridSize[קבלת גודל הרשת מהמשתמש: <br><code>get_grid_size()</code>]
    GetGridSize --> GetGenerations[קבלת מספר הדורות מהמשתמש: <br><code>get_generations()</code>]
    GetGenerations --> GetInitialConfig[קבלת תצורה התחלתית מהמשתמש: <br><code>get_initial_config(rows, cols)</code>]
    GetInitialConfig --> CreateGrid[יצירת רשת משחק: <br><code>create_grid(rows, cols, initial_config)</code>]
    CreateGrid --> LoopStart[לולאת דורות]
    LoopStart --> PrintGeneration[הדפסת מספר הדור: <br><code>print(f"דור: {generation + 1}")</code>]
    PrintGeneration --> PrintGrid[הדפסת הרשת הנוכחית: <br><code>print_grid(grid)</code>]
    PrintGrid --> NextGeneration[יצירת הדור הבא: <br><code>next_generation(grid)</code>]
     NextGeneration --> UpdateGrid[עדכון הרשת הנוכחית]
    UpdateGrid --> Sleep[השהייה: <br><code>time.sleep(0.5)</code>]
    Sleep --> LoopCheck{האם יש עוד דור?}
    LoopCheck -- כן --> LoopStart
    LoopCheck -- לא --> SimulationEnd[הדפסת הודעת סיום]
    SimulationEnd --> PrintFinalGrid[הדפסת הרשת הסופית: <br><code>print_grid(grid)</code>]
    PrintFinalGrid --> End[סיום]


    subgraph next_generation
    direction LR
        NG_Start[התחלת הפונקציה next_generation] --> CreateNewGrid[יצירת רשת חדשה ריקה: <br><code>new_grid = ...</code>]
        CreateNewGrid --> NG_LoopStart[לולאת שורות]
        NG_LoopStart --> NG_InnerLoopStart[לולאת עמודות]
         NG_InnerLoopStart --> ApplyRules[יישום חוקי המשחק: <br><code>apply_rules(grid, row, col)</code>]
         ApplyRules --> UpdateNewGrid[עדכון התא ברשת החדשה]
         UpdateNewGrid --> NG_InnerLoopCheck{האם יש עוד עמודה?}
        NG_InnerLoopCheck -- כן -->  NG_InnerLoopStart
       NG_InnerLoopCheck -- לא -->  NG_LoopCheck{האם יש עוד שורה?}
        NG_LoopCheck -- כן --> NG_LoopStart
        NG_LoopCheck -- לא --> NG_Return[החזרת הרשת החדשה]
    end

    subgraph apply_rules
        direction LR
       AR_Start[התחלת הפונקציה apply_rules] --> CountNeighbours[ספירת שכנים חיים: <br><code>count_live_neighbours(grid, row, col)</code>]
       CountNeighbours --> CheckCellState{האם התא חי?}
       CheckCellState -- כן --> CheckLiveNeighbours[בדיקת מספר שכנים חיים]
        CheckLiveNeighbours -- מספר שכנים < 2 OR > 3 --> ReturnDead[החזרת מצב "מת": <br><code>return ' '</code>]
         CheckLiveNeighbours -- מספר שכנים 2 OR 3  --> ReturnAlive[החזרת מצב "חי": <br><code>return '*'</code>]
       CheckCellState -- לא --> CheckDeadNeighbours[בדיקת מספר שכנים חיים]
        CheckDeadNeighbours -- מספר שכנים == 3 --> ReturnAlive2[החזרת מצב "חי": <br><code>return '*'</code>]
          CheckDeadNeighbours -- מספר שכנים != 3 --> ReturnDead2[החזרת מצב "מת": <br><code>return ' '</code>]

    end
     linkStyle 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40 stroke:#333,stroke-width:2px;

```

## <explanation>

**ייבוא (Imports):**

-   `import random`: המודול `random` משמש ליצירת מספרים אקראיים. זה נחוץ כדי ליצור את התצורה ההתחלתית של המשחק כאשר המשתמש מבקש תצורה רנדומלית.

-   `import time`: המודול `time` משמש להשהיית התוכנית בין דורות, כך שהמשתמש יכול לראות את התפתחות המשחק באופן ברור.

**פונקציות (Functions):**

-   **`get_grid_size()`**:
    -   **פרמטרים**: אין.
    -   **ערך מוחזר**: טאפל של שני מספרים שלמים `(rows, cols)`, המייצגים את גודל הרשת.
    -   **מטרה**: הפונקציה מבקשת מהמשתמש להזין את גודל הרשת (מספר שורות ועמודות) ומבצעת בדיקות תקינות על הקלט. היא ממשיכה לבקש קלט עד שהמשתמש מזין מספרים שלמים חיוביים.
    -   **דוגמה לשימוש**:
        ```python
        rows, cols = get_grid_size() # המשתמש מזין 5 ו-10
        print(rows, cols) # הפלט יהיה: 5, 10
        ```

-   **`get_generations()`**:
    -   **פרמטרים**: אין.
    -   **ערך מוחזר**: מספר שלם `generations` המייצג את מספר הדורות לסימולציה.
    -   **מטרה**: הפונקציה מבקשת מהמשתמש להזין את מספר הדורות לסימולציה ומבצעת בדיקות תקינות על הקלט. היא ממשיכה לבקש קלט עד שהמשתמש מזין מספר שלם חיובי.
    -   **דוגמה לשימוש**:
        ```python
        generations = get_generations() # המשתמש מזין 10
        print(generations) # הפלט יהיה: 10
        ```

-   **`get_initial_config(rows, cols)`**:
    -   **פרמטרים**: `rows` (מספר השורות), `cols` (מספר העמודות).
    -   **ערך מוחזר**: רשימה של מחרוזות המייצגות את התצורה ההתחלתית של הרשת.
    -   **מטרה**: הפונקציה שואלת את המשתמש אם ליצור תצורה אקראית או להזין תצורה ידנית. אם המשתמש בוחר להזין ידנית, הפונקציה מבקשת מהמשתמש להזין את התצורה שורה אחר שורה ומבצעת בדיקות תקינות על הקלט. אם המשתמש בוחר תצורה אקראית, הפונקציה מייצרת תצורה אקראית של תאים חיים ומתים.
    -   **דוגמה לשימוש**:
        ```python
        config = get_initial_config(2, 3) # המשתמש בוחר תצורה ידנית ומזין שתי שורות
        # לדוגמה:
        # *  
        #  *
        print(config)  # הפלט יהיה: ['*  ', '  *']
        ```

-   **`create_grid(rows, cols, initial_config=None)`**:
    -   **פרמטרים**: `rows` (מספר השורות), `cols` (מספר העמודות), `initial_config` (תצורה התחלתית אופציונלית).
    -   **ערך מוחזר**: רשימה של רשימות (רשת משחק) המייצגת את מצב התאים.
    -   **מטרה**: הפונקציה יוצרת את רשת המשחק. אם `initial_config` מסופקת, היא משתמשת בה. אחרת, היא מייצרת רשת אקראית עם תאים חיים ומתים.
    -   **דוגמה לשימוש**:
        ```python
        grid = create_grid(2, 3, ['*  ', '  *']) # שימוש בתצורה ידנית
        print(grid) # הפלט יהיה: [['*', ' ', ' '], [' ', ' ', '*']]

        grid = create_grid(2, 3) # יצירת תצורה אקראית
        print(grid) # הפלט יהיה: לדוגמה [[' ', '*', ' '], ['*', ' ', '*']]
        ```

-   **`print_grid(grid)`**:
    -   **פרמטרים**: `grid` (רשת המשחק).
    -   **ערך מוחזר**: אין.
    -   **מטרה**: הפונקציה מדפיסה את רשת המשחק למסך, כאשר כל שורה מודפסת בשורה נפרדת ומופרדת על ידי קו.
    -   **דוגמה לשימוש**:
        ```python
        grid = [['*', ' ', ' '], [' ', ' ', '*']]
        print_grid(grid)
        # הפלט יהיה:
        # *
        #   *
        # ---
        ```

-   **`count_live_neighbours(grid, row, col)`**:
    -   **פרמטרים**: `grid` (רשת המשחק), `row` (אינדקס השורה), `col` (אינדקס העמודה).
    -   **ערך מוחזר**: מספר שלם המייצג את מספר השכנים החיים לתא נתון.
    -   **מטרה**: הפונקציה סופרת כמה תאים חיים (עם הערך '\*') יש מסביב לתא הנתון (בסביבת 3x3).
    -   **דוגמה לשימוש**:
        ```python
        grid = [['*', '*', ' '], [' ', '*', ' '], ['*', ' ', ' ']]
        live_count = count_live_neighbours(grid, 1, 1)
        print(live_count) # הפלט יהיה: 3
        ```

-   **`apply_rules(grid, row, col)`**:
    -   **פרמטרים**: `grid` (רשת המשחק), `row` (אינדקס השורה), `col` (אינדקס העמודה).
    -   **ערך מוחזר**: מחרוזת '\*' (חי) או ' ' (מת) המייצגת את מצב התא בדור הבא.
    -   **מטרה**: הפונקציה מיישמת את חוקי המשחק של "החיים" כדי לקבוע את מצב התא בדור הבא.
    -   **דוגמה לשימוש**:
        ```python
         grid = [['*', '*', ' '], [' ', '*', ' '], ['*', ' ', ' ']]
         new_cell_state = apply_rules(grid, 1, 1)
         print(new_cell_state) # הפלט יהיה: '*' (בגלל 3 שכנים)
        ```

-   **`next_generation(grid)`**:
    -   **פרמטרים**: `grid` (רשת המשחק).
    -   **ערך מוחזר**: רשימה של רשימות (רשת משחק) המייצגת את הדור הבא של המשחק.
    -   **מטרה**: הפונקציה מייצרת את הדור הבא של רשת המשחק, על ידי יישום החוקים על כל תא ברשת הנוכחית.
    -    **דוגמה לשימוש**:
         ```python
        grid = [['*', '*', ' '], [' ', '*', ' '], ['*', ' ', ' ']]
        new_grid = next_generation(grid)
        print(new_grid) # הפלט יהיה לדוגמה: [['*', '*', '*'], ['*', '*', '*'], ['*', '*', ' ']]
         ```

-   **`play_game_of_life()`**:
    -   **פרמטרים**: אין.
    -   **ערך מוחזר**: אין.
    -   **מטרה**: הפונקציה הראשית שמנהלת את המשחק. היא מאתחלת את גודל הרשת, מספר הדורות, את התצורה הראשונית, ויוצרת את רשת המשחק. לאחר מכן, היא רצה בלולאה על הדורות, מדפיסה את הרשת, ומעדכנת אותה. בסיום הסימולציה, מדפיסה את מצב הרשת הסופי.
    -  **דוגמה לשימוש**:
        ```python
        play_game_of_life() # מפעיל את המשחק
        ```
**משתנים (Variables):**

-   `rows`, `cols`: מספר השורות והעמודות של רשת המשחק (מספרים שלמים).
-   `generations`: מספר הדורות לסימולציה (מספר שלם).
-   `initial_config`: תצורה ראשונית של המשחק (רשימה של מחרוזות).
-   `grid`: רשת המשחק הנוכחית (רשימה של רשימות).
-   `new_grid`: רשת המשחק של הדור הבא (רשימה של רשימות).
-   `row`, `col`, `i`, `j`: משתנים המשמשים ללולאות ועבור אינדקסים של שורות ועמודות.
-   `count`: משתנה המשמש לספירת השכנים החיים של תא.
-   `live_neighbours`: מספר השכנים החיים של תא מסוים.

**בעיות אפשריות ותחומים לשיפור:**

-   **קלט משתמש**: הקלט מהמשתמש יכול להיות לא תקין (למשל, מחרוזת במקום מספר), וישנן בדיקות תקינות אבל הן בסיסיות. כדאי להוסיף בדיקות קלט נוספות, כמו למשל בדיקה שהקלט אינו שלילי.
-  **ביצועים**: עבור רשתות גדולות ומספר דורות גדול, המשחק עלול לרוץ לאט. ניתן לשפר את הביצועים באמצעות אופטימיזציות לקוד.
-  **תצוגה**: התצוגה הגרפית של המשחק בסיסית. אפשר לשקול שימוש בספריות גרפיות ליצירת תצוגה ויזואלית טובה יותר.
-  **יחידות**: כדאי להשתמש בפונקציות עזר קטנות עבור כל פעולה קטנה, למשל פונקציה לבדוק אם התא חי.
-  **בדיקות אוטומטיות**: אין בדיקות אוטומטיות. כדאי להוסיף בדיקות יחידה על מנת לוודא שהקוד עובד כמו שצריך.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

-  הקוד אינו מקיים שרשרת קשרים עם חלקים אחרים בפרויקט, מכיוון שהוא משחק עצמאי.
-  אם המשחק היה חלק מפרויקט גדול יותר, ניתן היה לחבר אותו למודולים אחרים, למשל מודול ליצירת ממשק משתמש גרפי, מודול לשמירת נתונים, וכו.