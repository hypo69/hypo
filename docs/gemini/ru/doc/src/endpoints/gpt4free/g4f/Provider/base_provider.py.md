# Документация модуля `base_provider.py`

## Обзор

Модуль `base_provider.py` определяет базовые классы и типы, используемые для реализации различных провайдеров (providers) в проекте `hypotez`. Он предоставляет основу для создания классов, взаимодействующих с различными API для генерации текста, а также содержит общие структуры данных для обработки запросов и ответов.

## Подробней

Этот модуль служит основой для создания новых провайдеров, обеспечивая единый интерфейс и структуру для работы с различными сервисами генерации текста. Он определяет базовые классы, которые должны быть унаследованы при реализации конкретного провайдера, а также типы данных для представления потоковых (streaming) ответов и результатов завершения разговора (conversation).

## Классы

### `BaseProvider`

**Описание**: Базовый класс для всех провайдеров.

**Принцип работы**:
Определяет общие атрибуты и методы, которые должны быть реализованы в каждом конкретном провайдере.

**Атрибуты**:
- `name` (str): Имя провайдера.
- `ai_prefix` (str): Префикс, используемый для идентификации сообщений от AI. По умолчанию `"Assistant"`.
- `user_prefix` (str): Префикс, используемый для идентификации сообщений от пользователя. По умолчанию `"User"`.
- `supports_stream` (bool): Указывает, поддерживает ли провайдер потоковую передачу данных. По умолчанию `False`.
- `working` (bool): Указывает, работает ли провайдер. По умолчанию `True`.
- `model` (str): Указывает, какую модель использует провайдер. По умолчанию `None`.
- `needs_auth` (bool): Указывает, требуется ли аутентификация для использования провайдера. По умолчанию `False`.

**Методы**:
- `__init__(name: str = None, model: str = None)`: Конструктор класса.
- `_create_completion(model: str, prompt: str, stream: bool, *args, **kwargs)`: Абстрактный метод для создания завершения (completion).
- `create_completion(model: str, prompt: str, stream: bool, *args, **kwargs)`: Метод для создания завершения, который вызывает `_create_completion` и обрабатывает исключения.
- `_create_conversation(model: str, messages: list[dict[str, str]], stream: bool = False, *args, **kwargs)`: Абстрактный метод для создания разговора (conversation).
- `create_conversation(model: str, messages: list[dict[str, str]], stream: bool = False, *args, **kwargs)`: Метод для создания разговора, который вызывает `_create_conversation` и обрабатывает исключения.
- `get_sources(prompt: str, model: str)`: Метод для получения источников (sources) для данного промпта и модели.

### `AsyncProvider`

**Описание**: Базовый класс для асинхронных провайдеров.

**Принцип работы**:
Определяет асинхронные версии методов для создания завершений и разговоров.

**Атрибуты**:
- Все атрибуты от `BaseProvider`.

**Методы**:
- `_create_completion(model: str, prompt: str, stream: bool, *args, **kwargs)`: Асинхронный абстрактный метод для создания завершения.
- `create_completion(model: str, prompt: str, stream: bool, *args, **kwargs)`: Асинхронный метод для создания завершения, который вызывает `_create_completion` и обрабатывает исключения.
- `_create_conversation(model: str, messages: list[dict[str, str]], stream: bool = False, *args, **kwargs)`: Асинхронный абстрактный метод для создания разговора.
- `create_conversation(model: str, messages: list[dict[str, str]], stream: bool = False, *args, **kwargs)`: Асинхронный метод для создания разговора, который вызывает `_create_conversation` и обрабатывает исключения.

## Функции

### `get_cookies`

```python
def get_cookies(url: str) -> dict:
    """
    Функция получает куки для заданного URL.

    Args:
        url (str): URL, для которого нужно получить куки.

    Returns:
        dict: Словарь с куками.

    Raises:
        Exception: Если возникает ошибка при получении куки.

    Как работает функция:
    1. Инициализирует веб-драйвер Firefox.
    2. Открывает заданный URL в браузере.
    3. Получает куки из браузера.
    4. Закрывает браузер.
    5. Возвращает словарь с куками.

    ASCII flowchart:
    A [Инициализация Firefox драйвера]
    ↓
    B [Открытие URL в браузере]
    ↓
    C [Извлечение куки]
    ↓
    D [Закрытие браузера]
    ↓
    E [Возврат куки]

    Примеры:
    >>> get_cookies("https://example.com")
    {'cookie1': 'value1', 'cookie2': 'value2'}
    """
```

### `format_prompt`

```python
def format_prompt(prompt: str, ai_prefix: str, user_prefix: str) -> str:
    """
    Форматирует промпт, добавляя префиксы AI и пользователя.

    Args:
        prompt (str): Исходный промпт.
        ai_prefix (str): Префикс AI.
        user_prefix (str): Префикс пользователя.

    Returns:
        str: Отформатированный промпт.

    Как работает функция:
    1. Добавляет префикс пользователя в начало промпта.
    2. Добавляет префикс AI в конец промпта.
    3. Возвращает отформатированный промпт.

    ASCII flowchart:
    A [Добавление префикса пользователя в начало промпта]
    ↓
    B [Добавление префикса AI в конец промпта]
    ↓
    C [Возврат отформатированного промпта]

    Примеры:
    >>> format_prompt("Hello", "Assistant", "User")
    "User: Hello\\nAssistant:"
    """