# Анализ кода модуля `utils.py`

**Качество кода**
9
-  Плюсы
    - Код содержит ряд полезных функций для работы с шифрованием, кодированием и обработки данных, которые, по-видимому, используются для взаимодействия с Mega API.
    - Присутствует разделение на отдельные функции для выполнения конкретных задач.
    - Используются стандартные библиотеки `base64`, `struct`, `binascii`, `Crypto.Cipher.AES` для выполнения соответствующих операций.
    - Есть функция для разбиения данных на чанки (`get_chunks`), что может быть полезно для передачи больших файлов.
-  Минусы
    -  Отсутствует описание модуля и документация для функций в формате RST.
    -  Не хватает обработки ошибок, что может привести к непредсказуемому поведению.
    -  Используется приведение типов `type(b) == str`, что является плохой практикой. Необходимо проверять тип с помощью `isinstance`
    -  В функции `base64urlencode` кодирование в utf-8  выглядит как предположение и должно быть более явно прописано, либо  преобразование к `bytes` должно быть вынесено за пределы функции.

**Рекомендации по улучшению**

1.  Добавить описание модуля в начале файла.
2.  Добавить документацию в формате RST для всех функций.
3.  Использовать `isinstance` для проверки типа вместо `type(b) == str`.
4.  Обработать исключения в функциях для большей надежности.
5.  Уточнить кодировку при преобразовании в base64 в `base64urlencode`, например явно указать параметр кодировки, или сделать преобразование к байтам явным и вынести за функцию.
6.  Использовать `logger` для логирования ошибок и отладки.
7.  Переименовать переменную `b` в `data` в функции `str_to_a32` для ясности.
8.  Заменить магические числа в `get_chunks` на константы с описанием.
9.  Использовать f-строки для форматирования.

**Оптимизированный код**

```python
# -*- coding: utf-8 -*-
"""
Модуль содержит набор утилит для работы с шифрованием и кодированием данных,
используемых при взаимодействии с Mega API.
==============================================================================

Этот модуль предоставляет функции для преобразования данных в различные форматы,
шифрования и дешифрования с использованием AES, а также для работы с Base64 URL.

Примеры использования
--------------------

Пример шифрования данных:

.. code-block:: python

    key = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
    data = [0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f]
    encrypted_data = aes_cbc_encrypt_a32(data, key)

Пример кодирования Base64 URL:

.. code-block:: python

    data = b'Some data to encode'
    encoded_data = base64urlencode(data)

"""
import base64
import struct
import binascii
from typing import Union, List, Dict
from pathlib import Path
from Crypto.Cipher import AES
from src.logger.logger import logger


CHUNK_SIZE = 0x20000  # Размер чанка
MAX_CHUNKS = 8  # Максимальное количество чанков

def a32_to_str(a: List[int]) -> bytes:
    """
    Преобразует список 32-битных целых чисел в строку байтов.

    Args:
        a (List[int]): Список 32-битных целых чисел.

    Returns:
        bytes: Строка байтов.
    """
    return struct.pack(f'>{len(a)}I', *a)

def aes_cbc_encrypt(data: bytes, key: bytes) -> bytes:
    """
    Шифрует данные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для шифрования.
        key (bytes): Ключ шифрования.

    Returns:
        bytes: Зашифрованные данные.
    """
    # Код инициализирует шифратор AES в режиме CBC с нулевым вектором инициализации.
    encryptor = AES.new(key, AES.MODE_CBC, b'\\0' * 16)
    # Код возвращает зашифрованные данные.
    return encryptor.encrypt(data)


def aes_cbc_encrypt_a32(data: List[int], key: List[int]) -> List[int]:
    """
    Шифрует список 32-битных целых чисел с использованием AES в режиме CBC.

    Args:
        data (List[int]): Список 32-битных целых чисел, представляющих данные.
        key (List[int]): Список 32-битных целых чисел, представляющих ключ.

    Returns:
        List[int]: Зашифрованные данные в виде списка 32-битных целых чисел.
    """
    # Код возвращает зашифрованные данные преобразованные обратно в список 32-битных целых чисел
    return str_to_a32(aes_cbc_encrypt(a32_to_str(data), a32_to_str(key)))


def str_to_a32(data: Union[str, bytes]) -> List[int]:
    """
    Преобразует строку или байтовую строку в список 32-битных целых чисел.

    Args:
        data (Union[str, bytes]): Строка или байтовая строка для преобразования.

    Returns:
        List[int]: Список 32-битных целых чисел.
    """
    # Код проверяет длину входящих данных и при необходимости дополняет её до кратности 4.
    if isinstance(data, str):
        data = data.encode('utf-8')

    if len(data) % 4:
        data += b'\\0' * (4 - len(data) % 4)
    # Код форматирует данные в виде 32-битных целых чисел и преобразует их в список.
    fmt = f'>{len(data) // 4}I'
    return struct.unpack(fmt, data)


def mpi2int(s: bytes) -> int:
    """
    Преобразует многоразрядное целое число (MPI) в целое число.

    Args:
        s (bytes): MPI в виде байтовой строки.

    Returns:
        int: Целое число.
    """
    # Код преобразует MPI в целое число.
    return int(binascii.hexlify(s[2:]), 16)


def aes_cbc_decrypt(data: bytes, key: bytes) -> bytes:
    """
    Расшифровывает данные с использованием AES в режиме CBC.

    Args:
        data (bytes): Данные для расшифрования.
        key (bytes): Ключ расшифрования.

    Returns:
        bytes: Расшифрованные данные.
    """
    # Код инициализирует дешифратор AES в режиме CBC с нулевым вектором инициализации.
    decryptor = AES.new(key, AES.MODE_CBC, b'\\0' * 16)
    # Код возвращает расшифрованные данные.
    return decryptor.decrypt(data)


def aes_cbc_decrypt_a32(data: List[int], key: List[int]) -> List[int]:
    """
    Расшифровывает список 32-битных целых чисел с использованием AES в режиме CBC.

    Args:
        data (List[int]): Список 32-битных целых чисел, представляющих данные.
        key (List[int]): Список 32-битных целых чисел, представляющих ключ.

    Returns:
        List[int]: Расшифрованные данные в виде списка 32-битных целых чисел.
    """
    # Код возвращает расшифрованные данные преобразованные обратно в список 32-битных целых чисел
    return str_to_a32(aes_cbc_decrypt(a32_to_str(data), a32_to_str(key)))


def base64urldecode(data: str) -> bytes:
    """
    Декодирует строку из формата Base64 URL.

    Args:
        data (str): Строка в формате Base64 URL.

    Returns:
        bytes: Декодированные данные.
    """
    # Код добавляет недостающие символы '=' для правильной работы декодирования Base64.
    data += '=='[(2 - len(data) * 3) % 4:]
    # Код заменяет символы, специфичные для URL, на стандартные символы Base64.
    for search, replace in (('-', '+'), ('_', '/'), (',', '')):
        data = data.replace(search, replace)
    # Код возвращает декодированные данные.
    try:
         return base64.b64decode(data)
    except Exception as e:
        logger.error(f'Ошибка при декодировании base64url: {data}', exc_info=True)
        return b''


def base64_to_a32(s: str) -> List[int]:
    """
    Декодирует строку Base64 URL в список 32-битных целых чисел.

    Args:
        s (str): Строка в формате Base64 URL.

    Returns:
        List[int]: Список 32-битных целых чисел.
    """
    # Код возвращает преобразованные данные в виде списка 32-битных целых чисел
    return str_to_a32(base64urldecode(s))

def base64urlencode(data: Union[bytes,str]) -> str:
    """
    Кодирует байтовую строку в формат Base64 URL.

    Args:
        data (Union[bytes,str]): Строка байтов для кодирования.

    Returns:
        str: Строка в формате Base64 URL.
    """
    if isinstance(data, str):
        data = data.encode('utf-8')
    # Код кодирует данные в Base64 и затем преобразует в строку.
    data = base64.b64encode(data).decode('utf-8')
    # Код заменяет символы, специфичные для Base64, на символы для URL.
    for search, replace in (('+', '-'), ('/', '_'), ('=', '')):
        data = data.replace(search, replace)
    # Код возвращает закодированную строку.
    return data


def a32_to_base64(a: List[int]) -> str:
    """
    Кодирует список 32-битных целых чисел в строку Base64 URL.

    Args:
        a (List[int]): Список 32-битных целых чисел.

    Returns:
        str: Строка в формате Base64 URL.
    """
    # Код возвращает закодированную строку
    return base64urlencode(a32_to_str(a))


def get_chunks(size: int) -> Dict[int, int]:
    """
    Разбивает размер файла на чанки для загрузки.

    Args:
        size (int): Размер файла в байтах.

    Returns:
        Dict[int, int]: Словарь, где ключ - начальная позиция чанка, а значение - размер чанка.
    """
    chunks = {}
    p = pp = 0
    i = 1
    # Код определяет размер чанков до достижения максимального количества или размера файла.
    while i <= MAX_CHUNKS and p < size - i * CHUNK_SIZE:
        chunks[p] = i * CHUNK_SIZE
        pp = p
        p += chunks[p]
        i += 1
    # Код определяет размер оставшихся чанков, устанавливая их размер равным 0x100000.
    while p < size:
        chunks[p] = 0x100000
        pp = p
        p += chunks[p]
    # Код корректирует размер последнего чанка и удаляет его, если он нулевой.
    chunks[pp] = size - pp
    if not chunks[pp]:
        del chunks[pp]
    # Код возвращает словарь чанков.
    return chunks
```