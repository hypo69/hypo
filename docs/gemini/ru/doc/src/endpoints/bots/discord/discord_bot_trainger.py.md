# Модуль discord_bot_trainger

## Обзор

Модуль предназначен для создания и управления Discord-ботом, способным взаимодействовать с пользователями через текстовые команды и голосовой чат. Бот может обучаться на предоставленных данных, отвечать на вопросы, архивировать файлы и выполнять другие задачи, связанные с обработкой текста и речи.

## Подробней

Этот модуль является частью проекта `hypotez` и отвечает за интеграцию с платформой Discord. Он предоставляет функциональность для создания бота, который может подключаться к серверам Discord, обрабатывать команды пользователей, обучать модель искусственного интеллекта и взаимодействовать с пользователями через текст и голос.

## Классы

### `commands.Bot`

**Описание**: Класс `commands.Bot` из библиотеки `discord.ext` является основным классом для создания Discord-бота. Он наследует от класса `discord.Client` и добавляет функциональность для обработки команд.

**Аттрибуты**:

- `command_prefix` (str): Префикс, используемый для вызова команд бота.
- `intents` (discord.Intents): Определяет, какие события бот будет отслеживать.

**Методы**:

- `on_ready()`: Обработчик события, вызываемый при успешном подключении бота к Discord.
- `command()`: Декоратор для регистрации команд бота.
- `process_commands()`: Метод для обработки входящих сообщений и вызова соответствующих команд.

### `Model`

**Описание**: Класс `Model` из модуля `src.ai.openai.model.training` представляет модель искусственного интеллекта, используемую для обучения и предсказаний.

**Методы**:

- `train(data: str, data_dir: str, positive: bool) -> str`: Запускает процесс обучения модели на основе предоставленных данных.
- `predict(test_data: str) -> str`: Выполняет предсказания на основе предоставленных тестовых данных.
- `archive_files(directory: str)`: Архивирует файлы в указанной директории.
- `select_dataset_and_archive(path_to_dir_positive: str, positive: bool) -> str`: Выбирает и архивирует набор данных для обучения модели.
- `send_message(message: str) -> str`: Отправляет сообщение в модель и возвращает ответ.
- `handle_errors(predictions: str, test_data: str)`: Обрабатывает ошибки, возникшие в процессе предсказаний.
- `save_job_id(job_id: str, message: str)`: Сохраняет идентификатор задачи обучения.

## Функции

### `on_ready`

```python
@bot.event
async def on_ready():
    """Called when the bot is ready."""
```

**Назначение**: Обработчик события `on_ready`, вызываемый при успешном подключении бота к Discord.

**Как работает функция**:
1. Логирует сообщение об успешном входе в систему, используя `logger.info`.

**Примеры**:

```python
# Пример вызова функции on_ready (вызывается автоматически при подключении бота)
# Нет параметров для передачи, вызывается автоматически библиотекой discord.py
```

### `hi`

```python
@bot.command(name='hi')
async def hi(ctx):
    """Welcome message."""
```

**Назначение**: Команда `hi`, отправляющая приветственное сообщение в чат.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды, содержащий информацию о канале, пользователе и сервере.

**Как работает функция**:
1. Логирует вызов команды `hi` с контекстом, используя `logger.info`.
2. Отправляет приветственное сообщение "HI!" в канал, из которого была вызвана команда.
3. Возвращает `True`.

**Примеры**:

```python
# Пример вызова команды hi в Discord:
# !hi
```

### `join`

```python
@bot.command(name='join')
async def join(ctx):
    """Connect the bot to the voice channel."""
```

**Назначение**: Команда `join`, подключающая бота к голосовому каналу, в котором находится пользователь, вызвавший команду.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.

**Как работает функция**:

1. Проверяет, находится ли автор команды в голосовом канале.
2. Если автор находится в голосовом канале, подключает бота к этому каналу и отправляет сообщение об успешном подключении.
3. Если автор не находится в голосовом канале, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды join в Discord:
# !join
```

### `leave`

```python
@bot.command(name='leave')
async def leave(ctx):
    """Disconnect the bot from the voice channel."""
```

**Назначение**: Команда `leave`, отключающая бота от голосового канала.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.

**Как работает функция**:
1. Проверяет, подключен ли бот к голосовому каналу.
2. Если бот подключен к голосовому каналу, отключает бота от этого канала и отправляет сообщение об успешном отключении.
3. Если бот не подключен к голосовому каналу, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды leave в Discord:
# !leave
```

### `train`

```python
@bot.command(name='train')
async def train(ctx, data: str = None, data_dir: str = None, positive: bool = True, attachment: discord.Attachment = None):
    """Train the model with the provided data."""
```

**Назначение**: Команда `train`, запускающая процесс обучения модели на основе предоставленных данных.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `data` (str, optional): Текстовые данные для обучения модели.
- `data_dir` (str, optional): Путь к директории с данными для обучения модели.
- `positive` (bool, optional): Указывает, являются ли предоставленные данные позитивными или негативными. По умолчанию `True`.
- `attachment` (discord.Attachment, optional): Файл с данными для обучения модели, прикрепленный к сообщению.

**Как работает функция**:
1. Проверяет, есть ли прикрепленный файл к сообщению.
2. Если файл прикреплен, сохраняет его во временную директорию и устанавливает `data` в путь к этому файлу.
3. Вызывает метод `train` объекта `model` с предоставленными данными.
4. Если обучение запущено успешно, отправляет сообщение с идентификатором задачи.
5. Если запуск обучения не удался, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды train в Discord с текстовыми данными:
# !train Данные для обучения

# Пример вызова команды train в Discord с прикрепленным файлом:
# !train file.txt
```

### `test`

```python
@bot.command(name='test')
async def test(ctx, test_data: str):
    """Test the model with the provided test data."""
```

**Назначение**: Команда `test`, запускающая процесс тестирования модели на основе предоставленных данных.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `test_data` (str): Тестовые данные в формате JSON.

**Как работает функция**:
1. Пытается загрузить тестовые данные из JSON-строки.
2. Вызывает метод `predict` объекта `model` с загруженными данными.
3. Если предсказания получены успешно, отправляет сообщение с результатами.
4. Если получение предсказаний не удалось, отправляет сообщение об ошибке.
5. Если тестовые данные имеют неверный формат, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды test в Discord:
# !test {"text": "Тестовый текст"}
```

### `archive`

```python
@bot.command(name='archive')
async def archive(ctx, directory: str):
    """Archive files in the specified directory."""
```

**Назначение**: Команда `archive`, архивирующая файлы в указанной директории.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `directory` (str): Путь к директории для архивации.

**Как работает функция**:
1. Вызывает метод `archive_files` объекта `model` с указанной директорией.
2. Если архивация выполнена успешно, отправляет сообщение об успехе.
3. Если в процессе архивации произошла ошибка, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды archive в Discord:
# !archive /path/to/directory
```

### `select_dataset`

```python
@bot.command(name='select_dataset')
async def select_dataset(ctx, path_to_dir_positive: str, positive: bool = True):
    """Select a dataset for training the model."""
```

**Назначение**: Команда `select_dataset`, выбирающая набор данных для обучения модели.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `path_to_dir_positive` (str): Путь к директории с позитивными данными.
- `positive` (bool, optional): Указывает, являются ли данные позитивными или негативными. По умолчанию `True`.

**Как работает функция**:
1. Вызывает метод `select_dataset_and_archive` объекта `model` с указанным путем к директории и флагом `positive`.
2. Если выбор набора данных выполнен успешно, отправляет сообщение об успехе.
3. Если выбор набора данных не удался, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды select_dataset в Discord:
# !select_dataset /path/to/positive/data
```

### `instruction`

```python
@bot.command(name='instruction')
async def instruction(ctx):
    """Display the instruction message from an external file."""
```

**Назначение**: Команда `instruction`, отображающая инструкцию из внешнего файла.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.

**Как работает функция**:
1. Пытается прочитать содержимое файла `_docs/bot_instruction.md`.
2. Если файл найден, отправляет его содержимое в чат.
3. Если файл не найден, отправляет сообщение об ошибке.
4. Если в процессе чтения файла произошла ошибка, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды instruction в Discord:
# !instruction
```

### `correct`

```python
@bot.command(name='correct')
async def correct(ctx, message_id: int, *, correction: str):
    """Correct a previous response by providing the message ID and the correction."""
```

**Назначение**: Команда `correct`, позволяющая исправить предыдущий ответ бота.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `message_id` (int): Идентификатор сообщения, которое нужно исправить.
- `correction` (str): Текст исправления.

**Как работает функция**:
1. Пытается получить сообщение с указанным идентификатором.
2. Если сообщение найдено, логирует исправление и сохраняет его.
3. Если сообщение не найдено, отправляет сообщение об ошибке.
4. Если в процессе получения сообщения произошла ошибка, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды correct в Discord:
# !correct 1234567890 Исправленный текст
```

### `store_correction`

```python
def store_correction(original_text: str, correction: str):
    """Store the correction for future reference or retraining."""
```

**Назначение**: Функция `store_correction`, сохраняющая исправление для дальнейшего использования.

**Параметры**:
- `original_text` (str): Оригинальный текст сообщения.
- `correction` (str): Текст исправления.

**Как работает функция**:
1. Открывает файл `corrections_log.txt` в режиме добавления.
2. Записывает в файл оригинальный текст и исправление.

**Примеры**:

```python
# Пример вызова функции store_correction:
# store_correction("Оригинальный текст", "Исправленный текст")
```

### `feedback`

```python
@bot.command(name='feedback')
async def feedback(ctx, *, feedback_text: str):
    """Submit feedback about the model's response."""
```

**Назначение**: Команда `feedback`, позволяющая отправить отзыв о работе модели.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `feedback_text` (str): Текст отзыва.

**Как работает функция**:
1. Сохраняет отзыв с помощью функции `store_correction`.
2. Отправляет сообщение с благодарностью за отзыв.

**Примеры**:

```python
# Пример вызова команды feedback в Discord:
# !feedback Отличная работа!
```

### `getfile`

```python
@bot.command(name='getfile')
async def getfile(ctx, file_path: str):
    """Attach a file from the given path."""
```

**Назначение**: Команда `getfile`, отправляющая файл из указанного пути в чат.

**Параметры**:
- `ctx` (discord.ext.commands.Context): Контекст команды.
- `file_path` (str): Путь к файлу.

**Как работает функция**:
1. Проверяет, существует ли файл по указанному пути.
2. Если файл существует, отправляет его в чат.
3. Если файл не существует, отправляет сообщение об ошибке.

**Примеры**:

```python
# Пример вызова команды getfile в Discord:
# !getfile /path/to/file.txt
```

### `text_to_speech_and_play`

```python
async def text_to_speech_and_play(text, channel):
    """Convert text to speech and play it in a voice channel."""
```

**Назначение**: Функция `text_to_speech_and_play`, преобразующая текст в речь и воспроизводящая ее в голосовом канале.

**Параметры**:
- `text` (str): Текст для преобразования в речь.
- `channel` (discord.VoiceChannel): Голосовой канал для воспроизведения речи.

**Как работает функция**:

1.  **Преобразование текста в речь**:
    - Использует библиотеку `gTTS` для преобразования текста в речь на русском языке (`lang='ru'`).
    - `tts = gTTS(text=text, lang='ru')` - Создает объект `gTTS` для преобразования текста в речь.
    
2.  **Сохранение аудиофайла**:
    - Создает временный файл с путем `/tmp/response.mp3` для сохранения сгенерированной речи.
    - `tts.save(audio_file_path)` - Сохраняет аудиофайл в формате MP3.
    
3.  **Подключение к голосовому каналу**:
    - Проверяет, подключен ли бот к голосовому каналу.
    - Если бот не подключен, подключается к указанному голосовому каналу.
    - `voice_channel = channel.guild.voice_client` - Получает текущее подключение к голосовому каналу.
    - `if not voice_channel:` - Проверяет, подключен ли бот к голосовому каналу.
    - `voice_channel = await channel.connect()` - Подключается к голосовому каналу.
    
4.  **Воспроизведение аудиофайла**:
    - Воспроизводит аудиофайл в голосовом канале с использованием `discord.FFmpegPCMAudio`.
    - `voice_channel.play(discord.FFmpegPCMAudio(audio_file_path), after=lambda ex: logger.info(f'Finished playing: {ex}'))` - Воспроизводит аудиофайл и логирует окончание воспроизведения.
    
5.  **Ожидание окончания воспроизведения**:
    - Ожидает, пока аудиофайл не будет полностью воспроизведен.
    - `while voice_channel.is_playing():` - Проверяет, воспроизводится ли звук в голосовом канале.
    - `await asyncio.sleep(1)` - Засыпает на 1 секунду.
    
6.  **Отключение от голосового канала**:
    - Отключается от голосового канала после завершения воспроизведения.
    - `await voice_channel.disconnect()` - Отключается от голосового канала.

Схема работы:
```
Начало
  │
  ├──► Преобразование текста в речь (gTTS)
  │
  ├──► Сохранение аудиофайла (/tmp/response.mp3)
  │
  ├──► Проверка подключения к голосовому каналу
  │   │
  │   ├──► Подключение к голосовому каналу (если не подключен)
  │
  ├──► Воспроизведение аудиофайла (FFmpegPCMAudio)
  │
  ├──► Ожидание окончания воспроизведения
  │
  └──► Отключение от голосового канала
  │
Конец
```

**Примеры**:

```python
# Пример вызова функции text_to_speech_and_play:
# await text_to_speech_and_play("Привет, мир!", voice_channel)
```

### `on_message`

```python
@bot.event
async def on_message(message):
    """Handle incoming messages and respond to voice commands."""
```

**Назначение**: Обработчик события `on_message`, обрабатывающий входящие сообщения и отвечающий на голосовые команды.

**Параметры**:
- `message` (discord.Message): Объект сообщения, содержащий информацию об авторе, канале и содержимом сообщения.

**Как работает функция**:

1.  **Игнорирование сообщений от самого себя**:
    - Проверяет, является ли автор сообщения ботом.
    - Если автор сообщения бот, функция завершается, чтобы избежать зацикливания.
    - `if message.author == bot.user:` - Проверяет, является ли автор сообщения ботом.
    - `return` - Завершает функцию.
    
2.  **Обработка команд**:
    - Проверяет, начинается ли сообщение с префикса команды (`PREFIX`).
    - Если сообщение начинается с префикса команды, обрабатывает команду с помощью `bot.process_commands(message)`.
    - `if message.content.startswith(PREFIX):` - Проверяет, начинается ли сообщение с префикса команды.
    - `await bot.process_commands(message)` - Обрабатывает команду.
    - `return` - Завершает функцию.
    
3.  **Обработка голосовых сообщений**:
    - Проверяет, есть ли в сообщении вложения.
    - Если в сообщении есть вложения, проверяет, является ли первое вложение аудиофайлом.
    - Если первое вложение является аудиофайлом, распознает речь в аудиофайле и отправляет распознанный текст в модель.
    - `if message.attachments:` - Проверяет, есть ли в сообщении вложения.
    - `if message.attachments[0].content_type.startswith('audio/'):` - Проверяет, является ли первое вложение аудиофайлом.
    - `recognized_text = recognizer(message.attachments[0].url)` - Распознает речь в аудиофайле.
    - `response = model.send_message(recognized_text)` - Отправляет распознанный текст в модель.
    
4.  **Обработка текстовых сообщений**:
    - Если сообщение не является командой и не содержит аудиовложений, отправляет содержимое сообщения в модель.
    - `response = model.send_message(message.content)` - Отправляет содержимое сообщения в модель.
    
5.  **Воспроизведение ответа**:
    - Проверяет, находится ли автор сообщения в голосовом канале.
    - Если автор сообщения находится в голосовом канале, преобразует ответ модели в речь и воспроизводит ее в голосовом канале.
    - Если автор сообщения не находится в голосовом канале, отправляет ответ модели в текстовый канал.
    - `if message.author.voice:` - Проверяет, находится ли автор сообщения в голосовом канале.
    - `await text_to_speech_and_play(response, message.author.voice.channel)` - Преобразует ответ модели в речь и воспроизводит ее в голосовом канале.
    - `else:` - Если автор сообщения не находится в голосовом канале.
    - `await message.channel.send(response)` - Отправляет ответ модели в текстовый канал.

**Схема работы**:
```
Начало
  │
  ├──► Проверка: Сообщение от бота?
  │   └── ДА: Завершение
  │   └── НЕТ:
  │       │
  │       ├──► Проверка: Сообщение - команда?
  │       │   └── ДА: Обработка команды (bot.process_commands)
  │       │   └── НЕТ:
  │       │       │
  │       │       ├──► Проверка: Есть вложения?
  │       │       │   └── ДА: Проверка: Аудиофайл?
  │       │       │       └── ДА: Распознавание речи (recognizer)
  │       │       │       └── НЕТ:
  │       │       │           │
  │       │       │           └──► Отправка текста сообщения в модель (model.send_message)
  │       │       │
  │       │       └── НЕТ:
  │       │           │
  │       │           └──► Отправка текста сообщения в модель (model.send_message)
  │       │
  │       └──► Проверка: Автор в голосовом канале?
  │           └── ДА: Воспроизведение ответа в голосовом канале (text_to_speech_and_play)
  │           └── НЕТ: Отправка ответа в текстовый канал (message.channel.send)
  │
Конец
```

**Примеры**:

```python
# Пример вызова события on_message (вызывается автоматически при получении сообщения)
# Нет параметров для передачи, вызывается автоматически библиотекой discord.py
```