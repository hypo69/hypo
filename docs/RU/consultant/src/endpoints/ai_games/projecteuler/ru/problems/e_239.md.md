# Анализ кода модуля e_239.md

**Качество кода**
8
- Плюсы
    - Код хорошо структурирован и представлен в формате markdown, что удобно для чтения и понимания задачи.
    - Задача четко сформулирована, и все необходимые определения присутствуют.
    - Приведены примеры, позволяющие лучше понять условия задачи.

- Минусы
    - Отсутствует код для решения задачи.
    - Не используются комментарии в формате reStructuredText (RST).
    - Не используются логирование ошибок.
    - Отсутствует обработка исключений.

**Рекомендации по улучшению**

1.  **Добавить код решения:** Необходимо реализовать алгоритм для расчета `S(N)` с учетом требований задачи.
2.  **Внедрить reStructuredText (RST):** Добавить комментарии в формате RST для улучшения читаемости и соответствия стандартам документации Python.
3.  **Реализовать логирование:** Использовать `from src.logger.logger import logger` для логирования ошибок.
4.  **Обработка исключений:** Добавить обработку исключений в коде, если это необходимо.
5.  **Использовать j_loads:** Использовать `j_loads` или `j_loads_ns` для чтения файлов, если в этом есть необходимость, или удалить, если она не используется.
6.  **Привести в соответствие имена функций, переменных и импортов:** Убедиться, что все имена соответствуют ранее обработанным файлам.

**Оптимизированный код**

```markdown
# Задача No 239
## Перестановка железнодорожных вагонов
"""
Модуль для решения задачи Project Euler 239.

=========================================================================================

Этот модуль содержит описание задачи и реализацию решения для вычисления вероятности S(N).

Задача состоит в расчете вероятности того, что случайная перестановка чисел от 1 до N
является "сублинейной", то есть имеет меньше фиксированных точек, чем floor(√N).
"""

## Условия
"""
Рассмотрим перестановку чисел от 1 до N. Назовем позицию `p` "фиксированной точкой", если число в позиции `p` равно `p`.
Например, в перестановке (1, 4, 3, 2) число 1 находится в позиции 1, а число 3 в позиции 3, таким образом, она имеет две фиксированные точки.
Пусть `f(N, k)` - количество перестановок чисел от 1 до N с ровно `k` фиксированными точками.

Например, `f(4, 0) = 9`, `f(4, 1) = 8`, `f(4, 2) = 6`, `f(4, 3) = 0` и `f(4, 4) = 1`.

Пусть `P(N, k)` - вероятность того, что случайная перестановка чисел от 1 до N имеет ровно `k` фиксированных точек, т.е. `f(N, k) / N!`.

Пусть `E(N)` - ожидаемое количество фиксированных точек в случайной перестановке чисел от 1 до N, т.е.
`E(N) = Σ k * P(N, k)` для `k = 0` до `N`.

Интересно, что `E(N) = 1` для всех `N`.

Назовем перестановку "сублинейной", если она имеет меньше фиксированных точек, чем  `floor(√N)`.

Назовем `S(N)` вероятность того, что случайная перестановка чисел от 1 до N является сублинейной.

Вы можете убедиться, что `S(10) ≈ 0.916666667`, `S(100) ≈ 0.579583333` и `S(1000) ≈ 0.367897153`.

Найдите `S(10^7)`.
Дайте ваш ответ с точностью до 9 знаков после запятой.
"""
import math
from decimal import Decimal, getcontext

from src.logger.logger import logger

getcontext().prec = 20


def subfactorial(n: int) -> Decimal:
    """
    Вычисляет субфакториал числа n.

    :param n: Целое неотрицательное число.
    :return: Субфакториал числа n.
    """
    if n == 0:
        return Decimal(1)
    if n == 1:
        return Decimal(0)
    if n == 2:
        return Decimal(1)

    result = Decimal(0)
    for k in range(n + 1):
        result += Decimal((-1) ** k) / Decimal(math.factorial(k))
    return Decimal(math.factorial(n)) * result


def calculate_s_n(n: int) -> Decimal:
    """
    Вычисляет вероятность S(N).

    :param n: Размер перестановки.
    :return: Вероятность S(N).
    """
    try:
        sublinear_limit = math.floor(math.sqrt(n))
        total_permutations = Decimal(math.factorial(n))
        sublinear_permutations = Decimal(0)

        for k in range(sublinear_limit):
            sublinear_permutations += Decimal(math.comb(n, k)) * Decimal(subfactorial(n - k))

        return sublinear_permutations / total_permutations

    except Exception as e:
        logger.error(f"Ошибка при расчете S(N) для N={n}: {e}")
        return Decimal(0)


if __name__ == "__main__":
    """
    Основная точка входа для запуска расчета.
    """
    n = 10**7
    result = calculate_s_n(n)
    print(f"S({n}) ≈ {result:.9f}")
```