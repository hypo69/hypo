# Модуль для преобразования XML и JSON данных
## Обзор

Модуль `xml_json_convertor` предоставляет утилиты для конвертации XML данных в словари и наоборот. Он включает функции для парсинга XML строк и преобразования XML деревьев элементов в словарные представления. Этот модуль используется для обработки данных, которыми обменивается PrestaShop.

## Подробнее

Этот модуль предоставляет набор функций для преобразования данных между форматами XML и JSON. Он используется для работы с API PrestaShop, которое часто требует обмена данными в формате XML.

## Функции

### `dict2xml`

```python
def dict2xml(json_obj: dict, root_name: str = "product") -> str:
    """Конвертирует JSON словарь в XML строку.

    Args:
        json_obj (dict): JSON словарь для конвертации.
        root_name (str, optional): Имя корневого элемента. По умолчанию "product".

    Returns:
        str: XML строковое представление JSON.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Функция принимает JSON-подобный словарь `json_obj` и название корневого элемента `root_name`.

2.  **Внутренняя функция `build_xml_element`**: Рекурсивно строит XML элементы на основе JSON данных.

    *   Если данные - словарь, итерируется по элементам словаря.
    *   Если ключ начинается с "@", создается атрибут для текущего XML элемента.
    *   Если ключ равен "#text", устанавливается текстовое значение для текущего XML элемента.
    *   В противном случае, создается подэлемент.

    *   Если значение является списком, итерируется по списку и рекурсивно вызывает `build_xml_element` для каждого элемента списка.
        В противном случае, рекурсивно вызывает `build_xml_element` для значения.
    *   Если данные - список, итерируется по списку и рекурсивно вызывает `build_xml_element` для каждого элемента списка.
    *   В противном случае, устанавливает текстовое значение текущего XML элемента.
3.  **Создание корневого элемента**: Создается корневой элемент с именем `root_name`.

4.  **Конвертация в XML строку**: Преобразует XML дерево в строку и возвращает её.

5.

```
A (json_obj, root_name)
│
├── B (build_xml_element) - Рекурсивное построение XML элементов
│   │
│   ├── C (data is dict) - Обработка словаря
│   │   │
│   ├── D (key.startswith("@")) - Установка атрибута
│   │   │
│   ├── E (key == "#text") - Установка текста элемента
│   │   │
│   └── F (data is list) - Обработка списка
│   │
│   └── G (Установка значения текста)
│
└── H (Создание и возврат XML строки)
```

**Примеры**:

```python
json_data = {
    "product": {
        "name": "Test Product",
        "price": "10.00"
    }
}
xml_output = dict2xml(json_data)
print(xml_output)
# Expected output: <product><name>Test Product</name><price>10.00</price></product>
```

---

### `_parse_node`

```python
def _parse_node(node: ET.Element) -> dict | str:
    """Разбирает XML узел в словарь.

    Args:
        node (ET.Element): XML элемент для разбора.

    Returns:
        dict | str: Словарное представление XML узла, или строка, если узел не имеет атрибутов или дочерних элементов.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Принимает XML узел `node` для разбора.

2.  **Обработка атрибутов**: Извлекает атрибуты узла и сохраняет их в словаре `attrs`.

    *   Пропускает атрибуты `href` (не поддерживаются при конвертации в словарь).
3.  **Извлечение значения**: Извлекает текстовое значение узла и удаляет начальные и конечные пробелы.

4.  **Формирование структуры дерева**:

    *   Если есть атрибуты, добавляет их в словарь `tree` под ключом `attrs`.
    *   Итерируется по дочерним элементам узла.
    *   Рекурсивно вызывает `_parse_node` для каждого дочернего элемента.
    *   Формирует словарь `cdict` для каждого дочернего элемента.
    *   Если дочерний элемент встречается впервые, добавляет его в словарь `tree`.
    *   Если дочерний элемент встречается несколько раз, преобразует соответствующее значение в списке и добавляет новый элемент в список.
5.  **Обработка отсутствия дочерних элементов**: Если у узла нет дочерних элементов, сохраняет текстовое значение в словаре `tree` под ключом `value`.

6.  **Возврат значения**:

    *   Если в словаре `tree` есть только ключ `value`, возвращает значение этого ключа.
    *   В противном случае, возвращает словарь `tree`.

```
A (node)
│
├── B (Обработка атрибутов)
│   │
│   └── C (Пропуск атрибутов href)
│
├── D (Извлечение значения узла)
│
├── E (Формирование структуры дерева)
│   │
│   ├── F (Обработка атрибутов)
│   │
│   ├── G (Рекурсивный вызов для дочерних элементов)
│   │
│   └── H (Обработка повторяющихся дочерних элементов)
│
└── I (Возврат значения)
```

**Примеры**:

```python
import xml.etree.ElementTree as ET
xml_string = '<root><child attr="value">text</child></root>'
root = ET.fromstring(xml_string)
result = _parse_node(root.find('child'))
print(result)
# Expected output: {'attrs': {'attr': {'value': 'value'}}, 'value': 'text'}
```

---

### `_make_dict`

```python
def _make_dict(tag: str, value: any) -> dict:
    """Создает новый словарь с тегом и значением.

    Args:
        tag (str): Имя тега XML элемента.
        value (any): Значение, связанное с тегом.

    Returns:
        dict: Словарь с именем тега в качестве ключа и значением в качестве значения словаря.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Принимает имя тега `tag` и значение `value`.

2.  **Обработка пространства имен**: Пытается извлечь пространство имен из имени тега с использованием регулярного выражения.

    *   Если пространство имен найдено, создает словарь `tag_values` со значением и пространством имен.
    *   В противном случае, `tag_values` просто равно переданному значению `value`.
3.  **Создание словаря**: Создает и возвращает словарь с именем тега в качестве ключа и `tag_values` в качестве значения.

```
A (tag, value)
│
├── B (Поиск пространства имен)
│   │
│   └── C (Извлечение пространства имен)
│
└── D (Создание и возврат словаря)
```

**Примеры**:

```python
result = _make_dict('mytag', 'myvalue')
print(result)
# Expected output: {'mytag': 'myvalue'}
```

---

### `xml2dict`

```python
def xml2dict(xml: str) -> dict:
    """Разбирает XML строку в словарь.

    Args:
        xml (str): XML строка для разбора.

    Returns:
        dict: Словарное представление XML.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Принимает XML строку `xml` для разбора.
2.  **Создание дерева элементов**: Преобразует XML строку в дерево элементов с использованием `ET.fromstring`.
3.  **Преобразование в словарь**: Вызывает функцию `ET2dict` для преобразования дерева элементов в словарь.
4.  **Возврат результата**: Возвращает словарное представление XML.

```
A (xml)
│
├── B (Создание дерева элементов)
│
└── C (Преобразование в словарь)
```

**Примеры**:

```python
xml_string = '<root><child>text</child></root>'
result = xml2dict(xml_string)
print(result)
# Expected output: {'root': {'child': {'value': 'text'}}}
```

---

### `ET2dict`

```python
def ET2dict(element_tree: ET.Element) -> dict:
    """Преобразует XML дерево элементов в словарь.

    Args:
        element_tree (ET.Element): XML дерево элементов.

    Returns:
        dict: Словарное представление XML дерева элементов.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Принимает дерево элементов XML `element_tree`.
2.  **Преобразование в словарь**: Вызывает функцию `_make_dict` для создания словаря, используя тег корневого элемента и результат `_parse_node`.
3.  **Возврат результата**: Возвращает словарное представление дерева элементов.

```
A (element_tree)
│
└── B (Преобразование в словарь)
```

**Примеры**:

```python
import xml.etree.ElementTree as ET
xml_string = '<root><child>text</child></root>'
element_tree = ET.fromstring(xml_string)
result = ET2dict(element_tree)
print(result)
# Expected output: {'root': {'child': {'value': 'text'}}}
```

---

### `presta_fields_to_xml`

```python
def presta_fields_to_xml(presta_fields_dict: dict) -> str:
    """! Конвертирует JSON словарь в XML строку с фиксированным корневым именем 'prestashop'.

    Args:
        presta_fields_dict (dict): JSON словарь, содержащий данные (без ключа 'prestashop').

    Returns:
        str: XML строковое представление JSON.
    """
    ...
```

**Как работает функция**:

1.  **Инициализация**: Функция принимает JSON словарь `presta_fields_dict`, который содержит данные для преобразования в XML.

2.  **Внутренняя функция `build_xml_element`**: Рекурсивно строит XML элементы на основе JSON данных.

    *   Если данные - словарь, итерируется по элементам словаря.
    *   Если ключ начинается с "@", создается атрибут для текущего XML элемента.
    *   Если ключ равен "#text", устанавливается текстовое значение для текущего XML элемента.
    *   В противном случае, создается подэлемент.

    *   Если значение является списком, итерируется по списку и рекурсивно вызывает `build_xml_element` для каждого элемента списка.
        В противном случае, рекурсивно вызывает `build_xml_element` для значения.
    *   Если данные - список, итерируется по списку и рекурсивно вызывает `build_xml_element` для каждого элемента списка.
    *   В противном случае, устанавливает текстовое значение текущего XML элемента.

3.  **Обработка пустого словаря**: Если `presta_fields_dict` пуст, функция возвращает пустую строку.

4.  **Определение динамического ключа**: Извлекает первый ключ из словаря `presta_fields_dict`. Этот ключ будет использован в качестве имени динамического элемента.

5.  **Создание корневого элемента "prestashop"**: Создает корневой элемент с именем "prestashop" и динамический подэлемент, используя извлеченный ключ.

6.  **Конвертация в XML строку**: Преобразует XML дерево в строку и возвращает её.

```
A (presta_fields_dict)
│
├── B (build_xml_element) - Рекурсивное построение XML элементов
│   │
│   ├── C (data is dict) - Обработка словаря
│   │   │
│   ├── D (key.startswith("@")) - Установка атрибута
│   │   │
│   ├── E (key == "#text") - Установка текста элемента
│   │   │
│   └── F (data is list) - Обработка списка
│   │
│   └── G (Установка значения текста)
│
├── H (Обработка пустого словаря)
│
├── I (Определение динамического ключа)
│
└── J (Создание корневого элемента "prestashop" и динамического подэлемента)
│
└── K (Конвертация в XML строку и возврат)
```

**Примеры**:

```python
json_data = {
    "product": {
        "name": "Test Product",
        "price": "10.00"
    }
}
xml_output = presta_fields_to_xml(json_data)
print(xml_output)
# Expected output: <prestashop><product><name>Test Product</name><price>10.00</price></product></prestashop>