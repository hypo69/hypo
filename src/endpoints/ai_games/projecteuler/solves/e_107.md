## Ответ на Задачу No 107: Минимальная стоимость соединения

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Нам дана матрица смежности, представляющая сеть, где значения - это стоимости соединения между вершинами (0 означает отсутствие соединения).
*   Задача заключается в нахождении минимальной стоимости соединения сети, при которой все вершины остаются связанными. Это эквивалентно задаче поиска минимального остовного дерева (MST) в графе.
*   Также требуется определить, сколько можно сэкономить по сравнению с полной стоимостью соединения, которую она имеет в настоящее время.

**Решение:**

1.  **Расчет полной стоимости:** Сначала необходимо вычислить полную стоимость сети, сложив стоимости всех соединений (значения в матрице, кроме 0), и затем разделить на 2, так как каждое соединение учитывается дважды (например, от 1 к 2 и от 2 к 1).
2.  **Поиск минимального остовного дерева:** Затем, применим алгоритм Прима или Краскала для нахождения минимального остовного дерева. Алгоритм Прима будет более эффективен, так как матрица смежности известна и плотная.
3.  **Расчет экономии:**  После получения минимальной стоимости соединений,  вычтем эту стоимость из полной стоимости, чтобы получить величину экономии.

### 2. Алгоритм решения

1.  Начать.
2.  **Ввод матрицы смежности** (из файла `network.txt`)
3.  **Расчет полной стоимости:**
    *   Инициализировать `full_cost` = 0
    *   Пройти по всем элементам матрицы:
        *   Если значение > 0, добавить к `full_cost`.
    *   Разделить `full_cost` на 2.
4.  **Алгоритм Прима для MST:**
    *   Инициализировать `min_cost` = 0
    *   Выбрать произвольную начальную вершину.
    *   Создать множество посещенных вершин.
    *   Пока количество посещенных вершин < количества всех вершин:
        *   Найти ребро с минимальным весом, которое соединяет посещенную вершину с непосещенной.
        *   Добавить вес этого ребра к `min_cost`.
        *   Добавить непосещенную вершину в множество посещенных.
5.  **Расчет экономии:**
    *   `savings` = `full_cost` - `min_cost`.
6.  Вывести `min_cost` и `savings`.
7.  Конец.

### 3. Реализация на Python 3.12

```python
import heapq

def calculate_full_cost(matrix):
    """Calculates the full cost of the network."""
    full_cost = 0
    for row in matrix:
        for cost in row:
            if cost > 0:
                full_cost += cost
    return full_cost // 2

def prim_mst(matrix):
    """Calculates the minimum spanning tree cost using Prim's algorithm."""
    num_vertices = len(matrix)
    visited = [False] * num_vertices
    min_cost = 0
    priority_queue = [(0, 0)]  # (cost, vertex)

    while priority_queue:
        cost, vertex = heapq.heappop(priority_queue)
        if visited[vertex]:
            continue
        visited[vertex] = True
        min_cost += cost
        for next_vertex in range(num_vertices):
            if matrix[vertex][next_vertex] > 0 and not visited[next_vertex]:
                heapq.heappush(priority_queue, (matrix[vertex][next_vertex], next_vertex))
    return min_cost

def solve_network_problem(filename):
    """Solves the network connection problem."""
    with open(filename, 'r') as file:
        matrix = []
        for line in file:
            row = list(map(int, line.split(',')))
            matrix.append(row)

    full_cost = calculate_full_cost(matrix)
    min_cost = prim_mst(matrix)
    savings = full_cost - min_cost

    return min_cost, savings

# Запускаем решение
min_cost, savings = solve_network_problem("network.txt")

print(f"Минимальная стоимость соединения: {min_cost}")
print(f"Экономия по сравнению с полной стоимостью: {savings}")

```
### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InputData((<p>Ввод матрицы<br>смежности из файла</p>))
    InputData --> CalcFullCost((<p>Расчет полной стоимости<br>сети (full_cost)</p>))
    CalcFullCost --> InitializePrim((<p>Инициализация алгоритма<br>Прима (min_cost=0)</p>))
    InitializePrim --> StartPrimLoop((<p>Начать цикл алгоритма<br>Прима</p>))
    StartPrimLoop --> FindMinEdge((<p>Найти минимальное ребро, <br>соединяющее посещенную<br>с непосещенной вершиной</p>))
    FindMinEdge --> UpdateMST((<p>Обновить min_cost, <br>добавить вершину к MST</p>))
    UpdateMST --> CheckPrimEnd((<p>Все вершины<br>посещены?</p>))
    CheckPrimEnd -- Нет --> StartPrimLoop
    CheckPrimEnd -- Да --> CalcSavings((<p>Расчет экономии:<br>savings = full_cost - min_cost</p>))
    CalcSavings --> OutputResults((<p>Вывод min_cost<br>и savings</p>))
    OutputResults --> End((Конец))
```
**Легенда:**
*   **Начало, Конец:** Начало и конец выполнения программы.
*   **Ввод матрицы смежности из файла:** Чтение матрицы смежности из файла `network.txt`.
*   **Расчет полной стоимости сети:** Вычисление полной стоимости сети путем суммирования всех весов ребер и деления результата пополам.
*   **Инициализация алгоритма Прима:** Инициализация необходимых переменных для алгоритма Прима.
*   **Начать цикл алгоритма Прима:** Начало цикла, пока не будут посещены все вершины графа.
*  **Найти минимальное ребро:** Поиск ребра с наименьшим весом, соединяющее посещенную и непосещенную вершину.
*   **Обновить min_cost, добавить вершину к MST:** Добавление стоимости найденного минимального ребра к общей стоимости минимального остовного дерева и добавление новой вершины к минимальному остовному дереву.
*   **Все вершины посещены?**: Проверка, были ли посещены все вершины. Если нет, то цикл продолжается.
*   **Расчет экономии:** Вычисление экономии как разницы между полной стоимостью и стоимостью минимального остовного дерева.
*   **Вывод min_cost и savings:** Вывод результатов минимальной стоимости и экономии.
