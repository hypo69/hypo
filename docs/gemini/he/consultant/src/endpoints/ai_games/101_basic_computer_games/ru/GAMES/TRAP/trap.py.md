# Анализ кода модуля `trap.py`

**Качество кода**

- **Соответствие требованиям к формату кода (1-10):**
    -   **Преимущества:**
        - Код хорошо структурирован и разбит на логические функции.
        - Присутствуют docstring и комментарии, объясняющие логику работы каждой функции.
        - Используются константы для размеров игрового поля, что облегчает поддержку кода.
        - Код достаточно читаемый и понятный.
    -   **Недостатки:**
        - Отсутствует использование `j_loads` или `j_loads_ns` для чтения данных.
        - Не используются логи для отслеживания ошибок и отладки, нужно добавить `logger`.
        - Комментарии не в формате RST.
        - Нужно добавить импорт logger.
        -  Некоторые комментарии избыточны и не содержат достаточно информации о целях кода.
        - Не все функции имеют подробное описание в формате reStructuredText.
        - Не используются маркеры TODO для обозначения потенциальных улучшений.
        
**Рекомендации по улучшению**
1.  **Формат документации:**
    -   Перевести все комментарии и docstring в формат reStructuredText (RST).
    -   Добавить подробное описание к каждому модулю, функции, методу и переменной.
2.  **Обработка данных:**
    -   Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` вместо стандартного `json.load` (если это необходимо для обработки данных).
3.  **Регистрация ошибок:**
    -   Использовать `from src.logger.logger import logger` для логирования ошибок и отладки.
    -   Избегать использования общих `try-except` блоков,  предпочитая логирование ошибок с помощью `logger.error`.
4. **Анализ структуры:**
     - Добавить недостающие импорты, если это необходимо.
5.  **Совершенствование кода:**
    -   Добавить маркеры `TODO` для потенциальных улучшений.
    -   Уточнить описания в docstring.

**Улучшенный код**
```python
"""
Модуль для реализации игры "Ловушка".
====================================

Этот модуль содержит функции для создания, отображения и управления игровым процессом
в игре "Ловушка", где два игрока по очереди размещают свои метки на игровом поле,
пытаясь окружить и захватить клетки противника.

Пример использования:
--------------------

.. code-block:: python

    if __name__ == "__main__":
        play_trap_game()

"""
import copy  # Импорт модуля copy для создания глубоких копий списков
from src.logger.logger import logger # Импортируем логгер #

# Размер игрового поля
BOARD_SIZE = 7


def create_board():
    """
    Создает и возвращает пустое игровое поле.

    :return: Двумерный список, представляющий игровое поле, заполненный нулями.
    :rtype: list[list[int]]
    """
    # Создаем двумерный список, представляющий игровое поле, заполненный нулями (пустые клетки)
    return [[0 for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]


def display_board(board):
    """
    Отображает текущее состояние игрового поля.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    """
    # Выводим номера колонок
    print("  ", end="")
    for col in range(BOARD_SIZE):
        print(f"{col} ", end="")
    print()
    # Для каждой строки игрового поля
    for row in range(BOARD_SIZE):
        # Выводим номер строки
        print(f"{row} ", end="")
        # Для каждой клетки в текущей строке
        for col in range(BOARD_SIZE):
            # Выводим содержимое клетки, заменяя 0 на '.', 1 на '1', 2 на '2'
            print(f"{\'.\' if board[row][col] == 0 else str(board[row][col])} ", end="")
        # Переход на новую строку
        print()


def is_valid_move(row, col):
    """
    Проверяет, находятся ли координаты в пределах игрового поля.

    :param row: Номер строки.
    :type row: int
    :param col: Номер столбца.
    :type col: int
    :return: True, если координаты в пределах игрового поля, иначе False.
    :rtype: bool
    """
    # Проверяем, находятся ли координаты в допустимом диапазоне (от 0 до BOARD_SIZE - 1)
    return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE


def is_cell_empty(board, row, col):
    """
    Проверяет, является ли клетка пустой.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :param row: Номер строки.
    :type row: int
    :param col: Номер столбца.
    :type col: int
    :return: True, если клетка пуста, иначе False.
    :rtype: bool
    """
    # Возвращаем True, если клетка пуста (значение 0), иначе False
    return board[row][col] == 0


def get_neighbors(row, col):
    """
    Возвращает список координат соседних клеток.

    :param row: Номер строки.
    :type row: int
    :param col: Номер столбца.
    :type col: int
    :return: Список координат соседних клеток.
    :rtype: list[tuple[int, int]]
    """
    # Возвращает список координат соседних клеток (сверху, снизу, слева, справа)
    neighbors = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        new_row, new_col = row + dr, col + dc
        if is_valid_move(new_row, new_col):
            neighbors.append((new_row, new_col))
    return neighbors


def can_capture(board, row, col, current_player):
    """
    Проверяет, может ли клетка противника быть захвачена.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :param row: Номер строки клетки для проверки.
    :type row: int
    :param col: Номер столбца клетки для проверки.
    :type col: int
    :param current_player: Номер текущего игрока.
    :type current_player: int
    :return: True, если клетка может быть захвачена, иначе False.
    :rtype: bool
    """
    # Получаем номер противника (если текущий игрок 1, то противник 2, и наоборот)
    opponent_player = 3 - current_player
    # Если клетка не принадлежит противнику, то она не может быть захвачена
    if board[row][col] != opponent_player:
        return False

    # Получаем соседние клетки
    neighbors = get_neighbors(row, col)
    # Проверяем, окружена ли клетка противника клетками текущего игрока
    # Если соседних клеток меньше 4, то клетка не может быть захвачена
    if len(neighbors) < 4:
        return False
    # Проверяем, являются ли все соседние клетки метками текущего игрока
    for neighbor_row, neighbor_col in neighbors:
        if board[neighbor_row][neighbor_col] != current_player:
            return False
    # Если все проверки пройдены, клетка может быть захвачена
    return True


def capture_cell(board, row, col, current_player):
    """
    Захватывает клетку, заменяя ее меткой текущего игрока.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :param row: Номер строки захватываемой клетки.
    :type row: int
    :param col: Номер столбца захватываемой клетки.
    :type col: int
    :param current_player: Номер текущего игрока.
    :type current_player: int
    """
    # Меняем значение клетки на значение текущего игрока
    board[row][col] = current_player


def make_move(board, row, col, current_player):
    """
    Выполняет ход игрока.

    Размещает метку текущего игрока на выбранной клетке и проверяет возможность захвата соседних клеток.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :param row: Номер строки для размещения метки.
    :type row: int
    :param col: Номер столбца для размещения метки.
    :type col: int
    :param current_player: Номер текущего игрока.
    :type current_player: int
    """
    # Размещаем метку текущего игрока на выбранной клетке
    board[row][col] = current_player
    # Получаем список соседних клеток
    neighbors = get_neighbors(row, col)
    # Проверяем, может ли клетка противника быть захвачена
    for neighbor_row, neighbor_col in neighbors:
        # Если соседняя клетка может быть захвачена
        if can_capture(board, neighbor_row, neighbor_col, current_player):
            # Захватываем клетку
            capture_cell(board, neighbor_row, neighbor_col, current_player)


def switch_player(current_player):
    """
    Переключает текущего игрока.

    :param current_player: Номер текущего игрока.
    :type current_player: int
    :return: Номер следующего игрока.
    :rtype: int
    """
    # Переключаем игрока с 1 на 2 или с 2 на 1
    return 3 - current_player


def is_board_full(board):
    """
    Проверяет, заполнено ли игровое поле.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :return: True, если все клетки заполнены, иначе False.
    :rtype: bool
    """
    # Проходим по каждой клетке на поле
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            # Если клетка пуста (значение 0), возвращаем False (поле не заполнено)
            if board[row][col] == 0:
                return False
    # Если все клетки заполнены, возвращаем True
    return True


def calculate_scores(board):
    """
    Подсчитывает количество очков каждого игрока.

    :param board: Двумерный список, представляющий игровое поле.
    :type board: list[list[int]]
    :return: Кортеж с количеством очков первого и второго игроков.
    :rtype: tuple[int, int]
    """
    # Инициализируем счетчики для каждого игрока
    player1_score = 0
    player2_score = 0
    # Проходим по каждой клетке на поле
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            # Если в клетке метка первого игрока, увеличиваем его счетчик
            if board[row][col] == 1:
                player1_score += 1
            # Если в клетке метка второго игрока, увеличиваем его счетчик
            elif board[row][col] == 2:
                player2_score += 1
    # Возвращаем счетчики игроков
    return player1_score, player2_score


def determine_winner(player1_score, player2_score):
    """
    Определяет победителя на основе подсчитанных очков.

    :param player1_score: Количество очков первого игрока.
    :type player1_score: int
    :param player2_score: Количество очков второго игрока.
    :type player2_score: int
    :return: Сообщение о победителе или ничьей.
    :rtype: str
    """
    # Если у первого игрока больше очков, объявляем его победителем
    if player1_score > player2_score:
        return "Победил игрок 1!"
    # Если у второго игрока больше очков, объявляем его победителем
    elif player2_score > player1_score:
        return "Победил игрок 2!"
    # Если количество очков одинаковое, объявляем ничью
    else:
        return "Ничья!"


def play_trap_game():
    """
     Запускает игровой процесс.

     Инициализирует игровое поле, управляет ходами игроков,
     выводит состояние игрового поля и объявляет результаты.
    """
    # Создаем новое игровое поле
    board = create_board()
    # Устанавливаем первого игрока
    current_player = 1
    # Начинаем игровой цикл
    while not is_board_full(board):
        # Выводим текущее состояние игрового поля
        display_board(board)
        # Запрашиваем координаты хода у текущего игрока
        while True:
            try:
                row = int(input(f"Игрок {current_player}, введите номер строки (0-{BOARD_SIZE - 1}): "))
                col = int(input(f"Игрок {current_player}, введите номер столбца (0-{BOARD_SIZE - 1}): "))
            except ValueError as e: # обрабатываем ValueError при некорректном вводе
                logger.error("Некорректный ввод. Пожалуйста, введите целые числа.", exc_info=True) # Логируем ошибку
                print("Некорректный ввод. Пожалуйста, введите целые числа.")
                continue
            # Проверяем, находится ли введенные координаты в пределах игрового поля
            if not is_valid_move(row, col):
                print("Некорректный ход. Координаты выходят за пределы поля.")
                continue
            # Проверяем, является ли выбранная клетка пустой
            if not is_cell_empty(board, row, col):
                print("Некорректный ход. Клетка уже занята.")
                continue
            # Если все проверки пройдены, выходим из внутреннего цикла
            break
        # Выполняем ход игрока
        make_move(board, row, col, current_player)
        # Переключаем текущего игрока
        current_player = switch_player(current_player)

    # Выводим финальное состояние игрового поля
    display_board(board)
    # Подсчитываем количество очков каждого игрока
    player1_score, player2_score = calculate_scores(board)
    # Определяем победителя
    winner = determine_winner(player1_score, player2_score)
    # Выводим результат игры
    print(f"Игрок 1: {player1_score} очков")
    print(f"Игрок 2: {player2_score} очков")
    print(winner)


# Запускаем игру
if __name__ == "__main__":
    play_trap_game()

"""
Объяснение кода:
1. **Импорт модуля `copy`**::
    - `import copy`: Импортирует модуль `copy` для создания глубоких копий списков (игрового поля).
2. **Импорт логгера**:
    - `from src.logger.logger import logger`: Импортирует логгер для отслеживания ошибок.
3. **Константы**:
    - `BOARD_SIZE = 7`: Определяет размер игрового поля (7x7).
4. **Функция `create_board()`**:
    - Создает и возвращает пустое игровое поле в виде двумерного списка, заполненного нулями.
5. **Функция `display_board(board)`**:
    - Принимает игровое поле в качестве аргумента.
    - Выводит текущее состояние игрового поля в консоль, используя символы '.' для пустых клеток, '1' для меток первого игрока и '2' для меток второго игрока.
6. **Функция `is_valid_move(row, col)`**:
    - Проверяет, находятся ли координаты (row, col) в пределах игрового поля.
    - Возвращает `True`, если координаты действительны, иначе `False`.
7. **Функция `is_cell_empty(board, row, col)`**:
    - Проверяет, является ли клетка с координатами (row, col) пустой (равна 0).
    - Возвращает `True`, если клетка пуста, иначе `False`.
8. **Функция `get_neighbors(row, col)`**:
    - Возвращает список координат соседних клеток для заданной клетки (сверху, снизу, слева и справа).
    - Исключает координаты, выходящие за границы игрового поля.
9. **Функция `can_capture(board, row, col, current_player)`**:
    - Проверяет, может ли клетка противника (с координатами row, col) быть захвачена текущим игроком.
    - Возвращает `True`, если клетка может быть захвачена, иначе `False`.
10. **Функция `capture_cell(board, row, col, current_player)`**:
    - Захватывает клетку противника, изменяя её значение на значение текущего игрока.
11. **Функция `make_move(board, row, col, current_player)`**:
    - Размещает метку текущего игрока на выбранной клетке.
    - Проверяет и захватывает соседние клетки противника, если они могут быть захвачены.
12. **Функция `switch_player(current_player)`**:
    - Меняет текущего игрока (с 1 на 2 или с 2 на 1).
13. **Функция `is_board_full(board)`**:
    - Проверяет, заполнено ли все игровое поле.
    - Возвращает `True`, если все клетки заняты, иначе `False`.
14. **Функция `calculate_scores(board)`**:
    - Подсчитывает количество меток каждого игрока на игровом поле.
    - Возвращает количество очков для каждого игрока.
15. **Функция `determine_winner(player1_score, player2_score)`**:
    - Определяет победителя на основе подсчитанных очков.
    - Возвращает сообщение о победителе или ничьей.
16. **Функция `play_trap_game()`**:
    - Основная функция, управляющая ходом игры.
    - Инициализирует игровое поле, текущего игрока, и запускает основной игровой цикл.
    - Запрашивает ходы игроков, обрабатывает их, проверяет на корректность, захватывает клетки и переключает игроков.
    - Выводит текущее состояние игрового поля и результаты игры.
17. **Запуск игры**:
    - `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_trap_game()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    - `play_trap_game()`: Вызывает функцию для начала игры.
"""
```