# Анализ кода модуля `chomp.py`

**Качество кода**
    - Соответствие требованиям по оформлению кода: 7/10
    - Плюсы:
        - Код в целом соответствует требованиям, описанным в задании.
        - Используется `numpy` для представления игрового поля.
        - Есть функции для проверки хода и отображения доски.
        - Логика игры реализована корректно.
    - Минусы:
        - Отсутствует обработка ошибок с использованием `logger.error`.
        - Нет комментариев в формате RST для функций и модуля.
        -  Используется стандартный `print` для вывода, вместо логирования.
        -  Нумерация строк и столбцов начинается с 1 для ввода, но в коде используется 0-индексация.

**Рекомендации по улучшению**
1.  **Документация:**
    -   Добавить docstring в формате reStructuredText (RST) для модуля, функций и переменных.
    -   Включить подробное описание параметров, возвращаемых значений и исключений.

2.  **Обработка ошибок:**
    -   Использовать `from src.logger.logger import logger` для логирования ошибок и отладки.
    -   Заменить стандартные `try-except` блоки на использование `logger.error` для отлова исключений.

3.  **Улучшение кода:**
    -   Избегать прямого использования `print` для вывода сообщений пользователю, заменив его на логирование через `logger.info` или `logger.debug`.
    -   Пересмотреть нумерацию строк и столбцов для ввода, чтобы избежать путаницы (можно либо перенести логику ввода в отдельную функцию и там вычитать 1, либо явно документировать, что ввод начинается с 1, а внутри используется 0).

4.  **Импорты:**
    -   Добавить импорт `from src.utils.jjson import j_loads, j_loads_ns` (хотя в данном коде он не используется, но по инструкции требуется его наличие).

**Оптимизированный код**

```python
"""
Модуль для реализации игры CHOMP.
=========================================================================================

Игра CHOMP - это стратегическая игра для двух игроков, в которой игроки по очереди "съедают"
кусочки из виртуальной плитки шоколада. Цель - заставить противника съесть "отравленный"
кусочек в левом верхнем углу.

Описание игры:
    - Игровое поле представляет собой прямоугольную сетку, заполненную "кусочками шоколада".
    - Каждый игрок в свой ход выбирает кусочек и "съедает" его вместе со всеми кусочками
      справа и снизу от него.
    - "Отравленный" кусочек находится в левом верхнем углу (0, 0).
    - Проигрывает игрок, который съедает отравленный кусочек.

Использование модуля
---------------------

Для запуска игры CHOMP, используйте функцию :func:`play_chomp`.

Пример:
    
    .. code-block:: python

        if __name__ == "__main__":
            play_chomp()

"""
import numpy as np
from src.logger.logger import logger
# from src.utils.jjson import j_loads, j_loads_ns # TODO Добавил импорт согласно инструкции

def print_board(board: np.ndarray) -> None:
    """
    Выводит текущее состояние игрового поля в консоль.

    :param board: Двумерный массив NumPy, представляющий игровое поле.
    :type board: np.ndarray
    :return: None
    """
    for row in board:
        print(" ".join(row))
        # logger.debug(f"Вывод строки доски: {' '.join(row)}") # TODO Используем logger для отладки


def is_valid_move(board: np.ndarray, row: int, col: int) -> bool:
    """
    Проверяет, является ли выбранный ход допустимым.

    :param board: Двумерный массив NumPy, представляющий игровое поле.
    :type board: np.ndarray
    :param row: Индекс строки выбранного хода.
    :type row: int
    :param col: Индекс столбца выбранного хода.
    :type col: int
    :return: True, если ход допустим, иначе False.
    :rtype: bool
    """
    rows, cols = board.shape
    if 0 <= row < rows and 0 <= col < cols and board[row, col] == 'O':
        return True
    return False


def play_chomp() -> None:
    """
    Основная функция для управления игрой CHOMP.

    Обеспечивает ввод размеров доски, обработку ходов игроков,
    проверку победы и переключение игроков.
    :return: None
    """
    while True:
        try:
            rows = int(input("Введите количество строк на доске: "))
            cols = int(input("Введите количество столбцов на доске: "))
            if rows > 0 and cols > 0:
                break
            else:
                print("Количество строк и столбцов должно быть больше нуля.")
                # logger.error(f"Некорректный ввод размеров доски: {rows=}, {cols=}") # TODO Логируем ошибку
        except ValueError:
            print("Пожалуйста, введите целое число.")
            # logger.error("Некорректный ввод, ожидается целое число") # TODO Логируем ошибку

    board = np.array([['O'] * cols for _ in range(rows)])
    current_player = 1
    game_over = False

    while not game_over:
        print_board(board)

        while True:
            try:
                row = int(input(f"Игрок {current_player}, выберите строку (начиная с 1): ")) - 1
                col = int(input(f"Игрок {current_player}, выберите столбец (начиная с 1): ")) - 1
                if is_valid_move(board, row, col):
                    break
                else:
                    print("Недопустимый ход, выберите пустую ячейку в пределах доски.")
                    # logger.debug(f"Недопустимый ход: {row=}, {col=}") # TODO Логируем невалидный ход
            except ValueError:
                print("Пожалуйста, введите целое число.")
                # logger.error("Некорректный ввод, ожидается целое число") # TODO Логируем ошибку

        board[row:, col:] = 'X'

        if board[0, 0] == 'X':
            print_board(board)
            print(f"Игрок {current_player} проиграл!")
            # logger.info(f"Игрок {current_player} проиграл.") # TODO Используем logger
            game_over = True
        else:
            current_player = 3 - current_player


if __name__ == "__main__":
    play_chomp()
```