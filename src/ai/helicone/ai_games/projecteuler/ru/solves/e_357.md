## Ответ на Задачу No 357: Простое порождение делителей

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Необходимо найти все числа `n` в диапазоне от 1 до 100,000,000, которые являются "простыми порождающими делители" числами.
*   Число `n` является "простым порождающим делители" числом, если для каждого его делителя `d`, сумма `d + n/d` является простым числом.
*   Для этого потребуется:
    1.  Функция для проверки, является ли число простым.
    2.  Функция для нахождения всех делителей числа.
    3.  Функция для проверки, является ли число "простым порождающим делители" числом.
    4.  Итерирование по диапазону и суммирование всех таких чисел.

**Решение:**
1.  **Функция `is_prime(num)`:** Проверяет, является ли число `num` простым. Возвращает `True`, если число простое, и `False` в противном случае.
2.  **Функция `get_divisors(num)`:** Возвращает список всех делителей числа `num`.
3.  **Функция `is_divisor_generating(num)`:** Проверяет, является ли число `num` "простым порождающим делители" числом. Она получает делители `num` и проверяет условие `d + n/d` на простоту. Возвращает `True`, если условие выполнено для всех делителей, и `False` в противном случае.
4.  **Основной цикл:** Итерируем по всем числам от 1 до 100,000,000.
5.  Для каждого числа вызываем функцию `is_divisor_generating`. Если она возвращает `True`, то добавляем число к общей сумме.
6.  После итерации по всем числам выводим итоговую сумму.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать переменную `total_sum` со значением 0.
3.  Определить функцию `is_prime(num)`:
    *   Если `num` меньше 2, вернуть `False`.
    *   Для каждого числа `i` от 2 до корня из `num` (включительно):
        *   Если `num` делится на `i` без остатка, вернуть `False`.
    *   Вернуть `True`.
4.  Определить функцию `get_divisors(num)`:
    *   Инициализировать пустой список `divisors`.
    *   Для каждого числа `i` от 1 до корня из `num` (включительно):
        *   Если `num` делится на `i` без остатка:
            *   Добавить `i` в `divisors`.
            *   Если `i` не равно `num / i`, добавить `num / i` в `divisors`.
    *   Вернуть список `divisors`.
5.  Определить функцию `is_divisor_generating(num)`:
    *   Получить все делители `divisors` числа `num`, используя `get_divisors`.
    *   Для каждого делителя `d` в `divisors`:
        *   Вычислить `sum_val = d + num / d`.
        *   Если `sum_val` не является простым числом, используя `is_prime`, вернуть `False`.
    *   Вернуть `True`.
6.  Для каждого числа `number` от 1 до 100,000,000:
    *   Если `is_divisor_generating(number)` возвращает `True`:
        *   Прибавить `number` к `total_sum`.
7.  Вывести `total_sum`.
8.  Конец

### 3. Реализация на Python 3.12
```python
import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def get_divisors(num):
    divisors = []
    for i in range(1, int(math.sqrt(num)) + 1):
        if num % i == 0:
            divisors.append(i)
            if i != num // i:
                divisors.append(num // i)
    return divisors

def is_divisor_generating(num):
    divisors = get_divisors(num)
    for divisor in divisors:
        sum_val = divisor + num / divisor
        if not is_prime(int(sum_val)):
            return False
    return True

def sum_of_divisor_generating_numbers(limit):
  total_sum = 0
  for number in range(1, limit + 1):
    if is_divisor_generating(number):
      total_sum += number
  return total_sum

# Пример использования:
limit = 100000000
result = sum_of_divisor_generating_numbers(limit)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeSum((Инициализировать total_sum = 0))
    InitializeSum --> LoopStart((Начать цикл: number от 1 до 100000000))
    LoopStart --> CheckDivisorGenerating((Проверить: is_divisor_generating(number)?))
    CheckDivisorGenerating -- Да --> AddToSum((Добавить number к total_sum))
    AddToSum --> LoopStart
    CheckDivisorGenerating -- Нет --> LoopStart
    LoopStart --> OutputSum((Вывести total_sum))
    OutputSum --> End((Конец))

    subgraph is_prime(num)
        A[Начало is_prime] --> B{num < 2?}
        B -- Да --> C[вернуть False]
        B -- Нет --> D[Начать цикл: i от 2 до sqrt(num)]
        D --> E{num делится на i?}
        E -- Да --> F[вернуть False]
        E -- Нет --> G[продолжить цикл]
        G --> D
        D --> H[цикл завершен]
        H --> I[вернуть True]
        C --> J[Конец is_prime]
        I --> J
    end

    subgraph get_divisors(num)
        K[Начало get_divisors] --> L[Инициализировать divisors = []]
        L --> M[Начать цикл: i от 1 до sqrt(num)]
        M --> N{num делится на i?}
        N -- Да --> O[добавить i в divisors]
        O --> P{i != num / i?}
        P -- Да --> Q[добавить num/i в divisors]
        Q --> R[продолжить цикл]
         P -- Нет --> R
        N -- Нет --> R
        R --> M
        M --> S[цикл завершен]
        S --> T[вернуть divisors]
        T --> U[Конец get_divisors]
    end

    subgraph is_divisor_generating(num)
        V[Начало is_divisor_generating] --> W[divisors = get_divisors(num)]
        W --> X[Начать цикл: divisor в divisors]
        X --> Y[sum_val = divisor + num / divisor]
        Y --> Z{is_prime(sum_val)?}
        Z -- Нет --> AA[вернуть False]
        Z -- Да --> BB[продолжить цикл]
        BB --> X
        X --> CC[цикл завершен]
        CC --> DD[вернуть True]
        AA --> EE[Конец is_divisor_generating]
        DD --> EE
    end
```

**Легенда:**
*   **Начало, Конец:** Начало и конец основного алгоритма.
*   **Инициализировать total_sum = 0:** Создаем переменную для хранения общей суммы "простых порождающих делители" чисел и присваиваем ей начальное значение 0.
*   **Начать цикл: number от 1 до 100000000:** Определяет начало и конец цикла перебора всех чисел от 1 до 100,000,000.
*   **Проверить: is_divisor_generating(number)?:** Проверяет, является ли текущее число "простым порождающим делители" числом.
*   **Добавить number к total_sum:** Если число удовлетворяет условию, добавляем его к общей сумме.
*    **Вывести total_sum:** Выводим конечную сумму.

    **Подграф `is_prime(num)`:**

    *   **Начало is_prime, Конец is_prime:** Начало и конец функции проверки простоты числа.
    *   **num < 2?:** Проверяем, меньше ли число 2.
    *   **вернуть False:** Если число меньше 2, возвращаем `False`, так как оно не является простым.
    *   **Начать цикл: i от 2 до sqrt(num):** Итерируем по числам от 2 до квадратного корня из `num`.
    *   **num делится на i?:** Проверяем, делится ли `num` на текущее число `i` без остатка.
    *   **вернуть False:** Если `num` делится на `i` без остатка, то число не является простым, и мы возвращаем `False`.
    *    **цикл завершен:** Когда цикл заканчивается, это означает, что ни один делитель не был найден, и число является простым.
    *   **вернуть True:** Возвращаем `True`, если число является простым.
    
    **Подграф `get_divisors(num)`:**
        *   **Начало get_divisors, Конец get_divisors:** Начало и конец функции получения всех делителей числа.
        *   **Инициализировать divisors = []:** Создаем пустой список для хранения делителей.
        *   **Начать цикл: i от 1 до sqrt(num):** Итерируем по числам от 1 до квадратного корня из `num`.
        *   **num делится на i?:** Проверяем, делится ли `num` на текущее число `i` без остатка.
        *    **добавить i в divisors:** Если `num` делится на `i` без остатка, добавляем `i` в список делителей.
        *    **i != num / i?:** Проверяем, является ли `i` квадратным корнем из `num`.
        *    **добавить num/i в divisors:** Если `i` не является квадратным корнем из `num`, добавляем `num/i` в список делителей.
        *    **цикл завершен:** Когда цикл заканчивается, это означает, что все делители найдены.
        *   **вернуть divisors:** Возвращаем список делителей.

   **Подграф `is_divisor_generating(num)`:**
        *   **Начало is_divisor_generating, Конец is_divisor_generating:** Начало и конец функции проверки, является ли число "простым порождающим делители" числом.
        *    **divisors = get_divisors(num):** Получаем список делителей числа `num`.
        *   **Начать цикл: divisor в divisors:** Итерируем по каждому делителю числа `num`.
        *   **sum_val = divisor + num / divisor:** Вычисляем сумму `divisor + num / divisor`.
        *    **is_prime(sum_val)?:** Проверяем, является ли `sum_val` простым числом.
        *    **вернуть False:** Если `sum_val` не является простым, то число `num` не является "простым порождающим делители" числом и возвращаем `False`.
        *   **цикл завершен:** Когда цикл заканчивается, это означает, что все делители удовлетворяют условию.
        *    **вернуть True:** Возвращаем `True`, если все делители удовлетворяют условию.
