# Модуль MetaAIAccount

## Обзор

Модуль `MetaAIAccount` является частью проекта `hypotez` и предназначен для работы с Meta AI через аккаунт пользователя. Он расширяет функциональность класса `MetaAI`, добавляя поддержку авторизации и управления cookies.

## Подробней

Этот модуль специфичен для провайдеров, требующих авторизацию. `MetaAIAccount` использует cookies для аутентификации при взаимодействии с Meta AI. Расположение этого файла в структуре проекта указывает на его роль как специализированного компонента для обработки учетных записей Meta AI в рамках g4f (GPT4Free).

## Классы

### `MetaAIAccount(MetaAI)`

**Описание**: Класс `MetaAIAccount` расширяет класс `MetaAI`, добавляя поддержку аутентификации через учетную запись пользователя.

**Наследует**:

- `MetaAI`: Базовый класс для взаимодействия с Meta AI.

**Атрибуты**:

- `needs_auth` (bool): Указывает, требуется ли авторизация для использования данного провайдера. Всегда `True` для этого класса.
- `parent` (str): Имя родительского класса, в данном случае `"MetaAI"`.
- `image_models` (List[str]): Список моделей изображений, поддерживаемых данным классом. В данном случае `["meta"]`.

**Методы**:

- `create_async_generator`: Асинхронный генератор для создания запросов к Meta AI с использованием учетной записи пользователя.

## Функции

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    cookies: Cookies = None,
    **kwargs
) -> AsyncResult:
    """
    Создает асинхронный генератор для взаимодействия с Meta AI, используя учетные данные пользователя.

    Args:
        cls (type[MetaAIAccount]): Класс, для которого создается генератор.
        model (str): Модель для использования в запросе.
        messages (Messages): Список сообщений для отправки в запросе.
        proxy (str, optional): Прокси-сервер для использования при подключении. По умолчанию `None`.
        cookies (Cookies, optional): Cookies для аутентификации. По умолчанию `None`.
        **kwargs: Дополнительные аргументы.

    Returns:
        AsyncResult: Асинхронный генератор, возвращающий чанки данных из Meta AI.
    """
```

**Назначение**: Функция `create_async_generator` создает асинхронный генератор для взаимодействия с Meta AI, используя учетные данные пользователя, хранящиеся в cookies. Она получает сообщения, модель, прокси (опционально) и cookies (опционально), после чего создает запросы к Meta AI и возвращает результаты в виде асинхронного генератора.

**Параметры**:

- `cls` (type[MetaAIAccount]): Класс, для которого создается генератор.
- `model` (str): Модель для использования в запросе.
- `messages` (Messages): Список сообщений для отправки в запросе.
- `proxy` (str, optional): Прокси-сервер для использования при подключении. По умолчанию `None`.
- `cookies` (Cookies, optional): Cookies для аутентификации. Если `None`, cookies получаются из домена ".meta.ai". По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы.

**Возвращает**:

- `AsyncResult`: Асинхронный генератор, возвращающий чанки данных из Meta AI.

**Как работает функция**:

1. **Получение cookies**: Если cookies не переданы, они извлекаются с использованием `get_cookies(".meta.ai", True, True)`.
2. **Создание генератора**: Создается экземпляр класса `MetaAIAccount` с использованием прокси (если указан).
3. **Форматирование запроса**: Сообщения форматируются с использованием `format_prompt(messages)`.
4. **Отправка запроса**: Отправляется запрос к Meta AI с использованием метода `prompt` экземпляра класса `MetaAIAccount`.
5. **Генерация результатов**: Результаты возвращаются в виде асинхронного генератора, который выдает чанки данных.

```
A: Получение или использование предоставленных cookies
|
B: Форматирование запроса (prompt)
|
C: Отправка запроса к Meta AI и получение результатов
|
D: Генерация чанков данных
```

**Примеры**:

```python
# Пример использования функции create_async_generator
messages = [{"role": "user", "content": "Привет, как дела?"}]
async for chunk in MetaAIAccount.create_async_generator(model="default", messages=messages):
    print(chunk, end="")