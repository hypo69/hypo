## ИНСТРУКЦИЯ:

Анализируй предоставленный код подробно и объясни его функциональность. Ответ должен включать три раздела:

1. **<алгоритм>**: Опиши рабочий процесс в виде пошаговой блок-схемы, включая примеры для каждого логического блока, и проиллюстрируй поток данных между функциями, классами или методами.
2. **<mermaid>**: Напиши код для диаграммы в формате `mermaid`, проанализируй и объясни все зависимости,
    которые импортируются при создании диаграммы.
    **ВАЖНО!** Убедитесь, что все имена переменных, используемые в диаграмме `mermaid`,
    имеют осмысленные и описательные имена. Имена переменных вроде `A`, `B`, `C`, и т.д., не допускаются!

    **Дополнительно**: Если в коде есть импорт `import header`, добавьте блок `mermaid` flowchart, объясняющий `header.py`:
    ```mermaid
    flowchart TD
        Start --> Header[<code>header.py</code><br> Determine Project Root]

        Header --> import[Import Global Settings: <br><code>from src import gs</code>]
    ```

3. **<объяснение>**: Предоставьте подробные объяснения:
   - **Импорты**: Их назначение и взаимосвязь с другими пакетами `src.`.
   - **Классы**: Их роль, атрибуты, методы и взаимодействие с другими компонентами проекта.
   - **Функции**: Их аргументы, возвращаемые значения, назначение и примеры.
   - **Переменные**: Их типы и использование.
   - Выделите потенциальные ошибки или области для улучшения.

Дополнительно, постройте цепочку взаимосвязей с другими частями проекта (если применимо).

Это обеспечивает всесторонний и структурированный анализ кода.
## Формат ответа: `.md` (markdown)
**КОНЕЦ ИНСТРУКЦИИ**
```markdown
## <алгоритм>

1.  **Начало**: Пользователь запускает бота командой `/start`.
    *   Пример: Пользователь вводит `/start` в чате Telegram.
2.  **`command_start_handler`**:
    *   Отправляет приветственное сообщение пользователю.
    *   Отправляет сообщение с кнопкой "Найти фильм" (с использованием `kb.find_movie`).
3.  **Нажатие на кнопку "Найти фильм"**: Пользователь нажимает кнопку `new_movies`.
    *   Пример: Пользователь нажимает кнопку "Найти фильм" в чате Telegram.
4.  **`movie_handler`**:
    *   Устанавливает состояние `Params.type_movie` в FSM (машина состояний).
    *   Запрашивает тип фильма (фильм или сериал) с помощью кнопок `kb.choice`.
5.  **Выбор типа фильма**: Пользователь выбирает тип фильма: "сериал" или "фильм".
    *   Пример: Пользователь нажимает кнопку "Сериал" или "Фильм".
6.  **`series_handler` или `film_handler`**:
    *   `series_handler` срабатывает, если выбрано "сериал"; `film_handler` — если "фильм".
    *   Удаляет сообщение с кнопками выбора типа.
    *   Обновляет данные состояния, добавляя тип фильма (`type_movie`).
    *   Устанавливает состояние `Params.name`.
    *   Запрашивает название фильма/сериала.
7.  **Ввод названия фильма/сериала**: Пользователь вводит текст с названием.
    *   Пример: Пользователь вводит "Интерстеллар" или "Игра престолов".
8.  **`name_handler`**:
    *   Обновляет данные состояния, добавляя название (`name`).
    *   Извлекает данные из состояния (`name` и `type_movie`).
    *   Вызывает функцию `search_query` с названием и типом фильма.
    *   Отправляет сообщение с введенным названием и типом.
    *   Если фильм найден:
        *   Отправляет сообщение о том, что фильм найден.
        *   Отправляет сообщение с названием, описанием и ссылкой на фильм.
    *   Если фильм не найден:
        *   Отправляет сообщение о том, что фильм не найден.
    *   Отправляет кнопку "Найти новый фильм" (`kb.find_movie`).
    *   Очищает состояние.
9.  **Повторный поиск**: Процесс можно повторить, нажав кнопку "Найти новый фильм".

## <mermaid>

```mermaid
flowchart TD
    Start(Start: /start) --> commandStartHandler
    commandStartHandler(command_start_handler: Приветствие, кнопка "Найти фильм") --> movieHandlerButton
    movieHandlerButton(Пользователь нажимает "Найти фильм") --> movieHandler
    movieHandler(movie_handler: Запрос типа фильма) --> choiceMovieType
    choiceMovieType(Выбор типа фильма: "сериал" или "фильм") --> seriesOrFilm
    
    subgraph SeriesHandler
        seriesOrFilm -- "сериал" --> seriesHandler
        seriesHandler(series_handler: Запрос названия сериала) --> setNameSeries
    end
    
    subgraph FilmHandler
        seriesOrFilm -- "фильм" --> filmHandler
        filmHandler(film_handler: Запрос названия фильма) --> setNameFilm
    end

    setNameSeries(setName: Пользователь вводит название сериала) --> nameHandler
    setNameFilm(setName: Пользователь вводит название фильма) --> nameHandler
    
    nameHandler(name_handler: Поиск фильма, вывод результата) --> newSearchButton
    newSearchButton(newSearch: Кнопка "Найти новый фильм") --> movieHandlerButton
    
    classDef stateFill fill:#f9f,stroke:#333,stroke-width:2px
    class movieHandler stateFill
    class seriesHandler stateFill
    class filmHandler stateFill
    class nameHandler stateFill
```

**Анализ зависимостей `mermaid`:**

*   **`Start`**: Начальная точка взаимодействия с ботом (команда `/start`).
*   **`commandStartHandler`**: Обработчик команды `/start`, приветствует пользователя и предлагает начать поиск фильма.
*   **`movieHandlerButton`**: Представляет действие пользователя по нажатию кнопки "Найти фильм".
*   **`movieHandler`**: Обработчик запроса нового фильма, устанавливает состояние для ввода типа фильма.
*   **`choiceMovieType`**: Представляет выбор пользователя типа фильма (сериал или фильм).
*   **`seriesOrFilm`**: Разветвление логики в зависимости от выбора типа фильма.
*   **`SeriesHandler`**: Подграф, включающий обработчик выбора сериала.
    *   **`seriesHandler`**: Обработчик выбора сериала, запрашивает название сериала.
    *   **`setNameSeries`**: Действие пользователя по вводу названия сериала.
*   **`FilmHandler`**: Подграф, включающий обработчик выбора фильма.
    *   **`filmHandler`**: Обработчик выбора фильма, запрашивает название фильма.
    *   **`setNameFilm`**: Действие пользователя по вводу названия фильма.
*   **`nameHandler`**: Обработчик ввода названия фильма/сериала, выполняет поиск и выводит результат.
*   **`newSearchButton`**: Представляет кнопку "Найти новый фильм", позволяющую повторить поиск.

**Импорты для построения диаграммы:**

В диаграмме используются следующие концепции из кода:

*   **Состояния FSM:** Представлены переходами между обработчиками.
*   **Обработчики:** Функции, такие как `command_start_handler`, `movie_handler`, `series_handler`, `film_handler` и `name_handler` представлены в виде узлов диаграммы.
*   **Действия пользователя:** Представлены переходами по нажатию кнопок и вводу текста.
*   **Кнопки клавиатуры:** Использование `kb.find_movie` и `kb.choice` отображается в логике диаграммы.

## <объяснение>

**Импорты:**

*   `from aiogram import Router, F`: Импортирует `Router` для маршрутизации сообщений и `F` для фильтрации колбеков.
*   `from aiogram.filters import CommandStart`: Импортирует `CommandStart` для фильтрации команды `/start`.
*   `from aiogram.fsm.context import FSMContext`: Импортирует `FSMContext` для управления состояниями FSM.
*   `from aiogram.fsm.state import StatesGroup, State`: Импортирует `StatesGroup` и `State` для определения состояний FSM.
*   `from aiogram.types import Message, CallbackQuery`: Импортирует `Message` и `CallbackQuery` для работы с сообщениями и колбеками.
*   `import apps.keyboard as kb`: Импортирует модуль `keyboard` из пакета `apps`, который вероятно содержит определения клавиатур для бота.
*   `from apps.search import search_query`: Импортирует функцию `search_query` из модуля `search` пакета `apps`, которая выполняет поиск фильмов.
    *   **Взаимосвязь с `src`:** Все импорты `apps` указывают на то, что код является частью более крупного проекта, и эти модули (`keyboard`, `search`) находятся внутри пакета `src/apps`.

**Классы:**

*   `class Params(StatesGroup)`: Определяет группу состояний FSM для отслеживания параметров поиска:
    *   `type_movie = State()`: Состояние для хранения типа фильма (сериал или фильм).
    *   `name = State()`: Состояние для хранения названия фильма.

**Функции:**

*   `async def command_start_handler(message: Message) -> None`:
    *   **Аргументы**: Принимает объект `Message` от пользователя.
    *   **Назначение**: Обрабатывает команду `/start`.
    *   **Пример**: Когда пользователь вводит `/start`, бот отправляет приветственное сообщение и кнопку "Найти фильм".
*   `async def movie_handler(callback: CallbackQuery, state: FSMContext) -> None`:
    *   **Аргументы**: Принимает объект `CallbackQuery` от нажатия кнопки и `FSMContext` для работы с состояниями.
    *   **Назначение**: Обрабатывает нажатие кнопки "Найти фильм", устанавливает состояние `Params.type_movie` и запрашивает тип фильма.
    *   **Пример**: Когда пользователь нажимает кнопку "Найти фильм", бот запрашивает выбор типа фильма.
*   `async def series_handler(callback: CallbackQuery, state: FSMContext) -> None`:
    *   **Аргументы**: Принимает объект `CallbackQuery` от нажатия кнопки и `FSMContext` для работы с состояниями.
    *   **Назначение**: Обрабатывает выбор "сериал", обновляет данные состояния, устанавливает состояние `Params.name` и запрашивает название сериала.
    *   **Пример**: Когда пользователь выбирает "сериал", бот запрашивает ввод названия.
*   `async def film_handler(callback: CallbackQuery, state: FSMContext) -> None`:
    *   **Аргументы**: Принимает объект `CallbackQuery` от нажатия кнопки и `FSMContext` для работы с состояниями.
    *   **Назначение**: Обрабатывает выбор "фильм", обновляет данные состояния, устанавливает состояние `Params.name` и запрашивает название фильма.
    *   **Пример**: Когда пользователь выбирает "фильм", бот запрашивает ввод названия.
*   `async def name_handler(message: Message, state: FSMContext) -> None`:
    *   **Аргументы**: Принимает объект `Message` от пользователя и `FSMContext` для работы с состояниями.
    *   **Назначение**: Обрабатывает ввод названия фильма/сериала, извлекает данные из состояния, выполняет поиск с помощью `search_query`, выводит результат.
    *   **Пример**: Когда пользователь вводит название, бот ищет фильм/сериал и отправляет результат.

**Переменные:**

*   `router = Router()`: Создает экземпляр роутера для регистрации обработчиков.
*   `type_movies = {'film': 'Фильм', 'series': 'Сериал'}`: Словарь для хранения соответствия ключей `film` и `series` их текстовым представлениям.

**Потенциальные ошибки и области для улучшения:**

*   **Обработка ошибок**: Отсутствует явная обработка ошибок, например, если `search_query` вернет ошибку.
*   **Валидация ввода**: Не проводится валидация введенного пользователем названия фильма/сериала.
*   **Улучшение поиска**: `search_query` может быть улучшена, чтобы обрабатывать частичное совпадение или более сложные запросы.
*   **Локализация**: Текстовые сообщения не локализованы на другие языки.
*   **Код повторяется**:  `series_handler` и `film_handler` имеют почти идентичный код. Его можно перенести в отдельную функцию для сокращения дублирования.

**Цепочка взаимосвязей с другими частями проекта:**

*   `hendlers.py` -> `keyboard.py`: Использует клавиатуры, определенные в `keyboard.py`.
*   `hendlers.py` -> `search.py`: Использует функцию поиска `search_query` из `search.py`.
*   `hendlers.py` -> `aiogram`: Использует FSM из `aiogram` для управления состояниями диалога.
```