"""
LIFE:
=================
Сложность: 7
-----------------
Игра "Жизнь" - это симуляция клеточного автомата, разработанная Джоном Конвеем. Игровое поле представляет собой сетку из клеток, каждая из которых может находиться в одном из двух состояний: "живая" или "мертвая". Состояние каждой клетки в следующем поколении зависит от состояния ее соседей в текущем поколении. Цель игры - наблюдать за эволюцией начальной конфигурации клеток и исследовать интересные паттерны, возникающие в процессе симуляции.

Правила игры:
1.  Игровое поле состоит из клеток, каждая из которых может быть "живой" (обозначено символом "*") или "мертвой" (обозначено пробелом).
2.  Изначально поле заполняется случайным образом или задается определенная конфигурация клеток.
3.  Переход к следующему поколению осуществляется по следующим правилам:
    -  Живая клетка с менее чем двумя живыми соседями умирает от одиночества.
    -  Живая клетка с двумя или тремя живыми соседями выживает в следующем поколении.
    -  Живая клетка с более чем тремя живыми соседями умирает от перенаселения.
    -  Мертвая клетка с ровно тремя живыми соседями оживает.
4.  Игра продолжается заданное количество поколений.

-----------------
Алгоритм:
1. Запросить у пользователя размеры поля (количество строк и столбцов).
2. Запросить у пользователя количество поколений для симуляции.
3. Создать начальное поколение: 
    - если пользователь ввел начальные данные, то использовать их.
    - если нет, то заполнить поле случайным образом живыми и мертвыми клетками.
4. Для каждого поколения от 1 до заданного количества поколений:
    4.1 Вывести на экран текущее поколение (состояние поля).
    4.2 Создать новое поле (следующее поколение), применив правила игры:
        - Для каждой клетки в текущем поле:
            - Подсчитать количество живых соседей.
            - В зависимости от состояния клетки и количества соседей в текущем поколении, определить ее состояние в новом поле согласно правилам игры.
    4.3 Обновить текущее поле новым полем.
5. По завершению симуляции вывести на экран заключительное состояние поля.

-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InputGridSize["Ввод размеров сетки: <code><b>rows, cols</b></code>"]
    InputGridSize --> InputGenerations["Ввод количества поколений: <code><b>generations</b></code>"]
    InputGenerations --> InputInitialConfig{"Ввод начальной конфигурации: <code><b>initial_config</b></code>"}
    InputInitialConfig --> CreateInitialGrid{"Создание начальной сетки: <code><b>grid</b></code>"}
    CreateInitialGrid --> LoopStart{"Начало цикла поколений: <code><b>for generation in range(generations)</b></code>"}
    LoopStart -- Да --> OutputCurrentGrid["Вывод текущей сетки: <code><b>grid</b></code>"]
    OutputCurrentGrid --> CreateNextGenerationGrid["Создание новой сетки: <code><b>next_grid</b></code>"]
    CreateNextGenerationGrid --> LoopCellsStart{"Начало цикла по клеткам: <code><b>for row in range(rows): for col in range(cols)</b></code>"}
    LoopCellsStart --> CountLiveNeighbours["Подсчет живых соседей: <code><b>live_neighbours</b></code>"]
    CountLiveNeighbours --> ApplyRules["Применение правил игры для определения состояния клетки в <code><b>next_grid</b></code>"]
    ApplyRules --> LoopCellsEnd{"Конец цикла по клеткам"}
    LoopCellsEnd --> UpdateCurrentGrid{"Обновление текущей сетки: <code><b>grid = next_grid</b></code>"}
    UpdateCurrentGrid --> LoopEnd{"Конец цикла поколений"}
     LoopEnd -- Да --> LoopStart
    LoopEnd -- Нет --> OutputFinalGrid["Вывод финальной сетки: <code><b>grid</b></code>"]
    OutputFinalGrid --> End["Конец"]

```
Legenda:
    Start - Начало программы.
    InputGridSize - Ввод размеров сетки (количество строк и столбцов) от пользователя.
    InputGenerations - Ввод количества поколений для симуляции от пользователя.
    InputInitialConfig - Ввод начальной конфигурации клеток от пользователя.
    CreateInitialGrid - Создание начальной сетки (grid) на основе введенных размеров и начальной конфигурации. Если начальная конфигурация не предоставлена, поле заполняется случайным образом.
    LoopStart - Начало цикла, который выполняется заданное количество раз (количество поколений).
    OutputCurrentGrid - Вывод на экран текущего состояния сетки (grid).
    CreateNextGenerationGrid - Создание новой сетки (next_grid), которая будет представлять следующее поколение.
    LoopCellsStart - Начало цикла для каждой клетки в сетке.
    CountLiveNeighbours - Подсчет количества живых соседей для текущей клетки.
    ApplyRules - Применение правил игры (Conway's Game of Life) для определения состояния клетки в следующем поколении (next_grid) на основе количества живых соседей и текущего состояния клетки.
    LoopCellsEnd - Конец цикла для каждой клетки в сетке.
    UpdateCurrentGrid - Обновление текущей сетки (grid) новой сеткой (next_grid).
    LoopEnd - Конец цикла поколений. Если есть еще поколения, цикл повторяется.
    OutputFinalGrid - Вывод на экран финального состояния сетки (grid) после завершения всех поколений.
    End - Конец программы.
"""
import random
import time

def get_grid_size():
    """Запрашивает у пользователя размеры сетки."""
    while True:
        try:
            rows = int(input("Введите количество строк: "))
            cols = int(input("Введите количество столбцов: "))
            if rows > 0 and cols > 0:
                return rows, cols
            else:
                print("Пожалуйста, введите положительные значения для строк и столбцов.")
        except ValueError:
            print("Пожалуйста, введите целое число.")

def get_generations():
    """Запрашивает у пользователя количество поколений."""
    while True:
        try:
            generations = int(input("Введите количество поколений: "))
            if generations > 0:
                return generations
            else:
                print("Пожалуйста, введите положительное количество поколений.")
        except ValueError:
            print("Пожалуйста, введите целое число.")


def get_initial_config(rows, cols):
    """Запрашивает у пользователя ввод начальной конфигурации или использует случайную."""
    use_random = input("Использовать случайную конфигурацию (y/n)? ").lower()
    if use_random != 'y':
        print("Введите начальную конфигурацию, используя '*' для живых клеток и ' ' для мертвых.")
        print("Введите каждую строку отдельно:")
        initial_config = []
        for _ in range(rows):
            while True:
              row_input = input()
              if len(row_input) == cols and all(cell in ['*', ' '] for cell in row_input):
                  initial_config.append(row_input)
                  break
              else:
                print(f"Неверный ввод. Введите строку длиной {cols} символов '*' или ' '")
        return initial_config
    else:
        return  [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]



def create_grid(rows, cols, initial_config=None):
    """Создает сетку на основе заданных размеров и начальной конфигурации."""
    if initial_config:
        return [list(row) for row in initial_config]
    else:
        return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]


def print_grid(grid):
    """Выводит сетку на экран."""
    for row in grid:
        print(''.join(row))
    print("-" * len(grid[0]))

def count_live_neighbours(grid, row, col):
    """Подсчитывает количество живых соседей для заданной клетки."""
    rows = len(grid)
    cols = len(grid[0])
    count = 0
    for i in range(max(0, row - 1), min(rows, row + 2)):
        for j in range(max(0, col - 1), min(cols, col + 2)):
            if (i, j) != (row, col) and grid[i][j] == '*':
                count += 1
    return count

def apply_rules(grid, row, col):
    """Применяет правила игры "Жизнь" для определения состояния клетки в следующем поколении."""
    live_neighbours = count_live_neighbours(grid, row, col)
    if grid[row][col] == '*':
        if live_neighbours < 2 or live_neighbours > 3:
            return ' '  # Клетка умирает
        else:
            return '*'  # Клетка выживает
    else:
        if live_neighbours == 3:
            return '*'  # Клетка оживает
        else:
            return ' '  # Клетка остается мертвой


def next_generation(grid):
    """Создает следующее поколение сетки."""
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [[' ' for _ in range(cols)] for _ in range(rows)]
    for row in range(rows):
        for col in range(cols):
            new_grid[row][col] = apply_rules(grid, row, col)
    return new_grid

def play_game_of_life():
  """Основная функция, управляющая симуляцией игры "Жизнь"."""
  rows, cols = get_grid_size() # Запрос размера сетки у пользователя.
  generations = get_generations() # Запрос количества поколений у пользователя.
  initial_config = get_initial_config(rows, cols) # Запрос начальной конфигурации у пользователя
  grid = create_grid(rows, cols, initial_config) # Создание игровой сетки.

  for generation in range(generations):
    print(f"Поколение: {generation + 1}")
    print_grid(grid)
    grid = next_generation(grid)
    time.sleep(0.5)

  print("Симуляция завершена")
  print("Финальное состояние поля:")
  print_grid(grid)
  
if __name__ == "__main__":
    play_game_of_life()

"""
Объяснение кода:
1. **Импорт модулей**:
    -   `import random`: Импортирует модуль `random` для генерации случайных чисел.
    -   `import time`: Импортирует модуль `time` для добавления задержки между поколениями.
2.  **Функция `get_grid_size()`**:
    - Запрашивает у пользователя размеры сетки (количество строк и столбцов), проверяя корректность ввода.
    - Возвращает кортеж `rows, cols` целых чисел.
3.  **Функция `get_generations()`**:
    - Запрашивает у пользователя количество поколений для симуляции, проверяя корректность ввода.
    - Возвращает целое число `generations`.
4.  **Функция `get_initial_config(rows, cols)`**:
   - Запрашивает у пользователя, использовать ли случайную начальную конфигурацию или ввести свою.
   - Если пользователь не выбирает случайную конфигурацию, то запрашивает начальную конфигурацию, построчно, проверяя корректность ввода.
   - Если пользователь выбирает случайную, то возвращает случайную начальную конфигурацию.
   - Возвращает список строк (начальная конфигурация).
5. **Функция `create_grid(rows, cols, initial_config=None)`**:
    -   Создает и возвращает сетку (список списков) на основе заданных размеров `rows`, `cols` и начальной конфигурации `initial_config`.
    -   Если `initial_config` предоставлена, использует её для создания сетки.
    -   Если `initial_config` не предоставлена, генерирует случайную сетку, где каждая клетка имеет 50% шанс быть живой (`'*'`) или мертвой (`' '`).
6. **Функция `print_grid(grid)`**:
    -   Выводит текущую сетку на экран.
    -   Каждая строка сетки выводится на отдельной строке, а также добавляется разделительная линия.
7. **Функция `count_live_neighbours(grid, row, col)`**:
    -   Подсчитывает количество живых соседей у клетки с координатами `row` и `col` в сетке `grid`.
    -   Соседями считаются все клетки, прилегающие к данной клетке по горизонтали, вертикали и диагонали.
    -   Возвращает целое число - количество живых соседей.
8. **Функция `apply_rules(grid, row, col)`**:
    - Применяет правила игры "Жизнь" для клетки с координатами `row` и `col`.
    - Возвращает '*' если клетка должна быть живой, и ' ' если клетка должна быть мертвой.
    -   Возвращает новое состояние клетки.
9. **Функция `next_generation(grid)`**:
    - Создает и возвращает сетку следующего поколения на основе текущей сетки.
    - Применяет функцию apply_rules к каждой клетке.
    -   Создает новую сетку (список списков) и применяет правила игры для определения состояния каждой клетки в следующем поколении.
10. **Функция `play_game_of_life()`**:
    - Основная функция, управляющая симуляцией игры "Жизнь".
    - Вызывает функции get_grid_size(), get_generations() и create_grid() для инициализации игры.
    - В цикле for выводит на экран текущее поколение, рассчитывает и выводит следующее поколение.
    - После цикла for выводит на экран финальное состояние поля.
11. **Запуск игры**:
    -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_game_of_life()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `play_game_of_life()`: Вызывает функцию для начала игры.
"""
