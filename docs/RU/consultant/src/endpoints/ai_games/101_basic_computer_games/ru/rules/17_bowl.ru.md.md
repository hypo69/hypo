# Анализ кода модуля `17_bowl.ru.md`

**Качество кода: 7/10**
-   **Плюсы:**
    *   Документ предоставляет чёткое описание правил игры в боулинг.
    *   Хорошо структурированы шаги реализации игры.
    *   Присутствуют примеры работы программы, которые помогают понять логику игры.
    *   Есть описание типов бросков и подсчета победителя.
-   **Минусы:**
    *   Файл является описанием правил игры, а не кодом, и не содержит Python кода.
    *   Отсутствует информация о реализации логики подсчета очков, что является ключевым моментом в боулинге.
    *   Нет подробностей об обработке краевых случаев, например, как обрабатываются страйки и спэры при подсчете очков.
    *   Отсутствует описание требований к формату вывода, что может привести к неоднозначной реализации.
    *   Нет информации о конкретных библиотеках или методах, которые могут быть использованы при реализации, например, для генерации случайных чисел.

**Рекомендации по улучшению**
1.  **Добавить описание логики подсчета очков:** Необходимо подробно описать, как будут начисляться очки за страйки и спэры, включая учет дополнительных бросков.
2.  **Уточнить формат вывода:** Необходимо определить, как именно должны выводиться результаты (например, использовать таблицу для отображения счетов по фреймам).
3.  **Предоставить пример реализации:** Добавить пример кода на Python, который демонстрирует базовую структуру программы и логику бросков.
4.  **Учесть обработку исключений:** В описании реализации стоит упомянуть необходимость обработки возможных ошибок ввода (например, ввод некорректного количества игроков).
5.  **Более конкретно описать реализацию:** Вместо общих фраз типа "игра реализуется с помощью базовых операций ввода-вывода", нужно указать, что будет использоваться для ввода данных (например, `input()`) и для вывода результатов (`print()`). Также можно упомянуть, что для генерации случайных чисел будет использоваться `random.randint()`.

**Оптимизированный код**

```markdown
### Название игры: **BOWL** (Боулинг)

#### Описание
Игра "BOWL" — это симуляция игры в боулинг для одного до четырёх игроков. В игре используются стандартные правила боулинга: каждый игрок выполняет 10 фреймов, и его задача — сбить все 10 кеглей за два броска. После каждого броска компьютер отображает оставшиеся кегли и анализирует результат: "ГАТТЕР", "СТРАЙК", "СПЭР" или "ОШИБКА".

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - Игрок выбирает количество участников (от 1 до 4).
   - Каждый игрок выполняет 10 фреймов.
   - Для совершения броска игрок должен ввести команду "ROLL".

#### 2. **Основной цикл игры**
   - **Бросок игрока:**
     1. Игрок вводит команду "ROLL", чтобы сделать бросок.
     2. После каждого броска компьютер выводит на экран диаграмму оставшихся кеглей:
        - "0" — означает, что кегля сбита.
        - "+" — означает, что кегля стоит.
     3. Результат броска отображается в виде "ГАТТЕР", "СТРАЙК", "СПЭР" или "ОШИБКА" (если после второго броска остались кегли).

#### 3. **Типы бросков**
   - **ГАТТЕР (GUTTER)** — мяч не попал в кегли.
   - **СТРАЙК (STRIKE)** — все 10 кеглей сбиты с первого броска.
   - **СПЭР (SPARE)** — все 10 кеглей сбиты за два броска.
   - **ОШИБКА (ERROR)** — если после второго броска остались стоящие кегли.

#### 4. **Подсчёт победителя**
   - Каждый игрок выполняет 10 фреймов.
   - Очки начисляются следующим образом:
     - За каждый сбитый кегль начисляется 1 очко.
     - **СТРАЙК:** Если все 10 кеглей сбиты с первого броска, то игрок получает 10 очков плюс очки за два следующих броска.
     - **СПЭР:** Если все 10 кеглей сбиты за два броска, то игрок получает 10 очков плюс очки за следующий бросок.
   - После всех бросков программа выводит итоговый счёт и объявляет победителя:
     ```
     Итоговый счёт игрока: 120
     ```

#### 5. **Завершение игры**
   - После завершения игры игрокам предлагается сыграть ещё раз или выйти:
     ```
     Хотите сыграть снова? (да/нет)
     ```

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в боулинг!
   Сколько игроков участвуют? (1-4)
   > 2
   Игрок 1, ваш ход.
   РОЛЛ
   ```

2. **После первого броска:**
   ```
   Оставшиеся кегли: 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
   Результат: СТРАЙК!
   ```

3. **Второй игрок:**
   ```
   Игрок 2, ваш ход.
   РОЛЛ
   Оставшиеся кегли: 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
   Результат: СПЭР!
   ```

4. **Завершение игры:**
   ```
   Итоговый счёт игрока 1: 150
   Итоговый счёт игрока 2: 130
   Победил игрок 1!
   Хотите сыграть снова? (да/нет)
   > нет
   До свидания!
   ```

---

### Возможные ограничения
- Игра предполагает, что игроки делают только два броска в каждом фрейме.
- Игроки должны вводить команду "ROLL" для выполнения броска.

---

### Реализация

Игра реализуется с помощью базовых операций ввода-вывода, а также генерации случайных чисел для имитации результатов бросков в боулинге.

-   **Ввод данных**: используется функция `input()` для получения команд от пользователя и количества игроков.
-   **Вывод данных**: используется функция `print()` для отображения результатов, оставшихся кеглей и счетов игроков.
-   **Генерация случайных чисел**: используется модуль `random` и функция `random.randint()` для имитации броска и сбитых кеглей.

Примерная структура кода на Python:

```python
import random

def bowl_game():
    """
    Симуляция игры в боулинг.
    """
    num_players = int(input("Сколько игроков участвуют? (1-4): "))
    scores = [0] * num_players
    for player_idx in range(num_players):
        print(f"Игрок {player_idx + 1}, ваш ход.")
        for frame in range(10):
            pins = [1] * 10  # 1 - кегля стоит, 0 - кегля сбита
            first_roll = random.randint(0, 10)
            for i in range(first_roll):
                pins[i] = 0

            display_pins(pins)
            if first_roll == 10:
                print("Результат: СТРАЙК!")
                scores[player_idx] += 10 + calculate_bonus(player_idx, frame) # TODO: реализация подсчета очков за страйк и спэ
                continue


            second_roll = random.randint(0,10-first_roll)
            for i in range(first_roll, first_roll + second_roll):
                 pins[i] = 0

            display_pins(pins)
            if first_roll + second_roll == 10:
                print("Результат: СПЭР!")
                scores[player_idx] += 10 + calculate_bonus(player_idx, frame) # TODO: реализация подсчета очков за спэ
            elif first_roll + second_roll == 0:
                print("Результат: ГАТТЕР!")
            else:
                print("Результат: ОШИБКА")

            scores[player_idx] += first_roll+second_roll


    print("Результаты игры:")
    for player_idx, score in enumerate(scores):
        print(f"Итоговый счёт игрока {player_idx + 1}: {score}")
    winner = scores.index(max(scores)) + 1
    print(f"Победил игрок {winner}!")


def display_pins(pins):
    """
    Отображает оставшиеся кегли
    :param pins: список кеглей 0 или 1
    """
    print("Оставшиеся кегли: ", end='')
    for pin in pins:
        print("0" if pin == 0 else "+", end=" ")
    print()

def calculate_bonus(player_idx: int, frame:int)-> int:
    """
    Вычисляет бонусные очки за страйк и спэр.
    TODO: Реализация вычисления бонусных очков.
    """
    return 0


if __name__ == '__main__':
    play_again = 'да'
    while play_again == 'да':
        bowl_game()
        play_again = input("Хотите сыграть снова? (да/нет): ")
    print("До свидания!")
```
```