# Анализ кода модуля `ACEDU`

**Качество кода**
    
   -  Соответствие требованиям к формату кода с 1 по 10: 9/10
    
   -  Преимущества:
        - Код хорошо структурирован и разделен на функции, что облегчает чтение и понимание.
        - Использование `random.shuffle()` для перемешивания колоды.
        - Обработка ошибок ввода с помощью `try-except`.
        - Наличие комментариев, объясняющих логику кода.
        - Чёткое разделение этапов игры.
    
   -  Недостатки:
        - Отсутствует явное документирование функций с использованием reStructuredText.
        - Нет явного использования логгера для отслеживания ошибок и событий.
        - Жестко заданный начальный капитал.
        - Нет возможности настройки параметров игры (например, размер колоды, начальный капитал).
        - Не используется `j_loads` или `j_loads_ns`.
        - Используются `print` для вывода, вместо логгера.

**Рекомендации по улучшению**
1. Добавить reStructuredText (RST) для всех комментариев и docstring.
2. Заменить `print` на `logger` для вывода сообщений и ошибок.
3. Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` (если это необходимо).
4. Добавить обработку исключений с `logger.error` вместо `print` в блоке `try-except`.
5. Сделать начальный капитал настраиваемым параметром.
6. Добавить возможность выбора языка (русский, английский).
7. Добавить валидацию ввода пользователя.
8. Переписать функцию `card_name` для большей читаемости.
9. Проработать исключения при завершении игры.
10. Добавить docstring к функциям и модулю.

**Улучшенный код**
```python
"""
Модуль для карточной игры Acey-Ducey
=========================================================================================

Этот модуль содержит функции для симуляции карточной игры Acey-Ducey.
Игрок делает ставки, угадывая, будет ли следующая карта между двумя выложенными.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    if __name__ == "__main__":
        play_acey_ducey()
"""

import random # импорт библиотеки random
from src.logger.logger import logger # импорт логгера

def create_deck() -> list:
    """
    Создает и перемешивает колоду карт.

    :return: Перемешанная колода карт.
    :rtype: list
    """
    ranks = list(range(2, 15))  # Карты от 2 до 14 (туз = 14) # список значений карт от 2 до 14
    deck = ranks * 4  # 4 масти # создание колоды с 4 мастями
    random.shuffle(deck) # перемешивание колоды
    return deck # возвращаем перемешанную колоду

def card_name(value: int) -> str:
    """
    Возвращает текстовое представление карты.

    :param value: Числовое значение карты (от 2 до 14).
    :type value: int
    :return: Текстовое представление карты.
    :rtype: str
    """
    card_names = { # словарь для преобразования числовых значений в текстовые
        11: "Валет",
        12: "Дама",
        13: "Король",
        14: "Туз"
    }
    return card_names.get(value, str(value)) # возвращаем текстовое представление карты

def play_acey_ducey(initial_money: int = 100) -> None:
    """
    Запускает игровой цикл Acey-Ducey.

    :param initial_money: Начальный капитал игрока, по умолчанию 100.
    :type initial_money: int
    :return: None
    :rtype: None
    """
    logger.info("Добро пожаловать в игру Acey Ducey!") # логирование начала игры
    logger.info("Правила: Делаете ставку, угадывая, будет ли следующая карта между двумя выложенными.") # логирование правил игры
    logger.info("Если карта равна одной из выложенных или туз, вы проигрываете.") # логирование правила проигрыша
    logger.info("Введите '0', чтобы пропустить ход.\\n") # логирование опции пропустить ход

    money = initial_money  # Стартовый капитал игрока # задание начального капитала
    deck = create_deck() # создание колоды

    while money > 0 and len(deck) >= 3: # игровой цикл, пока есть деньги и карты
        logger.info(f"Ваш текущий баланс: ${money}") # логирование текущего баланса

        # Выкладываем две карты # выкладывание двух карт
        try: # обрабатываем возможные ошибки при работе с колодой
            card1 = deck.pop() # извлекаем первую карту
            card2 = deck.pop() # извлекаем вторую карту
        except IndexError as e: # ловим ошибку если в колоде закончились карты
            logger.error(f"Ошибка при извлечении карт из колоды: {e}") # логирование ошибки
            break # прерываем игровой цикл

        while card1 == card2:  # Если карты одинаковые, берем новые # обработка одинаковых карт
            deck.insert(0, card1) # возвращаем первую карту в колоду
            deck.insert(0, card2) # возвращаем вторую карту в колоду
            try:
                card1 = deck.pop() # извлекаем первую карту
                card2 = deck.pop() # извлекаем вторую карту
            except IndexError as e:
                logger.error(f"Ошибка при повторном извлечении карт из колоды: {e}") # логирование ошибки
                break # прерываем цикл если закончились карты
        if not (money > 0 and len(deck) >= 3): # условие для выхода из цикла, если денег нет или карт меньше трех
                break

        logger.info(f"Первая карта: {card_name(card1)}") # логирование первой карты
        logger.info(f"Вторая карта: {card_name(card2)}") # логирование второй карты

        low_card = min(card1, card2) # определяем младшую карту
        high_card = max(card1, card2) # определяем старшую карту

        try: # обрабатываем возможные ошибки при вводе ставки
            bet = int(input(f"Сделайте ставку (от 0 до {money}) или введите '0' для пропуска хода: ")) # запрос ставки
            if bet < 0 or bet > money: # проверка корректности ставки
                logger.info("Неверная ставка. Попробуйте снова.") # логирование неверной ставки
                continue # переход к следующей итерации цикла
            if bet == 0: # условие для пропуска хода
                logger.info("Вы пропустили ход.\\n") # логирование пропуска хода
                continue  # Пропускаем ход
        except ValueError as ex: # ловим ошибку, если введено не число
            logger.error(f"Ошибка ввода: {ex}. Пожалуйста, введите число.") # логирование ошибки
            continue # переход к следующей итерации цикла

        try: # обрабатываем возможные ошибки при работе с колодой
            next_card = deck.pop() # извлекаем следующую карту
        except IndexError as e: # ловим ошибку, если колода пустая
            logger.error(f"Ошибка при извлечении следующей карты: {e}") # логирование ошибки
            break # прерываем цикл

        logger.info(f"Следующая карта: {card_name(next_card)}") # логирование следующей карты

        if next_card == card1 or next_card == card2 or next_card == 14: # условие проигрыша
            logger.info("Вы проиграли!") # логирование проигрыша
            money -= bet # уменьшаем баланс
        elif low_card < next_card < high_card: # условие выигрыша
            logger.info("Вы выиграли!") # логирование выигрыша
            money += bet # увеличиваем баланс
        else: # условие проигрыша
            logger.info("Вы проиграли!") # логирование проигрыша
            money -= bet # уменьшаем баланс

    if money <= 0: # условие окончания игры при отсутствии денег
        logger.info("У вас закончились деньги. Игра окончена.") # логирование окончания игры
    else: # условие окончания игры при наличии денег
        logger.info(f"Игра окончена. Ваш итоговый баланс: ${money}") # логирование итогового баланса

if __name__ == "__main__":
    play_acey_ducey() # запуск игры, если скрипт выполняется напрямую
```