"""
BOWL:
=================
Сложность: 3
-----------------
Игра "Боулинг" - это текстовая игра, где игрок имитирует игру в боулинг. 
Игрок вводит количество сбитых кеглей для каждого броска (до 10 кеглей за бросок).
Игра состоит из 10 фреймов. Результат каждого фрейма и общий счет отображаются. 
В игре также учитываются страйки и спэры, добавляя соответствующие бонусные очки к результату.

Правила игры:
1. Игра состоит из 10 фреймов.
2. В каждом фрейме игрок имеет 2 броска, чтобы сбить все 10 кеглей.
3. Если игрок сбивает все 10 кеглей первым броском (страйк), он не делает второй бросок в этом фрейме.
4. Если игрок сбивает все 10 кеглей за два броска (спэр), то он получает бонусные очки за следующий бросок.
5. Если первый бросок - страйк, то бонусные очки начисляются за следующие 2 броска.
6. В последнем, 10-м фрейме, если игрок выбивает страйк или спэр, он получает дополнительный бросок.
7. Игра заканчивается после 10 фреймов, и выводится общий результат.
-----------------
Алгоритм:
1. Инициализировать переменные: общий счет (totalScore) = 0, номер текущего фрейма (currentFrame) = 1, список очков за фреймы (frameScores) = пустой список.
2. Начать цикл "пока номер текущего фрейма не больше 10":
   2.1 Инициализировать переменные для текущего фрейма: счет фрейма (frameScore) = 0, количество бросков (throws) = 0.
   2.2 Начать цикл "пока количество бросков меньше 2":
      2.2.1 Запросить у игрока ввод количества сбитых кеглей за бросок.
      2.2.2 Увеличить количество бросков на 1.
      2.2.3 Добавить сбитые кегли к счету фрейма (frameScore).
      2.2.4 Если это первый бросок и сбито 10 кеглей (страйк), то выйти из внутреннего цикла.
      2.2.5 Если количество бросков равно 2 и сбито 10 кеглей (спэр) то добавить признак, что это спэр.
      2.2.6 Сохранить счет фрейма в список frameScores.
    2.3 Увеличить номер текущего фрейма на 1.
3. Рассчитать общий счет totalScore с учетом бонусов за страйки и спэры.
4. Вывести результаты каждого фрейма и общий счет totalScore.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeVariables["<p align='left'>Инициализация переменных:
    <code><b>
    totalScore = 0<br>
    currentFrame = 1<br>
    frameScores = []
    </b></code></p>"]
    InitializeVariables --> FrameLoopStart{"Начало цикла: <code><b>currentFrame <= 10</b></code>"}
    FrameLoopStart -- Да --> InitializeFrameVariables["<p align='left'>Инициализация переменных фрейма:
    <code><b>
    frameScore = 0<br>
    throws = 0
    </b></code></p>"]
    InitializeFrameVariables --> ThrowLoopStart{"Начало цикла: <code><b>throws < 2</b></code>"}
    ThrowLoopStart -- Да --> InputKnockedPins["Ввод сбитых кеглей: <code><b>pins</b></code>"]
    InputKnockedPins --> IncreaseThrows["<code><b>throws = throws + 1</b></code>"]
    IncreaseThrows --> AddScore["<code><b>frameScore = frameScore + pins</b></code>"]
    AddScore --> CheckStrike{"Проверка: <code><b>throws == 1 и pins == 10?</b></code>"}
    CheckStrike -- Да --> EndThrowLoop["Конец цикла бросков"]
    CheckStrike -- Нет --> CheckSpare{"Проверка: <code><b>throws == 2 и frameScore == 10?</b></code>"}
    CheckSpare -- Да --> SetSpareFlag["<code><b>spare = True</b></code>"]
    SetSpareFlag --> StoreFrameScore["Сохранить <code><b>frameScore</b></code> в <code><b>frameScores</b></code>"]
    StoreFrameScore --> EndThrowLoop
    CheckSpare -- Нет --> StoreFrameScore
    EndThrowLoop --> FrameLoopStart
    FrameLoopStart -- Нет --> CalculateTotalScore["Расчет общего счета с бонусами"]
    CalculateTotalScore --> OutputResults["Вывод результатов: фреймы и общий счет"]
    OutputResults --> End["Конец"]

```
    **Legenda**:
    Start - Начало программы.
    InitializeVariables - Инициализация переменных: totalScore (общий счет) устанавливается в 0, currentFrame (текущий фрейм) устанавливается в 1, frameScores (список очков за фреймы) инициализируется пустым списком.
    FrameLoopStart - Начало цикла по фреймам, который продолжается, пока номер текущего фрейма currentFrame не превышает 10.
    InitializeFrameVariables - Инициализация переменных для текущего фрейма: frameScore (счет текущего фрейма) устанавливается в 0, throws (количество бросков) устанавливается в 0.
    ThrowLoopStart - Начало цикла бросков внутри фрейма, который продолжается, пока количество бросков throws меньше 2.
    InputKnockedPins - Запрос у игрока ввода количества сбитых кеглей pins.
    IncreaseThrows - Увеличение счетчика бросков throws на 1.
    AddScore - Добавление количества сбитых кеглей pins к счету текущего фрейма frameScore.
    CheckStrike - Проверка, является ли текущий бросок страйком (первый бросок и 10 сбитых кеглей).
    EndThrowLoop - Конец цикла бросков. Если страйк, то пропускается второй бросок.
    CheckSpare - Проверка, является ли текущий фрейм спэром (два броска и 10 сбитых кеглей).
    SetSpareFlag - Установка флага spare (спэр) в значение True.
    StoreFrameScore - Сохранение счета текущего фрейма frameScore в список frameScores.
    CalculateTotalScore - Расчет общего счета totalScore с учетом бонусов за страйки и спэры.
    OutputResults - Вывод результатов: очков за каждый фрейм и общий счет totalScore.
    End - Конец программы.
"""

__author__ = 'hypo69 (hypo69@davidka.net)'


import random


def bowl_game():
    """
     Симуляция игры в боулинг.
    """

    # Инициализация переменных
    totalScore = 0  # Общий счет игры
    currentFrame = 1  # Текущий фрейм
    frameScores = []  # Список для хранения очков за каждый фрейм
    
    # Основной игровой цикл (10 фреймов)
    while currentFrame <= 10:
        frameScore = 0  # Счет текущего фрейма
        throws = 0  # Количество бросков в текущем фрейме
        spare = False # Признак спэра
         # Цикл бросков в рамках одного фрейма
        while throws < 2:
           try:
               # Запрос ввода количества сбитых кеглей в текущем броске
               pins = int(input(f"Фрейм {currentFrame}, бросок {throws + 1}: Сколько кеглей сбили? (0-10): "))
               # Проверка допустимости введенных данных
               if pins < 0 or pins > 10:
                   print("Пожалуйста, введите число от 0 до 10.")
                   continue # Начать цикл бросков сначала
               
               throws += 1 # Увеличиваем количество бросков
               frameScore += pins # Добавляем сбитые кегли к счету текущего фрейма
               
               # Проверка на страйк (все 10 кеглей сбиты первым броском)
               if throws == 1 and pins == 10:
                  print("Страйк!")
                  break # Выход из цикла бросков текущего фрейма
               if throws == 2 and frameScore == 10:
                    spare = True
           except ValueError:
               print("Пожалуйста, введите целое число.")
        
        frameScores.append((frameScore, spare)) # Сохраняем счет текущего фрейма в список
        currentFrame += 1# Увеличиваем номер текущего фрейма
        
    # Расчет общего счета с учетом бонусов за страйки и спэры
    totalScore = calculate_total_score(frameScores)
    
     # Вывод результатов игры
    print("\nРезультаты игры:")
    for i, (score, spare) in enumerate(frameScores):
        print(f"Фрейм {i + 1}: {score}{' (спэр)' if spare else ''}")
    print(f"Общий счет: {totalScore}")

def calculate_total_score(frameScores):
    """
    Вычисляет общий счет с учетом бонусов за страйки и спэры.
    """
    totalScore = 0
    for i, (score, spare) in enumerate(frameScores):
        totalScore += score # Добавляем очки за текущий фрейм
        if spare:
            if i < len(frameScores) - 1:
                next_score, _  = frameScores[i + 1] # Берем очки следующего фрейма
                totalScore +=  next_score if next_score < 10 else 10 #Добавляем бонус, но не более 10
        elif score == 10: # Если это страйк
             if i < len(frameScores) - 1: #Если есть следующий фрейм
                next_score1, _  = frameScores[i + 1]  #Берем первый бросок следующего фрейма
                totalScore += next_score1  # добавляем бонус 1 броска следующего фрейма
                if next_score1 != 10 and i < len(frameScores) - 2: # если это не страйк и есть послеследующий фрейм
                    next_score2, _ = frameScores[i + 2] #берем первый бросок послеследующего фрейма
                    totalScore += next_score2 if next_score2 < 10 else 10# добавляем бонус 1 броска послеследующего фрейма не более 10
                elif next_score1 == 10 and i < len(frameScores) - 2:# если это страйк
                     next_score2, _ = frameScores[i + 2]
                     totalScore += next_score2
    
    return totalScore


if __name__ == "__main__":
    bowl_game()
"""
Пояснения:
1. **Импорт модуля `random`**:
   - `import random`: Импортирует модуль `random`, который не используется в этой версии игры, но может быть добавлен для будущих улучшений.

2. **Функция `bowl_game()`**:
   - Определяет основную функцию игры в боулинг.
   - **Инициализация переменных**:
     - `totalScore = 0`: Инициализирует переменную для хранения общего счета игры.
     - `currentFrame = 1`: Инициализирует переменную для отслеживания текущего фрейма (всего 10 фреймов).
     - `frameScores = []`: Инициализирует список для хранения результатов каждого фрейма.

   - **Основной игровой цикл**:
     - `while currentFrame <= 10:`: Цикл, продолжающийся, пока не будут сыграны все 10 фреймов.
     - **Инициализация переменных фрейма**:
        -   `frameScore = 0`:  Инициализирует переменную для хранения счета текущего фрейма.
        -   `throws = 0`:   Инициализирует переменную для отслеживания количества бросков в текущем фрейме (максимум 2).
     -   `spare = False`: Инициализация переменной для отслеживания был ли спэр в этом фрейме.
     -  **Цикл бросков в рамках одного фрейма**:
          - `while throws < 2:`: Цикл, продолжающийся пока не сделано 2 броска в фрейме.
        - `try ... except ValueError`: Обработка исключений, если ввод пользователя не является целым числом.
         -   `pins = int(input(f"Фрейм {currentFrame}, бросок {throws + 1}: Сколько кеглей сбили? (0-10): "))`: Запрашивает у пользователя количество сбитых кеглей.
         -   `if pins < 0 or pins > 10:`: Проверяет, находится ли ввод пользователя в допустимом диапазоне (0-10).
         -  `throws += 1`:  Увеличивает счетчик бросков.
         - `frameScore += pins`: Добавляет сбитые кегли к общему счету фрейма.
        -  `if throws == 1 and pins == 10:`: Проверяет, был ли выбит страйк в первом броске.
          -   `break`: Завершает текущий цикл бросков если был страйк.
        -  `if throws == 2 and frameScore == 10:`: Проверяет, был ли спэр выбит в текущем фрейме.
              -    `spare = True`: Устанавливает флаг, что был спэр.
      -   `frameScores.append((frameScore, spare))`: Сохраняет счет фрейма и признак спэра в список результатов.
      -   `currentFrame += 1`: Переходит к следующему фрейму.
        
   -  **Расчет общего счета:**
        -   `totalScore = calculate_total_score(frameScores)`: Вызывает функцию `calculate_total_score` для вычисления общего счета с учетом бонусов.
   - **Вывод результатов игры:**
     -   `print("\nРезультаты игры:")`: Выводит заголовок результатов.
     -   `for i, (score, spare) in enumerate(frameScores):`: Цикл для вывода результатов каждого фрейма.
     - `print(f"Фрейм {i + 1}: {score}{' (спэр)' if spare else ''}")`: Выводит результат каждого фрейма, а если есть спэр, то добавляет соответствующую пометку.
      -   `print(f"Общий счет: {totalScore}")`: Выводит итоговый общий счет игры.

3. **Функция `calculate_total_score(frameScores)`**:
   - Принимает список результатов фреймов `frameScores`.
   -  `totalScore = 0`: Инициализирует переменную для хранения общего счета.
   -  `for i, (score, spare) in enumerate(frameScores):`: Итерирует по результатам всех фреймов.
   - `totalScore += score`: Добавляет очки текущего фрейма к общему счету.
   - `if spare:`: Проверяет, был ли в текущем фрейме спэр.
       -   `if i < len(frameScores) - 1:`: Проверяет, есть ли следующий фрейм.
          -   `next_score = frameScores[i + 1]`: Получает очки следующего фрейма.
          -   `totalScore += next_score if next_score < 10 else 10`: Добавляет бонус за спэр, но не более 10.
    -   `elif score == 10:`: Проверяет, был ли в текущем фрейме страйк.
        -    `if i < len(frameScores) - 1:`: Проверяет, есть ли следующий фрейм.
              - `next_score1, _  = frameScores[i + 1]`: Получает очки первого броска следующего фрейма.
              - `totalScore += next_score1`: Добавляет бонус за страйк (первый бросок следующего фрейма).
              - `if next_score1 != 10 and i < len(frameScores) - 2:`: Проверяет, не является ли следующий бросок страйком и есть ли послеследующий фрейм.
                 -  `next_score2, _ = frameScores[i + 2]`: Получает очки первого броска послеследующего фрейма.
                -   `totalScore += next_score2 if next_score2 < 10 else 10`: Добавляет бонус за страйк (второй бросок).
              -   `elif next_score1 == 10 and i < len(frameScores) - 2:`: Если первый бросок следующего фрейма страйк, то взять первый бросок послеследующего.
                 - `next_score2, _ = frameScores[i + 2]`: Получает очки первого броска послеследующего фрейма.
                 -   `totalScore += next_score2`: Добавляет бонус за страйк (второй бросок).

   - `return totalScore`: Возвращает итоговый общий счет.

4.  **Запуск игры**:
    -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `bowl_game()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `bowl_game()`: Вызывает функцию для начала игры.
"""
