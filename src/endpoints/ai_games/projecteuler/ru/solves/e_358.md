## Ответ на Задачу No 358: Циклические числа

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Задача заключается в нахождении *n*-го циклического числа максимальной длины, а затем в вычислении суммы его цифр.
*   Циклическое число – это число, которое при умножении на 2, 3, ... (n -1) дает результат, содержащий те же цифры в другой последовательности.
*   Максимальная длина означает, что это число не может быть получено путем конкатенации более короткого циклического числа.
*   Нам нужно найти s(2011), где s(n) — сумма цифр n-го циклического числа максимальной длины.

**Решение:**

1.  **Поиск циклического числа:** Циклические числа тесно связаны с десятичными разложениями дробей 1/p, где p — простое число.  В частности, циклические числа получаются как периоды десятичных разложений  1/p, где p простое и 10 - первообразный корень по модулю p. 
    
    *   Циклическое число длины *n* можно получить, вычислив период десятичного разложения 1/p, где p является простым числом, а длина периода равна n.
    *   Для получения циклических чисел максимальной длины, нам нужно убедиться, что p - простое число, и длина периода не является делителем длины периода для других меньших p.
    *   Необходимо перебрать простые числа и вычислить длины периодов 1/p.
    *   Первые несколько циклов будут получены из простых чисел 7, 17, 19, 23, 29, 47, 59, 61, 97...
    
2.  **Определение f(n):** Мы будем последовательно генерировать циклические числа и формировать последовательность f(n)
3.  **Вычисление s(n):** После нахождения f(n), нужно просуммировать его цифры для получения s(n).
4.  **Нахождение s(2011):** Выполнить итерации до нахождения 2011-го циклического числа и вычислить сумму его цифр.

### 2. Алгоритм решения

1.  Начать.
2.  Инициализировать список циклических чисел `cyclic_numbers` как пустой список, и счетчик `count = 0`
3.  Инициализировать список простых чисел `primes` начальными простыми числами.
4.  Итерировать, пока `count < 2011`
   *   Для каждого простого числа `p` из списка `primes`, проверить, что 10 - первообразный корень по модулю p, это означает, что наименьшее `k` такое что `10^k = 1 (mod p)` равно `p - 1`
   *   Если 10 является первообразным корнем, то:
        *    вычислить длину периода `length = p - 1`
        *    если `length` не является делителем длины других циклических чисел в списке `cyclic_numbers`, то
             *    вычислить десятичное представление `1/p` до `length` знаков после запятой, получив циклическое число.
             *    добавить цикличное число в список `cyclic_numbers`.
             *    увеличить `count` на 1.
   *    Если 10 не является первообразным корнем, перейти к следующему простому числу.
   *    Если простых чисел недостаточно, генерируем следующее простое число и добавляем в `primes`.
5.  Получив `cyclic_numbers[2010]` вычислить сумму его цифр.
6.  Вернуть сумму цифр.
7.  Конец.

### 3. Реализация на Python 3.12

```python
def is_prime(n):
    """Проверяет, является ли число простым."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_primes(limit):
    """Генерирует список простых чисел до заданного предела."""
    primes = []
    num = 2
    while len(primes) < limit:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes

def is_primitive_root(base, p):
    """Проверяет, является ли base первообразным корнем по модулю p."""
    if base % p == 0:
      return False
    
    remainders = set()
    power = 1
    value = 1
    while power < p:
      value = (value * base) % p
      if value in remainders:
        return False
      remainders.add(value)
      power += 1
    return True
    


def find_cyclic_number(p):
    """Находит циклическое число для данного простого числа p."""
    
    if not is_primitive_root(10, p):
      return None
    
    period_length = p - 1
    
    numerator = 1
    result = ""
    remainders = {}
    
    for i in range(period_length):
        numerator *= 10
        remainder = numerator % p
        if remainder in remainders:
             break 
        remainders[remainder] = i
        result += str(numerator // p)
        numerator = remainder 
    
    return result

def solve():
    """Находит s(2011)."""
    cyclic_numbers = []
    count = 0
    primes = generate_primes(1000)
    prime_index = 0
    
    while count < 2011:
        p = primes[prime_index]
        
        
        cyclic_number = find_cyclic_number(p)

        if cyclic_number:
          is_maximum = True
          for c in cyclic_numbers:
            if len(cyclic_number) % len(c) == 0:
              is_maximum = False
              break

          if is_maximum:
            cyclic_numbers.append(cyclic_number)
            count += 1

        prime_index += 1
        if prime_index >= len(primes):
          primes = generate_primes(prime_index + 1000)


    
    target_cyclic_number = cyclic_numbers[2010]
    
    
    sum_of_digits = sum(int(digit) for digit in target_cyclic_number)
    return sum_of_digits

result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> Initialize((Инициализировать: cyclic_numbers = [], count = 0, primes = первые простые числа))
    Initialize --> LoopStart((Начать цикл: пока count < 2011))
    LoopStart --> GetPrime((Получить следующее простое число p))
    GetPrime --> CheckPrimitiveRoot((Проверить: 10 - первообразный корень по модулю p?))
    CheckPrimitiveRoot -- Да --> CalculateCycleLength((Вычислить длину периода: length = p - 1))
    CalculateCycleLength --> CheckMaxLength((Проверить: length не делитель длин предыдущих?))
    CheckMaxLength -- Да --> FindCyclicNumber((Найти циклическое число для p))
    FindCyclicNumber --> AddCyclicNumber((Добавить циклическое число в cyclic_numbers))
    AddCyclicNumber --> IncrementCount((Увеличить счетчик: count += 1))
    CheckMaxLength -- Нет --> LoopStart
    CheckPrimitiveRoot -- Нет --> LoopStart
    LoopStart --> CalculateSum((Вычислить сумму цифр cyclic_numbers[2010]))
    CalculateSum --> Output((Вывести сумму цифр))
    Output --> End((Конец))
```

**Legenda:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать:** Инициализация переменных и списка простых чисел.
*   **Начать цикл:** Начало цикла для генерации 2011 циклических чисел.
*   **Получить следующее простое число p:** Получаем очередное простое число из списка.
*   **Проверить: 10 - первообразный корень по модулю p?:** Проверяем, является ли 10 первообразным корнем по модулю p.
*  **Вычислить длину периода: length = p - 1**:  Вычисляем длину периода циклического числа.
*   **Проверить: length не делитель длин предыдущих?:** Проверяем, не является ли length делителем длин уже полученных циклических чисел
*   **Найти циклическое число для p:** Вычисляем циклическое число по периоду 1/p.
*   **Добавить циклическое число в cyclic\_numbers:** Добавляем найденное циклическое число в список.
*   **Увеличить счетчик:** Увеличиваем счетчик на 1, чтобы отслеживать количество найденных циклических чисел.
*   **Вычислить сумму цифр cyclic\_numbers\[2010]:** Получаем 2011-е циклическое число и вычисляем сумму его цифр.
*   **Вывести сумму цифр:** Выводим результат – сумму цифр s(2011).
