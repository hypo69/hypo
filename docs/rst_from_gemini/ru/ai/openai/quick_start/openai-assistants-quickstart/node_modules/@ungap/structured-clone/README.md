## structuredClone Полифилл

[![Загрузки](https://img.shields.io/npm/dm/@ungap/structured-clone.svg)](https://www.npmjs.com/package/@ungap/structured-clone) [![Статус сборки](https://github.com/ungap/structured-clone/actions/workflows/node.js.yml/badge.svg)](https://github.com/ungap/structured-clone/actions) [![Статус покрытия кода](https://coveralls.io/repos/github/ungap/structured-clone/badge.svg?branch=main)](https://coveralls.io/github/ungap/structured-clone?branch=main)

Полифилл для `structuredClone`, который сериализует и десериализует данные, поддерживая типы, выходящие за рамки JSON, согласно спецификации HTML.

* **Поддерживаемые типы**:
    * *Ещё не поддерживается*: Blob, File, FileList, ImageBitmap, ImageData и ArrayBuffer, но массивы с типами данных (typed arrays) поддерживаются без серьёзных проблем, но *только* uint8, uint16 и uint32 (сейчас).
    * *Невозможно реализовать*: Опция `{transfer: []}` может быть передана, но игнорируется полностью.
    * Подробный список поддерживаемых типов см. в [документации MDN](https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types).
* **Документация MDN**: [https://developer.mozilla.org/ru/docs/Web/API/structuredClone](https://developer.mozilla.org/ru/docs/Web/API/structuredClone)
* **Сериализация**: [https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal](https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal)
* **Десериализация**: [https://html.spec.whatwg.org/multipage/structured-data.html#structureddeserialize](https://html.spec.whatwg.org/multipage/structured-data.html#structureddeserialize)

Сериализованные значения можно безопасно преобразовать в JSON, а десериализация восстановит все значения, включая рекурсивные структуры и более сложные, чем позволяет JSON.


### Примеры

Более подробные примеры можно найти в [тестах](./test/index.js) (100% покрытие кода).

```javascript
// Использование как импорта по умолчанию
import structuredClone from '@ungap/structured-clone';
const cloned = structuredClone({any: 'serializable'});

// Использование отдельных функций сериализации/десериализации
import {serialize, deserialize} from '@ungap/structured-clone';

// Результат можно преобразовать в JSON без проблем
// даже если есть рекурсивные данные, значения bigint,
// массивы с типами данных и т.д.
const serialized = serialize({any: 'serializable'});
const deserialized = deserialize(serialized);
```

#### Глобальный полифилл
Примечание: Используйте этот способ только если необходимо. Этот полифилл работает и без глобальной привязки: `import structuredClone from "@ungap/structured-clone"`

```javascript
// Привязка полифилла как глобальной функции
import structuredClone from "@ungap/structured-clone";
if (!("structuredClone" in globalThis)) {
  globalThis.structuredClone = structuredClone;
}

// Или без привязки к глобальному объекту
import structuredClone from "@ungap/structured-clone";
// Просто используйте его в файле
structuredClone()
```

**Важно**: Не привязывайте этот модуль к глобальному объекту напрямую без проверки наличия родного `structuredClone()`. В средах, где уже существует встроенная реализация `structuredClone()`, прямое присваивание глобальному объекту приведёт к бесконечному циклу при вызове `globalThis.structuredClone()`. Используйте пример выше для безопасной глобальной привязки полифилла в вашем проекте.


### Дополнительные возможности

Между алгоритмом структурированного клонирования и JSON нет промежуточного варианта:

* JSON более гибкий относительно несовместимых типов: он просто их игнорирует.
* Структурированное клонирование жёстче в отношении несовместимых типов, но оно делает специализированные экземпляры невоспроизводимыми, плюс оно не предлагает никаких помощников, таких как `toJSON()`, для облегчения сериализации или для работы с особыми случаями.

Экспорт `serialize` этого модуля позволяет использовать необязательный дополнительный аргумент с параметром **lossy**, чтобы избежать ошибок при обнаружении несовместимых типов (функции, символы и т.д.), что снижает вероятность проблем при передаче данных.

```javascript
// Использование как импорта по умолчанию
import structuredClone from '@ungap/structured-clone';
const cloned = structuredClone(
  {
    method() {
      // игнорируется, не будет клонировано
    },
    special: Symbol('также игнорируется')
  },
  {
    // избежать ошибок
    lossy: true,
    // избежать ошибок *и* искать метод toJSON
    json: true
  }
);
```

Поведение при обработке массивов такое же, как в JSON: неподдерживаемые значения заменяются на `null`.


#### toJSON

Если опция `lossy` недостаточна, опция `json`  добавляет `lossy` и проверяет наличие метода `toJSON` у объектов.

Альтернативно, экспорт `json` объединяет все функции:

```javascript
import {stringify, parse} from '@ungap/structured-clone/json';

parse(stringify({any: 'serializable'}));
```
