## Ответ на Задачу No 289: Euler's Zigzag Path

### 1. Анализ задачи и решение
**Понимание задачи:**
* Задача заключается в нахождении количества зигзагообразных путей из n шагов вправо, которые заканчиваются на оси x (z(n)).
* Зигзагообразный путь - это путь на целочисленной решетке, который начинается в (0,0), каждый раз делает шаг вправо (увеличивает x на 1), а затем шаг вверх или вниз (изменяет y на +1 или -1).
* Путь не должен пересекаться сам с собой.
* Нас интересует значение z(10<sup>10</sup>) mod 10<sup>9</sup>.

**Решение:**
1. **Свойство зигзагообразных путей:** Количество зигзагообразных путей, заканчивающихся на оси x (z(n)) связано с числами Каталана.
2. **Числа Каталана:** Числа Каталана (C<sub>n</sub>)  определены как C<sub>n</sub> = (1/(n+1)) * (2n choose n). В нашем случае z(n) = C<sub>(n/2)</sub>,  если n чётное, и z(n) = 0, если n нечётное. 
3. **Вычисление C<sub>(n/2)</sub>:** C<sub>k</sub> = (2k)! / (k! * (k+1)!)
4. **Работа с большими числами:** Поскольку нам нужно вычислить z(10<sup>10</sup>) mod 10<sup>9</sup>, мы не можем просто вычислить факториалы напрямую, так как они будут очень большими. Нужно использовать свойства модульной арифметики и модульного обратного.
5. **Свойство модульного обратного:** (a / b) mod m == (a * inv(b, m)) mod m, где inv(b, m) - это модульный обратный b по модулю m.
6. **Рекуррентное соотношение для чисел Каталана:** C<sub>0</sub>=1 и C<sub>n+1</sub>=∑(C<sub>i</sub>C<sub>n-i</sub>) for i=0 to n, C<sub>n+1</sub>=(2*(2*n+1)/(n+2))*C<sub>n</sub>
7. **Свойство z(n):** z(n) =  C<sub>n/2</sub> если n четное и 0 если n нечетное.

Нам нужно посчитать `z(10^10) mod 10^9`, что эквивалентно  `C(5*10^9) mod 10^9`

Давайте рассмотрим формулу для чисел Каталана: C<sub>n</sub> = (1 / (n+1)) * (2n choose n) = (2n)! / (n! * (n+1)!).
Мы знаем, что  `z(n) = C(n/2)` если n четное.
В нашем случае n = 10<sup>10</sup>, n/2 = 5 * 10<sup>9</sup>,
поэтому нам нужно вычислить `C(5 * 10^9) mod 10^9`.

Заметим, что нас просят вычислить `z(10^10) mod 10^9`. Это значит, что все вычисления нужно проводить по модулю 10<sup>9</sup>.

Поскольку прямое вычисление факториалов невозможно, мы можем воспользоваться рекуррентным соотношением: C<sub>n+1</sub> = [2*(2n+1)/(n+2)] * C<sub>n</sub>
или
C<sub>n</sub> = [2*(2n-1)/(n+1)] * C<sub>n-1</sub>

И будем считать по модулю 10<sup>9</sup>
1. Если n - нечетное, то z(n) = 0
2. Если n четное, то z(n) = C<sub>n/2</sub>, где C<sub>k</sub> - число Каталана.

### 2. Алгоритм решения
1. Начать
2. Ввести `n = 10^10`
3. Если `n` нечетное, то `result = 0` и перейти к шагу 8
4. Иначе:
    * `k = n / 2`
    * Инициализировать `catalan = 1`
    * Для `i` от `1` до `k`:
        * `catalan = (catalan * (2 * (2 * i - 1) % 1000000000) * pow(i+1, 1000000000-2, 1000000000)) % 1000000000`
    * `result = catalan % 1000000000`
5. Вывести `result`
6. Конец

### 3. Реализация на Python 3.12
```python
def power(base, exp, modulus):
    """Calculates (base^exp) % modulus using binary exponentiation."""
    result = 1
    base %= modulus
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exp //= 2
    return result

def inverse(number, modulus):
  """Calculates modular inverse of a number."""
  return power(number, modulus - 2, modulus)

def calculate_z(n):
  """Calculates z(n) mod 10^9"""
  if n % 2 != 0:
    return 0
  
  k = n // 2
  catalan = 1
  modulus = 1000000000
  
  for i in range(1, k+1):
        catalan = (catalan * (2 * (2 * i - 1) % modulus) * inverse(i + 1, modulus)) % modulus

  return catalan


n = 10**10
result = calculate_z(n)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InputN((Ввести n = 10^10))
    InputN --> CheckNIsOdd((Проверить: n нечетное?))
    CheckNIsOdd -- Да --> SetResultZero((result = 0))
    SetResultZero --> OutputResult((Вывести result))
    CheckNIsOdd -- Нет --> CalculateK((k = n / 2))
    CalculateK --> InitializeCatalan((catalan = 1))
    InitializeCatalan --> LoopStart((Начать цикл: i от 1 до k))
    LoopStart --> CalculateCatalan((catalan = (catalan * (2 * (2 * i - 1)) * inv(i+1, 10^9)) % 10^9 ))
    CalculateCatalan --> LoopStart
    LoopStart --> SetResult((result = catalan mod 10^9))
    SetResult --> OutputResult
    OutputResult --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Ввести n = 10<sup>10</sup>:** Получение входного значения `n`.
*   **Проверить: n нечетное?:** Проверяет, является ли `n` нечетным числом.
*   **result = 0:** Присваивание значения `0` переменной `result` в случае, если `n` нечетное.
*   **Вывести result:** Выводит рассчитанное значение `result`.
*   **k = n / 2:** Вычисление значения `k`, равного половине `n`.
*   **catalan = 1:** Инициализация переменной `catalan` значением `1`.
*   **Начать цикл: i от 1 до k:** Начало цикла перебора `i` от `1` до `k`.
*   **catalan = (catalan * (2 * (2 * i - 1)) * inv(i+1, 10^9)) % 10^9:**  Вычисление следующего числа Каталана по модулю `10^9` с использованием модульного обратного.
*    **result = catalan mod 10^9:** Присваивание переменной `result` вычисленного значения числа Каталана по модулю `10^9`.
