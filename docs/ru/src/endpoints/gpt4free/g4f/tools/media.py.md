# Модуль для рендеринга медиа контента
## Обзор

Модуль `media.py` предназначен для обработки и рендеринга медиа-файлов (изображений и аудио) в сообщениях. Он включает функции для преобразования медиа-файлов в различные форматы, такие как base64, URL, а также для интеграции медиа-контента в сообщения.

## Подробней

Модуль содержит функции для рендеринга медиа-файлов, обработки частей сообщений, объединения медиа-данных и рендеринга сообщений целиком. Он используется для подготовки медиа-контента к отображению в интерфейсе пользователя, например, в чат-ботах или других приложениях обмена сообщениями.

## Функции

### `render_media`

```python
def render_media(bucket_id: str, name: str, url: str, as_path: bool = False, as_base64: bool = False) -> Union[str, Path]:
    """
    Рендерит медиа-файл, преобразуя его в путь, base64 или URL.

    Args:
        bucket_id (str): Идентификатор бакета, где хранится файл.
        name (str): Имя файла.
        url (str): URL файла.
        as_path (bool, optional): Если True, возвращает путь к файлу. По умолчанию False.
        as_base64 (bool, optional): Если True, возвращает файл в формате base64. По умолчанию False.

    Returns:
        Union[str, Path]: Путь к файлу, данные в формате base64 или URL файла.
    """
```

**Как работает функция**:

1.  Функция `render_media` принимает идентификатор бакета (`bucket_id`), имя файла (`name`), URL файла (`url`), а также необязательные параметры `as_path` и `as_base64`.
2.  Если `as_base64` или `as_path` равны `True`, или URL начинается с "/", функция формирует путь к файлу на основе `bucket_id`, "media" и имени файла.
3.  Если `as_path` равен `True`, функция возвращает путь к файлу.
4.  Иначе, функция читает содержимое файла в байтах, кодирует его в base64 и формирует строку с данными в формате URI (`data:{mime_type};base64,{data_base64}`). MIME-тип определяется с помощью функции `is_data_an_media`.
5.  Если `as_base64` равен `True`, функция возвращает данные в формате base64.
6.  Если ни одно из условий не выполнено, функция возвращает исходный URL файла.

**Примеры**:

```python
# Пример вызова функции render_media
bucket_id = "test_bucket"
name = "example.jpg"
url = "http://example.com/example.jpg"

# Получение пути к файлу
path = render_media(bucket_id, name, url, as_path=True)

# Получение данных в формате base64
base64_data = render_media(bucket_id, name, url, as_base64=True)

# Получение URI
uri_data = render_media(bucket_id, name, url)
```

### `render_part`

```python
def render_part(part: dict) -> dict:
    """
    Рендерит часть сообщения, определяя тип контента (текст, аудио, изображение) и возвращает соответствующий словарь.

    Args:
        part (dict): Словарь с данными части сообщения.

    Returns:
        dict: Словарь с отрендеренной частью сообщения.
    """
```

**Как работает функция**:

1.  Функция `render_part` принимает словарь `part` с данными части сообщения.
2.  Если в словаре `part` есть ключ `"type"`, функция возвращает этот словарь без изменений.
3.  Если ключа `"type"` нет, функция проверяет наличие ключа `"name"`. Если `"name"` отсутствует, функция формирует путь к директории бакета на основе `bucket_id` и читает содержимое бакета с помощью функции `read_bucket`. Результатом является словарь с типом `"text"` и содержимым, полученным из бакета.
4.  Если `"name"` присутствует, функция проверяет, является ли файл аудиофайлом с помощью функции `is_data_an_audio`. Если это аудиофайл, функция рендерит медиа-файл в формате base64 с помощью функции `render_media` и возвращает словарь с типом `"input_audio"`, содержащий данные и формат аудио.
5.  Если файл не является аудиофайлом, функция рендерит медиа-файл с помощью функции `render_media` и возвращает словарь с типом `"image_url"`, содержащий URL изображения.

**Примеры**:

```python
# Пример вызова функции render_part
part_image = {"bucket_id": "test_bucket", "name": "image.jpg"}
part_audio = {"bucket_id": "test_bucket", "name": "audio.mp3"}
part_text = {"bucket_id": "test_bucket"}

# Рендеринг части сообщения с изображением
rendered_image = render_part(part_image)

# Рендеринг части сообщения с аудио
rendered_audio = render_part(part_audio)

# Рендеринг текстовой части сообщения
rendered_text = render_part(part_text)
```

### `merge_media`

```python
def merge_media(media: list, messages: list) -> Iterator:
    """
    Объединяет медиа-файлы из списка `media` с сообщениями из списка `messages`.

    Args:
        media (list): Список медиа-файлов.
        messages (list): Список сообщений.

    Yields:
        Iterator: Итератор по объединенным медиа-файлам и сообщениям.
    """
```

**Как работает функция**:

1.  Функция `merge_media` принимает два аргумента: `media` (список медиа-файлов) и `messages` (список сообщений).
2.  Функция итерируется по сообщениям в списке `messages`. Если роль сообщения (`message.get("role")`) равна "user", функция проверяет содержимое сообщения (`message.get("content")`).
3.  Если содержимое является списком, функция итерируется по частям контента (`part`):
    *   Если в части контента отсутствует ключ `"type"`, но присутствует ключ `"name"`, функция рендерит медиа-файл как путь с помощью функции `render_media` и добавляет путь и имя файла в буфер (`buffer`).
    *   Если часть контента имеет тип `"image_url"`, функция добавляет URL изображения в буфер.
4.  Если роль сообщения не равна "user", функция очищает буфер.
5.  После обработки всех сообщений функция возвращает элементы из буфера, а затем элементы из списка `media`.

**Примеры**:

```python
# Пример вызова функции merge_media
media_files = ["image1.jpg", "image2.jpg"]
messages = [{"role": "user", "content": [{"name": "image3.jpg"}]}, {"role": "bot", "content": "Hello"}]

# Объединение медиа-файлов и сообщений
merged_data = list(merge_media(media_files, messages))
```

### `render_messages`

```python
def render_messages(messages: Messages, media: list = None) -> Iterator:
    """
    Рендерит список сообщений, обрабатывая медиа-контент и объединяя его с текстовыми сообщениями.

    Args:
        messages (Messages): Список сообщений для рендеринга.
        media (list, optional): Список медиа-файлов для добавления в сообщения. По умолчанию None.

    Yields:
        Iterator: Итератор по отрендеренным сообщениям.
    """
```

**Как работает функция**:

1.  Функция `render_messages` принимает список сообщений `messages` и опциональный список медиа-файлов `media`.
2.  Функция итерируется по сообщениям в списке `messages`. Для каждого сообщения функция проверяет, является ли содержимое сообщения списком.
3.  Если содержимое сообщения является списком, функция рендерит каждую часть сообщения с помощью функции `render_part` и возвращает новое сообщение с отрендеренным содержимым.
4.  Если содержимое сообщения не является списком, функция проверяет, передан ли список `media` и является ли текущее сообщение последним в списке `messages`.
5.  Если оба условия выполняются, функция создает новое сообщение, в котором медиа-файлы преобразуются в элементы типа `"input_audio"` или `"image_url"` в зависимости от типа файла. Если содержимое исходного сообщения является строкой, оно также добавляется в список содержимого нового сообщения как элемент типа `"text"`.
6.  Если условия не выполняются, функция просто возвращает исходное сообщение.

**Примеры**:

```python
# Пример вызова функции render_messages
messages = [{"role": "user", "content": [{"name": "image.jpg"}, {"text": "Hello"}]}, {"role": "bot", "content": "Hi"}]
media_files = [("audio.mp3", "audio.mp3")]

# Рендеринг списка сообщений
rendered_messages = list(render_messages(messages, media_files))