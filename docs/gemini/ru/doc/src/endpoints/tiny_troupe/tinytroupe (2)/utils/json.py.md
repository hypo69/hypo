# Модуль `json`

## Обзор

Модуль `json` предоставляет класс `JsonSerializableRegistry` для сериализации и десериализации объектов в формат JSON, а также вспомогательные функции `merge_dicts` и `remove_duplicates` для работы со словарями и списками. Модуль облегчает сохранение и загрузку объектов, поддерживая наследование и расширение атрибутов при сериализации.

## Подробнее

Этот модуль предоставляет инструменты для работы с JSON-сериализацией и десериализацией объектов, а также функции для манипулирования словарями и списками. `JsonSerializableRegistry` позволяет классам автоматически регистрировать подклассы и управлять атрибутами, которые должны быть включены или исключены при сериализации. Это особенно полезно для сложных объектов с иерархической структурой.

## Классы

### `JsonSerializableRegistry`

**Описание**:
Этот класс-миксин предоставляет функциональность для JSON-сериализации, десериализации и регистрации подклассов.

**Принцип работы**:
Класс поддерживает преобразование объектов в JSON-представление и обратно, позволяя сохранять и восстанавливать состояние объектов. Он также обеспечивает автоматическую регистрацию подклассов, что упрощает работу с иерархией классов.

**Атрибуты**:
- `class_mapping` (dict): Словарь, содержащий соответствия между именами классов и самими классами.
- `serializable_attributes` (list): Список атрибутов, которые должны быть включены при сериализации.
- `suppress_attributes_from_serialization` (list): Список атрибутов, которые должны быть исключены при сериализации.
- `custom_serialization_initializers` (dict): Словарь, содержащий пользовательские функции инициализации для атрибутов при десериализации.

**Методы**:

- `to_json(self, include: list = None, suppress: list = None, file_path: str = None, serialization_type_field_name: str = "json_serializable_class_name") -> dict`
- `from_json(cls, json_dict_or_path: dict | str, suppress: list = None, serialization_type_field_name: str = "json_serializable_class_name", post_init_params: dict = None)`
- `__init_subclass__(cls, **kwargs)`
- `_post_deserialization_init(self, **kwargs)`
- `_programmatic_name_to_json_name(cls, name: str) -> str`
- `_json_name_to_programmatic_name(cls, name: str) -> str`

## Функции

### `to_json`

```python
def to_json(self, include: list = None, suppress: list = None, file_path: str = None,
            serialization_type_field_name: str = "json_serializable_class_name") -> dict:
    """
    Возвращает JSON-представление объекта.

    Args:
        include (list, optional): Атрибуты для включения в сериализацию. Переопределяет поведение по умолчанию.
        suppress (list, optional): Атрибуты для исключения из сериализации. Переопределяет поведение по умолчанию.
        file_path (str, optional): Путь к файлу, куда будет записан JSON.
        serialization_type_field_name (str, optional): Имя поля, содержащего имя класса. По умолчанию "json_serializable_class_name".

    Returns:
        dict: Словарь, представляющий JSON-представление объекта.

    Raises:
        Exception: Если возникает ошибка при записи в файл.

    """
```

**Назначение**:
Преобразует объект в JSON-совместимый словарь.

**Параметры**:
- `include` (list, optional): Список атрибутов, которые следует включить в JSON-представление. Если указан, то только эти атрибуты будут включены. По умолчанию `None`.
- `suppress` (list, optional): Список атрибутов, которые следует исключить из JSON-представления. По умолчанию `None`.
- `file_path` (str, optional): Путь к файлу, в который будет записано JSON-представление. Если указан, словарь будет записан в файл. По умолчанию `None`.
- `serialization_type_field_name` (str, optional): Имя поля, которое будет содержать имя класса при сериализации. По умолчанию `"json_serializable_class_name"`.

**Возвращает**:
- `dict`: Словарь, представляющий JSON-представление объекта.

**Как работает функция**:

1.  **Инициализация**: Функция начинает с определения атрибутов, которые будут сериализованы. Она собирает все атрибуты, помеченные как сериализуемые, из иерархии классов объекта.
2.  **Обработка атрибутов**: Проверяет, переданы ли параметры `include` или `suppress`, чтобы переопределить атрибуты для сериализации.
3.  **Сериализация атрибутов**: Проходит по атрибутам, которые должны быть сериализованы, и преобразует их значения в JSON-совместимые типы данных. Если значение является экземпляром `JsonSerializableRegistry`, вызывается его метод `to_json` рекурсивно.
4.  **Запись в файл (опционально)**: Если указан `file_path`, функция пытается записать JSON-представление в указанный файл.

```
Сериализация объекта
│
├── Получение атрибутов из иерархии классов
│   │
│   ├── Проверка параметров include/suppress
│   │   │
│   │   └── Определение атрибутов для сериализации
│   │
│   └── Создание JSON-словаря
│       │
│       ├── Итерация по атрибутам
│       │   │
│       │   ├── Рекурсивная сериализация (если атрибут - JsonSerializableRegistry)
│       │   │
│       │   └── Копирование значения атрибута
│       │
│       └── Запись в файл (опционально)
│           │
│           └── Возврат JSON-словаря
│
└── Конец
```

**Примеры**:

```python
class Example(JsonSerializableRegistry):
    serializable_attributes = ['name', 'value']

    def __init__(self, name: str, value: int):
        self.name: str = name
        self.value: int = value

example = Example(name='test', value=123)
json_data = example.to_json()
print(json_data)
# {'json_serializable_class_name': 'Example', 'name': 'test', 'value': 123}

json_data_with_include = example.to_json(include=['name'])
print(json_data_with_include)
# {'json_serializable_class_name': 'Example', 'name': 'test'}

json_data_with_suppress = example.to_json(suppress=['value'])
print(json_data_with_suppress)
# {'json_serializable_class_name': 'Example', 'name': 'test'}

```

### `from_json`

```python
@classmethod
def from_json(cls, json_dict_or_path: dict | str, suppress: list = None,
              serialization_type_field_name: str = "json_serializable_class_name",
              post_init_params: dict = None) -> JsonSerializableRegistry:
    """
    Загружает JSON-представление объекта и создает экземпляр класса.

    Args:
        json_dict_or_path (dict | str): JSON-словарь, представляющий объект, или путь к файлу для загрузки JSON.
        suppress (list, optional): Атрибуты, которые следует исключить из загрузки.
        serialization_type_field_name (str, optional): Имя поля, содержащего имя класса. По умолчанию "json_serializable_class_name".
        post_init_params (dict, optional): Параметры для передачи в метод `_post_deserialization_init`.

    Returns:
        JsonSerializableRegistry: Экземпляр класса, заполненный данными из json_dict_or_path.

    Raises:
        FileNotFoundError: Если указан путь к файлу, и файл не найден.
        Exception: Если возникает ошибка при чтении из файла.
    """
```

**Назначение**:
Создает экземпляр класса из JSON-совместимого словаря.

**Параметры**:
- `json_dict_or_path` (dict | str): Словарь или путь к файлу, содержащему JSON-представление объекта.
- `suppress` (list, optional): Список атрибутов, которые следует исключить при десериализации. По умолчанию `None`.
- `serialization_type_field_name` (str, optional): Имя поля, в котором хранится имя класса для десериализации. По умолчанию `"json_serializable_class_name"`.
- `post_init_params` (dict, optional): Словарь параметров, передаваемых в метод `_post_deserialization_init` после десериализации. По умолчанию `None`.

**Возвращает**:
- `JsonSerializableRegistry`: Экземпляр класса, созданный на основе JSON-данных.

**Как работает функция**:

1.  **Загрузка JSON**: Если `json_dict_or_path` является строкой, функция пытается загрузить JSON из указанного файла. В противном случае используется переданный словарь.
2.  **Определение класса**: Функция определяет класс, который нужно инстанцировать, используя поле `serialization_type_field_name` из JSON-данных.
3.  **Создание экземпляра**: Создает экземпляр класса без вызова метода `__init__`.
4.  **Десериализация атрибутов**: Проходит по атрибутам, указанным в JSON-данных, и присваивает их значения атрибутам созданного экземпляра. Если значение атрибута является словарем и содержит поле `serialization_type_field_name`, вызывается метод `from_json` рекурсивно для десериализации вложенного объекта.
5.  **Вызов `_post_deserialization_init`**: Если у класса есть метод `_post_deserialization_init`, он вызывается после десериализации всех атрибутов.

```
Десериализация объекта
│
├── Загрузка JSON из файла или словаря
│   │
│   └── Определение класса для инстанцирования
│       │
│       └── Создание экземпляра класса
│           │
│           └── Десериализация атрибутов
│               │
│               ├── Итерация по атрибутам JSON
│               │   │
│               │   ├── Рекурсивная десериализация (если атрибут - JsonSerializableRegistry)
│               │   │
│               │   └── Присвоение значения атрибуту экземпляра
│               │
│               └── Вызов _post_deserialization_init (если есть)
│                   │
│                   └── Возврат экземпляра класса
│
└── Конец
```

**Примеры**:

```python
class Example(JsonSerializableRegistry):
    serializable_attributes = ['name', 'value']

    def __init__(self, name: str, value: int):
        self.name: str = name
        self.value: int = value

    def _post_deserialization_init(self, extra_param: str = None):
        self.extra_param: str = extra_param  # Атрибут, инициализируемый после десериализации

json_data = {'json_serializable_class_name': 'Example', 'name': 'test', 'value': 123}
example = Example.from_json(json_data, post_init_params={'extra_param': 'extra_value'})

print(example.name)
# test
print(example.value)
# 123
print(example.extra_param)
# extra_value
```

### `__init_subclass__`

```python
def __init_subclass__(cls, **kwargs):
    """
    Автоматически расширяет сериализуемые атрибуты и пользовательские инициализаторы из родительских классов.
    """
```

**Назначение**:
Метод класса, который автоматически вызывается при создании подкласса.

**Параметры**:
- `cls` (type): Создаваемый подкласс.
- `**kwargs`: Дополнительные аргументы, переданные при создании подкласса.

**Как работает функция**:

1.  **Регистрация подкласса**: Регистрирует подкласс в `JsonSerializableRegistry.class_mapping`, используя имя класса в качестве ключа.
2.  **Расширение атрибутов**: Автоматически расширяет списки `serializable_attributes` и `suppress_attributes_from_serialization` из родительских классов.
3.  **Обновление инициализаторов**: Обновляет словарь `custom_serialization_initializers` из родительских классов.

### `_post_deserialization_init`

```python
def _post_deserialization_init(self, **kwargs):
    """
    Вызывает метод `_post_init` после десериализации, если он существует.
    """
```

**Назначение**:
Вызывает метод `_post_init` после десериализации, если он определен в классе.

**Параметры**:
- `self` (object): Экземпляр класса.
- `**kwargs`: Дополнительные аргументы, передаваемые в метод `_post_init`.

**Как работает функция**:

1.  **Проверка наличия `_post_init`**: Проверяет, существует ли метод `_post_init` в классе.
2.  **Вызов `_post_init`**: Если метод `_post_init` существует, он вызывается с переданными аргументами.

### `_programmatic_name_to_json_name`

```python
@classmethod
def _programmatic_name_to_json_name(cls, name: str) -> str:
    """
    Конвертирует имя атрибута в формат JSON (snake_case).
    """
```

**Назначение**:
Преобразует имя атрибута из программного вида в формат JSON (snake_case).

**Параметры**:
- `name` (str): Имя атрибута.

**Возвращает**:
- `str`: Преобразованное имя атрибута.

**Как работает функция**:

1.  **Проверка переименования**: Проверяет, определен ли словарь `serializable_attributes_renaming` в классе.
2.  **Возврат переименованного имени**: Если словарь определен и имя атрибута есть в словаре, возвращает переименованное имя. В противном случае возвращает исходное имя.

### `_json_name_to_programmatic_name`

```python
@classmethod
def _json_name_to_programmatic_name(cls, name: str) -> str:
    """
    Конвертирует имя атрибута из формата JSON (snake_case) в программный вид.
    """
```

**Назначение**:
Преобразует имя атрибута из формата JSON (snake_case) в программный вид.

**Параметры**:
- `name` (str): Имя атрибута в формате JSON.

**Возвращает**:
- `str`: Преобразованное имя атрибута.

**Как работает функция**:

1.  **Проверка переименования**: Проверяет, определен ли словарь `serializable_attributes_renaming` в классе.
2.  **Обратное переименование**: Если словарь определен, создает обратный словарь, в котором ключами являются значения из `serializable_attributes_renaming`, а значениями - ключи. Возвращает соответствующее имя атрибута из обратного словаря. Если имя атрибута отсутствует, возвращает исходное имя.

### `post_init`

```python
def post_init(cls):
    """
    Декоратор для вызова метода `_post_init` после инициализации класса.
    """
```

**Назначение**:
Декоратор для принудительного вызова метода `_post_init` в классе, если он есть.

**Параметры**:
- `cls` (type): Класс, к которому применяется декоратор.

**Как работает функция**:

1.  **Заменяет `__init__`**: Заменяет оригинальный метод `__init__` класса на новый метод `new_init`.
2.  **Вызывает `_post_init`**: В новом методе `__init__` после вызова оригинального `__init__` проверяется наличие метода `_post_init` и, если он есть, вызывается.

### `merge_dicts`

```python
def merge_dicts(current: dict, additions: dict, overwrite: bool = False, error_on_conflict: bool = True) -> dict:
    """
    Объединяет два словаря и возвращает новый словарь.
    """
```

**Назначение**:
Объединяет два словаря, обрабатывая конфликты ключей.

**Параметры**:
- `current` (dict): Исходный словарь.
- `additions` (dict): Словарь с добавлениями.
- `overwrite` (bool, optional): Флаг, указывающий, следует ли перезаписывать значения в случае конфликта. По умолчанию `False`.
- `error_on_conflict` (bool, optional): Флаг, указывающий, следует ли вызывать исключение в случае конфликта и если `overwrite` установлен в `False`. По умолчанию `True`.

**Возвращает**:
- `dict`: Новый словарь с объединенными значениями.

**Как работает функция**:

1.  **Копирование исходного словаря**: Создает копию словаря `current`, чтобы не изменять исходный словарь.
2.  **Итерация по добавлениям**: Проходит по ключам и значениям в словаре `additions`.
3.  **Обработка ключей**:
    - Если ключ уже существует в `merged`, происходит проверка значений.
      - Если значение в `merged` равно `None`, оно заменяется значением из `additions`.
      - Если оба значения являются словарями, вызывается рекурсивно `merge_dicts`.
      - Если оба значения являются списками, они объединяются, и дубликаты удаляются.
      - Если типы значений разные, вызывается исключение `TypeError`.
      - Если типы значений одинаковые, но не списки и не словари, значение заменяется в соответствии с параметром `overwrite`.
    - Если ключа нет в `merged`, он добавляется из `additions`.

```
Объединение словарей
│
├── Копирование текущего словаря
│   │
│   └── Итерация по словарю с добавлениями
│       │
│       ├── Проверка наличия ключа в объединенном словаре
│       │   │
│       │   ├── Если ключ отсутствует, добавление нового ключа и значения
│       │   │
│       │   └── Если ключ присутствует:
│       │       │
│       │       ├── Если текущее значение None, замена значением из словаря с добавлениями
│       │       │
│       │       ├── Если оба значения - словари, рекурсивное объединение
│       │       │
│       │       ├── Если оба значения - списки, объединение с удалением дубликатов
│       │       │
│       │       ├── Если типы значений разные, исключение TypeError
│       │       │
│       │       └── Если типы значений одинаковые, перезапись в зависимости от параметра overwrite
│       │
│       └── Возврат объединенного словаря
│
└── Конец
```

**Примеры**:

```python
dict1 = {'a': 1, 'b': {'c': 2}}
dict2 = {'b': {'d': 3}, 'e': 4}
merged_dict = merge_dicts(dict1, dict2)
print(merged_dict)
# {'a': 1, 'b': {'c': 2, 'd': 3}, 'e': 4}

dict3 = {'a': [1, 2], 'b': 3}
dict4 = {'a': [2, 3], 'c': 4}
merged_dict2 = merge_dicts(dict3, dict4)
print(merged_dict2)
# {'a': [1, 2, 3], 'b': 3, 'c': 4}
```

### `remove_duplicates`

```python
def remove_duplicates(lst: list) -> list:
    """
    Удаляет дубликаты из списка, сохраняя порядок.
    """
```

**Назначение**:
Удаляет дубликаты из списка, сохраняя порядок элементов.

**Параметры**:
- `lst` (list): Список, из которого нужно удалить дубликаты.

**Возвращает**:
- `list`: Новый список без дубликатов.

**Как работает функция**:

1.  **Инициализация**: Создает два пустых списка: `seen` для отслеживания уже встреченных элементов и `result` для хранения уникальных элементов.
2.  **Итерация по списку**: Проходит по каждому элементу в списке `lst`.
3.  **Проверка на дубликат**: Для каждого элемента проверяет, был ли он уже встречен. Если элемент является словарем, он преобразуется во `frozenset` для возможности хеширования.
4.  **Добавление уникального элемента**: Если элемент не был встречен, он добавляется в `seen` и `result`.

```
Удаление дубликатов из списка
│
├── Инициализация списков seen и result
│   │
│   └── Итерация по списку
│       │
│       ├── Проверка элемента на словарь
│       │   │
│       │   └── Преобразование словаря во frozenset для хеширования
│       │
│       └── Проверка наличия элемента в списке seen
│           │
│           ├── Если элемент отсутствует, добавление в списки seen и result
│           │
│           └── Возврат списка result
│
└── Конец
```

**Примеры**:

```python
list1 = [1, 2, 2, 3, 4, 4, 5]
unique_list = remove_duplicates(list1)
print(unique_list)
# [1, 2, 3, 4, 5]

list2 = [{'a': 1}, {'b': 2}, {'a': 1}]
unique_list2 = remove_duplicates(list2)
print(unique_list2)
# [{'a': 1}, {'b': 2}]