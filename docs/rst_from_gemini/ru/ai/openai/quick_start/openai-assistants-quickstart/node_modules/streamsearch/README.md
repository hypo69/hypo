```markdown
# streamsearch

**A Node.js module for searching streams using the Boyer-Moore-Horspool algorithm.**

This module allows you to efficiently search for a specific pattern (needle) within a stream of data.  It leverages the Boyer-Moore-Horspool algorithm for optimized performance.

**Note:** This module is heavily based on Hongli Lai's C++ implementation of the Boyer-Moore-Horspool algorithm.


## Installation

```bash
npm install streamsearch
```


## Usage

```javascript
const { inspect } = require('util');
const StreamSearch = require('streamsearch');

// Define the pattern to search for (needle)
const needle = Buffer.from('\r\n');

// Create a new StreamSearch instance
const ss = new StreamSearch(needle, (isMatch, data, start, end, isSafeData) => {
  if (data) {
    console.log('data: ' + inspect(data.toString('utf8', start, end))); // Use utf8 for better readability
  }
  if (isMatch) {
    console.log('match!');
  }
});

// Example data (in chunks)
const chunks = [
  'foo',
  ' bar',
  '\r',
  '\n',
  'baz, hello\r',
  '\n world.',
  '\r\n Node.JS rules!!\r\n\r\n',
];


// Push chunks to the stream
for (const chunk of chunks) {
    ss.push(Buffer.from(chunk));
}

// Important: Always call destroy() to ensure all buffered data is processed
ss.destroy();

// Example output (showing matches and data chunks):
// ... (Output as in the original example, but now using utf8 encoding)
```


## API

### Constructor

```javascript
new StreamSearch(needle, callback)
```

*   **needle:** The pattern to search for (either a `Buffer` or a `String`).
*   **callback:** A function called whenever there's a match or non-matching data.
    *   `isMatch`: `boolean` - `true` if a match is found.
    *   `data`: `Buffer` - The chunk of data that did not match (if `isMatch` is `false`).  **Crucially**: If `isSafeData` is `false`, do *not* reference this `data` Buffer directly, as it may be reused.
    *   `start`: `number` - Starting index of `data` within the Buffer chunk.
    *   `end`: `number` - Ending index of `data` within the Buffer chunk (exclusive).
    *   `isSafeData`: `boolean` - Indicates whether the `data` Buffer can be safely referenced (e.g., using `data.slice()`).  If `false`, do not store references to `data`.


### Methods

*   **`destroy()`**:  Clears any remaining buffered data and resets the internal state. **Important:**  Always call this to ensure that all buffered data is processed.

*   **`push(chunk)`**: Processes a chunk of data (`Buffer`).  Returns the index in the chunk where processing ended.

*   **`reset()`**: Resets the internal state to allow searching from the beginning of a new stream.


### Properties

*   `maxMatches`: `number` - Maximum number of matches to find (defaults to `Infinity`).
*   `matches`: `number` - Current match count.


## Important Considerations

*   **`Buffer` vs. `String`:**  The `needle` parameter can be either a `Buffer` or a `String`. Internally, it's converted to a `Buffer`.  Using `Buffer` objects is generally recommended for better performance.
*   **Error Handling:**  The original example lacks robust error handling.  Adding error handling (e.g., checking for valid types and parameters) is good practice.
*   **Callback Handling:**  The callback is *extremely* crucial; make sure to use the `isSafeData` flag appropriately to avoid memory issues or unexpected behavior.
*   **`destroy()` Method:** Always call `destroy()` to prevent memory leaks and correctly process any remaining buffered data.  This is essential for proper cleanup.


## Example (using better error handling and readability):

```javascript
// ... (rest of the code, modified to use 'utf8' encoding consistently)
```
```