# Модуль copy_images.py

## Обзор

Модуль предназначен для загрузки и хранения изображений локально, присваивая им безопасные с точки зрения Unicode имена файлов. Он предоставляет функции для обработки различных типов медиафайлов, проверки их формата и создания URL-адресов для доступа к ним.

## Подробней

Этот модуль играет важную роль в проекте `hypotez`, поскольку позволяет сохранять сгенерированные изображения локально, обеспечивая к ним удобный доступ через URL-адреса. Он также обрабатывает различные типы ошибок, которые могут возникнуть в процессе загрузки и сохранения изображений, и обеспечивает ведение журнала этих ошибок.

Модуль содержит следующие основные компоненты:

- Функции для извлечения расширений медиафайлов, создания каталогов для хранения изображений и получения исходных URL-адресов.
- Асинхронную функцию для сохранения медиафайлов из ответа на локальный диск и возврата URL-адреса.
- Функцию для создания безопасных имен файлов.
- Асинхронную функцию для копирования медиафайлов из списка URL-адресов.

## Функции

### `get_media_extension`

```python
def get_media_extension(media: str) -> str:
    """Extract media file extension from URL or filename"""
```

**Назначение**: Извлекает расширение медиафайла из URL-адреса или имени файла.

**Параметры**:

- `media` (str): URL-адрес или имя файла.

**Возвращает**:

- `str`: Расширение файла (например, ".jpg", ".png").

**Вызывает исключения**:

- `ValueError`: Если расширение файла не поддерживается.

**Как работает функция**:

1.  Разбирает URL-адрес, чтобы получить путь.
2.  Извлекает расширение файла из пути.
3.  Если расширение не найдено, пытается извлечь его из исходной строки `media`.
4.  Проверяет, поддерживается ли расширение.
5.  Возвращает расширение.

```text
URL или имя файла --> Разбор URL --> Извлечение расширения --> Проверка расширения --> Возврат расширения
```

**Примеры**:

```python
>>> get_media_extension("https://example.com/image.jpg")
'.jpg'
>>> get_media_extension("image.png")
'.png'
```

### `ensure_images_dir`

```python
def ensure_images_dir():
    """Create images directory if it doesn't exist"""
```

**Назначение**: Создает каталог для хранения изображений, если он еще не существует.

**Параметры**:

- Нет.

**Возвращает**:

- Нет.

**Как работает функция**:

1.  Пытается создать каталог `images_dir`.
2.  Если каталог уже существует, функция завершается без ошибок.

```text
Проверка наличия каталога --> Создание каталога (если отсутствует)
```

**Примеры**:

```python
>>> ensure_images_dir()
```

### `get_source_url`

```python
def get_source_url(image: str, default: str = None) -> str:
    """Extract original URL from image parameter if present"""
```

**Назначение**: Извлекает исходный URL-адрес из параметра изображения, если он присутствует.

**Параметры**:

- `image` (str): Строка изображения, которая может содержать URL-адрес.
- `default` (str, optional): URL-адрес, возвращаемый по умолчанию, если URL-адрес не найден в строке изображения. По умолчанию `None`.

**Возвращает**:

- `str`: Исходный URL-адрес или значение по умолчанию.

**Как работает функция**:

1.  Проверяет, содержит ли строка изображения параметр "url=".
2.  Если параметр найден, извлекает и декодирует URL-адрес.
3.  Проверяет, начинается ли декодированный URL-адрес с "http://" или "https://".
4.  Если URL-адрес действителен, возвращает его.
5.  В противном случае возвращает значение по умолчанию.

```text
Строка изображения --> Проверка наличия параметра "url=" --> Извлечение и декодирование URL --> Проверка URL --> Возврат URL или значения по умолчанию
```

**Примеры**:

```python
>>> get_source_url("image.jpg?url=https://example.com/image.jpg")
'https://example.com/image.jpg'
>>> get_source_url("image.jpg", "https://example.com/default.jpg")
'https://example.com/default.jpg'
```

### `is_valid_media_type`

```python
def is_valid_media_type(content_type: str) -> bool:
    """Определяет, является ли указанный тип контента допустимым медиатипом."""
```

**Назначение**: Определяет, является ли указанный тип контента допустимым типом медиафайла.

**Параметры**:

- `content_type` (str): Тип контента для проверки.

**Возвращает**:

- `bool`: `True`, если тип контента является допустимым типом медиафайла, `False` в противном случае.

**Как работает функция**:

1.  Проверяет, находится ли тип контента в `MEDIA_TYPE_MAP`.
2.  Проверяет, начинается ли тип контента с "audio/" или "video/".
3.  Возвращает `True`, если любое из этих условий выполняется, в противном случае возвращает `False`.

```text
Тип контента --> Проверка в MEDIA_TYPE_MAP --> Проверка префикса "audio/" или "video/" --> Возврат True или False
```

**Примеры**:

```python
>>> is_valid_media_type("image/jpeg")
True
>>> is_valid_media_type("audio/mpeg")
True
>>> is_valid_media_type("text/html")
False
```

### `save_response_media`

```python
async def save_response_media(response: StreamResponse, prompt: str, tags: list[str]) -> AsyncIterator:
    """Сохраняет медиа из ответа в локальный файл и возвращает URL"""
```

**Назначение**: Сохраняет медиафайл из ответа на локальный диск и возвращает URL-адрес.

**Параметры**:

- `response` (StreamResponse): Объект ответа, содержащий медиафайл.
- `prompt` (str): Подсказка, используемая для создания имени файла.
- `tags` (list[str]): Список тегов, используемых для создания имени файла.

**Возвращает**:

- `AsyncIterator`: Асинхронный итератор, возвращающий объекты `ImageResponse`, `AudioResponse` или `VideoResponse`.

**Как работает функция**:

1.  Получает тип контента из заголовков ответа.
2.  Проверяет, является ли тип контента допустимым типом медиафайла.
3.  Определяет расширение файла на основе типа контента.
4.  Создает имя файла с использованием тегов, подсказки и расширения.
5.  Сохраняет содержимое ответа в локальный файл.
6.  Создает URL-адрес для доступа к файлу.
7.  Возвращает объект `ImageResponse`, `AudioResponse` или `VideoResponse` с URL-адресом.

```text
Ответ --> Получение типа контента --> Проверка типа контента --> Определение расширения --> Создание имени файла --> Сохранение содержимого --> Создание URL --> Возврат объекта ответа
```

**Примеры**:

```python
# Пример использования требует мок-объекта response
```

### `get_filename`

```python
def get_filename(tags: list[str], alt: str, extension: str, image: str) -> str:
    return "".join((\
        f"{int(time.time())}_",\
        f"{secure_filename(\'+\'.join([tag for tag in tags if tag]))}+" if tags else "",\
        f"{secure_filename(alt)}_",\
        hashlib.sha256(image.encode()).hexdigest()[:16],\
        extension\
    ))
```

**Назначение**: Создает имя файла на основе тегов, альтернативного текста, расширения и содержимого изображения.

**Параметры**:

- `tags` (list[str]): Список тегов для включения в имя файла.
- `alt` (str): Альтернативный текст для включения в имя файла.
- `extension` (str): Расширение файла.
- `image` (str): Содержимое изображения, используемое для создания хеша.

**Возвращает**:

- `str`: Созданное имя файла.

**Как работает функция**:

1.  Создает временную метку.
2.  Создает строку тегов, если теги предоставлены.
3.  Экранирует альтернативный текст.
4.  Создает хеш SHA256 содержимого изображения.
5.  Объединяет все компоненты в имя файла.

```text
Теги, альт. текст, расширение, изображение --> Создание компонентов имени файла --> Объединение компонентов --> Возврат имени файла
```

**Примеры**:

```python
>>> get_filename(["tag1", "tag2"], "alt_text", ".jpg", "image_content")
'1678886400_tag1+tag2+alt_text_1a2b3c4d5e6f7g8h.jpg'
```

### `copy_media`

```python
async def copy_media(
    images: list[str],
    cookies: Optional[Cookies] = None,
    headers: Optional[dict] = None,
    proxy: Optional[str] = None,
    alt: str = None,
    tags: list[str] = None,
    add_url: bool = True,
    target: str = None,
    ssl: bool = None
) -> list[str]:
    """
    Download and store images locally with Unicode-safe filenames
    Returns list of relative image URLs
    """
```

**Назначение**: Загружает и сохраняет изображения локально, присваивая им безопасные с точки зрения Unicode имена файлов. Возвращает список относительных URL-адресов изображений.

**Параметры**:

- `images` (list[str]): Список URL-адресов изображений для загрузки.
- `cookies` (Optional[Cookies], optional): Файлы cookie для использования при загрузке изображений. По умолчанию `None`.
- `headers` (Optional[dict], optional): Заголовки для использования при загрузке изображений. По умолчанию `None`.
- `proxy` (Optional[str], optional): Прокси-сервер для использования при загрузке изображений. По умолчанию `None`.
- `alt` (str, optional): Альтернативный текст для использования при создании имен файлов. По умолчанию `None`.
- `tags` (list[str], optional): Список тегов для использования при создании имен файлов. По умолчанию `None`.
- `add_url` (bool, optional): Добавлять ли исходный URL-адрес в URL-адрес локального изображения. По умолчанию `True`.
- `target` (str, optional): Целевой путь для сохранения изображений. По умолчанию `None`.
- `ssl` (bool, optional): Использовать ли SSL при загрузке изображений. По умолчанию `None`.

**Возвращает**:

- `list[str]`: Список относительных URL-адресов изображений.

**Как работает функция**:

1.  Создает каталог для хранения изображений, если он еще не существует.
2.  Создает сеанс клиента с использованием предоставленных файлов cookie, заголовков и прокси-сервера.
3.  Определяет асинхронную функцию `copy_image` для обработки отдельных изображений.
4.  Собирает список задач `copy_image` для каждого изображения.
5.  Запускает задачи асинхронно и возвращает список результатов.

**Внутренние функции**:

### `copy_image`

```python
async def copy_image(image: str, target: str = None) -> str:
    """Process individual image and return its local URL"""
```

**Назначение**: Обрабатывает отдельное изображение и возвращает его локальный URL-адрес.

**Параметры**:

- `image` (str): URL-адрес изображения для загрузки.
- `target` (str, optional): Целевой путь для сохранения изображения. По умолчанию `None`.

**Возвращает**:

- `str`: Локальный URL-адрес изображения.

**Как работает функция**:

1.  Проверяет, является ли изображение уже локальным.
2.  Определяет целевой путь для сохранения изображения.
3.  Обрабатывает изображения, закодированные как data URI.
4.  Загружает изображение с использованием сеанса клиента.
5.  Проверяет тип файла и переименовывает файл, если необходимо.
6.  Создает URL-адрес для доступа к файлу.
7.  Обрабатывает ошибки, которые могут возникнуть в процессе загрузки и сохранения изображения.

```text
Список URL-адресов --> Создание сеанса клиента --> Определение функции copy_image --> Сбор задач copy_image --> Запуск задач асинхронно --> Возврат списка результатов
```

**Примеры**:

```python
# Пример использования требует мок-объекта session и предварительно созданных файлов cookie и заголовков