# Модуль для проведения экспериментов в Tiny Troupe
## Обзор

Модуль `experimentation.py` предоставляет классы и утилиты для проведения A/B-тестирования и внедрения изменений в симуляции Tiny Troupe. Он включает в себя класс `ABRandomizer` для случайного назначения вариантов и их последующей дерандомизации, а также класс `Intervention` для моделирования вмешательств в симуляцию.

## Подробнее

Этот модуль предоставляет инструменты для проведения экспериментов, в которых сравниваются различные варианты (например, контрольная группа и экспериментальная группа). Класс `ABRandomizer` позволяет случайным образом назначать элементы в одну из групп, а затем анализировать результаты с учетом этого случайного назначения. Класс `Intervention` предназначен для моделирования изменений в симуляции, таких как изменение поведения агентов или окружающей среды.

## Классы

### `ABRandomizer`

**Описание**: Утилитарный класс для рандомизации между двумя опциями и последующей дерандомизации.

**Принцип работы**: Класс `ABRandomizer` позволяет проводить A/B-тестирование, случайным образом назначая элементы в группу A или B. Выбор сохраняется, что позволяет впоследствии дерандомизировать результаты. Это полезно для анализа данных, собранных в результате эксперимента.

**Атрибуты**:

- `choices` (dict): Словарь, хранящий информацию о том, как были рандомизированы элементы.
- `real_name_1` (str): Имя первой опции в данных.
- `real_name_2` (str): Имя второй опции в данных.
- `blind_name_a` (str): Имя первой опции, отображаемое пользователю.
- `blind_name_b` (str): Имя второй опции, отображаемое пользователю.
- `passtrough_name` (list): Список имен, которые не должны быть рандомизированы.
- `random_seed` (int): Зерно для генератора случайных чисел.

**Методы**:

- `__init__(self, real_name_1="control", real_name_2="treatment", blind_name_a="A", blind_name_b="B", passtrough_name=[], random_seed=42)`: Инициализирует экземпляр класса `ABRandomizer`.
- `randomize(self, i, a, b)`: Случайным образом меняет местами `a` и `b` и возвращает выбор.
- `derandomize(self, i, a, b)`: Дерандомизирует выбор для элемента `i` и возвращает значения.
- `derandomize_name(self, i, blind_name)`: Декодирует выбор, сделанный пользователем, и возвращает реальное имя опции.

### `Intervention`

**Описание**: Класс для моделирования вмешательств в симуляцию.

**Принцип работы**: Класс `Intervention` позволяет моделировать изменения в поведении агентов или в окружающей среде. Он предоставляет методы для установки предварительных условий и эффектов вмешательства.

**Атрибуты**:

- `agents` (list): Список агентов, на которых оказывается воздействие.
- `environments` (list): Список окружений, в которых происходит вмешательство.
- `text_precondition` (str): Текстовое описание предварительного условия.
- `precondition_func` (function): Функция, определяющая предварительное условие.
- `effect_func` (function): Функция, определяющая эффект вмешательства.

**Методы**:

- `__init__(self, agent=None, agents: list = None, environment=None, environments: list = None)`: Инициализирует экземпляр класса `Intervention`.
- `check_precondition(self)`: Проверяет, выполнено ли предварительное условие для вмешательства.
- `apply(self)`: Применяет вмешательство.
- `set_textual_precondition(self, text)`: Устанавливает предварительное условие в виде текста.
- `set_functional_precondition(self, func)`: Устанавливает предварительное условие в виде функции.
- `set_effect(self, effect_func)`: Устанавливает функцию, определяющую эффект вмешательства.

## Функции

### `ABRandomizer.__init__`

```python
def __init__(self, real_name_1="control", real_name_2="treatment",
                       blind_name_a="A", blind_name_b="B",
                       passtrough_name=[],
                       random_seed=42):
```

**Назначение**: Инициализирует экземпляр класса `ABRandomizer`.

**Параметры**:

- `real_name_1` (str): Имя первой опции (по умолчанию "control").
- `real_name_2` (str): Имя второй опции (по умолчанию "treatment").
- `blind_name_a` (str): Имя первой опции, отображаемое пользователю (по умолчанию "A").
- `blind_name_b` (str): Имя второй опции, отображаемое пользователю (по умолчанию "B").
- `passtrough_name` (list): Список имен, которые не должны быть рандомизированы (по умолчанию `[]`).
- `random_seed` (int): Зерно для генератора случайных чисел (по умолчанию 42).

**Возвращает**: None

**Как работает функция**:

1.  Инициализирует словарь `choices` для хранения информации о рандомизации.
2.  Сохраняет имена опций и другие параметры в атрибутах экземпляра класса.
3.  Устанавливает зерно для генератора случайных чисел, чтобы обеспечить воспроизводимость результатов.

```
Инициализация атрибутов класса
↓
Сохранение имен опций
↓
Установка зерна для генератора случайных чисел
```

**Примеры**:

```python
randomizer = ABRandomizer(real_name_1="контроль", real_name_2="эксперимент", blind_name_a="А", blind_name_b="Б", random_seed=123)
```

### `ABRandomizer.randomize`

```python
def randomize(self, i, a, b):
```

**Назначение**: Случайным образом меняет местами `a` и `b` и возвращает выбор.

**Параметры**:

- `i` (int): Индекс элемента.
- `a` (str): Первая опция.
- `b` (str): Вторая опция.

**Возвращает**: Кортеж из двух элементов, представляющих рандомизированные опции.

**Как работает функция**:

1.  Использует генератор случайных чисел с фиксированным зерном для определения, нужно ли менять местами `a` и `b`.
2.  Если случайное число меньше 0.5, сохраняет `(0, 1)` в словаре `choices` и возвращает `a, b`.
3.  В противном случае сохраняет `(1, 0)` в словаре `choices` и возвращает `b, a`.

```
Генерация случайного числа
↓
Проверка, нужно ли менять местами опции
│
├── Нет → Сохранение (0, 1) и возврат a, b
│
└── Да  → Сохранение (1, 0) и возврат b, a
```

**Примеры**:

```python
randomizer = ABRandomizer()
a, b = randomizer.randomize(1, "вариант_1", "вариант_2")
print(f"Рандомизированные значения: a={a}, b={b}")
```

### `ABRandomizer.derandomize`

```python
def derandomize(self, i, a, b):
```

**Назначение**: Дерандомизирует выбор для элемента `i` и возвращает значения.

**Параметры**:

- `i` (int): Индекс элемента.
- `a` (str): Первая опция.
- `b` (str): Вторая опция.

**Возвращает**: Кортеж из двух элементов, представляющих дерандомизированные опции.

**Вызывает исключения**:

- `Exception`: Если для элемента `i` не найдена информация о рандомизации.

**Как работает функция**:

1.  Проверяет значение в словаре `choices` для элемента `i`.
2.  Если значение равно `(0, 1)`, возвращает `a, b`.
3.  Если значение равно `(1, 0)`, возвращает `b, a`.
4.  Если значение не найдено, вызывает исключение.

```
Проверка значения в choices[i]
│
├── (0, 1) → Возврат a, b
│
├── (1, 0) → Возврат b, a
│
└── Нет значения → Вызов исключения
```

**Примеры**:

```python
randomizer = ABRandomizer()
a, b = randomizer.randomize(1, "вариант_1", "вариант_2")
a, b = randomizer.derandomize(1, "вариант_1", "вариант_2")
print(f"Дерандомизированные значения: a={a}, b={b}")
```

### `ABRandomizer.derandomize_name`

```python
def derandomize_name(self, i, blind_name):
```

**Назначение**: Декодирует выбор, сделанный пользователем, и возвращает реальное имя опции.

**Параметры**:

- `i` (int): Индекс элемента.
- `blind_name` (str): Имя опции, выбранное пользователем.

**Возвращает**: Реальное имя опции.

**Вызывает исключения**:

- `Exception`: Если для элемента `i` не найдена информация о рандомизации или если имя опции не распознано.

**Как работает функция**:

1.  Проверяет значение в словаре `choices` для элемента `i`.
2.  Если значение равно `(0, 1)`, проверяет значение `blind_name` и возвращает соответствующее реальное имя.
3.  Если значение равно `(1, 0)`, проверяет значение `blind_name` и возвращает противоположное реальное имя.
4.  Если значение не найдено, вызывает исключение.

```
Проверка значения в choices[i]
│
├── (0, 1) → Проверка blind_name
│   │
│   ├── blind_name == blind_name_a → Возврат real_name_1
│   │
│   ├── blind_name == blind_name_b → Возврат real_name_2
│   │
│   ├── blind_name in passtrough_name → Возврат blind_name
│   │
│   └── Исключение: Имя опции не распознано
│
├── (1, 0) → Проверка blind_name
│   │
│   ├── blind_name == blind_name_a → Возврат real_name_2
│   │
│   ├── blind_name == blind_name_b → Возврат real_name_1
│   │
│   ├── blind_name in passtrough_name → Возврат blind_name
│   │
│   └── Исключение: Имя опции не распознано
│
└── Нет значения → Вызов исключения
```

**Примеры**:

```python
randomizer = ABRandomizer(real_name_1="вариант_1", real_name_2="вариант_2", blind_name_a="А", blind_name_b="Б")
randomizer.randomize(1, "А", "Б")
real_name = randomizer.derandomize_name(1, "А")
print(f"Реальное имя опции: {real_name}")
```

### `Intervention.__init__`

```python
def __init__(self, agent=None, agents: list = None, environment=None, environments: list = None):
```

**Назначение**: Инициализирует экземпляр класса `Intervention`.

**Параметры**:

- `agent` (TinyPerson): Агент, на которого оказывается воздействие (по умолчанию `None`).
- `agents` (list): Список агентов, на которых оказывается воздействие (по умолчанию `None`).
- `environment`: Окружение, в котором происходит вмешательство (по умолчанию `None`).
- `environments` (list): Список окружений, в которых происходит вмешательство (по умолчанию `None`).

**Возвращает**: None

**Вызывает исключения**:

- `Exception`: Если не предоставлен ни агент, ни окружение, или если предоставлены и агент, и список агентов, или если предоставлены и окружение, и список окружений.

**Как работает функция**:

1.  Проверяет, что предоставлен хотя бы один из параметров: `agent`, `agents`, `environment`, `environments`.
2.  Проверяет, что не предоставлены одновременно `agent` и `agents`, а также `environment` и `environments`.
3.  Инициализирует атрибуты `agents` и `environments` в зависимости от предоставленных параметров.
4.  Инициализирует атрибуты `text_precondition`, `precondition_func` и `effect_func` в `None`.

```
Проверка параметров
↓
Инициализация атрибутов agents и environments
↓
Инициализация атрибутов precondition и effect
```

**Примеры**:

```python
agent = TinyPerson()
intervention = Intervention(agent=agent)
```

### `Intervention.check_precondition`

```python
def check_precondition(self):
```

**Назначение**: Проверяет, выполнено ли предварительное условие для вмешательства.

**Параметры**: None

**Возвращает**: None

**Вызывает исключения**:

- `NotImplementedError`: Всегда вызывается, так как метод должен быть переопределен в подклассах.

**Как работает функция**:

1.  Вызывает исключение `NotImplementedError`, указывая на то, что метод должен быть переопределен в подклассах.

```
Вызов исключения NotImplementedError
```

### `Intervention.apply`

```python
def apply(self):
```

**Назначение**: Применяет вмешательство.

**Параметры**: None

**Возвращает**: None

**Как работает функция**:

1.  Вызывает функцию `effect_func` с аргументами `agents` и `environments`.

```
Вызов effect_func(agents, environments)
```

**Примеры**:

```python
def my_effect(agents, environments):
    print("Вмешательство применено!")

agent = TinyPerson()
intervention = Intervention(agent=agent)
intervention.effect_func = my_effect
intervention.apply()
```

### `Intervention.set_textual_precondition`

```python
def set_textual_precondition(self, text):
```

**Назначение**: Устанавливает предварительное условие в виде текста.

**Параметры**:

- `text` (str): Текст предварительного условия.

**Возвращает**: None

**Как работает функция**:

1.  Сохраняет текст предварительного условия в атрибуте `text_precondition`.

```
Сохранение текста в text_precondition
```

**Примеры**:

```python
intervention = Intervention(agent=TinyPerson())
intervention.set_textual_precondition("Агент должен быть голоден")
```

### `Intervention.set_functional_precondition`

```python
def set_functional_precondition(self, func):
```

**Назначение**: Устанавливает предварительное условие в виде функции.

**Параметры**:

- `func` (function): Функция предварительного условия. Функция должна принимать аргументы: `agent`, `agents`, `environment`, `environments`.

**Возвращает**: None

**Как работает функция**:

1.  Сохраняет функцию предварительного условия в атрибуте `precondition_func`.

```
Сохранение функции в precondition_func
```

**Примеры**:

```python
def my_precondition(agent, agents, environment, environments):
    return agent.is_hungry

intervention = Intervention(agent=TinyPerson())
intervention.set_functional_precondition(my_precondition)
```

### `Intervention.set_effect`

```python
def set_effect(self, effect_func):
```

**Назначение**: Устанавливает функцию, определяющую эффект вмешательства.

**Параметры**:

- `effect_func` (function): Функция эффекта вмешательства.

**Возвращает**: None

**Как работает функция**:

1.  Сохраняет функцию эффекта в атрибуте `effect_func`.

```
Сохранение функции в effect_func
```

**Примеры**:

```python
def my_effect(agents, environments):
    for agent in agents:
        agent.eat()

intervention = Intervention(agent=TinyPerson())
intervention.set_effect(my_effect)