# Анализ кода модуля `amazin.py`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):**
   - 2 - Код частично соответствует требованиям, есть много проблем с форматированием, документацией и структурой.
-  **Преимущества:**
     - Код реализует базовую логику генерации лабиринта с использованием алгоритма DFS.
     - Есть проверка на корректность ввода размеров лабиринта.
     - Код прост для понимания.
-   **Недостатки:**
    -  Отсутствует документация в формате reStructuredText (RST).
    -  Не используется `j_loads` или `j_loads_ns` для обработки данных.
    -  Отсутствует импорт и использование `logger` для регистрации ошибок.
    -  Комментарии `#` не всегда информативны, и не предоставляют подробного объяснения.
    -  Функция `main` содержит try-except блоки, которые могли бы быть заменены на использование logger для ошибок.
    -  Недостаточное использование docstrings для функций.
    -  Нет необходимых импортов для `src.utils.jjson`, `src.logger.logger`.
    -  Не везде соблюдены требования использования одинарных кавычек.

**Рекомендации по улучшению**

1. **Документация:**
    - Добавить docstring в формате RST для модуля, всех функций и методов.
2. **Обработка данных:**
    -  Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` вместо `json.load`, если это применимо. В данном коде это не применимо.
3. **Логирование ошибок:**
    -  Импортировать и использовать `logger` из `src.logger.logger` для регистрации ошибок и отладочной информации.
4. **Структура кода:**
    -  Переработать try-except блоки в функции `main` и использовать `logger` для обработки ошибок.
    -  Добавить проверку на наличие необходимых импортов.
5. **Форматирование кода:**
    -  Привести все строки к использованию одинарных кавычек.
    -  Уточнить комментарии `#` для лучшего понимания логики.
6. **Размер лабиринта:**
    -  Добавить ограничение на максимальный размер лабиринта, чтобы избежать проблем с памятью.
7. **Общие улучшения:**
    -  Добавить примеры использования и улучшений в формате TODO.

**Улучшенный код**
```python
"""
Модуль для генерации лабиринтов.
=========================================================================================

Этот модуль реализует генератор лабиринтов, который создает уникальный лабиринт
с единственным правильным путем. Игрок задает размеры лабиринта, и программа строит его
с учетом заданных параметров.

Пример использования
--------------------

Пример запуска программы:

.. code-block:: python

   python amazin.py
"""
import random
# Добавлен импорт logger
from src.logger.logger import logger  # импортируем логгер


def create_maze(width: int, height: int) -> list:
    """
    Создает лабиринт заданных размеров.

    :param width: Ширина лабиринта.
    :type width: int
    :param height: Высота лабиринта.
    :type height: int
    :return: Матрица, представляющая лабиринт.
    :rtype: list
    """
    # Инициализация матрицы лабиринта
    maze = [['+' for _ in range(2 * width + 1)] for _ in range(2 * height + 1)]  # Создаем матрицу с границами

    def is_valid(x: int, y: int) -> bool:
        """
        Проверяет, являются ли координаты ячейки допустимыми.

        :param x: Координата x ячейки.
        :type x: int
        :param y: Координата y ячейки.
        :type y: int
        :return: True, если координаты допустимы, иначе False.
        :rtype: bool
        """
        return 0 <= x < height and 0 <= y < width # Проверяем вхождение координат в границы

    def carve_path(x: int, y: int):
        """
        Рекурсивно прокладывает путь через лабиринт.

        :param x: Координата x текущей ячейки.
        :type x: int
        :param y: Координата y текущей ячейки.
        :type y: int
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # возможные направления для прохода
        random.shuffle(directions) # Случайное перемешивание направлений

        for dx, dy in directions: # Обходим все направления
            nx, ny = x + dx, y + dy # Вычисляем координаты следующей ячейки
            # Проверяем, является ли соседняя ячейка в пределах лабиринта и еще не посещена
            if is_valid(nx, ny) and maze[2 * nx + 1][2 * ny + 1] == '+':
                # Удаляем стену между текущей и следующей ячейкой
                maze[2 * x + 1 + dx][2 * y + 1 + dy] = ' '  # Удаляем стену между текущей и следующей ячейкой
                maze[2 * nx + 1][2 * ny + 1] = ' ' # Помечаем следующую ячейку как посещенную
                carve_path(nx, ny)  # Рекурсивный вызов для дальнейшего обхода

    # Начинаем генерацию лабиринта со случайной ячейки
    start_x = random.randint(0, height - 1)
    start_y = random.randint(0, width - 1)
    maze[2 * start_x + 1][2 * start_y + 1] = ' ' # Отмечаем стартовую ячейку как посещенную
    carve_path(start_x, start_y) # Запускаем алгоритм генерации лабиринта
    return maze


def print_maze(maze: list):
    """
    Выводит лабиринт на экран.

    :param maze: Матрица, представляющая лабиринт.
    :type maze: list
    """
    for row in maze: # Перебираем все строки матрицы
        print(''.join(row)) # Выводим каждую строку


def main():
    """
    Основная функция игры.

    Организует взаимодействие с пользователем, запрашивает размеры лабиринта,
    генерирует и выводит лабиринт на экран.
    """
    while True: # Бесконечный цикл для повторной генерации лабиринта
        try:
            width = int(input('Введите ширину лабиринта: '))  # Запрашиваем ширину лабиринта
            height = int(input('Введите высоту лабиринта: ')) # Запрашиваем высоту лабиринта

            # Проверка корректности размеров
            if width <= 0 or height <= 0:
                logger.error('Размеры лабиринта должны быть больше 0.') # Используем логгер для вывода ошибки
                print('Размеры лабиринта должны быть больше 0.')
                continue # Переходим к следующей итерации цикла
            if width > 50 or height > 50:
                 logger.error('Слишком большие размеры лабиринта. Рекомендуется использовать значения меньше 50.')  # Используем логгер для вывода ошибки
                 print('Слишком большие размеры лабиринта. Рекомендуется использовать значения меньше 50.')
                 continue  # Переходим к следующей итерации цикла

            maze = create_maze(width, height) # Генерация лабиринта
            print_maze(maze)  # Вывод лабиринта на экран

        except ValueError as e:  # Обработка ошибки ввода
             logger.error(f'Неверный формат ввода. Пожалуйста, введите целые числа. {e}') # Используем логгер для вывода ошибки
             print('Неверный формат ввода. Пожалуйста, введите целые числа.')
             continue   # Переходим к следующей итерации цикла

        # Предложение сгенерировать еще один лабиринт
        new_maze = input('Сгенерировать новый лабиринт? (да/нет): ').lower() # Запрашиваем у пользователя желает ли он сгенерировать еще лабиринт
        if new_maze != 'да':
            print('До свидания!')
            break # Выходим из цикла, если пользователь не хочет генерировать новый лабиринт


if __name__ == '__main__':
    main()

# TODO:
# 1. Добавить возможность сохранения лабиринта в файл.
# 2. Реализовать возможность выбора начальной и конечной точки в лабиринте.
# 3. Добавить проверку на максимально допустимый размер лабиринта для предотвращения переполнения памяти.