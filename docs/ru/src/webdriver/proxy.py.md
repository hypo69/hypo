# Модуль для работы с прокси

## Обзор

Модуль определяет функции для загрузки и парсинга списка прокси. Загружается текстовый файл с прокси-адресами и распределяется по категориям.

## Подробнее

Этот модуль предназначен для автоматической загрузки и обработки списка прокси-серверов. Он загружает список прокси из удаленного источника, сохраняет его локально и предоставляет функциональность для парсинга этого списка и проверки работоспособности прокси-серверов. Модуль используется для обеспечения анонимности и обхода ограничений при веб-скрейпинге или других задачах, требующих использования прокси.

## Функции

### `download_proxies_list`

```python
def download_proxies_list(url: str = url, save_path: Path = proxies_list_path) -> bool:
    """
    Загружает файл по указанному URL и сохраняет его в заданный путь.

    Args:
        url (str, optional): URL файла для загрузки. По умолчанию используется глобальная переменная `url`.
        save_path (Path, optional): Путь для сохранения загруженного файла. По умолчанию используется глобальная переменная `proxies_list_path`.

    Returns:
        bool: `True` в случае успешной загрузки и сохранения файла, `False` в случае ошибки.
    
    Raises:
        Exception: Если возникает ошибка при загрузке файла.
    """
```

**Назначение**: Загрузка файла со списком прокси-серверов по указанному URL и сохранение его в локальный файл.

**Параметры**:
- `url` (str): URL-адрес, по которому находится файл со списком прокси. По умолчанию используется значение глобальной переменной `url`.
- `save_path` (Path): Путь для сохранения загруженного файла. По умолчанию используется значение глобальной переменной `proxies_list_path`.

**Возвращает**:
- `bool`: `True`, если файл успешно загружен и сохранен, иначе `False`.

**Вызывает исключения**:
- `requests.exceptions.RequestException`: Если возникает ошибка при выполнении HTTP-запроса.
- `IOError`: Если возникает ошибка при записи в файл.

**Как работает функция**:

1. Отправляет HTTP-запрос к указанному URL для загрузки файла.
2. Проверяет статус ответа, чтобы убедиться, что запрос выполнен успешно (код 200).
3. Сохраняет содержимое ответа в файл по указанному пути, используя потоковую запись для экономии памяти.
4. Логирует информацию об успешной загрузке и сохранении файла или ошибке, если она произошла.

```
    Начало
     ↓
    HTTP-запрос к URL
     ↓
    Проверка статуса ответа (200?)
     ├── Да → Сохранение содержимого в файл
     │       ↓
     │       Логирование успеха
     └── Нет → Логирование ошибки
     ↓
    Конец
```

**Примеры**:

```python
from pathlib import Path
from src.webdriver.proxy import download_proxies_list

# Пример использования с параметрами по умолчанию
result = download_proxies_list()
print(f"Результат загрузки (по умолчанию): {result}")

# Пример использования с указанием URL и пути сохранения
custom_url = 'https://example.com/proxies.txt'
custom_path = Path('custom_proxies.txt')
result = download_proxies_list(url=custom_url, save_path=custom_path)
print(f"Результат загрузки (с указанием URL и пути): {result}")
```

### `get_proxies_dict`

```python
def get_proxies_dict(file_path: Path = proxies_list_path) -> Dict[str, List[Dict[str, Any]]]:
    """
    Парсит файл с прокси-адресами и распределяет их по категориям.

    Args:
        file_path (Path, optional): Путь к файлу с прокси. По умолчанию используется глобальная переменная `proxies_list_path`.

    Returns:
        Dict[str, List[Dict[str, Any]]]: Словарь с распределёнными по типам прокси.
            Пример:
            {
                'http': [{'protocol': 'http', 'host': '1.2.3.4', 'port': '8080'}, ...],
                'socks4': [{'protocol': 'socks4', 'host': '5.6.7.8', 'port': '1080'}, ...],
                'socks5': [{'protocol': 'socks5', 'host': '9.10.11.12', 'port': '4145'}, ...]
            }
    
    Raises:
        FileNotFoundError: Если указанный файл не найден.
        Exception: Если возникает ошибка при парсинге прокси.
    """
```

**Назначение**: Парсинг файла со списком прокси-серверов и распределение их по категориям (http, socks4, socks5).

**Параметры**:
- `file_path` (Path): Путь к файлу, содержащему список прокси-серверов. По умолчанию используется значение глобальной переменной `proxies_list_path`.

**Возвращает**:
- `Dict[str, List[Dict[str, Any]]]: Словарь, где ключи - это типы прокси (http, socks4, socks5), а значения - списки словарей, каждый из которых содержит информацию о прокси-сервере (protocol, host, port).

**Вызывает исключения**:
- `FileNotFoundError`: Если файл с прокси не найден.
- `Exception`: Если возникает ошибка при парсинге файла.

**Как работает функция**:

1. Вызывает функцию `download_proxies_list` для загрузки актуального списка прокси.
2. Инициализирует пустой словарь для хранения прокси по категориям.
3. Открывает файл, указанный в `file_path`, и построчно считывает его содержимое.
4. Для каждой строки пытается извлечь протокол, хост и порт, используя регулярное выражение.
5. Если строка соответствует формату прокси, добавляет информацию о прокси в соответствующий список в словаре.
6. Возвращает словарь с распределенными прокси.

```
    Начало
     ↓
    Вызов download_proxies_list()
     ↓
    Инициализация словаря proxies
     ↓
    Чтение файла построчно
     │
     └── Для каждой строки:
         │
         └── Попытка извлечь протокол, хост и порт
             │
             ├── Успех → Добавление прокси в словарь
             │   │    
             │   └── Неудача →  Переход к следующей строке
             │       
             └── Конец файла
                 │
                 └── Возврат словаря proxies
```

**Примеры**:

```python
from pathlib import Path
from src.webdriver.proxy import get_proxies_dict

# Пример использования с параметрами по умолчанию
proxies = get_proxies_dict()
print(f"Полученные прокси (по умолчанию): {proxies}")

# Пример использования с указанием пути к файлу
custom_path = Path('custom_proxies.txt')
proxies = get_proxies_dict(file_path=custom_path)
print(f"Полученные прокси (с указанием пути): {proxies}")
```

### `check_proxy`

```python
def check_proxy(proxy: dict) -> bool:
    """
    Проверяет работоспособность прокси-сервера.
    
    Args:
        proxy (dict): Словарь с данными прокси (host, port, protocol).
            Пример:
            {'protocol': 'http', 'host': '1.2.3.4', 'port': '8080'}

    Returns:
        bool: True, если прокси работает, иначе False.
    """
```

**Назначение**: Проверка работоспособности прокси-сервера путем выполнения запроса через него.

**Параметры**:
- `proxy` (dict): Словарь, содержащий информацию о прокси-сервере, включая протокол, хост и порт.

**Возвращает**:
- `bool`: `True`, если прокси-сервер работает и возвращает код ответа 200, иначе `False`.

**Вызывает исключения**:
- `requests.exceptions.ProxyError`: Если возникает ошибка при подключении к прокси-серверу.
- `requests.exceptions.RequestException`: Если возникает общая ошибка при выполнении запроса.

**Как работает функция**:

1. Пытается выполнить GET-запрос к адресу "https://httpbin.org/ip" через указанный прокси-сервер.
2. Проверяет код ответа. Если код равен 200, функция считает, что прокси-сервер работает.
3. В случае возникновения исключений, связанных с прокси или запросом, функция считает, что прокси-сервер не работает.
4. Логирует информацию о результате проверки прокси-сервера.

```
    Начало
     ↓
    Попытка GET-запроса через прокси
     ↓
    Проверка кода ответа (200?)
     ├── Да → Логирование успеха, возврат True
     │   
     └── Нет → Логирование предупреждения, возврат False
     ↓
    Обработка исключений (ProxyError, RequestException)
     ↓
    Логирование ошибки, возврат False
     ↓
    Конец
```

**Примеры**:

```python
from src.webdriver.proxy import check_proxy

# Пример использования с рабочим прокси
working_proxy = {'protocol': 'http', 'host': '104.131.154.228', 'port': '8080'}  # Замените на рабочий прокси
result = check_proxy(working_proxy)
print(f"Результат проверки рабочего прокси: {result}")

# Пример использования с нерабочим прокси
not_working_proxy = {'protocol': 'http', 'host': '1.2.3.4', 'port': '8080'}  # Замените на нерабочий прокси
result = check_proxy(not_working_proxy)
print(f"Результат проверки нерабочего прокси: {result}")