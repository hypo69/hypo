## Ответ на Задачу No 409: Сумма разбиений

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Задача состоит из трех частей:
    *   **s(n, k):** Количество способов представить число `n` как сумму целых чисел, не превышающих `k`.
    *   **S(n):** Сумма `s(n, k)` для всех `k` от 1 до `n`.
    *   **F(n):** Сумма `S(i)` для всех `i` от 1 до `n`.
*   Нужно найти `F(10^15)` по модулю 1,000,000,007.

**Решение:**

1.  **Оптимизация вычислений `s(n, k)`:** Вместо рекурсивного перебора разбиений, используем динамическое программирование. `dp[i][j]` будет хранить количество разбиений числа `i` на слагаемые не более `j`.  Можно показать, что `s(n,k) = dp[n][k]`.

    *   `dp[i][j] = dp[i][j-1]` (не используем `j` в сумме) `+ dp[i-j][j]` (используем `j` как минимум один раз).

    *   База: `dp[0][j] = 1` (пустое разбиение для 0),  `dp[i][0] = 0` для i>0.

2.  **Вычисление `S(n)`:** После вычисления `dp` для всех нужных `k`,  `S(n)` - это просто сумма `dp[n][k]` для `k` от `1` до `n`.
    `S(n) = ∑ dp[n][k]` для `1 <= k <= n`.

3.  **Вычисление `F(n)`:**  `F(n)` - это сумма `S(i)` для `i` от 1 до `n`, что можно считать инкрементно.  `F(n) = ∑ S(i)` для `1 <= i <= n`.

4.  **Оптимизация `S(n)` и `F(n)`:** Заметим, что `S(n)` - это просто сумма количеств разбиений числа `n` с ограничениями на максимальное слагаемое.  Это можно представить как количество разбиений числа `n` на любые слагаемые, что равно  числу разбиений числа `n` на различные слагаемые.  Это число разбиений без ограничений на слагаемые.  Также известно, что  количество разбиений числа `n` без ограничений равно коэффициенту при x^n в произведении `1 / (1-x)(1-x^2)(1-x^3)...`.
    Асимптотика алгоритма с `dp` - `O(n^2)`. Асимптотика без `dp`  - `O(n*sqrt(n))`

5.  **Использование пентагональной теоремы:** Для нахождения количества разбиений `p(n)` можно использовать Пентагональную теорему Эйлера, которая гласит:

    `p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + p(n-12) + p(n-15) ...`

    Где аргументы - обобщённые пятиугольные числа вида `k * (3k - 1) / 2`.

    Используя эту теорему, мы можем эффективно найти `p(n)`.  Тогда `S(n) = p(n)`.

6.  **Вычисление `F(n)` для больших `n`:** Поскольку `n = 10^15` - очень большое число, нам нужно найти закономерность  или оптимизировать вычисление `F(n)`.  К сожалению, явной формулы для `F(n)` не существует, поэтому  придётся вычислять  `S(n)` для каждого `i` от `1` до `n`, но  с помощью пентагональной теоремы, что будет  намного быстрее, чем с `dp`.

7. **Сумма разбиений:** Можно доказать, что `S(n) = p(n)`, где `p(n)` – число разбиений числа `n`, то есть число способов представить `n` в виде суммы положительных целых чисел.
8.  **Вычисление `F(n)`:** `F(n) = ∑ p(i)` для `1 <= i <= n`
    Так как мы ищем F(10^15) mod 1000000007 и при этом n очень велико, то вряд ли можно это посчитать "в лоб".  Покажем, что нам не нужно считать `p(i)` для `i` вплоть до 10^15.  Так как нам нужен только остаток от деления на 1000000007, то можно накапливать сумму  по модулю.
    **Вычисление `F(n)` по модулю:** Накапливаем  сумму  `F(n)` по модулю.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать `MOD = 1000000007`.
3.  Инициализировать `F_n = 0`.
4.  Для каждого `i` от 1 до `n` (в нашем случае, n = 10^15):
    1.  Вычислить `p(i)` (количество разбиений `i`) с помощью пентагональной теоремы и по модулю `MOD`.
    2.  Прибавить `p(i)` к `F_n` по модулю `MOD`.
5.  Вернуть `F_n`.
6.  Конец.

### 3. Реализация на Python 3.12
```python
def solve():
    MOD = 1000000007
    n = 10**3 #Для примера, иначе вычисления будут очень долгими
    #n = 10**15 #Для решения, но это будет долго выполняться.
    f_n = 0

    partitions = [0] * (n + 1)
    partitions[0] = 1

    for i in range(1, n + 1):
        k = 1
        while True:
            pent1 = k * (3 * k - 1) // 2
            pent2 = k * (3 * k + 1) // 2
            if pent1 > i:
                break
            sign = 1 if k % 2 == 1 else -1
            partitions[i] = (partitions[i] + sign * partitions[i - pent1] + MOD) % MOD
            if pent2 <= i:
                partitions[i] = (partitions[i] + sign * partitions[i - pent2] + MOD) % MOD
            k += 1

    for i in range(1, n + 1):
      f_n = (f_n + partitions[i]) % MOD
    print(f_n)

solve()
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeVariables((Инициализировать MOD, n, F_n = 0, partitions[0] = 1))
    InitializeVariables --> LoopStartForI((Начать цикл: i от 1 до n))
    LoopStartForI --> InitializeK((Инициализировать k = 1))
    InitializeK --> LoopStartWhile((Начать цикл: пока pent1 <= i))
    LoopStartWhile --> CalculatePentagonals((Вычислить pent1, pent2))
    CalculatePentagonals --> CheckPent1((pent1 > i?))
    CheckPent1 -- Да --> LoopEndWhile((Конец цикла while))
    CheckPent1 -- Нет --> CalculateSign((sign = 1 if k % 2 == 1 else -1))
    CalculateSign --> UpdatePartitions((partitions[i] += sign * partitions[i - pent1] mod MOD))
    UpdatePartitions --> CheckPent2((pent2 <= i?))
    CheckPent2 -- Да --> UpdatePartitions2((partitions[i] += sign * partitions[i - pent2] mod MOD))
    UpdatePartitions2 --> IncrementK((k++))
    CheckPent2 -- Нет --> IncrementK((k++))
    IncrementK --> LoopStartWhile
    LoopEndWhile --> UpdateFn((F_n = (F_n + partitions[i]) mod MOD))
    UpdateFn --> LoopStartForI
    LoopStartForI --> OutputFn((Вывести F_n))
    OutputFn --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать MOD, n, F\_n = 0, partitions[0] = 1:** Инициализация константы модуля, верхней границы, суммы F(n) и массива для количества разбиений.
*   **Начать цикл: i от 1 до n:** Начало внешнего цикла для итерации по числам от 1 до n.
*   **Инициализировать k = 1:** Инициализация счетчика для вычисления пентагональных чисел.
*   **Начать цикл: пока pent1 <= i:** Начало внутреннего цикла while для вычисления пентагональных чисел до тех пор, пока pent1 не превысит i.
*   **Вычислить pent1, pent2:** Вычисление пентагональных чисел.
*   **pent1 > i?:** Проверка условия выхода из внутреннего цикла.
*   **Конец цикла while:** Конец внутреннего цикла.
*   **sign = 1 if k % 2 == 1 else -1:** Вычисление знака для коррекции суммы в пентагональной теореме.
*   **partitions\[i] += sign \* partitions\[i - pent1] mod MOD:** Обновление количества разбиений с использованием пентагональной теоремы по модулю.
*   **pent2 <= i?:** Проверка, нужно ли добавлять еще одно слагаемое из пентагонального ряда.
*   **partitions\[i] += sign \* partitions\[i - pent2] mod MOD:** Добавление еще одного слагаемого из пентагонального ряда по модулю.
*   **k++:** Увеличение счетчика для перехода к следующему пентагональному числу.
*   **F_n = (F_n + partitions[i]) mod MOD:** Накопление суммы значений разбиений по модулю.
*   **Вывести F_n:** Вывод итоговой суммы.
