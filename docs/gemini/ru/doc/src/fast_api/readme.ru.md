# Документация для `fast_api_rpc.py` и `main.py`

## Обзор

Этот документ содержит подробное описание архитектуры и принципов работы компонентов `fast_api_rpc.py` (серверная часть) и `main.py` (клиентская часть), которые используются для управления FastAPI сервером через удаленные вызовы процедур (RPC).

## Подробнее

В данном проекте реализована система управления FastAPI сервером через XML-RPC. `fast_api_rpc.py` предоставляет серверную часть, включающую класс `FastApiServer` для запуска FastAPI серверов и класс `CommandHandler` для управления этими серверами через RPC. `main.py` является клиентской частью, предоставляющей пользовательский интерфейс для отправки команд на сервер.

## Основные компоненты

### `fast_api_rpc.py` (Серверная часть)

#### Обзор

Содержит классы для запуска FastAPI серверов и управления ими через XML-RPC.

#### Классы

##### `FastApiServer`

**Описание**: Этот класс содержит логику для запуска FastAPI-сервера. Он отвечает за создание и настройку веб-сервера, а также за добавление новых маршрутов.

##### `CommandHandler`

**Описание**: Этот класс управляет вызовами функций управления сервером.

**Принцип работы**:
1.  При инициализации создает экземпляр `SimpleXMLRPCServer`, который прослушивает запросы на порту `9000` (по умолчанию).
2.  Регистрирует все методы класса для удаленного вызова через `register_instance(self)`.
3.  Запускает XML-RPC сервер в отдельном потоке, что позволяет ему работать параллельно с остальным кодом.

**Методы**:

-   `start_server()`: Запускает FastAPI сервер.
-   `stop_server()`: Останавливает FastAPI сервер.
-   `stop_all_servers()`: Останавливает все запущенные FastAPI серверы.
-   `status_servers()`: Возвращает статус серверов.
-   `add_new_route()`: Добавляет новый маршрут к FastAPI серверу.
-   `shutdown()`: Завершает работу RPC-сервера.

### `main.py` (Клиентская часть)

#### Обзор

Предоставляет пользовательский интерфейс для отправки команд на сервер `fast_api_rpc.py` через XML-RPC.

#### Классы

##### `ServerProxy`

**Описание**: Этот класс из библиотеки `xmlrpc.client` используется для создания объекта, через который можно вызывать методы XML-RPC сервера.

#### Функции

##### Основной цикл `while True`

**Описание**:
    Основная логика работы клиентской части.

**Принцип работы**:
   1. Отображает меню доступных команд.
   2. Запрашивает ввод пользователя.
   3. Парсит введенную строку, выделяя команду и её аргументы.
   4. В зависимости от введенной команды вызывает соответствующий метод RPC-сервера через объект `rpc_client`.

**Как работает цикл**:
1.  Отображение меню: Вывод списка доступных команд.
2.  Получение ввода пользователя: Чтение введенной пользователем строки.
3.  Парсинг команды: Разделение строки на команду и аргументы.
4.  Вызов RPC-метода: Отправка запроса на сервер через `rpc_client`.
5.  Обработка ответа: Отображение или игнорирование результата в консоль.

```
    A
    ↓
    B
    ↓
    C
    ↓
    D
    ↓
    E
```

Где:
A - Отображение меню доступных команд.
B - Получение ввода пользователя.
C - Парсинг введенной команды и аргументов.
D - Вызов соответствующего метода RPC-сервера через `rpc_client`.
E - Отображение результата или игнорирование ответа.

##### Функция вызова метода RPC-сервера

**Описание**:
   Функция отправляет запрос на сервер для выполнения указанной команды.

**Принцип работы**:
   1. Формирует XML-сообщение с запросом на вызов метода.
   2. Отправляет сообщение на сервер.
   3. Получает ответ от сервера.
   4. Возвращает результат выполнения команды.

**Как работает функция**:
1.  Формирование запроса: Создание XML-сообщения с именем метода и аргументами.
2.  Отправка запроса: Отправка сообщения на сервер по указанному адресу.
3.  Получение ответа: Ожидание и получение ответа от сервера.
4.  Обработка результата: Преобразование ответа в удобный формат и его возврат.

```
    A
    ↓
    B
    ↓
    C
    ↓
    D
```

Где:
A - Формирование XML-сообщения с запросом на вызов метода.
B - Отправка сообщения на сервер.
C - Получение ответа от сервера.
D - Преобразование ответа в удобный формат и его возврат.

## Взаимодействие между компонентами

1.  **Запуск `fast_api_rpc.py`**:
    *   Создается экземпляр `CommandHandler`.
    *   В конструкторе `CommandHandler` создается XML-RPC сервер, который начинает прослушивать порт `9000`.
    *   Запускается FastAPI-сервер(ы) в соответствии с кодом.
2.  **Запуск `main.py`**:
    *   Создается экземпляр `CommandHandler` (но он не играет роли, поскольку в `main.py` используется только RPC-клиент).
    *   Создается `ServerProxy`, который подключается к XML-RPC серверу по адресу `http://localhost:9000`.
    *   `main.py` начинает показывать меню и ожидать ввода пользователя.
3.  **Ввод команды**: Когда пользователь вводит команду в `main.py`, например `start 8000`:
    *   `main.py` анализирует эту строку, выделяет команду `start` и порт `8000`.
    *   `main.py` вызывает метод `start_server(port=8000, host="0.0.0.0")` у объекта `rpc_client`.
4.  **Обработка запроса на сервере**: XML-RPC клиент `rpc_client` создает XML-сообщение, которое отправляет на сервер `fast_api_rpc.py`.
    *   XML-RPC сервер в `fast_api_rpc.py` получает этот запрос.
    *   Он понимает, что нужно вызвать метод `start_server` у объекта `CommandHandler`.
    *   Вызывается метод `start_server`, который вызывает функцию `start_server` и запускает FastAPI сервер.
5.  **Возврат ответа**: XML-RPC сервер формирует ответ, содержащий результат вызова (в данном случае, это может быть `None`).
    *   Этот ответ отправляется обратно клиенту `main.py`.
    *   Клиент получает ответ.
6.  **Отображение результата**: `main.py` может отобразить результат в консоль (или проигнорировать его, если это None).
7.  **Повторение цикла**: `main.py` возвращается к началу цикла, отображая меню и ожидая ввода следующей команды.

## Преимущества подхода

*   **Управление сервером из другой программы**: Мы можем контролировать запущенный сервер через другой процесс или даже с другой машины.
*   **Разделение кода**: Логика управления сервером и пользовательский интерфейс разделены, что делает код более модульным и легким в обслуживании.
*   **Гибкость**: Мы можем добавить новые методы управления сервером, просто добавив их в `CommandHandler`, и они автоматически станут доступны через RPC.