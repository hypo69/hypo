# Анализ кода модуля `orbit.py`

**Качество кода**
6/10
- Плюсы
    - Код игры в целом понятен и имеет четкую логику, соответствующую описанию.
    - Присутствуют комментарии, которые объясняют основные шаги игры.
    - Используется `math` для математических операций.
    - Есть базовый `try-except` для обработки ввода пользователя.

- Минусы
    - Комментарии не соответствуют формату reStructuredText (RST).
    - Нет логирования ошибок.
    - Присутствует избыточное использование `try-except`.
    - Отсутствуют docstring для модуля и функции.
    - Некоторые вычисления могут быть оптимизированы для читаемости.
    - Имена переменных недостаточно информативны (например, `r`, `v`, `k`, `ag`, `vt`, `vr`).
    - Нет проверок на корректность ввода угла и скорости.
    - Код не структурирован в функции, которые можно было бы переиспользовать.
    - Использован `print` для вывода, что не соответствует стандартам логирования.

**Рекомендации по улучшению**

1. **Форматирование документации**:
   - Переписать все комментарии в формате reStructuredText (RST).
   - Добавить docstring к модулю и функции.

2. **Логирование**:
   - Заменить `print` на логирование через `src.logger.logger`.
   - Логировать ошибки и важные события игры.

3. **Обработка ошибок**:
   - Улучшить обработку ошибок, используя `logger.error` вместо `try-except` в основном цикле.

4. **Рефакторинг**:
   - Разбить код на более мелкие, переиспользуемые функции (например, функцию для расчета силы тяжести, функцию для обновления положения).
   - Переименовать переменные на более понятные (например, `r` на `distance_from_sun`).

5. **Улучшение кода**:
   - Добавить проверки на корректность ввода угла и скорости.
   - Упростить и уточнить вычисления.
   - Избегать повторных вычислений, если это возможно.

**Оптимизированный код**

```python
"""
Модуль ORBIT
================

Этот модуль представляет собой симуляцию простой солнечной системы, где игрок управляет ракетой,
пытаясь избежать Солнца и выйти на стабильную орбиту.

Игра завершается сообщением о победе или поражении, в зависимости от траектории полета.

Основные правила игры:
1. Игра начинается с ракеты на начальном расстоянии от Солнца.
2. Игрок вводит угол запуска (в градусах) и начальную скорость ракеты.
3. Ракета движется под воздействием гравитации Солнца.
4. Игра проверяет, не врезалась ли ракета в Солнце, не вышла ли на стабильную орбиту или не покинула ли систему.
5. Игра завершается сообщением в зависимости от результата.

Алгоритм:
1. Определяются константы:
    - начальное расстояние от Солнца (initial_distance).
    - гравитационная постоянная (gravitational_constant).
    - начальная радиальная скорость (initial_radial_velocity).
    - минимальное расстояние для столкновения (min_crash_distance).
    - максимальное расстояние для выхода из системы (max_escape_distance).
2. Игрок вводит угол запуска (launch_angle_degrees) и начальную скорость (initial_velocity).
3. Угол запуска преобразуется из градусов в радианы.
4. Вычисляются начальные декартовы координаты ракеты (x, y).
5. Вычисляются начальные декартовы компоненты скорости ракеты (vx, vy).
6. Запускается цикл (ранее цикл for на 1000 итераций), который симулирует траекторию полета:
   - Вычисляется текущее расстояние от ракеты до Солнца (distance_from_sun).
   - Если ракета слишком близко к Солнцу, выводится сообщение "CRASH" и игра завершается.
   - Если ракета слишком далеко от Солнца, выводится сообщение "OUT OF RANGE" и игра завершается.
   - Вычисляется ускорение ракеты из-за гравитации (gravitational_acceleration).
   - Обновляются радиальная и тангенциальная компоненты скорости (radial_velocity, tangential_velocity).
   - Обновляются декартовы компоненты скорости (vx, vy).
   - Обновляются декартовы координаты ракеты (x, y).
   - Вычисляется абсолютная скорость ракеты (total_velocity).
   - Вычисляется параметр k, используемый для проверки стабильности орбиты.
   - Если значение k между 0.99 и 1.01, выводится сообщение "ORBIT ESTABLISHED" и игра завершается.
7. Если цикл завершается без победы или поражения, игра завершается сообщением о неудаче.
"""
import math
from src.logger.logger import logger  # Импорт логгера


def play_orbit_game():
    """
    Симулирует игру "Орбита", где игрок запускает ракету и пытается вывести ее на стабильную орбиту вокруг Солнца.

    Функция запрашивает у пользователя угол запуска и начальную скорость, а затем моделирует движение ракеты,
    проверяя условия столкновения, ухода за пределы досягаемости или выхода на стабильную орбиту.
    """
    # Константы
    initial_distance = 200  # Начальное расстояние от Солнца
    gravitational_constant = 10000  # Гравитационная постоянная
    initial_radial_velocity = 0  # Начальная радиальная скорость
    min_crash_distance = 50  # Минимальное расстояние для столкновения
    max_escape_distance = 400  # Максимальное расстояние для выхода за пределы

    # Получение ввода от пользователя
    try:
        launch_angle_degrees = float(input("Введите угол запуска в градусах (0-90): "))
        initial_velocity = float(input("Введите начальную скорость: "))
        # Проверка валидности угла
        if not 0 <= launch_angle_degrees <= 90:
            logger.error(f"Неверный угол запуска: {launch_angle_degrees}. Угол должен быть в диапазоне от 0 до 90 градусов.")
            print("Неверный угол запуска. Угол должен быть в диапазоне от 0 до 90 градусов.")
            return
        # Проверка валидности скорости
        if initial_velocity <= 0:
            logger.error(f"Неверная начальная скорость: {initial_velocity}. Скорость должна быть положительным числом.")
            print("Неверная начальная скорость. Скорость должна быть положительным числом.")
            return

    except ValueError as e:
        logger.error(f"Неверный ввод. Пожалуйста, введите число. Ошибка: {e}")
        print("Неверный ввод. Пожалуйста, введите число.")
        return

    # Преобразование угла в радианы
    launch_angle_radians = math.radians(launch_angle_degrees)

    # Начальное положение ракеты
    x = initial_distance
    y = 0

    # Начальная скорость
    vx = initial_velocity * math.cos(launch_angle_radians)
    vy = initial_velocity * math.sin(launch_angle_radians)

    # Симуляция
    for _ in range(1000): # ранее цикл for с 1000 итераций
        # Расчет расстояния от Солнца
        distance_from_sun = math.sqrt(x**2 + y**2)

        # Проверка на столкновение
        if distance_from_sun < min_crash_distance:
            logger.info("Ракета столкнулась с Солнцем.") # логирование
            print("CRASH")
            return

        # Проверка на выход за пределы
        if distance_from_sun > max_escape_distance:
            logger.info("Ракета покинула систему.") # логирование
            print("OUT OF RANGE")
            return

        # Расчет гравитационного ускорения
        gravitational_acceleration = -gravitational_constant / distance_from_sun**2

        # Обновление радиальной и тангенциальной скорости
        radial_velocity = initial_radial_velocity + gravitational_acceleration * (x / distance_from_sun)
        tangential_velocity = initial_velocity + gravitational_acceleration * (y / distance_from_sun)

        # Обновление декартовых скоростей
        vx = tangential_velocity * (y / distance_from_sun)
        vy = tangential_velocity * (x / distance_from_sun)

        # Обновление позиции
        x = x + vx
        y = y + vy

        # Расчет общей скорости
        total_velocity = math.sqrt(vx**2 + vy**2)

        # Расчет параметра стабильной орбиты
        k = (total_velocity**2 * distance_from_sun) / gravitational_constant

        # Проверка на стабильную орбиту
        if 0.99 < k < 1.01:
            logger.info("Ракета вышла на стабильную орбиту.") # логирование
            print("ORBIT ESTABLISHED")
            return

    logger.info("Не удалось достичь стабильной орбиты.") # логирование
    print("Не удалось достичь стабильной орбиты.")


if __name__ == "__main__":
    play_orbit_game()
```