## Ответ на Задачу No 153: Интегральные точки на окружности

### 1. Анализ задачи и решение
**Понимание задачи:**

*   Нам нужно найти количество целых точек (x, y) на окружности с радиусом `r` и центром в начале координат. Уравнение окружности: `x² + y² = r²`.
*   `N(r)` - количество целых точек на окружности с радиусом `r`.
*   `S(r)` - сумма `r` для всех окружностей, где `N(r) > 0` при `r <= 100`.
*   Необходимо найти `S(10^8)`.

**Ключевые идеи:**

1.  **Связь с суммой квадратов:** Количество целых точек на окружности `x² + y² = r²` связано с представлением `r²` в виде суммы двух квадратов.  Если `r² = a² + b²` , тогда точки `(±a, ±b)` и `(±b, ±a)` будут лежать на окружности, итого 4 или 8 точек, если `a != b` или 4 если `a == 0` или `b == 0`, или 4, если `a=b`.
2.  **Представление целых чисел в виде суммы двух квадратов:**  Число может быть представлено в виде суммы двух квадратов, если в его каноническом разложении на простые множители простые числа вида `4k + 3` входят в четной степени.
3.  **Поиск r:** Вместо перебора всех `r` до 10<sup>8</sup> мы перебираем `r`, представляя их в виде суммы двух квадратов.

**Решение:**
1.  **Оптимизация:** Нам нет нужды перебирать все радиусы `r` от 1 до 10<sup>8</sup>, достаточно перебирать все пары чисел `a` и `b`, и вычислять `r` как `sqrt(a*a + b*b)`, т.к. только такие `r` будут иметь точки на окружности
2.  **Хранение уникальных r:** Мы будем использовать множество (set), чтобы отслеживать уже встречавшиеся значения `r`. Это поможет избежать дублирования `r` и считать сумму `S(r)` только для уникальных `r`.
3.  **Ограничение:** Для расчета `S(10^8)` нам нужно брать такие пары `a` и `b`, что `r = sqrt(a*a + b*b) <= 10^8`. Мы можем ограничить перебор `a` и `b` до `10^8`, т.к. `a` и `b` не могут быть больше, чем `r`.
4. **Вычисление суммы:**  Для каждого уникального значения `r` будем добавлять его к общей сумме `S`.

### 2. Алгоритм решения

1.  **Начать.**
2.  **Инициализация:** Создать переменную `total_sum = 0` и пустое множество `unique_r = set()`.
3.  **Цикл по a:** Для каждого `a` от `0` до `10^8`
    *   **Цикл по b:** Для каждого `b` от `0` до `a`
        *   Вычислить `r_squared = a*a + b*b`
        *   Вычислить `r = sqrt(r_squared)`.
        *   Если `r` целое и `r` <= 10<sup>8</sup>:
            *   Если `r` не в `unique_r`:
                *   Добавить `r` в `unique_r`.
                *   Добавить `r` к `total_sum`
4.  **Вернуть `total_sum`**.
5.  **Конец.**

### 3. Реализация на Python 3.12

```python
import math

def sum_of_radii(limit):
    """
    Calculates the sum of unique radii for which N(r) > 0 up to a given limit.

    Args:
        limit: The upper bound for the radius.

    Returns:
        The sum of unique radii.
    """
    total_sum = 0
    unique_r = set()

    for a in range(0, limit + 1):
      for b in range(0, a + 1):
        r_squared = a*a + b*b
        r = math.sqrt(r_squared)
        if r == int(r) and r <= limit:
            r = int(r)
            if r not in unique_r:
                unique_r.add(r)
                total_sum += r
    return total_sum

# Пример использования:
result = sum_of_radii(100)
print(f"S(100) = {result}")

result_large = sum_of_radii(10**8)
print(f"S(10^8) = {result_large}")
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> Initialize((Инициализация: total_sum = 0, unique_r = set()))
    Initialize --> LoopAStart((Начать цикл: a от 0 до limit))
    LoopAStart --> LoopBStart((Начать цикл: b от 0 до a))
    LoopBStart --> CalculateRSquared((Вычислить r_squared = a*a + b*b))
    CalculateRSquared --> CalculateR((Вычислить r = sqrt(r_squared)))
    CalculateR --> CheckRIsInteger((Проверить: r целое? и r <= limit))
    CheckRIsInteger -- Да --> CheckRInUnique((Проверить: r в unique_r?))
    CheckRIsInteger -- Нет --> LoopBEnd
    CheckRInUnique -- Нет --> AddRToUniqueAndSum((Добавить r в unique_r и total_sum))
    CheckRInUnique -- Да --> LoopBEnd
    AddRToUniqueAndSum --> LoopBEnd
    LoopBEnd --> LoopBNext
    LoopBNext -- Конец цикла B --> LoopANext
    LoopANext -- Конец цикла A --> ReturnSum((Вернуть total_sum))
     ReturnSum --> End((Конец))
```
**Legenda:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализация:** Инициализация суммы и множества для хранения уникальных радиусов.
*   **Начать цикл a, Начать цикл b:** Начало вложенных циклов для перебора `a` и `b`.
*   **Вычислить r_squared:** Вычисляется квадрат радиуса.
*    **Вычислить r:** Вычисляется радиус `r`.
*   **Проверить: r целое? и r <= limit:** Проверяем, является ли r целым числом и не превышает ли он лимит.
*   **Проверить: r в unique_r?:** Проверяем, не встречался ли уже данный радиус.
*   **Добавить r в unique_r и total_sum:**  Если радиус новый и удовлетворяет условиям, то добавляем его в множество `unique_r` и увеличиваем сумму.
*   **Конец цикла B, Конец цикла A:** Конец вложенных циклов.
*   **Вернуть total_sum:** Возвращаем общую сумму.
