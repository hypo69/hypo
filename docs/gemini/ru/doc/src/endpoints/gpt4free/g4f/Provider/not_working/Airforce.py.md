# Модуль Airforce
## Обзор

Модуль `Airforce` предоставляет асинхронные инструменты для взаимодействия с API Airforce, включая генерацию текста и изображений. Он поддерживает потоковую передачу данных и предоставляет возможность использования различных моделей, как текстовых, так и графических.

## Подробней

Модуль `Airforce` является асинхронным провайдером, предназначенным для работы с API Airforce. Он включает в себя функциональность для генерации текста и изображений, а также предоставляет инструменты для фильтрации контента и обработки ошибок. Модуль поддерживает потоковую передачу данных и позволяет использовать различные модели, предоставляемые Airforce. В частности, модуль содержит классы для:

- Получения списка доступных моделей.
- Генерации изображений на основе текстового запроса.
- Генерации текста на основе предоставленных сообщений.
- Фильтрации контента для удаления нежелательных элементов.

## Классы

### `Airforce`

**Описание**: Класс `Airforce` является основным классом модуля, который предоставляет методы для взаимодействия с API Airforce.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию данных.
- `ProviderModelMixin`: Добавляет функциональность для работы с моделями.

**Атрибуты**:
- `url` (str): Базовый URL API Airforce.
- `api_endpoint_completions` (str): URL для запросов на завершение текста.
- `api_endpoint_imagine2` (str): URL для запросов на генерацию изображений.
- `working` (bool): Указывает, работает ли провайдер.
- `supports_stream` (bool): Указывает, поддерживает ли провайдер потоковую передачу данных.
- `supports_system_message` (bool): Указывает, поддерживает ли провайдер системные сообщения.
- `supports_message_history` (bool): Указывает, поддерживает ли провайдер историю сообщений.
- `default_model` (str): Модель, используемая по умолчанию для генерации текста.
- `default_image_model` (str): Модель, используемая по умолчанию для генерации изображений.
- `models` (List[str]): Список поддерживаемых текстовых моделей.
- `image_models` (List[str]): Список поддерживаемых моделей изображений.
- `hidden_models` (Set[str]): Список скрытых моделей.
- `additional_models_imagine` (List[str]): Список дополнительных моделей для генерации изображений.
- `model_aliases` (Dict[str, str]): Словарь псевдонимов моделей.

**Методы**:
- `get_models()`: Возвращает список доступных моделей.
- `get_model(model: str) -> str`: Возвращает фактическое имя модели из псевдонима.
- `_filter_content(part_response: str) -> str`: Фильтрует нежелательный контент из частичного ответа.
- `_filter_response(response: str) -> str`: Фильтрует полный ответ для удаления системных ошибок и другого нежелательного текста.
- `generate_image(model: str, prompt: str, size: str, seed: int, proxy: str = None) -> AsyncResult`: Генерирует изображение на основе заданных параметров.
- `generate_text(model: str, messages: Messages, max_tokens: int, temperature: float, top_p: float, stream: bool, proxy: str = None) -> AsyncResult`: Генерирует текст на основе заданных параметров.
- `create_async_generator(model: str, messages: Messages, prompt: str = None, proxy: str = None, max_tokens: int = 512, temperature: float = 1, top_p: float = 1, stream: bool = True, size: str = "1:1", seed: int = None, **kwargs) -> AsyncResult`: Создает асинхронный генератор для генерации текста или изображений.

## Функции

### `split_message`
```python
def split_message(message: str, max_length: int = 1000) -> List[str]:
    """Splits the message into parts up to (max_length)."""
    chunks = []
    while len(message) > max_length:
        split_point = message.rfind(' ', 0, max_length)
        if split_point == -1:
            split_point = max_length
        chunks.append(message[:split_point])
        message = message[split_point:].strip()
    if message:
        chunks.append(message)
    return chunks
```

**Назначение**: Разбивает сообщение на части длиной не более `max_length`.

**Параметры**:
- `message` (str): Сообщение для разбиения.
- `max_length` (int, optional): Максимальная длина каждой части сообщения. По умолчанию `1000`.

**Возвращает**:
- `List[str]`: Список частей сообщения.

**Как работает функция**:

1. **Инициализация**: Функция принимает строку `message` и максимальную длину `max_length` (по умолчанию 1000). Создается пустой список `chunks` для хранения частей сообщения.
2. **Цикл разбиения**: Пока длина `message` превышает `max_length`, выполняется поиск последнего пробела в пределах `max_length`.
3. **Поиск точки разбиения**:
   - Если найден пробел (`split_point != -1`), сообщение разбивается по этому пробелу.
   - Если пробел не найден, сообщение разбивается по `max_length`.
4. **Добавление части**: Первая часть сообщения (до точки разбиения) добавляется в список `chunks`.
5. **Обновление сообщения**: Оставшаяся часть сообщения (после точки разбиения) сохраняется в `message` после удаления начальных пробелов.
6. **Окончание цикла**: Когда длина `message` становится меньше или равной `max_length`, оставшаяся часть добавляется в `chunks`.
7. **Возврат результата**: Функция возвращает список `chunks`, содержащий все части исходного сообщения.

```
Начало
  ↓
Сообщение, max_length
  ↓
Цикл: len(сообщение) > max_length?
  ├── Да → Поиск последнего пробела в сообщении[0:max_length]
  │       ├── Пробел найден → split_point = индекс пробела
  │       └── Пробел не найден → split_point = max_length
  │       ↓
  │       Добавить сообщение[0:split_point] в chunks
  │       ↓
  │       сообщение = сообщение[split_point:].strip()
  └── Нет → Добавить сообщение в chunks
  ↓
Возврат chunks
Конец
```

**Примеры**:

```python
>>> split_message("This is a long message that needs to be split into smaller parts.", max_length=10)
['This is a ', 'long messa', 'ge that ne', 'eds to be ', 'split into', ' smaller p', 'arts.']

>>> split_message("Short message", max_length=20)
['Short message']

>>> split_message("OneTwoThreeFourFiveSixSevenEightNineTen", max_length=5)
['OneTw', 'oThre', 'eFour', 'FiveS', 'ixSev', 'enEig', 'htNin', 'eTen']
```

### `Airforce.get_models`

```python
    @classmethod
    def get_models(cls):
        """Get available models with error handling"""
        ...
```

**Назначение**: Получает список доступных моделей с обработкой ошибок.

**Как работает функция**:

1. **Проверка наличия моделей изображений**: Проверяет, был ли уже получен список моделей изображений (`cls.image_models`).
2. **Получение моделей изображений**:
   - Если список моделей изображений пуст, пытается получить его с помощью HTTP-запроса к `f"{cls.url}/imagine2/models"`.
   - В случае успеха парсит JSON-ответ и сохраняет список моделей изображений в `cls.image_models`.
   - Если происходит ошибка при получении моделей изображений, логирует ошибку и использует `cls.additional_models_imagine` в качестве списка моделей изображений.
3. **Проверка наличия текстовых моделей**: Проверяет, был ли уже получен список текстовых моделей (`cls.models`).
4. **Получение текстовых моделей**:
   - Если список текстовых моделей пуст, пытается получить его с помощью HTTP-запроса к `f"{cls.url}/models"`.
   - В случае успеха парсит JSON-ответ и извлекает список идентификаторов моделей из поля `data`.
   - Расширяет список текстовых моделей моделями изображений и удаляет скрытые модели.
   - Если происходит ошибка при получении текстовых моделей, логирует ошибку и использует ключи из `cls.model_aliases` в качестве списка текстовых моделей.
5. **Возврат списка моделей**: Возвращает список доступных моделей (текстовых и графических) или список ключей из `cls.model_aliases` в случае ошибки.

```
Начало
  ↓
image_models пуст?
  ├── Да → Попытка получить image_models с api_endpoint_imagine2
  │       ├── Успех → Сохранить image_models
  │       └── Ошибка → Записать ошибку, image_models = additional_models_imagine
  └── Нет
  ↓
models пуст?
  ├── Да → Попытка получить models с api_endpoint_completions
  │       ├── Успех → Сохранить models, расширить image_models, удалить hidden_models
  │       └── Ошибка → Записать ошибку, models = model_aliases.keys()
  └── Нет
  ↓
Вернуть models
Конец
```

### `Airforce.get_model`

```python
    @classmethod
    def get_model(cls, model: str) -> str:
        """Get the actual model name from alias"""
        return cls.model_aliases.get(model, model or cls.default_model)
```

**Назначение**: Получает фактическое имя модели из псевдонима.

**Параметры**:
- `model` (str): Псевдоним модели.

**Возвращает**:
- `str`: Фактическое имя модели или модель по умолчанию, если псевдоним не найден.

**Как работает функция**:

1. **Поиск псевдонима**: Функция пытается получить значение из словаря `cls.model_aliases` по ключу `model`.
2. **Возврат значения**:
   - Если псевдоним найден, возвращается соответствующее значение (фактическое имя модели).
   - Если псевдоним не найден, возвращается либо переданное значение `model`, либо `cls.default_model`, если `model` равно `None`.

```
Начало
  ↓
model
  ↓
Поиск псевдонима model в model_aliases
  ├── Псевдоним найден → вернуть имя модели
  └── Псевдоним не найден → вернуть model или default_model
  ↓
Конец
```

**Примеры**:

```python
>>> Airforce.model_aliases = {"alias": "actual_model"}
>>> Airforce.default_model = "default_model"
>>> Airforce.get_model("alias")
'actual_model'

>>> Airforce.get_model("unknown")
'unknown'

>>> Airforce.get_model(None)
'default_model'
```

### `Airforce._filter_content`

```python
    @classmethod
    def _filter_content(cls, part_response: str) -> str:
        """
        Filters out unwanted content from the partial response.
        """
        part_response = re.sub(
            r"One message exceeds the \\d+chars per message limit\\..+https:\\/\\/discord\\.com\\/invite\\/\\S+",
            '',
            part_response
        )

        part_response = re.sub(
            r"Rate limit \\(\\d+\\/minute\\) exceeded\\. Join our discord for more: .+https:\\/\\/discord\\.com\\/invite\\/\\S+",
            '',
            part_response
        )

        return part_response
```

**Назначение**: Фильтрует нежелательный контент из частичного ответа.

**Параметры**:
- `part_response` (str): Частичный ответ для фильтрации.

**Возвращает**:
- `str`: Отфильтрованный частичный ответ.

**Как работает функция**:

1. **Удаление сообщений о превышении лимита символов**: Использует регулярное выражение для удаления сообщений о превышении лимита символов в сообщении и ссылок на Discord.
2. **Удаление сообщений об ограничении скорости**: Использует регулярное выражение для удаления сообщений об ограничении скорости и ссылок на Discord.
3. **Возврат отфильтрованного ответа**: Возвращает отфильтрованный частичный ответ.

```
Начало
  ↓
part_response
  ↓
Удаление сообщений о превышении лимита символов
  ↓
Удаление сообщений об ограничении скорости
  ↓
Вернуть отфильтрованный part_response
Конец
```

### `Airforce._filter_response`

```python
    @classmethod
    def _filter_response(cls, response: str) -> str:
        """
        Filters the full response to remove system errors and other unwanted text.
        """
        if "Model not found or too long input. Or any other error (xD)" in response:
            raise ValueError(response)

        filtered_response = re.sub(r"\\[ERROR\\] \'\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}\'", '', response)  # any-uncensored
        filtered_response = re.sub(r\'<\\|im_end\\|>\', '', filtered_response)  # remove <|im_end|> token
        filtered_response = re.sub(r\'</s>\', '', filtered_response)  # neural-chat-7b-v3-1  
        filtered_response = re.sub(r'^(Assistant: |AI: |ANSWER: |Output: )', '', filtered_response)  # phi-2
        filtered_response = cls._filter_content(filtered_response)
        return filtered_response
```

**Назначение**: Фильтрует полный ответ для удаления системных ошибок и другого нежелательного текста.

**Параметры**:
- `response` (str): Полный ответ для фильтрации.

**Возвращает**:
- `str`: Отфильтрованный полный ответ.

**Как работает функция**:

1. **Проверка на наличие ошибки модели**: Проверяет, содержит ли ответ сообщение об ошибке, связанной с моделью или длиной ввода. Если да, вызывает исключение `ValueError`.
2. **Удаление идентификаторов ошибок**: Использует регулярное выражение для удаления идентификаторов ошибок в формате `\\[ERROR\\] \'\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}\'`.
3. **Удаление токенов `<|im_end|>`**: Использует регулярное выражение для удаления токенов `<\\|im_end\\|>`.
4. **Удаление токенов `</s>`**: Использует регулярное выражение для удаления токенов `</s>`.
5. **Удаление префиксов**: Использует регулярное выражение для удаления префиксов "Assistant: ", "AI: ", "ANSWER: " и "Output: ".
6. **Фильтрация контента**: Вызывает метод `_filter_content` для дополнительной фильтрации контента.
7. **Возврат отфильтрованного ответа**: Возвращает отфильтрованный полный ответ.

```
Начало
  ↓
response
  ↓
Проверка на наличие ошибки модели
  ├── Ошибка найдена → Вызвать ValueError
  └── Ошибка не найдена
  ↓
Удаление идентификаторов ошибок
  ↓
Удаление токенов <|im_end|>
  ↓
Удаление токенов </s>
  ↓
Удаление префиксов
  ↓
Фильтрация контента с помощью _filter_content
  ↓
Вернуть отфильтрованный response
Конец
```

### `Airforce.generate_image`

```python
    @classmethod
    async def generate_image(
        cls,
        model: str,
        prompt: str,
        size: str,
        seed: int,
        proxy: str = None
    ) -> AsyncResult:
        ...
```

**Назначение**: Генерирует изображение на основе заданных параметров.

**Параметры**:
- `model` (str): Модель для генерации изображения.
- `prompt` (str): Текстовый запрос для генерации изображения.
- `size` (str): Размер изображения.
- `seed` (int): Зерно для генерации случайных чисел (для воспроизводимости).
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий объект `ImageResponse` с URL изображения и альтернативным текстом.

**Как работает функция**:

1. **Формирование заголовков**: Создает словарь `headers` с заголовками HTTP-запроса, включая `User-Agent`, `Accept`, `Accept-Language`, `Accept-Encoding` и `Content-Type`.
2. **Формирование параметров запроса**: Создает словарь `params` с параметрами запроса, включая `model`, `prompt`, `size` и `seed`.
3. **Выполнение асинхронного запроса**:
   - Использует `ClientSession` для выполнения асинхронного GET-запроса к `cls.api_endpoint_imagine2` с заданными параметрами и прокси.
   - Проверяет статус ответа. Если статус равен 200, извлекает URL изображения из ответа.
4. **Генерация результата**: Генерирует объект `ImageResponse` с URL изображения и текстовым запросом в качестве альтернативного текста, затем передает его в асинхронный генератор.
5. **Обработка ошибок**: Если статус ответа не равен 200, извлекает текст ошибки из ответа и вызывает исключение `RuntimeError`.

```
Начало
  ↓
model, prompt, size, seed, proxy
  ↓
Формирование заголовков и параметров запроса
  ↓
Асинхронный GET-запрос к api_endpoint_imagine2
  ↓
Проверка статуса ответа
  ├── Статус 200 → Извлечь URL изображения
  │               ↓
  │               Сгенерировать ImageResponse и передать в генератор
  └── Статус != 200 → Извлечь текст ошибки и вызвать RuntimeError
  ↓
Конец
```

### `Airforce.generate_text`

```python
    @classmethod
    async def generate_text(
        cls,
        model: str,
        messages: Messages,
        max_tokens: int,
        temperature: float,
        top_p: float,
        stream: bool,
        proxy: str = None
    ) -> AsyncResult:
        ...
```

**Назначение**: Генерирует текст на основе заданных параметров.

**Параметры**:
- `model` (str): Модель для генерации текста.
- `messages` (Messages): Список сообщений для передачи в модель.
- `max_tokens` (int): Максимальное количество токенов в ответе.
- `temperature` (float): Температура для управления случайностью генерации.
- `top_p` (float): Top-p для управления разнообразием генерации.
- `stream` (bool): Указывает, использовать ли потоковую передачу данных.
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий сгенерированный текст.

**Как работает функция**:

1. **Формирование заголовков**: Создает словарь `headers` с заголовками HTTP-запроса, включая `User-Agent`, `Accept`, `Accept-Language`, `Accept-Encoding` и `Content-Type`.
2. **Разбиение сообщений на части**:
   - Проходит по каждому сообщению в списке `messages`.
   - Разбивает содержимое каждого сообщения на части длиной не более 1000 символов с помощью функции `split_message`.
   - Создает новые сообщения для каждой части и добавляет их в список `final_messages`.
3. **Формирование данных запроса**: Создает словарь `data` с данными запроса, включая `messages`, `model`, `temperature`, `top_p` и `stream`.
4. **Добавление параметра max_tokens**: Если `max_tokens` не равно 512, добавляет его в словарь `data`.
5. **Выполнение асинхронного запроса**:
   - Использует `ClientSession` для выполнения асинхронного POST-запроса к `cls.api_endpoint_completions` с заданными данными и прокси.
   - Вызывает функцию `raise_for_status` для проверки статуса ответа.
6. **Обработка потокового ответа**:
   - Если `stream` равно `True`, читает ответ построчно.
   - Для каждой строки проверяет, начинается ли она с "data: ".
   - Если строка является данными, извлекает JSON-объект из строки.
   - Извлекает содержимое из поля `content` в объекте `delta` внутри `choices`.
   - Фильтрует содержимое с помощью функции `_filter_response`.
   - Передает отфильтрованное содержимое в асинхронный генератор.
7. **Обработка не потокового ответа**:
   - Если `stream` равно `False`, извлекает JSON-объект из ответа.
   - Извлекает информацию об использовании токенов из поля `usage`.
   - Извлекает содержимое из поля `content` в объекте `message` внутри `choices`.
   - Фильтрует содержимое с помощью функции `_filter_response`.
   - Передает отфильтрованное содержимое в асинхронный генератор.

```
Начало
  ↓
model, messages, max_tokens, temperature, top_p, stream, proxy
  ↓
Формирование заголовков
  ↓
Разбиение сообщений на части
  ↓
Формирование данных запроса
  ↓
Асинхронный POST-запрос к api_endpoint_completions
  ↓
Проверка статуса ответа
  ↓
Обработка потокового ответа (stream == True) или не потокового ответа (stream == False)
  ↓
Вернуть сгенерированный текст через асинхронный генератор
Конец
```

### `Airforce.create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        prompt: str = None,
        proxy: str = None,
        max_tokens: int = 512,
        temperature: float = 1,
        top_p: float = 1,
        stream: bool = True,
        size: str = "1:1",
        seed: int = None,
        **kwargs
    ) -> AsyncResult:
        ...
```

**Назначение**: Создает асинхронный генератор для генерации текста или изображений.

**Параметры**:
- `model` (str): Модель для генерации.
- `messages` (Messages): Список сообщений для передачи в модель.
- `prompt` (str, optional): Текстовый запрос для генерации изображения. По умолчанию `None`.
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.
- `max_tokens` (int, optional): Максимальное количество токенов в ответе. По умолчанию `512`.
- `temperature` (float, optional): Температура для управления случайностью генерации. По умолчанию `1`.
- `top_p` (float, optional): Top-p для управления разнообразием генерации. По умолчанию `1`.
- `stream` (bool, optional): Указывает, использовать ли потоковую передачу данных. По умолчанию `True`.
- `size` (str, optional): Размер изображения. По умолчанию `"1:1"`.
- `seed` (int, optional): Зерно для генерации случайных чисел (для воспроизводимости). По умолчанию `None`.
- `**kwargs`: Дополнительные параметры.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий сгенерированный текст или изображение.

**Как работает функция**:

1. **Получение имени модели**: Получает фактическое имя модели с помощью метода `get_model`.
2. **Проверка типа модели**: Проверяет, является ли модель моделью изображения.
3. **Генерация изображения**:
   - Если модель является моделью изображения, извлекает текстовый запрос из последнего сообщения в списке `messages`, если `prompt` не задан.
   - Генерирует случайное число для `seed`, если оно не задано.
   - Вызывает метод `generate_image` для генерации изображения.
   - Передает результат в асинхронный генератор.
4. **Генерация текста**:
   - Если модель не является моделью изображения, вызывает метод `generate_text` для генерации текста.
   - Передает результат в асинхронный генератор.

```
Начало
  ↓
model, messages, prompt, proxy, max_tokens, temperature, top_p, stream, size, seed, kwargs
  ↓
Получение имени модели с помощью get_model
  ↓
Проверка типа модели (модель изображения?)
  ├── Да → Генерация изображения с помощью generate_image
  └── Нет → Генерация текста с помощью generate_text
  ↓
Вернуть результат через асинхронный генератор
Конец