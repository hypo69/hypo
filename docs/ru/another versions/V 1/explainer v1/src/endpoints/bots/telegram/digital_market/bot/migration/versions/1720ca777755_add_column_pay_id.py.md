## **<алгоритм>**

1.  **Начало миграции (upgrade):**
    *   Получаем соединение с базой данных с помощью `op.get_bind()`.
    *   Выполняем SQL-запрос `PRAGMA table_info('purchases')` для получения информации о столбцах таблицы `purchases`.
    *   Извлекаем имена столбцов из результата запроса.
    *   Проверяем, существует ли столбец `payment_id` в списке столбцов.
        *   Если столбца `payment_id` нет:
            *   Добавляем столбец `payment_id` типа `String` с `nullable=False` в таблицу `purchases` с помощью `op.add_column()`.
            *   Создаем уникальное ограничение `uq_purchases_payment_id` для столбца `payment_id` в таблице `purchases` с помощью `op.create_unique_constraint()`.
        *   Если столбец `payment_id` уже существует:
            *   Выводим сообщение о том, что столбец уже существует и добавление пропускается.
2.  **Откат миграции (downgrade):**
    *   Получаем соединение с базой данных с помощью `op.get_bind()`.
    *   Выполняем SQL-запрос `PRAGMA table_info('purchases')` для получения информации о столбцах таблицы `purchases`.
    *   Извлекаем имена столбцов из результата запроса.
    *   Проверяем, существует ли столбец `payment_id` в списке столбцов.
        *   Если столбец `payment_id` существует:
            *   Удаляем уникальное ограничение `uq_purchases_payment_id` из таблицы `purchases` с помощью `op.drop_constraint()`.
            *   Удаляем столбец `payment_id` из таблицы `purchases` с помощью `op.drop_column()`.
        *   Если столбца `payment_id` не существует:
            *   Выводим сообщение о том, что столбец не существует и удаление пропускается.

## **<mermaid>**

```mermaid
flowchart TD
    subgraph upgrade
        A[Start Upgrade] --> B{Get Database Connection};
        B --> C{Execute SQL: PRAGMA table_info('purchases')};
        C --> D[Extract Column Names];
        D --> E{Check if 'payment_id' exists?};
        E -- No --> F[Add Column 'payment_id'];
        F --> G[Create Unique Constraint 'uq_purchases_payment_id'];
        G --> H[End Upgrade];
        E -- Yes --> I[Print: 'Column \'payment_id\' already exists, skip'];
        I --> H;

    end
    subgraph downgrade
        J[Start Downgrade] --> K{Get Database Connection};
        K --> L{Execute SQL: PRAGMA table_info('purchases')};
        L --> M[Extract Column Names];
         M --> N{Check if 'payment_id' exists?};
        N -- Yes --> O[Drop Constraint 'uq_purchases_payment_id'];
        O --> P[Drop Column 'payment_id'];
        P --> Q[End Downgrade];
        N -- No --> R[Print: 'Column \'payment_id\' not exists, skip'];
        R --> Q;

    end
```

## **<объяснение>**

### Импорты:

*   `from typing import Sequence, Union`: Импортирует типы `Sequence` и `Union` для аннотации типов переменных, что повышает читаемость кода и позволяет статическим анализаторам проверять типы.
    *   `Sequence` используется для обозначения последовательности элементов.
    *   `Union` используется для обозначения переменной, которая может принимать одно из нескольких указанных типов.
*   `from alembic import op`: Импортирует объект `op` из библиотеки `alembic`. `alembic` используется для управления миграциями базы данных. Объект `op` предоставляет функции для выполнения операций миграции, таких как добавление и удаление столбцов, индексов, ограничений и т.д.
*   `import sqlalchemy as sa`: Импортирует библиотеку `sqlalchemy` как `sa`. `sqlalchemy` - это ORM (Object-Relational Mapper), который используется для работы с базами данных. Здесь она используется для определения типов данных столбцов, таких как `sa.String()`, а также для создания SQL запросов.

### Переменные:

*   `revision: str = '1720ca777755'`:  Идентификатор текущей миграции. Используется `alembic` для отслеживания версий миграций.
*   `down_revision: Union[str, None] = '1b95d36c8908'`:  Идентификатор предыдущей миграции. Используется `alembic` для отслеживания версий миграций.
*   `branch_labels: Union[str, Sequence[str], None] = None`: Метки ветки, которые `alembic` может использовать для управления миграциями в разных ветвях.
*   `depends_on: Union[str, Sequence[str], None] = None`: Зависимости от других миграций, если таковые имеются.
*   `conn = op.get_bind()`: Получает объект соединения с базой данных. Используется для выполнения SQL-запросов напрямую через `sqlalchemy`.
*   `result = conn.execute(sa.text("PRAGMA table_info('purchases')"))`: Выполняет SQL-запрос к базе данных с использованием `sqlalchemy.text`.
    *   `sa.text("PRAGMA table_info('purchases')")` - запрос для получения метаданных о столбцах таблицы `purchases`.
*   `columns = [row[1] for row in result]`: Создает список имен столбцов, полученных из результата запроса `PRAGMA table_info`.  Индекс `1` соответствует имени столбца в результатах запроса.

### Функции:

*   `def upgrade() -> None:`: Функция, выполняющая миграцию базы данных, то есть добавляет новый столбец.
    *   Получает соединение с БД.
    *   Извлекает список столбцов из таблицы `purchases`.
    *   Если столбец `payment_id` отсутствует, добавляет его с типом `String` и ограничением уникальности.
    *   Если столбец уже существует, то пропускает добавление.
*    `def downgrade() -> None:`: Функция, выполняющая откат миграции, то есть удаляет столбец, если он существует.
   *   Получает соединение с БД.
   *   Извлекает список столбцов из таблицы `purchases`.
    *   Если столбец `payment_id` присутствует, удаляет его и ограничение уникальности.
    *   Если столбец не существует, то пропускает удаление.

### Ошибки и улучшения:

*   **Обработка ошибок**: Код неявно обрабатывает ошибку в случае, если столбец не существует, пропуская добавление или удаление и выводя сообщение в консоль. Можно добавить более явную обработку исключений.
*   **Логирование**: Вместо вывода сообщений в консоль, можно использовать библиотеку логирования Python, чтобы вести более подробный журнал операций миграции.
*   **Использование констант**: Имя таблицы (`purchases`) и имя столбца (`payment_id`) можно вынести в константы, чтобы избежать дублирования кода и облегчить его изменение в будущем.
*   **Гибкость**: Код напрямую работает с таблицей `purchases`. Можно сделать код более гибким, передавая имя таблицы как параметр.

### Цепочка взаимосвязей с другими частями проекта:

*   Этот файл миграции является частью `alembic`, что является инструментом для управления изменениями в схеме базы данных. Он используется для автоматического внесения изменений в базу данных при развертывании нового кода.
*   Этот файл связан с моделями данных (например, `purchases`), которые используют этот столбец `payment_id`.
*   Миграция выполняется с использованием `alembic` в рамках процесса развертывания, что позволяет коду работать с последней версией базы данных.
*   Изменения структуры БД могут повлиять на логику сервисов, использующих `purchases`, которые в свою очередь, являются частью бизнес-логики проекта.