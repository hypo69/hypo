# Анализ кода модуля e_192.md

**Качество кода**

9
-  Плюсы
    - Код хорошо структурирован, разбит на функции, каждая из которых выполняет определенную задачу.
    -  Используются понятные имена переменных и функций.
    - Присутствует подробная документация к задаче, алгоритму и реализации решения.
    - Наличие блок-схемы в формате mermaid.

-  Минусы
    -  Отсутствуют docstring для функций.
    -  Не используется `src.utils.jjson` для чтения файлов.
    -  Отсутствует логирование ошибок.

**Рекомендации по улучшению**
1. Добавить docstring к каждой функции в формате reStructuredText (RST).
2. Использовать `from src.logger.logger import logger` для логирования ошибок, а не `print`.
3. Вместо `return None` можно использовать `return` без возвращаемого значения, что эквивалентно `return None` в Python.
4.  Удалить неиспользуемые импорты.
5.  Вместо `return` в конце функции,  где не требуется явное указание возвращаемого значения, можно не указывать `return`, так как `return None` будет возвращен по умолчанию.
6.  Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson`, если в дальнейшем потребуется чтение данных из файла.
7.  Улучшить читаемость, добавив пустые строки между блоками кода.

**Оптимизированный код**
```python
"""
Модуль для решения задачи 192 Project Euler: Рациональные приближения.
=========================================================================================

Модуль содержит функции для вычисления цепных дробей, подходящих дробей
и нахождения рациональных приближений к квадратным корням.

Пример использования
--------------------

Пример вызова функций:

.. code-block:: python

    f_n_value = find_f_n()
    total_g_sum_result = calculate_sum_of_g_k()

"""
import math
from src.logger.logger import logger


def continued_fraction(x: float) -> list[int]:
    """
    Вычисляет цепную дробь для заданного числа.

    :param x: Вещественное число.
    :return: Список целых чисел, представляющих цепную дробь.
    """
    cf = []
    # Цикл выполняется, пока дробная часть x не равна нулю.
    while x != math.floor(x):
        # Добавляем целую часть x к цепной дроби.
        cf.append(math.floor(x))
        # Обновляем x, вычисляя обратную величину его дробной части.
        x = 1 / (x - math.floor(x))
    # Добавляем последнюю целую часть x к цепной дроби.
    cf.append(math.floor(x))
    return cf


def convergent(cf: list[int]) -> list[tuple[int, int]]:
    """
    Вычисляет подходящие дроби для заданной цепной дроби.

    :param cf: Список целых чисел, представляющих цепную дробь.
    :return: Список кортежей (числитель, знаменатель) подходящих дробей.
    """
    # Инициализируем список подходящих дробей начальными значениями.
    conv = [(0, 1), (1, 0)]
    # Перебираем элементы цепной дроби.
    for a in cf:
        # Вычисляем и добавляем следующую подходящую дробь.
        conv.append((conv[-1][0] * a + conv[-2][0], conv[-1][1] * a + conv[-2][1]))
    # Возвращаем список подходящих дробей, начиная с третьей.
    return conv[2:]


def find_f_n() -> int:
    """
    Находит наименьшее n, при котором рациональное приближение sqrt(2) равно 99/70.

    :return: Значение n.
    """
    # Целевые значения числителя и знаменателя.
    target_p = 99
    target_q = 70
    # Вычисляем квадратный корень из 2.
    x = math.sqrt(2)
    # Вычисляем цепную дробь для sqrt(2).
    cf = continued_fraction(x)
    # Вычисляем подходящие дроби для цепной дроби.
    convergents = convergent(cf)
    # Перебираем подходящие дроби.
    for p, q in convergents:
        # Проверяем, равна ли текущая дробь целевой.
        if p == target_p and q == target_q:
            return q
    # Если подходящая дробь не найдена, возвращаем None.
    #  return None # можно удалить так как по умолчанию возвращается None


def find_g_k(k: int) -> int:
    """
    Находит наименьшее n, при котором рациональное приближение sqrt(k) отличается от sqrt(k) менее чем на 1e-12.

    :param k: Целое число, для которого вычисляется приближение.
    :return: Значение n.
    """
    # Вычисляем квадратный корень из k.
    x = math.sqrt(k)
    # Вычисляем цепную дробь для sqrt(k).
    cf = continued_fraction(x)
    # Вычисляем подходящие дроби для цепной дроби.
    convergents = convergent(cf)
    # Перебираем подходящие дроби.
    for p, q in convergents:
        # Проверяем, удовлетворяет ли текущая дробь условию точности.
        if abs(x - p / q) < 1e-12:
            return q
    # Если подходящая дробь не найдена, возвращаем None.
    # return None # можно удалить так как по умолчанию возвращается None


def calculate_sum_of_g_k() -> int:
    """
    Вычисляет сумму g(k) для k от 2 до 10.

    :return: Сумма значений g(k).
    """
    total_g_sum = 0
    # Перебираем k от 2 до 10.
    for k in range(2, 11):
        # Вычисляем g(k).
        g_k = find_g_k(k)
        # Проверяем, что g(k) найдено.
        if g_k is not None:
            total_g_sum += g_k
        else:
            logger.error(f"Не удалось найти g(k) для k = {k}")
    return total_g_sum


# Вызов функций
f_n_value = find_f_n()
total_g_sum_result = calculate_sum_of_g_k()


print(f"f(n) for sqrt(2) = {f_n_value}")
print(f"Sum of g(k) for k from 2 to 10 = {total_g_sum_result}")
```