# Анализ кода модуля hmrabi.py

**Качество кода**
- Соответствие требованиям к формату кода (1-10): 8
    - Преимущества:
        - Код достаточно хорошо структурирован и имеет понятную логику.
        - Присутствуют комментарии, описывающие основные этапы игры и действия переменных.
        - Алгоритм игры в целом соответствует описанию.
    - Недостатки:
        - Отсутствует docstring для модуля и для каждого блока кода.
        - Не используются `j_loads` или `j_loads_ns` для чтения файлов (если это требуется).
        - Не используются логирование ошибок с помощью `logger.error`.
        - Код содержит много блоков `while True: try...except`, которые можно упростить.
        - Переменные написаны в snake_case, но с опечаткой `land_price` (должно быть land_price).
        - Комментарии не соответствуют стандарту RST.
        - Нет импорта `logger`

**Рекомендации по улучшению**
1. Добавить docstring для модуля, функций и методов в формате reStructuredText (RST).
2. Заменить стандартные блоки `try-except` на логирование ошибок с помощью `logger.error`.
3. Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` для чтения файлов, если это требуется (в данном коде чтения файлов нет).
4. Улучшить обработку ввода пользователя, используя более строгие проверки.
5. Изменить все переменные в snake_case на правильный вид, `land_price` -> `land_price`.
6. Добавить импорт `logger` из `src.logger.logger`.
7. Убрать ненужный `try except` в циклах для ввода данных.
8. Добавить более подробные комментарии в формате RST к блокам кода, особенно к сложным условиям и расчетам.
9. Вынести повторяющиеся куски кода в отдельные функции.

**Улучшенный код**
```python
"""
Модуль для игры "Хамурапи"
==========================

Этот модуль реализует текстовую экономическую игру "Хамурапи",
в которой игрок управляет древним городом, пытаясь выжить и процветать.

Игрок принимает решения о покупке и продаже земли, распределении урожая, посеве,
и следит за уровнем голода и численностью населения.

Игра заканчивается, если население города умирает от голода,
или по истечении 10 игровых лет.
"""
import random
from src.logger.logger import logger  # Импортируем logger #
# from src.utils.jjson import j_loads, j_loads_ns # Если потребуется работа с файлами

# Инициализация переменных
year = 0 # текущий год #
population = 100 # начальное население #
grain = 2800 # начальное количество зерна #
land = 1000 # начальная площадь земли #

print("Добро пожаловать в игру Хаммурапи!")

def get_int_input(prompt: str) -> int:
    """
    Запрашивает у пользователя ввод целого числа и обрабатывает ошибки ввода.

    :param prompt: Сообщение для пользователя, запрашивающее ввод.
    :return: Введенное пользователем целое число.
    """
    while True:
        try:
            value = int(input(prompt))
            return value
        except ValueError:
            logger.error('Ошибка: Пожалуйста, введите целое число.') # Заменили стандартную ошибку на логгер #
            print("Пожалуйста, введите целое число.")

# Основной игровой цикл
while year < 10 and population > 0:
    print(f"\nГод {year + 1}")
    print(f"Население: {population}")
    print(f"Зерно: {grain} бушелей")
    print(f"Земля: {land} акров")

    # Вычисляем случайную цену земли
    land_price = random.randint(15, 25) # Исправили land_price #
    print(f"Цена земли: {land_price} бушелей за акр")

    # Запрашиваем у игрока сколько земли купить или продать
    while True:
        land_trade = get_int_input("Сколько земли купить (+) или продать (-)? ")
        if land_trade > 0 and grain < land_trade * land_price:
            logger.error('Недостаточно зерна для покупки земли.') # Заменили стандартную ошибку на логгер #
            print("Недостаточно зерна для покупки земли.")
        elif land_trade < 0 and land < abs(land_trade):
            logger.error('Недостаточно земли для продажи.') # Заменили стандартную ошибку на логгер #
            print("Недостаточно земли для продажи.")
        else:
            break

    # Обновляем количество земли и зерна
    land += land_trade
    grain -= land_trade * land_price

    # Запрашиваем сколько зерна посеять
    while True:
        grain_to_plant = get_int_input("Сколько зерна использовать для посева? ")
        if grain < grain_to_plant:
            logger.error('Недостаточно зерна для посева.')  # Заменили стандартную ошибку на логгер #
            print("Недостаточно зерна для посева.")
        else:
            break

    # Вычисляем случайный урожай
    yield_per_acre = random.randint(1, 8)
    harvest = grain_to_plant * yield_per_acre
    grain += harvest

    # Вычисляем количество зерна съеденное крысами
    rats_damage = int(random.random() * 0.1 * grain)
    grain -= rats_damage
    print(f"Крысы съели {rats_damage} бушелей зерна.")

    # Запрашиваем, сколько зерна отдать на пропитание
    grain_to_feed = get_int_input("Сколько зерна отдать на пропитание? ")

    # Проверяем, хватит ли зерна на пропитание
    if grain_to_feed >= population:
        population = min(1000, int(population * 1.1)) # Увеличиваем популяцию на 10%, но не более 1000 #
        grain -= grain_to_feed
        print("Все сыты, население растёт!")
    else:
        starved = int(population * (1 - grain_to_feed / population )) # Рассчитываем число умерших от голода #
        population -= starved
        grain -= grain_to_feed
        print(f"{starved} человек умерло от голода.")
        if population <= 0:
            print("Вы проиграли, все население вымерло от голода!")
            break

    year += 1  # увеличиваем год на 1

if year == 10:
    print("Игра окончена. Прошло 10 лет.")

"""
Объяснение кода:
1. **Импорт модуля `random`**:
   - `import random`: Импортирует модуль `random`, который используется для генерации случайных чисел в игре.
   - `from src.logger.logger import logger`: Импортирует модуль `logger` для логирования ошибок.

2. **Инициализация переменных**:
   - `year = 0`: Инициализирует переменную `year` для отслеживания текущего года, начиная с 0.
   - `population = 100`: Устанавливает начальное количество населения в 100 человек.
   - `grain = 2800`: Устанавливает начальное количество зерна в 2800 бушелей.
   - `land = 1000`: Устанавливает начальное количество земли в 1000 акров.
   - `print("Добро пожаловать в игру Хаммурапи!")`: Выводит приветственное сообщение для игрока.

3. **Функция `get_int_input`**:
   - `def get_int_input(prompt: str) -> int:`: Определяет функцию для запроса ввода целого числа от пользователя.
   - :param prompt: Текст приглашения для ввода.
   - :return: Введенное пользователем целое число.
   - `while True:`: Цикл, который продолжает запрашивать ввод, пока не будет введено корректное целое число.
   - `try...except ValueError`: Обработка исключения `ValueError`, если пользователь ввел не целое число.
   - `logger.error('Ошибка: Пожалуйста, введите целое число.')`: Регистрирует ошибку ввода в лог.
   - `return value`: Возвращает введенное пользователем значение.

4. **Основной игровой цикл `while year < 10 and population > 0:`**:
   - Цикл `while` обеспечивает выполнение игры до тех пор, пока не пройдет 10 лет (`year < 10`) или пока население не станет равным или меньше 0 (`population > 0`).
   - `print(f"\\nГод {year + 1}")`: Выводит текущий год игры.
   - `print(f"Население: {population}")`: Выводит текущее количество населения.
   - `print(f"Зерно: {grain} бушелей")`: Выводит текущее количество зерна.
   - `print(f"Земля: {land} акров")`: Выводит текущее количество земли.

5. **Расчет цены земли**:
   - `land_price = random.randint(15, 25)`: Генерирует случайное целое число в диапазоне от 15 до 25 для цены земли.
   - `print(f"Цена земли: {land_price} бушелей за акр")`: Выводит цену земли.

6. **Ввод для покупки/продажи земли**:
   - `while True:`: Цикл, который повторяется до тех пор, пока ввод пользователя не будет корректным.
   - `land_trade = get_int_input("Сколько земли купить (+) или продать (-)? ")`: Запрашивает у пользователя количество земли для покупки или продажи, используя функцию `get_int_input` для обработки ввода.
   - `if land_trade > 0 and grain < land_trade * land_price:`: Проверяет, достаточно ли зерна для покупки земли. Если нет, выводит сообщение и ошибку в лог.
   - `elif land_trade < 0 and land < abs(land_trade):`: Проверяет, достаточно ли земли для продажи. Если нет, выводит сообщение и ошибку в лог.
   - `else: break`: Выход из цикла, если ввод корректен.

7. **Обновление запасов земли и зерна**:
   - `land += land_trade`: Обновляет количество земли.
   - `grain -= land_trade * land_price`: Обновляет количество зерна в зависимости от покупки или продажи земли.

8. **Ввод для посева зерна**:
   - `while True:`: Цикл, который повторяется до тех пор, пока ввод пользователя не будет корректным.
    -`grain_to_plant = get_int_input("Сколько зерна использовать для посева? ")`: Запрашивает у пользователя количество зерна для посева, используя функцию `get_int_input` для обработки ввода.
   - `if grain < grain_to_plant:`: Проверяет, достаточно ли зерна для посева. Если нет, выводит сообщение и ошибку в лог.
   - `else: break`: Выход из цикла, если ввод корректен.

9. **Расчет урожая**:
   - `yield_per_acre = random.randint(1, 8)`: Генерирует случайный урожай (от 1 до 8 бушелей на акр).
   - `harvest = grain_to_plant * yield_per_acre`: Вычисляет общий урожай зерна.
   - `grain += harvest`: Увеличивает количество зерна на величину урожая.

10. **Расчет ущерба от крыс**:
   - `rats_damage = int(random.random() * 0.1 * grain)`: Вычисляет случайный ущерб от крыс (от 0 до 10% текущего количества зерна).
   - `grain -= rats_damage`: Уменьшает количество зерна на величину ущерба от крыс.
   - `print(f"Крысы съели {rats_damage} бушелей зерна.")`: Выводит сообщение о количестве зерна, съеденном крысами.

11. **Ввод для кормления населения**:
    -`grain_to_feed = get_int_input("Сколько зерна отдать на пропитание? ")`: Запрашивает у пользователя количество зерна для пропитания населения, используя функцию `get_int_input` для обработки ввода.

12. **Проверка достаточности зерна для пропитания**:
   - `if grain_to_feed >= population:`: Проверяет, хватает ли зерна для пропитания всего населения.
   - `population = min(1000, int(population * 1.1))`: Если зерна достаточно, увеличивает население на 10%, но не более 1000.
   - `grain -= grain_to_feed`: Уменьшает количество зерна на количество, отданное для пропитания населения.
   - `else:`: Выполняется, если зерна недостаточно.
   - `starved = int(population * (1 - grain_to_feed / population ))`: Вычисляет количество умерших от голода пропорционально нехватке зерна.
   - `population -= starved`: Уменьшает количество населения на число умерших от голода.
   - `print(f"{starved} человек умерло от голода.")`: Выводит сообщение о количестве умерших от голода.
   - `if population <= 0:`: Проверяет, не умерло ли все население.
   - `print("Вы проиграли, все население вымерло от голода!")`: Выводит сообщение о поражении в случае смерти всего населения.
   - `break`: Выход из основного цикла, если все население умерло.

13. **Увеличение года**:
   - `year += 1`: Увеличивает значение года на 1.

14. **Завершение игры**:
   - `if year == 10:`: Проверяет, прошло ли 10 лет.
   - `print("Игра окончена. Прошло 10 лет.")`: Выводит сообщение об окончании игры, если прошло 10 лет.
"""
```