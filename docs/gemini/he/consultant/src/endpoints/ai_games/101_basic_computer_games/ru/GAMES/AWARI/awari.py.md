# Анализ кода модуля `awari.py`

**Качество кода**
- **Соблюдение требований к формату кода (1-10):**
    -  **1 (Формат документации):** Код не соответствует формату `reStructuredText (RST)`.  Вместо этого, используется обычный docstring. 
    -  **2 (Сохранение комментариев):** Комментарии после `#` сохранены, как и требуется.
    -  **3 (Обработка данных):** Не используется `j_loads` или `j_loads_ns` из `src.utils.jjson`, хотя в коде нет операций загрузки файлов.
    -  **4 (Анализ структуры):** Не хватает импорта `logger`.
    -  **5 (Рефакторинг и улучшения):**  Отсутствует документация в формате RST для функций, методов и классов. Не используется `from src.logger.logger import logger` для журналирования ошибок. Использование `try-except` ограничено, но можно улучшить обработку ошибок.
    -  **7 (Финальный код):** Код будет представлен в конце в едином блоке.
    -  **8 (Примеры кода):** Не включены примеры документации в формате RST и `TODO`.
    -  **9 (Дополнительные инструкции):** Документация отсутствует, и должна быть переписана в формате reStructuredText (RST).
-   **Преимущества:**
    -   Код игры "Авари" реализован логично и понятно.
    -   Имеется базовая игровая логика: ходы игрока и компьютера, проверка на конец игры и подсчет результатов.
    -   Код включает в себя ASCII-графику для отображения доски.
-   **Недостатки:**
    -   Отсутствует полноценная документация в формате RST.
    -   Отсутствует механизм логирования ошибок (logger)
    -  Не проводится полноценная обработка ошибок ввода.
    -  Код не использует рекомендованные функции для загрузки json `j_loads` or `j_loads_ns` (хотя загрузка данных из файлов не происходит).
    -  Некоторые части кода можно упростить.
    
**Рекомендации по улучшению**
1.  **Документация:** Необходимо переписать документацию в формате `reStructuredText (RST)`.
2.  **Логирование ошибок:** Необходимо использовать `from src.logger.logger import logger` и журналировать ошибки через `logger.error()`.
3.  **Обработка ошибок:** Улучшить обработку ошибок, особенно при вводе пользователя.
4.  **Структура кода:** Можно разделить код на более мелкие функции.
5.  **Импорты:** Добавить недостающие импорты (например, `logger`).
6.  **Использование `j_loads`:** Если в будущем потребуется загрузка данных, использовать `j_loads` или `j_loads_ns` из `src.utils.jjson`.
7. **Улучшение удобочитаемости**: Добавить пустые строки для повышения читаемости кода.

**Улучшенный код**
```python
"""
Модуль для реализации игры Авари.
=========================================================================================

Модуль предоставляет реализацию игры Авари, в которой игрок играет против компьютера.
Игра включает в себя базовую логику ходов игрока и компьютера, проверку конца игры и определение победителя.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    import awari

    awari.run_game()
"""

import random  # Импортируем модуль random #  Используется для выбора случайного хода компьютера
from src.logger.logger import logger # Импортируем logger для логирования ошибок #  Используется для записи ошибок

# Инициализация доски.
# Ячейки 0-5 - ячейки игрока, 6 - амбар игрока
# Ячейки 7-12 - ячейки компьютера, 13 - амбар компьютера
board = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]  #  Инициализируем игровую доску с начальными значениями


def display_board():
    """
    Выводит текущее состояние игровой доски.

    :return: None
    """
    print("----------------------------------------------------")  #  Выводим разделительную линию
    print(f"  {board[12]:2}  {board[11]:2}  {board[10]:2}  {board[9]:2}  {board[8]:2}  {board[7]:2}   ") # Выводим верхнюю часть доски (компьютер)
    print("----------------------------------------------------")# Выводим разделительную линию
    print(f"{board[13]:2}                                 {board[6]:2}") # Выводим амбары игроков (слева компьютер, справа игрок)
    print("----------------------------------------------------")# Выводим разделительную линию
    print(f"  {board[0]:2}  {board[1]:2}  {board[2]:2}  {board[3]:2}  {board[4]:2}  {board[5]:2}  ") # Выводим нижнюю часть доски (игрок)
    print("----------------------------------------------------")# Выводим разделительную линию


def player_turn():
    """
    Обрабатывает ход игрока.

    Запрашивает у игрока ввод номера ячейки, перемещает камни, проверяет захват.

    :return: None
    """
    while True: # Начинаем цикл для обработки ввода игрока
        try:
            cell = int(input("Выберите ячейку (0-5): ")) #  Запрашиваем у игрока номер ячейки
            if 0 <= cell <= 5 and board[cell] > 0: # Проверяем, что ввод корректный (ячейка в допустимом диапазоне и не пустая)
                break
            else:
                print("Недопустимый выбор. Выберите ячейку с камнями от 0 до 5.") #  Выводим сообщение об ошибке если выбор недопустимый
        except ValueError as e: #  Ловим ошибку, если ввод не является числом
            logger.error(f'Неверный ввод при выборе ячейки игроком: {e}') #  Логируем ошибку
            print("Неверный ввод. Пожалуйста, введите число.") # Выводим сообщение об ошибке
            continue

    stones = board[cell] # Сохраняем количество камней из выбранной ячейки
    board[cell] = 0  # Обнуляем выбранную ячейку
    current_cell = cell  # Сохраняем текущую позицию

    while stones > 0: #  Начинаем цикл распределения камней
        current_cell = (current_cell + 1) % 14 #  Переходим к следующей ячейке по часовой стрелке
        board[current_cell] += 1 # Добавляем камень в текущую ячейку
        stones -= 1 # Уменьшаем количество переносимых камней

    # Проверка на дополнительный ход если последний камень попал в амбар игрока
    if current_cell == 6: # Проверяем, что последний камень попал в амбар игрока
        print("Игрок получает дополнительный ход.") # Выводим сообщение
        display_board() # Выводим обновленную доску
        player_turn()  # Даем игроку еще один ход
        return # Выходим из функции

    # Захват камней
    if 0 <= current_cell <= 5 and board[current_cell] == 1: # Проверяем условие захвата (ячейка на стороне игрока и содержит 1 камень)
        opposite_cell = 12 - current_cell  #  Находим противоположную ячейку
        if board[opposite_cell] > 0: #  Проверяем, что противоположная ячейка не пустая
             board[6] += board[opposite_cell] + 1 # Добавляем камни в амбар игрока
             board[opposite_cell] = 0 #  Обнуляем противоположную ячейку
             board[current_cell] = 0 #  Обнуляем текущую ячейку
             print(f"Игрок захватывает камни из ячеек {current_cell} и {opposite_cell}") # Выводим сообщение о захвате


def computer_turn():
    """
    Обрабатывает ход компьютера.

    Компьютер выбирает случайную ячейку, перемещает камни, проверяет захват.

    :return: None
    """
    possible_moves = [i for i in range(7, 13) if board[i] > 0] #  Формируем список доступных ячеек для хода компьютера
    if not possible_moves: # Если список доступных ходов пуст
        return  # Если нет доступных ходов для компьютера, выйти

    cell = random.choice(possible_moves)  #  Выбираем случайную ячейку из списка доступных
    print(f"Компьютер выбирает ячейку {cell}") # Выводим сообщение о выборе компьютера
    stones = board[cell] #  Сохраняем количество камней из выбранной ячейки
    board[cell] = 0  #  Обнуляем выбранную ячейку
    current_cell = cell #  Сохраняем текущую позицию

    while stones > 0: # Начинаем цикл распределения камней
         current_cell = (current_cell + 1) % 14  #  Переходим к следующей ячейке по часовой стрелке
         board[current_cell] += 1 # Добавляем камень в текущую ячейку
         stones -= 1 # Уменьшаем количество переносимых камней

    # Проверка на дополнительный ход если последний камень попал в амбар компьютера
    if current_cell == 13:  # Проверяем, что последний камень попал в амбар компьютера
        print("Компьютер получает дополнительный ход.") # Выводим сообщение
        display_board() # Выводим обновленную доску
        computer_turn() #  Даем компьютеру еще один ход
        return # Выходим из функции

    # Захват камней
    if 7 <= current_cell <= 12 and board[current_cell] == 1: # Проверяем условие захвата (ячейка на стороне компьютера и содержит 1 камень)
          opposite_cell = 12 - current_cell # Находим противоположную ячейку
          if board[opposite_cell] > 0: #  Проверяем, что противоположная ячейка не пустая
             board[13] += board[opposite_cell] + 1 # Добавляем камни в амбар компьютера
             board[opposite_cell] = 0 # Обнуляем противоположную ячейку
             board[current_cell] = 0 #  Обнуляем текущую ячейку
             print(f"Компьютер захватывает камни из ячеек {current_cell} и {opposite_cell}") #  Выводим сообщение о захвате


def is_game_over():
    """
    Проверяет, закончена ли игра.

    Игра заканчивается, когда все ячейки на стороне игрока или компьютера пусты.

    :return: bool: True, если игра закончена, иначе False.
    """
    player_side_empty = all(board[i] == 0 for i in range(0, 6)) # Проверяем, что все ячейки на стороне игрока пусты
    computer_side_empty = all(board[i] == 0 for i in range(7, 13))# Проверяем, что все ячейки на стороне компьютера пусты
    return player_side_empty or computer_side_empty # Возвращаем результат проверки (игра закончилась если одна из сторон пуста)


def calculate_winner():
    """
    Определяет победителя и выводит результаты.

    Сравнивает количество камней в амбарах игрока и компьютера.

    :return: None
    """
    player_score = board[6] #  Получаем количество камней в амбаре игрока
    computer_score = board[13] #  Получаем количество камней в амбаре компьютера

    print(f"Игрок: {player_score} очков") # Выводим счет игрока
    print(f"Компьютер: {computer_score} очков") # Выводим счет компьютера

    if player_score > computer_score: #  Проверяем, кто победил
        print("Вы победили!")  # Выводим сообщение о победе игрока
    elif computer_score > player_score: # Проверяем, кто победил
        print("Компьютер победил!")# Выводим сообщение о победе компьютера
    else: # Если счет одинаковый
        print("Ничья!")# Выводим сообщение о ничьей


# Основной игровой цикл
while True: # Начинаем основной игровой цикл
    display_board() # Выводим доску
    player_turn() #  Ход игрока
    if is_game_over(): # Проверяем, закончилась ли игра
        break # Выходим из цикла, если игра закончилась
    display_board() # Выводим доску
    computer_turn() #  Ход компьютера
    if is_game_over(): # Проверяем, закончилась ли игра
       break # Выходим из цикла, если игра закончилась


# После завершения игры
display_board() # Выводим финальную доску
calculate_winner() # Выводим результаты и объявляем победителя

"""
Объяснение кода:
1. **Инициализация доски (`board`)**:
   - `board = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]`: Создается список, представляющий игровое поле. 
     Первые 6 элементов (0-5) - ячейки игрока, 7-12 - ячейки компьютера, 6 - амбар игрока, 13 - амбар компьютера. 
     В начале игры в каждой ячейке по 4 камня, в амбарах - 0.

2. **Функция `display_board()`**:
   - Выводит текущее состояние игровой доски на экран.

3. **Функция `player_turn()`**:
   - Обрабатывает ход игрока:
     - Запрашивает ввод номера ячейки (0-5).
     - Проверяет корректность ввода (число от 0 до 5 и ячейка не пустая).
     - Забирает камни из выбранной ячейки.
     - Распределяет камни по одной в каждую следующую ячейку по часовой стрелке.
     - Проверяет, попал ли последний камень в амбар игрока (ячейка 6). Если да, то игрок делает еще один ход.
     - Проверяет, попал ли последний камень в пустую ячейку на стороне игрока, если да, то захватывает камни напротив.

4. **Функция `computer_turn()`**:
   - Обрабатывает ход компьютера:
     - Выбирает случайную ячейку (7-12), не пустую.
     - Распределяет камни по одной в каждую следующую ячейку по часовой стрелке.
     - Проверяет, попал ли последний камень в амбар компьютера (ячейка 13). Если да, то компьютер делает еще один ход.
     - Проверяет, попал ли последний камень в пустую ячейку на стороне компьютера, если да, то захватывает камни напротив.

5.  **Функция `is_game_over()`**:
    - Проверяет, закончилась ли игра. Игра заканчивается, когда все ячейки на стороне игрока или компьютера пусты.

6.  **Функция `calculate_winner()`**:
    - Выводит количество очков каждого игрока.
    - Определяет победителя.

7.  **Основной игровой цикл (`while True`)**:
    - Выводит доску.
    - Дает ход игроку.
    - Проверяет, закончилась ли игра. Если да, то выходит из цикла.
    - Дает ход компьютеру.
    - Проверяет, закончилась ли игра. Если да, то выходит из цикла.

8.  **Вывод результатов**:
    - После завершения игры выводит доску и результаты.
"""
```