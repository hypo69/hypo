# Модуль `xml_json_convertor`

## Обзор

Модуль предоставляет утилиты для конвертации XML данных в словари и JSON в XML. Он включает функции для парсинга XML строк и преобразования XML деревьев элементов в представления словарей.

## Подробней

Этот модуль содержит набор функций, предназначенных для преобразования данных между форматами XML и JSON. Он используется в проекте `hypotez` для работы с данными, полученными из PrestaShop API, который часто предоставляет информацию в формате XML. Модуль позволяет преобразовывать XML-ответы в удобные для работы словари Python, а также создавать XML-документы из JSON-объектов для отправки данных в PrestaShop.

## Функции

### `dict2xml`

```python
def dict2xml(json_obj: dict, root_name: str = "product") -> str:
    """Конвертирует JSON словарь в XML строку.

    Args:
        json_obj (dict): JSON словарь для конвертации.
        root_name (str, optional): Имя корневого элемента. По умолчанию "product".

    Returns:
        str: XML строковое представление JSON.
    """
```

**Назначение**: Преобразует JSON-подобный словарь в XML-формат.

**Параметры**:
- `json_obj` (dict): JSON словарь, который необходимо преобразовать в XML.
- `root_name` (str, optional): Имя корневого элемента XML. По умолчанию "product".

**Возвращает**:
- `str`: Строка, содержащая XML-представление входного JSON-словаря.

**Как работает функция**:
1. Функция `dict2xml` принимает JSON-словарь и имя корневого элемента XML.
2. Определяется внутренняя функция `build_xml_element`, которая рекурсивно строит XML-элементы на основе данных JSON.
3. Создается корневой элемент XML с заданным именем.
4. Вызывается `build_xml_element` для заполнения корневого элемента данными из JSON-словаря.
5. XML-дерево преобразуется в строку и возвращается.

**Внутренние функции**:

#### `build_xml_element`

```python
def build_xml_element(parent, data):
    """Рекурсивно строит XML элементы из JSON данных."""
```

**Назначение**: Рекурсивно строит XML-элементы из JSON данных.

**Параметры**:
- `parent`: Родительский XML-элемент, к которому добавляются новые элементы.
- `data`: Данные JSON, используемые для построения XML-элементов.

**Как работает функция**:
1. Проверяет тип данных: словарь, список или примитивное значение.
2. Если данные - словарь, итерируется по элементам словаря:
   - Если ключ начинается с "@", то это атрибут родительского элемента.
   - Если ключ равен "#text", то это текстовое значение родительского элемента.
   - В противном случае создается подэлемент (ET.SubElement) родительского элемента с именем ключа, и рекурсивно вызывается `build_xml_element` для этого подэлемента.
3. Если данные - список, итерируется по элементам списка и рекурсивно вызывается `build_xml_element` для каждого элемента.
4. Если данные - примитивное значение, устанавливает текстовое значение родительского элемента равным этому значению.

**ASCII flowchart**:

```
JSON -> build_xml_element
|
-> Проверка типа данных (словарь/список/значение)
|
-> Если словарь:
|  |
|  -> Итерация по элементам словаря
|  |
|  -> Определение типа элемента (атрибут, текст, подэлемент)
|  |
|  -> Создание XML элемента
|  |
-> Если список:
|  |
|  -> Итерация по элементам списка
|  |
|  -> Рекурсивный вызов build_xml_element
|  |
-> Если значение:
|
-> Установка значения для XML элемента
|
XML
```

**Примеры**:

```python
json_data = {
    "product": {
        "name": "Test Product",
        "price": "10.00"
    }
}
xml_output = dict2xml(json_data)
print(xml_output)
# Вывод:
# <b>Test Product</b>10.00
```

### `_parse_node`

```python
def _parse_node(node: ET.Element) -> dict | str:
    """Разбирает XML узел в словарь.

    Args:
        node (ET.Element): XML элемент для разбора.

    Returns:
        dict | str: Представление XML узла в виде словаря или строка, если узел не имеет атрибутов или дочерних элементов.
    """
```

**Назначение**: Преобразует XML-узел в словарь Python.

**Параметры**:
- `node` (ET.Element): XML-элемент для разбора.

**Возвращает**:
- `dict | str`: Представление XML-узла в виде словаря или строка, если узел не имеет атрибутов или дочерних элементов.

**Как работает функция**:
1. Инициализирует пустой словарь `tree` для хранения результата и словарь `attrs` для хранения атрибутов узла.
2. Перебирает атрибуты узла и добавляет их в словарь `attrs`, пропуская атрибуты `href`.
3. Извлекает текстовое значение узла и удаляет начальные и конечные пробелы.
4. Если у узла есть атрибуты, добавляет их в словарь `tree` под ключом `'attrs'`.
5. Перебирает дочерние элементы узла и рекурсивно вызывает `_parse_node` для каждого из них.
6. Добавляет информацию о дочерних элементах в словарь `tree`. Если дочерний элемент встречается впервые, он добавляется в словарь `tree` как есть. Если дочерний элемент встречается несколько раз, он добавляется в список значений под соответствующим ключом.
7. Если узел не имеет дочерних элементов, добавляет его текстовое значение в словарь `tree` под ключом `'value'`.
8. Если словарь `tree` содержит только ключ `'value'`, возвращает значение этого ключа. В противном случае возвращает словарь `tree`.

**Внутренние функции**: Нет.

**ASCII flowchart**:

```
XML Node -> _parse_node
|
-> Инициализация словарей (tree, attrs)
|
-> Извлечение атрибутов
|
-> Извлечение текстового значения
|
-> Добавление атрибутов в словарь
|
-> Перебор дочерних элементов
|  |
|  -> Рекурсивный вызов _parse_node
|  |
|  -> Добавление информации о дочерних элементах в словарь
|  |
-> Если нет дочерних элементов:
|
-> Добавление текстового значения в словарь
|
-> Если словарь содержит только значение:
|
-> Возврат значения
|
-> Возврат словаря
```

**Примеры**:

```python
import xml.etree.ElementTree as ET

xml_string = "<root><child attr1='value1'>text</child></root>"
root = ET.fromstring(xml_string)
result = _parse_node(root)
print(result)
# Вывод: {'child': {'attrs': {'attr1': 'value1'}, 'value': 'text'}}
```

### `_make_dict`

```python
def _make_dict(tag: str, value: any) -> dict:
    """Генерирует новый словарь с тегом и значением.

    Args:
        tag (str): Имя тега XML элемента.
        value (any): Значение, связанное с тегом.

    Returns:
        dict: Словарь с именем тега в качестве ключа и значением в качестве значения словаря.
    """
```

**Назначение**: Создает словарь, где ключ - тег, а значение - данные, связанные с этим тегом.

**Параметры**:
- `tag` (str): Имя тега XML элемента.
- `value` (any): Значение, связанное с тегом.

**Возвращает**:
- `dict`: Словарь с именем тега в качестве ключа и значением в качестве значения.

**Как работает функция**:
1. Принимает тег и значение.
2. Пытается найти в теге пространство имен, используя регулярное выражение.
3. Если пространство имен найдено, создает словарь с ключами 'value' и 'xmlns', иначе использует переданное значение как есть.
4. Возвращает словарь, где ключ - тег, а значение - обработанные данные.

**Внутренние функции**: Нет.

**ASCII flowchart**:

```
Tag, Value -> _make_dict
|
-> Поиск пространства имен в теге
|
-> Если пространство имен найдено:
|  |
|  -> Создание словаря {'value': value, 'xmlns': namespace}
|  |
-> Иначе:
|
-> Использование переданного значения как есть
|
-> Возврат словаря {tag: value}
```

**Примеры**:

```python
result = _make_dict("tag", "value")
print(result)
# Вывод: {'tag': 'value'}

result = _make_dict("{http://www.w3.org/2001/XMLSchema}tag", "value")
print(result)
# Вывод: {'tag': {'value': 'value', 'xmlns': 'http://www.w3.org/2001/XMLSchema'}}
```

### `xml2dict`

```python
def xml2dict(xml: str) -> dict:
    """Разбирает XML строку в словарь.

    Args:
        xml (str): XML строка для разбора.

    Returns:
        dict: Представление XML в виде словаря.
    """
```

**Назначение**: Преобразует XML строку в словарь Python.

**Параметры**:
- `xml` (str): XML строка для разбора.

**Возвращает**:
- `dict`: Представление XML в виде словаря.

**Как работает функция**:
1. Принимает XML строку.
2. Использует `ET.fromstring` для преобразования XML строки в дерево элементов.
3. Вызывает функцию `ET2dict` для преобразования дерева элементов в словарь.
4. Возвращает полученный словарь.

**Внутренние функции**: Нет.

**ASCII flowchart**:

```
XML String -> xml2dict
|
-> Преобразование XML строки в дерево элементов (ET.fromstring)
|
-> Преобразование дерева элементов в словарь (ET2dict)
|
-> Возврат словаря
```

**Примеры**:

```python
xml_string = "<root><child>text</child></root>"
result = xml2dict(xml_string)
print(result)
# Вывод: {'root': {'child': 'text'}}
```

### `ET2dict`

```python
def ET2dict(element_tree: ET.Element) -> dict:
    """Преобразует XML дерево элементов в словарь.

    Args:
        element_tree (ET.Element): XML дерево элементов.

    Returns:
        dict: Представление XML дерева элементов в виде словаря.
    """
```

**Назначение**: Преобразует дерево элементов XML (ElementTree) в словарь Python.

**Параметры**:
- `element_tree` (ET.Element): Дерево элементов XML.

**Возвращает**:
- `dict`: Представление XML в виде словаря.

**Как работает функция**:
1. Принимает дерево элементов XML.
2. Вызывает функцию `_parse_node` для разбора корневого элемента дерева.
3. Вызывает функцию `_make_dict` для создания словаря, где ключ - тег корневого элемента, а значение - результат разбора `_parse_node`.
4. Возвращает полученный словарь.

**Внутренние функции**: Нет.

**ASCII flowchart**:

```
XML ElementTree -> ET2dict
|
-> Разбор корневого элемента (_parse_node)
|
-> Создание словаря {tag: value} (_make_dict)
|
-> Возврат словаря
```

**Примеры**:

```python
import xml.etree.ElementTree as ET

xml_string = "<root><child>text</child></root>"
root = ET.fromstring(xml_string)
result = ET2dict(root)
print(result)
# Вывод: {'root': {'child': {'value': 'text'}}}
```

### `presta_fields_to_xml`

```python
def presta_fields_to_xml(presta_fields_dict: dict) -> str:
    """! Конвертирует JSON словарь в XML строку с фиксированным корневым именем \'prestashop\'.

    Args:
        presta_fields_dict (dict): JSON словарь, содержащий данные (без ключа \'prestashop\').

    Returns:
        str: XML строковое представление JSON.
    """
```

**Назначение**: Преобразует JSON словарь в XML строку с фиксированным корневым элементом "prestashop".

**Параметры**:
- `presta_fields_dict` (dict): JSON словарь, содержащий данные для преобразования в XML.

**Возвращает**:
- `str`: XML строковое представление JSON.

**Как работает функция**:
1. Функция `presta_fields_to_xml` принимает JSON-словарь, который не содержит корневой ключ "prestashop".
2. Проверяет, не пуст ли входной словарь. Если пуст, возвращает пустую строку.
3. Определяется внутренняя функция `build_xml_element`, которая рекурсивно строит XML-элементы на основе данных JSON.
4. Получает первый ключ из словаря (например, 'product', 'category' и т. д.).
5. Создает корневой элемент XML с именем "prestashop".
6. Создает подэлемент корневого элемента с именем, полученным из первого ключа словаря.
7. Вызывает `build_xml_element` для заполнения подэлемента данными из JSON-словаря.
8. XML-дерево преобразуется в строку и возвращается.

**Внутренние функции**:

#### `build_xml_element`

```python
def build_xml_element(parent, data):
    """Рекурсивно строит XML элементы из JSON данных."""
```

**Назначение**: Рекурсивно строит XML элементы из JSON данных.

**Параметры**:
- `parent`: Родительский XML-элемент, к которому добавляются новые элементы.
- `data`: Данные JSON, используемые для построения XML-элементов.

**Как работает функция**:
1. Проверяет тип данных: словарь, список или примитивное значение.
2. Если данные - словарь, итерируется по элементам словаря:
   - Если ключ начинается с "@", то это атрибут родительского элемента.
   - Если ключ равен "#text", то это текстовое значение родительского элемента.
   - В противном случае создается подэлемент (ET.SubElement) родительского элемента с именем ключа, и рекурсивно вызывается `build_xml_element` для этого подэлемента.
3. Если данные - список, итерируется по элементам списка и рекурсивно вызывается `build_xml_element` для каждого элемента.
4. Если данные - примитивное значение, устанавливает текстовое значение родительского элемента равным этому значению.

**ASCII flowchart**:

```
JSON -> build_xml_element
|
-> Проверка типа данных (словарь/список/значение)
|
-> Если словарь:
|  |
|  -> Итерация по элементам словаря
|  |
|  -> Определение типа элемента (атрибут, текст, подэлемент)
|  |
|  -> Создание XML элемента
|  |
-> Если список:
|  |
|  -> Итерация по элементам списка
|  |
|  -> Рекурсивный вызов build_xml_element
|  |
-> Если значение:
|
-> Установка значения для XML элемента
|
XML
```

**Примеры**:

```python
json_data = {
    "product": {
        "name": "Test Product",
        "price": "10.00"
    }
}
xml_output = presta_fields_to_xml(json_data)
print(xml_output)
# Вывод:
# <prestashop><product><name>Test Product</name><price>10.00</price></product></prestashop>
```