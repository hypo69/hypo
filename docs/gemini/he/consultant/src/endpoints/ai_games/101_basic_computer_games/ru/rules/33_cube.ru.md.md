# Анализ кода модуля CUBE (Путешествие по 3D-кубу)

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):**
  - Текст в формате Markdown, который содержит описание игры, её правила и примеры использования.
  - Отсутствуют doctstring в стиле reStructuredText, как требуется.
  - Нет кода Python, нет проверок, нет комментариев.
- **Преимущества:**
   - Понятное описание правил игры.
   - Хорошая структура представления информации.
   - Примеры работы программы, которые помогают понять механику игры.
- **Недостатки:**
    - Отсутствует код игры.
    - Не используется reStructuredText для форматирования, как требуется.
    - Нет описания модулей, функций, классов и переменных.
    - Отсутствуют импорты.

**Рекомендации по улучшению:**
1. Реализовать саму игру на Python.
2. Добавить структуру reStructuredText (RST) для документации кода.
3. Включить docstring для всех функций и классов.
4. Убедиться, что используются `j_loads` или `j_loads_ns` из `src.utils.jjson` для обработки JSON (если необходимо).
5. Добавить логирование ошибок с помощью `src.logger.logger`.
6. Реализовать проверку на корректность ввода данных пользователя.
7. Разделить логику игры на отдельные функции и классы для лучшей читаемости и поддержки.
8. Учесть все ограничения, указанные в документе.
9. Добавить пояснения к коду с помощью комментариев в стиле `#`.

**Улучшенный код**
```markdown
### Название игры: **CUBE** (Путешествие по 3D-кубу)
"""
Модуль, реализующий игру "CUBE" - путешествие по 3D-кубу.

=========================================================================================

Этот модуль содержит логику для игры в куб 3x3x3, где игрок должен перемещаться от (1, 1, 1) до (3, 3, 3),
избегая мин.

Пример использования:

.. code-block:: python

    game = CubeGame()
    game.start()
"""

#### Описание
**CUBE** — это игра, в которой игрок должен путешествовать по 3D-кубу с размерами 3x3x3, перемещаясь от одной ячейки к другой, избегая 5 случайно размещённых мин. Каждая ячейка на кубе обозначена тремя числами (например, 1, 2, 1), указывающими её положение по уровням, столбцам и строкам. Игрок начинает в ячейке (1, 1, 1) и должен добраться до ячейки (3, 3, 3), двигаясь по вертикали или горизонтали (не по диагонали), не попав на мину. Игра начинается с 500 долларов, и до каждого хода игрок может ставить деньги на то, что он достигнет своей цели.

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - В начале игры вы начнёте с $500.
   - Программа случайным образом размещает 5 мин в различных ячейках куба.
   - Задача игрока — перемещаться от (1, 1, 1) до (3, 3, 3), избегая мин.

#### 2. **Основной цикл игры**
   - **Ввод данных:**
     1. Игрок выбирает, сколько денег он ставит перед началом игры.
     2. Затем программа спрашивает игрока, в какую ячейку он хочет переместиться. Ячейки определяются тремя числами (например, 1, 2, 1).
   
   - **Перемещение:**
     1. Игрок может перемещаться только на одну ячейку за раз, по вертикали или горизонтали.
     2. Если игрок попадает на мину, он теряет игру.
   
   - **Победа:**
     - Игра считается выигранной, если игрок успешно достигает ячейки (3, 3, 3) без попадания на мину.

#### 3. **Подсчёт победителя**
   - Победителем становится игрок, который добрался до (3, 3, 3), не наступив на мину.
   - Если игрок попадает на мину, он теряет деньги и игру.

#### 4. **Завершение игры**
   - После завершения игры игрок может выбрать:
     ```
     Хотите сыграть снова? (да/нет)
     ```

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в игру CUBE!
   У вас есть $500.
   Мины случайным образом размещены на поле. 
   Ваше начало: (1, 1, 1)
   Введите вашу ставку на достижение цели:
   > 50
   ```

2. **Перемещение игрока:**
   ```
   Ваше текущее местоположение: (1, 1, 1)
   Куда вы хотите переместиться? (введите 3 числа через запятую):
   > 2, 1, 1
   ```

3. **Результат хода:**
   ```
   Вы успешно переместились в (2, 1, 1).
   Мины на поле: [x, x, x, x, x]
   Ваш баланс: $450
   ```

4. **Завершение игры:**
   ```
   Вы успешно достигли цели! Вы победили!
   Хотите сыграть снова? (да/нет)
   > нет
   Спасибо за игру!
   ```

---

### Возможные ограничения
- Игрок может делать только горизонтальные или вертикальные ходы.
- Если игрок совершает несанкционированный ход (например, меняет два или более числа), он теряет игру.
- Мины размещаются случайным образом, и вероятность попасть на мину зависит от количества ходов.

---

### Реализация
Игра реализована с использованием случайных чисел для генерации мин на поле и проверки каждого хода игрока.
```python
"""
Модуль, реализующий игру "CUBE" - путешествие по 3D-кубу.

=========================================================================================

Этот модуль содержит логику для игры в куб 3x3x3, где игрок должен перемещаться от (1, 1, 1) до (3, 3, 3),
избегая мин.

Пример использования:

.. code-block:: python

    game = CubeGame()
    game.start()
"""
import random # импортируем модуль random для генерации случайных чисел
from src.logger.logger import logger  # импортируем logger для логирования
from typing import List, Tuple # импортируем List и Tuple для аннотации типов
from src.utils.jjson import j_loads_ns # импортируем j_loads_ns для загрузки json

class CubeGame:
    """
    Класс, представляющий игру "CUBE".

    :ivar int balance: начальный баланс игрока.
    :ivar List[Tuple[int, int, int]]: координаты мин на кубе.
    :ivar Tuple[int, int, int] current_position: текущая позиция игрока.
    :ivar bool game_over: флаг, показывающий, закончилась ли игра.
    """
    def __init__(self):
        """
        Инициализирует игру. Устанавливает начальные параметры, такие как баланс игрока,
        генерирует случайные позиции мин и определяет стартовую позицию игрока.
        """
        self.balance = 500 # устанавливаем начальный баланс игрока
        self.mines = self._generate_mines() # генерируем случайные позиции мин
        self.current_position = (1, 1, 1) # устанавливаем начальную позицию игрока
        self.game_over = False # игра не закончена

    def _generate_mines(self) -> List[Tuple[int, int, int]]:
        """
        Генерирует список случайных позиций мин на кубе.

        :return: список координат мин.
        :rtype: List[Tuple[int, int, int]]
        """
        mines = set() # создаем множество для хранения мин
        while len(mines) < 5: # пока не будет 5 мин
            mine = (random.randint(1, 3), random.randint(1, 3), random.randint(1, 3)) # генерируем случайную позицию мины
            mines.add(mine) # добавляем ее в множество
        return list(mines) # возвращаем список позиций мин

    def _is_valid_move(self, move: Tuple[int, int, int]) -> bool:
        """
        Проверяет, является ли ход допустимым.

        :param move: координаты следующего хода.
        :type move: Tuple[int, int, int]
        :return: True, если ход допустим, False - в противном случае.
        :rtype: bool
        """
        x1, y1, z1 = self.current_position # получаем текущие координаты
        x2, y2, z2 = move # получаем координаты следующего хода
        diff_count = abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2) # считаем разницу координат
        if diff_count != 1: # если разница не 1, ход не валидный
            logger.error(f'Недопустимый ход: {move}') # логируем ошибку
            return False # возвращаем False
        return True # иначе возвращаем True

    def _is_mine(self, position: Tuple[int, int, int]) -> bool:
         """
         Проверяет, находится ли в заданной позиции мина.

         :param position: координаты проверяемой позиции.
         :type position: Tuple[int, int, int]
         :return: True, если мина есть, False - в противном случае.
         :rtype: bool
         """
         return position in self.mines # возвращаем True если позиция есть в списке мин

    def _make_move(self, move: Tuple[int, int, int]) -> None:
        """
        Выполняет ход игрока, проверяя, попал ли он на мину.

        :param move: координаты следующего хода.
        :type move: Tuple[int, int, int]
        :return: None
        """
        if self._is_mine(move): # проверяем, попал ли игрок на мину
            self.game_over = True # игра закончена
            logger.info(f'Игрок попал на мину в {move}') # логируем это
            print('Вы попали на мину! Игра окончена.') # выводим сообщение
            return # завершаем выполнение функции

        self.current_position = move # обновляем текущую позицию игрока
        logger.info(f'Игрок переместился в {move}') # логируем перемещение

    def _check_win(self) -> bool:
        """
        Проверяет, достиг ли игрок цели.

        :return: True, если игрок достиг цели, False - в противном случае.
        :rtype: bool
        """
        if self.current_position == (3, 3, 3): # проверяем достиг ли игрок цели
            logger.info('Игрок достиг цели!') # логируем победу
            return True # возвращаем True
        return False # возвращаем False

    def _get_bet(self) -> int:
        """
        Получает ставку от игрока.

        :return: ставка игрока.
        :rtype: int
        """
        while True: # запускаем цикл
            try:
                bet = int(input('Введите вашу ставку на достижение цели: ')) # получаем ставку
                if 0 < bet <= self.balance: # проверяем, что ставка валидная
                    return bet # возвращаем ставку
                else: # иначе
                    print(f'Некорректная ставка. Ваш баланс: {self.balance}. Попробуйте еще раз.') # выводим сообщение
            except ValueError: # если не введено число
                print('Некорректный ввод. Попробуйте еще раз.') # выводим сообщение

    def _get_move(self) -> Tuple[int, int, int]:
        """
        Получает ход от игрока.

        :return: координаты хода игрока.
        :rtype: Tuple[int, int, int]
        """
        while True: # запускаем цикл
            try:
                move_str = input('Куда вы хотите переместиться? (введите 3 числа через запятую): ') # получаем ввод пользователя
                move = tuple(map(int, move_str.split(','))) # преобразуем в кортеж чисел
                if len(move) == 3: # если введено 3 числа
                    if all(1 <= x <= 3 for x in move): # проверяем валидность чисел
                         return move # возвращаем кортеж
                    else:
                        print('Координаты должны быть в диапазоне от 1 до 3.') # выводим сообщение
                else: # если чисел не 3
                    print('Некорректный ввод. Введите три числа через запятую.') # выводим сообщение
            except ValueError:
                print('Некорректный ввод. Попробуйте еще раз.') # выводим сообщение

    def start(self) -> None:
        """
        Запускает игру.

        :return: None
        """
        print('Добро пожаловать в игру CUBE!') # приветствуем пользователя
        print(f'У вас есть ${self.balance}.') # выводим баланс
        print('Мины случайным образом размещены на поле.') # выводим сообщение
        print(f'Ваше начало: {self.current_position}') # выводим текущую позицию
        bet = self._get_bet() # получаем ставку игрока
        self.balance -= bet # уменьшаем баланс на ставку
        while not self.game_over: # пока игра не закончена
             print(f'Ваше текущее местоположение: {self.current_position}') # выводим текущую позицию
             move = self._get_move() # получаем ход игрока
             if self._is_valid_move(move): # проверяем ход
                 self._make_move(move) # делаем ход
                 if self._check_win(): # проверяем победу
                     self.game_over = True # игра закончена
                     self.balance += bet * 2 # увеличиваем баланс в 2 раза
                     print('Вы успешно достигли цели! Вы победили!') # выводим сообщение
                     print(f'Ваш баланс: ${self.balance}') # выводим баланс
             else: # если ход не валидный
                 print('Неверный ход. Попробуйте еще раз.') # выводим сообщение

        play_again = input('Хотите сыграть снова? (да/нет) ').lower() # спрашиваем, хочет ли игрок играть снова
        if play_again == 'да': # если да
            CubeGame().start() # начинаем новую игру
        else: # иначе
            print('Спасибо за игру!') # благодарим за игру

if __name__ == '__main__':
    CubeGame().start() # запускаем игру
```