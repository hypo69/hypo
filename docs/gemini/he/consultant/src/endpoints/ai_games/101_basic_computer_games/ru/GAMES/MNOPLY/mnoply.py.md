# Анализ кода модуля `mnoply.py`

**Качество кода**
 -  Соответствие требованиям к формату кода (от 1 до 10): 7
    -  Преимущества:
        - Код игры логически структурирован и понятен.
        -  Используются понятные имена переменных.
        -  Наличие комментариев, поясняющих основные блоки кода.
        -  Присутствует описание игры и алгоритма в начале файла.
        -  Использование f-строк для форматирования вывода.
    -  Недостатки:
        -  Отсутствует docstring для модуля.
        -  Комментарии `#` не соответствуют формату RST.
        -  Не используется `j_loads` или `j_loads_ns` для загрузки данных (хотя в данном случае это не требуется).
        -  Отсутствует обработка ошибок и логирование.
        -  Не используются константы для магических чисел (например, 24 - количество ячеек).
        -  Нет документации для переменных.
        -  Не соблюдается принцип DRY (Don't Repeat Yourself) - дублируется код для обработки каждого игрока.

**Рекомендации по улучшению**

1. Добавить docstring в формате RST для модуля.
2. Перевести все комментарии `#` в формат RST.
3. Добавить логирование ошибок с использованием `src.logger.logger`.
4. Использовать константы для магических чисел.
5. Оптимизировать код для игроков, чтобы избежать дублирования кода (использовать функцию или цикл).
6. Добавить документацию в формате RST для всех переменных, констант и функций.
7. Добавить обработку возможных ошибок с помощью `try-except` и `logger.error`.
8. Использовать `j_loads` или `j_loads_ns` если потребуется загрузка данных из файлов.
9. Добавить проверку на корректность входных данных.

**Улучшенный код**

```python
"""
Модуль реализует упрощенную версию игры "Монополия".
=========================================================================================

В игре участвуют два игрока, которые по очереди бросают кубик и перемещаются по игровому полю.
Каждая ячейка поля имеет свою стоимость, которая либо добавляется, либо вычитается из капитала игрока.
Цель игры - остаться с наибольшей суммой денег после заданного количества раундов.

Пример использования:
--------------------
Запустите этот скрипт для начала игры в монополию. Результаты каждого раунда и победитель будут выведены в консоль.

.. code-block:: python

    python mnoply.py

"""
import random
from src.logger.logger import logger  #  импортируем logger #
from typing import List # импортируем List

#: Количество ячеек на игровом поле.
BOARD_SIZE: int = 24 # Константа для размера игрового поля #
#: Начальный капитал каждого игрока.
INITIAL_CAPITAL: int = 1500 # Константа для начального капитала #
#: Количество раундов в игре.
NUMBER_OF_ROUNDS: int = 10 # Константа для количества раундов #
#: Стоимости ячеек на игровом поле.
BOARD_VALUES: List[int] = [  #  константа значений игрового поля #
    -200, 100, -100, 200, -50, 50, -150, 150, 0,
    -200, 100, -100, 200, -50, 50, -150, 150, 0,
    -200, 100, -100, 200, -50, 50
]


def play_round(player_number: int, current_position: int, current_money: int) -> tuple[int, int]:
    """
    Обрабатывает ход игрока в текущем раунде.

    :param player_number: Номер игрока (1 или 2).
    :param current_position: Текущая позиция игрока на поле.
    :param current_money: Текущее количество денег игрока.
    :return: Обновленная позиция и количество денег игрока.
    """
    try:
        dice_roll: int = random.randint(1, 6) #  выбрасываем случайное число от 1 до 6 #
        logger.debug(f'Игрок {player_number}: бросок кубика - {dice_roll}') # логируем бросок кубика #

        new_position: int = (current_position + dice_roll) % BOARD_SIZE #  вычисляем новую позицию #
        new_money: int = current_money + BOARD_VALUES[new_position] #  обновляем деньги #
        logger.debug(f'Игрок {player_number}: новая позиция - {new_position + 1}, деньги - {new_money}') #  логируем новую позицию и деньги #
        print(f"   Бросок кубика: {dice_roll}") # выводим результат броска кубика #
        print(f"   Позиция: {new_position + 1}, Деньги: {new_money}") #  выводим текущую позицию и деньги игрока #
        return new_position, new_money #  возвращаем новые позицию и деньги #
    except Exception as e:
        logger.error(f'Ошибка при обработке хода игрока {player_number}: {e}') # логируем ошибку #
        return current_position, current_money # в случае ошибки возвращаем прежние значения #


def main() -> None:
    """
     Основная функция запуска игры.
    """
    player1_money: int = INITIAL_CAPITAL  #  начальный капитал первого игрока #
    player2_money: int = INITIAL_CAPITAL  #  начальный капитал второго игрока #
    player1_position: int = 0  #  начальная позиция первого игрока #
    player2_position: int = 0  #  начальная позиция второго игрока #

    for round_number in range(1, NUMBER_OF_ROUNDS + 1): #  цикл для каждого раунда #
        print(f"\nРаунд {round_number}") # выводим номер раунда #

        player1_position, player1_money = play_round(1, player1_position, player1_money) #  вызываем функцию для первого игрока #
        player2_position, player2_money = play_round(2, player2_position, player2_money) #  вызываем функцию для второго игрока #


    print("\nИгра окончена!") # выводим сообщение о завершении игры #
    if player1_money > player2_money: #  сравниваем деньги игроков #
        print(f"Победил Игрок 1 с {player1_money} деньгами!") #  выводим сообщение о победе первого игрока #
    elif player2_money > player1_money: #  сравниваем деньги игроков #
        print(f"Победил Игрок 2 с {player2_money} деньгами!") #  выводим сообщение о победе второго игрока #
    else:
        print(f"Ничья, у обоих игроков {player1_money} денег") #  выводим сообщение о ничьей #


if __name__ == "__main__":
    main()
```