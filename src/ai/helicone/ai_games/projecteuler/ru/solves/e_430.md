## Ответ на Задачу No 430: Перемещения на прямой

### 1. Анализ задачи и решение

**Понимание задачи:**
*   У нас есть `N` точек на прямой, изначально все синие.
*   Происходит `M` случайных перекрашиваний.
*   При каждом перекрашивании выбираются две случайные точки `p` и `q`, и все точки между ними (включая `p` и `q`) перекрашиваются в красный.
*   Нужно найти ожидаемое количество синих точек после `M` перекрашиваний.

**Решение:**
1.  **Вероятность, что точка останется синей после одного перемещения:**  Рассмотрим произвольную точку `i`. Чтобы точка `i` осталась синей после одного перемещения, она должна не попасть в диапазон `[min(p, q), max(p, q)]`. Это означает, что либо `p` и `q` должны быть оба слева от `i`, либо оба справа от `i`.
    *   Вероятность, что `p < i` равна `(i - 1) / N`.
    *   Вероятность, что `q < i` равна `(i - 1) / N`.
    *   Вероятность, что оба `p` и `q` меньше `i`, равна `((i - 1) / N) * ((i - 1) / N) = ((i-1)/N)^2`
    *   Аналогично, вероятность, что оба `p` и `q` больше `i`, равна `((N - i) / N) * ((N - i) / N) = ((N-i)/N)^2`.
    *   Общая вероятность, что точка `i` останется синей после одного перемещения равна: `((i-1)/N)^2 + ((N-i)/N)^2`
2.  **Вероятность, что точка останется синей после M перемещений:**  После `M` независимых перемещений, вероятность, что точка `i` останется синей, равна: `(((i-1)/N)^2 + ((N-i)/N)^2)^M`.
3.  **Ожидаемое количество синих точек:** Ожидаемое количество синих точек будет суммой вероятностей того, что каждая точка остается синей, то есть: `sum( [((i-1)/N)^2 + ((N-i)/N)^2]^M for i in range(1, N+1) )`.

    Для упрощения, пусть `p_i = (((i-1)/N)^2 + ((N-i)/N)^2)`. Тогда ожидание - это `sum(p_i^M) for i in range(1, N+1)`

    Так как `N` очень большое `10^7`, мы можем немного преобразовать формулу `(i-1)^2 + (N-i)^2 = i^2 -2i + 1 + N^2 - 2Ni + i^2 = 2i^2 - 2i(N+1) + N^2 + 1`
    Тогда `p_i = (2i^2 - 2i(N+1) + N^2 + 1)/N^2`. И можно вынести `1/N^2`, но так как у нас и без этого есть N в сумме, можно не выносить.
    По итогу, просто будем вычислять ожидание, как `sum( [((i-1)/N)^2 + ((N-i)/N)^2]^M for i in range(1, N+1) )`.

    Так как N = 10^7 и M = 10^16, то есть проблема с точностью, нужно воспользоваться `decimal` для хранения промежуточных значений.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать N = 10<sup>7</sup> и M = 10<sup>16</sup>
3.  Инициализировать `expected_blue_points = 0`
4.  Импортировать `decimal`
5.  Для каждого `i` от 1 до N (включительно):
    *   Вычислить `p_i = (((i-1)/N)^2 + ((N-i)/N)^2)` в decimal формате
    *   Вычислить `p_i^M` в decimal формате.
    *   Прибавить `p_i^M` к `expected_blue_points`
6.  Вывести `expected_blue_points` с 10 знаками после запятой
7.  Конец

### 3. Реализация на Python 3.12

```python
from decimal import Decimal, getcontext

def expected_blue_points(N, M):
    """
    Calculates the expected number of blue points after M moves.

    Args:
        N: The number of points on the line.
        M: The number of moves.

    Returns:
        The expected number of blue points.
    """
    getcontext().prec = 50 #  Устанавливаем точность для decimal
    N_dec = Decimal(N)
    expected_blue_points = Decimal(0)

    for i in range(1, N + 1):
        i_dec = Decimal(i)
        p_i = ((i_dec - 1) / N_dec)**2 + ((N_dec - i_dec) / N_dec)**2
        expected_blue_points += p_i**Decimal(M)

    return expected_blue_points


if __name__ == "__main__":
    N = 10**7
    M = 10**16
    result = expected_blue_points(N, M)
    print(f"{result:.10f}")

```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InputData((Ввод: N = 10<sup>7</sup>, M = 10<sup>16</sup>))
    InputData --> InitializeExpected((Инициализировать expected_blue_points = 0))
     InitializeExpected --> ImportDecimal((Импорт Decimal, Установка точности))
    ImportDecimal --> LoopStart((Начать цикл: i от 1 до N))
    LoopStart --> Calculate_Pi((Вычислить p<sub>i</sub> = (((i-1)/N)<sup>2</sup> + ((N-i)/N)<sup>2</sup>) в Decimal))
    Calculate_Pi --> Calculate_Pi_M((Вычислить p<sub>i</sub><sup>M</sup> в Decimal))
    Calculate_Pi_M --> AddToExpected((Добавить p<sub>i</sub><sup>M</sup> к expected_blue_points))
    AddToExpected --> LoopStart
    LoopStart --> OutputResult((Вывод expected_blue_points с 10 знаками после запятой))
    OutputResult --> End((Конец))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Ввод: N, M:** Задание значений N и M.
*   **Инициализировать expected\_blue\_points:** Создание переменной для хранения ожидаемого количества синих точек и присвоение ей начального значения 0.
*   **Импорт Decimal, Установка точности:** импорт библиотеки decimal для работы с точной арифметикой. Установка точности вычислений.
*  **Начать цикл, Конец цикла:** Определяют начало и конец цикла перебора чисел от 1 до N.
*   **Вычислить p<sub>i</sub>:** Вычисляем вероятность для i точки.
*  **Вычислить p<sub>i</sub><sup>M</sup>:** Вычисляем вероятность, что i точка будет синей после M перемещений.
*   **Добавить p<sub>i</sub><sup>M</sup> к expected\_blue\_points:**  Добавляем вероятность того, что i точка останется синей, к общему ожиданию.
*   **Вывод expected\_blue\_points:** Выводим полученное ожидаемое количество синих точек с заданной точностью.
