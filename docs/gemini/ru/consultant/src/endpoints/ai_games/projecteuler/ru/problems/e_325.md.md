# Анализ кода модуля `e_325.md`

**Качество кода**
8
-  Плюсы
    - Код содержит описание задачи и примеры.
    -  Задача четко сформулирована.
-  Минусы
    - Отсутствует сам код решения.
    - Нет импортов, функций, и классов.
    - Комментарии не в формате reStructuredText (RST).

**Рекомендации по улучшению**

1. **Добавить код решения:** Необходимо предоставить Python код, который решает поставленную задачу.
2. **Использовать reStructuredText (RST):** Необходимо переписать все комментарии в формате RST.
3. **Добавить документацию:** Добавить docstring для функций и классов.
4.  **Использовать `logger`:** Для логирования ошибок.
5.  **Улучшить читаемость:**  Код должен быть хорошо структурирован.
6. **Разбить решение на функции:** Для удобства и повторного использования кода.
7. **Избегать глобальных переменных:** Для повышения модульности.

**Оптимизированный код**

```python
"""
Решение задачи 325 Project Euler: Каменная куча
=================================================

Задача заключается в определении наименьшего количества камней,
которые первый игрок должен забрать, чтобы обеспечить себе выигрыш
в игре с кучей камней, при условии оптимальной игры обоих игроков.

Функции:
    - :func:`calculate_m_n`: Вычисляет значение M(n) для заданного n.
    - :func:`solve_problem`: Решает задачу для диапазона n от 1 до 10^7
    и возвращает сумму значений M(n).

Пример использования
---------------------

.. code-block:: python

   sum_m_n = solve_problem()
   print(f"Сумма M(n) для 1 <= n <= 10^7: {sum_m_n}")
"""

from functools import lru_cache
from src.logger.logger import logger


@lru_cache(maxsize=None)
def calculate_m_n(n: int) -> int:
    """
    Вычисляет наименьшее количество камней, которое первый игрок должен забрать,
    чтобы гарантировать себе выигрыш при оптимальной игре обоих игроков.

    :param n: Начальное количество камней в куче.
    :return: Наименьшее количество камней, которое первый игрок должен забрать.
             Возвращает 0, если первый игрок не может выиграть на первом ходу.
    """
    if n == 1:
        return 0 # Если 1 камень, игрок проигрывает
    for move in range(1, n // 2 + 1):
        # Проверяем, есть ли выигрышная стратегия для первого игрока при данном ходе.
        win = True
        for second_move in range(1, (n - move) // 2 + 1):
            if calculate_m_n(n - move - second_move) == 0:
                 win = False
                 break
        if win:
            return move
    return 0 # Если нет выигрышного хода, возвращаем 0

def solve_problem(limit: int = 10**7) -> int:
    """
    Решает задачу для диапазона n от 1 до `limit` и возвращает сумму
    значений M(n).

    :param limit: Верхняя граница диапазона n.
    :return: Сумма значений M(n) для 1 <= n <= limit.
    """
    try:
        total_sum = sum(calculate_m_n(i) for i in range(1, limit + 1))
        return total_sum
    except Exception as ex:
         logger.error(f'Ошибка при вычислении суммы M(n): {ex}')
         return 0


if __name__ == "__main__":
    sum_m_n = solve_problem()
    print(f"Сумма M(n) для 1 <= n <= 10^7: {sum_m_n}")
```