# Анализ кода модуля hang.py

**Качество кода: 7/10**

-   **Плюсы:**
    *   Код игры "Виселица" реализован корректно и соответствует описанному алгоритму.
    *   Присутствует функция `draw_hangman` для отображения виселицы в зависимости от количества ошибок.
    *   Игровой процесс логически понятен и прост в использовании.
    *   Есть подробное описание модуля, функций и алгоритма игры в комментариях.
    *   Используются информативные сообщения для игрока (победа/поражение).

-   **Минусы:**
    *   Не используются константы для магических чисел (например, 6 для максимального количества ошибок), что снижает читаемость кода.
    *   Используется стандартный `input` для ввода, что может вызывать проблемы с обработкой некорректного ввода (например, ввод более одного символа).
    *   Отсутствует обработка возможных ошибок (например, если пользователь введет не букву).
    *   Нет логирования ошибок, что затрудняет отладку и мониторинг проблем.
    *   Docstring не соответствует стандарту reStructuredText (RST).
    *   Не все комментарии переписаны в формате RST.

**Рекомендации по улучшению:**

1.  **Форматирование docstring:**
    *   Переписать все docstring в формате reStructuredText (RST), чтобы соответствовать стандартам оформления документации.
2.  **Константы:**
    *   Ввести константы для максимального количества ошибок (6) и других магических чисел, чтобы сделать код более читаемым и поддерживаемым.
3.  **Обработка ввода:**
    *   Добавить обработку некорректного ввода от пользователя (например, небуквенные символы, более одного символа) для повышения устойчивости программы.
4.  **Логирование ошибок:**
    *   Использовать `src.logger.logger` для логирования ошибок, что позволит отслеживать проблемы в работе программы.
5.  **Улучшение читаемости:**
    *   Разбить функцию `play_hangman` на более мелкие, чтобы сделать код более модульным и понятным.
6. **Комментарии**:
    *   Переписать комментарии к коду в формате RST.
7.  **Именование переменных:**
    *   Использовать более информативные имена переменных.

**Оптимизированный код:**

```python
"""
Модуль для реализации игры "Виселица"
=========================================================================================

Этот модуль содержит функции для игры в виселицу, включая отображение виселицы,
выбор случайного слова и обработку ввода пользователя.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    if __name__ == "__main__":
        play_hangman()
"""
import random
from src.logger.logger import logger # Добавлен импорт logger

# Константа для максимального количества ошибок
MAX_ERRORS = 6

# Список слов для игры
WORDS = ["python", "java", "kotlin", "javascript", "swift", "ruby", "csharp"]

def draw_hangman(errors: int) -> None:
    """
    Отображает текущее состояние виселицы на основе количества ошибок.

    :param errors: Количество ошибок, сделанных игроком.
    :type errors: int
    """
    hangman_stages = [
        """
          ________
         |        |
         |
         |
         |
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |
         |
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |        |
         |
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |       /|
         |
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |       /|\\
         |
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |       /|\\
         |       /
         |
        ---
        """,
        """
          ________
         |        |
         |        O
         |       /|\\
         |       / \\
         |
        ---
        """
    ]
    print(hangman_stages[errors]) # Выводит на экран текущую стадию виселицы


def get_user_letter() -> str:
    """
    Запрашивает у пользователя ввод буквы и проверяет его корректность.

    :return: Введенная пользователем буква в верхнем регистре.
    :rtype: str
    """
    while True:
        user_input = input("Введите букву: ").upper() # Запрашивает ввод буквы у пользователя и преобразует в верхний регистр
        if len(user_input) != 1 or not user_input.isalpha(): # Проверяет, что введена одна буква
            logger.error(f'Некорректный ввод: {user_input=}. Введите одну букву') # Логирует некорректный ввод
            print("Пожалуйста, введите одну букву.")
            continue
        return user_input # Возвращает введенную букву

def update_guess_string(target_word: str, guess_string: str, user_letter: str) -> str:
    """
    Обновляет строку отгадывания, добавляя в нее угаданные буквы.

    :param target_word: Загаданное слово.
    :type target_word: str
    :param guess_string: Текущая строка отгадывания.
    :type guess_string: str
    :param user_letter: Буква, введенная пользователем.
    :type user_letter: str
    :return: Обновленная строка отгадывания.
    :rtype: str
    """
    new_guess_string = "" # Создает пустую строку для нового варианта отгаданного слова
    for i in range(len(target_word)): # Перебирает символы в загаданном слове
        if target_word[i] == user_letter: # Если буква в слове совпадает с введенной буквой
            new_guess_string += user_letter # Добавляет букву в строку
        else:
            new_guess_string += guess_string[i] # Добавляет символ из текущей строки
    return new_guess_string # Возвращает обновленную строку

def play_hangman() -> None:
    """
    Основная функция игры "Виселица".

    Инициализирует игру, обрабатывает ввод пользователя и определяет
    победу или поражение.
    """
    try:
      target_word = random.choice(WORDS).upper() # Случайно выбирает слово из списка и переводит в верхний регистр
      guess_string = "_" * len(target_word) # Создает строку из прочерков
      number_of_errors = 0 # Инициализирует счетчик ошибок

      while number_of_errors < MAX_ERRORS and "_" in guess_string: # Пока количество ошибок меньше максимального и есть прочерки
          print("Слово:", guess_string) # Выводит текущее состояние слова
          user_letter = get_user_letter() # Запрашивает букву у пользователя
          if user_letter in target_word: # Проверяет, есть ли введенная буква в слове
            guess_string = update_guess_string(target_word, guess_string, user_letter) # Обновляет строку отгадывания
            if guess_string == target_word: # Проверяет, угадано ли слово
                  print("ПОЗДРАВЛЯЮ! Вы угадали слово:", target_word) # Выводит поздравление
                  return  # Завершает игру
          else:
             number_of_errors += 1 # Увеличивает счетчик ошибок
             draw_hangman(number_of_errors) # Отображает текущее состояние виселицы

      if number_of_errors == MAX_ERRORS: # Если количество ошибок достигло максимума
        print("СОЖАЛЕЮ, вы не отгадали слово. Загаданное слово:", target_word) # Выводит сообщение о проигрыше

    except Exception as ex:
        logger.error(f'Произошла ошибка в игре: {ex}', exc_info=True) # Логирование ошибок
        ... # Точка остановки

if __name__ == "__main__":
    play_hangman()
"""
Объяснение кода:

1.  **Импорт модуля `random` и `logger`:**
    -   `import random`: Импортирует модуль random для случайного выбора слова.
    -   `from src.logger.logger import logger`: Импортирует модуль logger для логирования ошибок.

2.  **Константа `MAX_ERRORS`:**
    -   `MAX_ERRORS = 6`: Определяет максимальное количество ошибок, допустимых в игре.

3.  **Список слов `WORDS`:**
    -   `WORDS = ["python", "java", "kotlin", "javascript", "swift", "ruby", "csharp"]`: Список, содержащий слова, из которых компьютер выбирает слово для игры.

4. **Функция `draw_hangman(errors)`:**
    -   Отображает состояние виселицы в зависимости от количества ошибок, используя ASCII-арт.
    -  `hangman_stages` - массив строк, представляющих стадии виселицы.
    -  `print(hangman_stages[errors])` - выводит на экран соответсвующую строку.

5.  **Функция `get_user_letter()`:**
    -   `while True:`: Бесконечный цикл, который продолжается до тех пор, пока пользователь не введет корректную букву.
    -   `user_input = input("Введите букву: ").upper()`: Запрашивает у пользователя ввод буквы и переводит ее в верхний регистр.
    -   `if len(user_input) != 1 or not user_input.isalpha():`: Проверяет, что введена ровно одна буква.
    -   `logger.error(f'Некорректный ввод: {user_input=}. Введите одну букву')`: Логирует некорректный ввод.
    -   `print("Пожалуйста, введите одну букву.")`: Выводит сообщение об ошибке.
    -   `continue`: Переходит к следующей итерации цикла.
    -   `return user_input`: Возвращает введенную букву, если она корректна.

6.  **Функция `update_guess_string(target_word, guess_string, user_letter)`:**
    -   `new_guess_string = ""`: Создает пустую строку для сборки нового варианта отгадываемого слова.
    -   Цикл `for i in range(len(target_word))` перебирает все символы в загаданном слове.
    -   Если текущая буква в загаданном слове совпадает с введенной буквой `user_letter`, то добавляет ее в `new_guess_string`, иначе добавляет символ с текущей позиции из `guess_string`.
    -   `return new_guess_string`: Возвращает обновленную строку.

7.  **Функция `play_hangman()`:**
    -   `try:`: Блок для обработки исключений.
    -  `target_word = random.choice(WORDS).upper()`: Случайно выбирает слово из списка `WORDS` и переводит его в верхний регистр.
    -  `guess_string = "_" * len(target_word)`: Создает строку, состоящую из прочерков, длина которой соответствует длине загаданного слова.
    -  `number_of_errors = 0`: Устанавливает начальное количество ошибок в 0.
    -  `while number_of_errors < MAX_ERRORS and "_" in guess_string:`: Цикл продолжается, пока количество ошибок меньше `MAX_ERRORS` и в строке `guess_string` есть прочерки (т.е. пока слово не угадано и не исчерпан лимит ошибок).
    -  `print("Слово:", guess_string)`: Выводит текущее состояние слова с угаданными буквами и прочерками.
    -  `user_letter = get_user_letter()`: Запрашивает у пользователя ввод буквы.
    -  `if user_letter in target_word:`: Проверяет, есть ли введенная буква в загаданном слове.
        - Если буква есть:
        -  `guess_string = update_guess_string(target_word, guess_string, user_letter)`: Обновляет `guess_string` новым вариантом с угаданными буквами.
        -  `if guess_string == target_word:`: Проверяет, угадано ли слово.
        -  `print("ПОЗДРАВЛЯЮ! Вы угадали слово:", target_word)`: Выводит поздравление и загаданное слово.
        -  `return`: Завершает функцию (игру).
    - Если буквы нет в слове:
        -  `number_of_errors += 1`: Увеличивает счетчик ошибок на 1.
        -  `draw_hangman(number_of_errors)`: Вызывает функцию `draw_hangman` для отображения виселицы.
    -  `if number_of_errors == MAX_ERRORS:`: Проверяет, равно ли количество ошибок `MAX_ERRORS`.
    - `print("СОЖАЛЕЮ, вы не отгадали слово. Загаданное слово:", target_word)`: Выводит сообщение о проигрыше и загаданное слово.
    -  `except Exception as ex:`: Блок обработки ошибок.
    -   `logger.error(f'Произошла ошибка в игре: {ex}', exc_info=True)`: Логирует ошибку.
    - `...`:  Точка остановки.

8.  **Запуск игры:**
    -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_hangman()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `play_hangman()`: Вызывает функцию для начала игры.
"""
```