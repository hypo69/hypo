### **Алгоритм**

1.  **save\_text\_file**:
    *   Принимает путь к файлу, данные (строка, список строк или словарь) и режим записи.
    *   Преобразует путь к файлу в объект `Path`.
    *   Создает родительские директории, если они не существуют.
        *   Пример: Если указан путь `path/to/file.txt`, и директории `path` и `to` не существуют, они будут созданы.
    *   Открывает файл в указанном режиме (`w` - запись, `a` - добавление) с кодировкой `utf-8`.
        *   Пример: `with file_path.open('w', encoding='utf-8') as file:`
    *   В зависимости от типа данных:
        *   Если данные - список, записывает каждую строку в файл с добавлением символа новой строки.
            *   Пример: `['строка1', 'строка2']` будет записано как `"строка1\nстрока2\n"`.
        *   Если данные - словарь, записывает их в файл в формате JSON с отступами и отключенной экранизацией ASCII.
            *   Пример: `{'ключ': 'значение'}` будет записано как `{\n    "ключ": "значение"\n}`.
        *   Если данные - строка, записывает строку в файл.
            *   Пример: `'просто строка'` будет записано как `"просто строка"`.
    *   Возвращает `True` в случае успеха, `False` в случае ошибки.
    *   Логирует ошибки с использованием `logger.error`.
2.  **read\_text\_file\_generator**:
    *   Принимает путь к файлу или директории, флаг `as_list` (возвращать как список строк), список расширений файлов, размер чанка для чтения, флаг рекурсивного поиска и шаблоны файлов.
    *   Преобразует путь к файлу в объект `Path`.
    *   Если путь указывает на файл:
        *   Если `as_list` равен `True`, возвращает генератор строк из файла, используя функцию `_read_file_lines_generator`.
        *   Если `as_list` равен `False`, возвращает содержимое файла как строку, используя функцию `_read_file_content`.
    *   Если путь указывает на директорию:
        *   Если `recursive` равен `True`:
            *   Если указаны шаблоны, получает список файлов, используя функцию `recursively_get_file_path`.
            *   Иначе получает список всех файлов в директории и её поддиректориях с учетом расширений.
            *   Если `as_list` равен `True`, возвращает генератор строк из всех файлов.
            *   Если `as_list` равен `False`, возвращает объединенную строку из содержимого всех файлов.
        *   Если `recursive` равен `False`:
            *   Получает список файлов в директории с учетом расширений.
            *   Если `as_list` равен `True`, возвращает генератор строк из всех файлов.
            *   Если `as_list` равен `False`, возвращает объединенную строку из содержимого всех файлов.
    *   Если путь не является файлом или директорией, логирует ошибку и возвращает `None`.
    *   Логирует ошибки с использованием `logger.error`.
3.  **read\_text\_file**:
    *   Принимает путь к файлу или директории, флаг `as_list` (возвращать как список строк), список расширений файлов и флаг логирования информации об исключении.
    *   Преобразует путь к файлу в объект `Path`.
    *   Если путь указывает на файл, открывает файл, читает его содержимое и возвращает как строку или список строк в зависимости от значения `as_list`.
    *   Если путь указывает на директорию, получает список файлов в директории с учетом расширений, рекурсивно читает содержимое каждого файла и возвращает как объединенную строку или список строк в зависимости от значения `as_list`.
    *   Если путь не является файлом или директорией, логирует предупреждение и возвращает `None`.
    *   Логирует ошибки с использованием `logger.error`.
4.  **yield\_text\_from\_files**:
    *   Принимает путь к файлу, флаг `as_list` и размер чанка.
    *   Преобразует путь к файлу в объект `Path`.
    *   Если путь указывает на файл:
        *   Если `as_list` равен `True`, возвращает генератор строк из файла, используя функцию `_read_file_lines_generator`.
        *   Если `as_list` равен `False`, возвращает содержимое файла как строку, используя функцию `_read_file_content`.
    *   Если путь не является файлом, логирует ошибку и возвращает `None`.
    *   Логирует ошибки с использованием `logger.error`.
5.  **\_read\_file\_content**:
    *   Принимает путь к файлу и размер чанка.
    *   Открывает файл, читает его содержимое по чанкам и возвращает как строку.
6.  **\_read\_file\_lines\_generator**:
    *   Принимает путь к файлу и размер чанка.
    *   Открывает файл, читает его содержимое по чанкам и генерирует строки.
    *   Учитывает случай, когда чанк заканчивается неполной строкой.
7.  **get\_filenames\_from\_directory**:
    *   Принимает путь к директории и расширение файла (или список расширений).
    *   Возвращает список имен файлов в директории, отфильтрованных по расширению.
    *   Логирует ошибку, если указанный путь не является директорией.
8.  **recursively\_yield\_file\_path**:
    *   Принимает путь к корневой директории и шаблон файла (или список шаблонов).
    *   Рекурсивно генерирует пути ко всем файлам, соответствующим заданным шаблонам.
9.  **recursively\_get\_file\_path**:
    *   Принимает путь к корневой директории и шаблон файла (или список шаблонов).
    *   Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам.
10. **recursively\_read\_text\_files**:
    *   Принимает путь к корневой директории, шаблон файла (или список шаблонов) и флаг `as_list`.
    *   Рекурсивно читает текстовые файлы, соответствующие заданным шаблонам, и возвращает список содержимого файлов (или список строк, если `as_list=True`).
11. **get\_directory\_names**:
    *   Принимает путь к директории.
    *   Возвращает список имен директорий, находящихся в указанной директории.
12. **remove\_bom**:
    *   Принимает путь к файлу или директории.
    *   Удаляет BOM (Byte Order Mark) из текстового файла или из всех файлов Python в указанной директории.
13. **main**:
    *   Удаляет BOM из файлов Python в директории `src`.

### **Mermaid**

```mermaid
flowchart TD
    subgraph save_text_file
        A[Принимает file_path, data, mode] --> B{file_path - str | Path, data - str | list[str] | dict, mode - str}
        B --> C{Преобразование file_path в Path}
        C --> D{Создание родительских директорий}
        D --> E{Открытие файла в режиме mode}
        E --> F{isinstance(data, list)?}
        F -- True --> G[Запись каждой строки с \\n]
        F -- False --> H{isinstance(data, dict)?}
        H -- True --> I[Запись в формате JSON]
        H -- False --> J[Запись data в файл]
        G --> K[Возврат True]
        I --> K
        J --> K
        E --> L[Обработка исключений]
        L --> M{Логирование ошибки}
        M --> N[Возврат False]
    end

    subgraph read_text_file_generator
        AA[Принимает file_path, as_list, extensions, chunk_size, recursive, patterns] --> BB{Определение типа file_path}
        BB -- Файл --> CC{as_list?}
        CC -- True --> DD[Вызов _read_file_lines_generator]
        CC -- False --> EE[Вызов _read_file_content]
        BB -- Директория --> FF{recursive?}
        FF -- True --> GG{patterns?}
        GG -- Да --> HH[Вызов recursively_get_file_path]
        GG -- Нет --> II[Получение списка файлов (glob)]
        FF -- False --> JJ[Получение списка файлов (iterdir)]
        HH --> KK{as_list?}
        II --> KK
        JJ --> LL{as_list?}

        KK -- True --> MM[Генератор строк из файлов]
        KK -- False --> NN[Объединенная строка из файлов]
        LL -- True --> OO[Генератор строк из файлов]
        LL -- False --> PP[Объединенная строка из файлов]
        BB -- Не файл и не директория --> QQ[Логирование ошибки и возврат None]
        DD --> RR[Возврат результата]
        EE --> RR
        MM --> RR
        NN --> RR
        OO --> RR
        PP --> RR
        QQ --> RR
    end

    subgraph read_text_file
        AAA[Принимает file_path, as_list, extensions, exc_info] --> BBB{Определение типа file_path}
        BBB -- Файл --> CCC[Чтение файла и возврат (list[str] или str)]
        BBB -- Директория --> DDD[Получение списка файлов (rglob)]
        DDD --> EEE[Рекурсивное чтение файлов]
        EEE --> FFF[Возврат (list[str] или str)]
        BBB -- Не файл и не директория --> GGG[Логирование предупреждения и возврат None]
        CCC --> HHH[Возврат результата]
        FFF --> HHH
        GGG --> HHH
    end

    subgraph yield_text_from_files
        AAAA[Принимает file_path, as_list, chunk_size] --> BBBB{Определение типа file_path}
        BBBB -- Файл --> CCCC{as_list?}
        CCCC -- True --> DDDD[Вызов _read_file_lines_generator]
        CCCC -- False --> EEEE[Вызов _read_file_content]
        BBBB -- Не файл --> FFFF[Логирование ошибки и возврат None]
        DDDD --> GGGG[Возврат результата]
        EEEE --> GGGG
        FFFF --> GGGG
    end

    subgraph _read_file_content
        AAAAA[Принимает file_path, chunk_size] --> BBBBB[Открытие файла]
        BBBBB --> CCCCC[Чтение файла по частям (chunk_size)]
        CCCCC --> DDDDD[Объединение частей в строку]
        DDDDD --> EEEEE[Возврат строки]
    end

    subgraph _read_file_lines_generator
        AAAAAA[Принимает file_path, chunk_size] --> BBBBBB[Открытие файла]
        BBBBBB --> CCCCCC[Чтение файла по частям (chunk_size)]
        CCCCCC --> DDDDDD[Разделение чанка на строки]
        DDDDDD --> EEEEEE[Генерация строк]
    end

    subgraph get_filenames_from_directory
        AAAAAAA[Принимает directory, ext] --> BBBBBBB{Проверка, является ли directory директорией}
        BBBBBBB -- Нет --> CCCCCCC[Логирование ошибки и возврат []]
        BBBBBBB -- Да --> DDDDDDD[Получение списка файлов в директории]
        DDDDDDD --> EEEEEEE[Фильтрация по расширению ext]
        EEEEEEE --> FFFFFFF[Возврат списка имен файлов]
    end

    subgraph recursively_yield_file_path
        AAAAAAAA[Принимает root_dir, patterns] --> BBBBBBBB[Генерация путей файлов, соответствующих шаблонам]
        BBBBBBBB --> CCCCCCCC[Возврат генератора путей]
    end

    subgraph recursively_get_file_path
        AAAAAAAAA[Принимает root_dir, patterns] --> BBBBBBBBB[Получение списка путей файлов, соответствующих шаблонам]
        BBBBBBBBB --> CCCCCCCCC[Возврат списка путей]
    end

    subgraph recursively_read_text_files
        AAAAAAAAAA[Принимает root_dir, patterns, as_list] --> BBBBBBBBBB{Проверка, является ли root_dir директорией}
        BBBBBBBBBB -- Нет --> CCCCCCCCC[Логирование и возврат []]
        BBBBBBBBBB -- Да --> DDDDDDDDDD[Рекурсивный обход директории]
        DDDDDDDDDD --> EEEEEEEEEE[Чтение файлов, соответствующих шаблонам]
        EEEEEEEEEE --> FFFFFFFFFF[Возврат списка содержимого файлов (или строк)]
    end

    subgraph get_directory_names
        AAAAAAAAAAA[Принимает directory] --> BBBBBBBBBBB[Получение списка элементов в директории]
        BBBBBBBBBBB --> CCCCCCCCCCC[Фильтрация: только директории]
        CCCCCCCCCCC --> DDDDDDDDDDD[Возврат списка имен директорий]
    end

    subgraph remove_bom
        AAAAAAAAAAAA[Принимает path] --> BBBBBBBBBBBB{Определение типа path}
        BBBBBBBBBBBB -- Файл --> CCCCCCCCCCC[Удаление BOM из файла]
        BBBBBBBBBBBB -- Директория --> DDDDDDDDDDDD[Рекурсивный обход директории]
        DDDDDDDDDDDD --> EEEEEEEEEEEE[Удаление BOM из файлов Python]
        BBBBBBBBBBBB -- Не файл и не директория --> FFFFFFFFFFF[Логирование ошибки]
    end

    subgraph main
        AAAAAAAAAAAAA --> BBBBBBBBBBBBB[Удаление BOM в директории src]
    end
```

**Зависимости и пояснения:**

*   **os**: Используется для обхода директорий в функциях `recursively_read_text_files` и `remove_bom`.
*   **json**: Используется для записи данных в формате JSON в функции `save_text_file`.
*   **fnmatch**: Используется для сопоставления имен файлов с шаблонами в функции `recursively_read_text_files`.
*   **pathlib.Path**: Используется для представления путей к файлам и директориям и выполнения операций над ними.
*   **typing.List, Optional, Union, Generator**: Используются для аннотации типов.
*   **src.logger.logger.logger**: Используется для логирования ошибок и предупреждений.

### **Объяснение**

Данный модуль (`src.utils.file.py`) предоставляет набор функций для работы с файлами, включая чтение, запись, поиск и удаление BOM (Byte Order Mark). Он предназначен для упрощения операций с файлами и директориями в проекте `hypotez`.

**Импорты:**

*   `os`: Модуль операционной системы, используемый для работы с путями и директориями. В данном модуле применяется для рекурсивного обхода директорий и выполнения операций с файлами.
*   `json`: Модуль для работы с JSON-данными. Используется в функции `save_text_file` для записи словарей в файл в формате JSON.
*   `fnmatch`: Модуль для сопоставления имен файлов с шаблонами. Используется в функции `recursively_read_text_files` для фильтрации файлов по шаблону.
*   `pathlib.Path`: Класс для представления путей к файлам и директориям. Предоставляет удобный интерфейс для работы с файловой системой.
*   `typing.List, typing.Optional, typing.Union, typing.Generator`: Модуль для аннотации типов. Используется для указания типов аргументов и возвращаемых значений функций, что улучшает читаемость и облегчает отладку кода.
*   `src.logger.logger.logger`: Модуль для логирования. Используется для записи информации о событиях, ошибках и предупреждениях в процессе работы модуля.

**Функции:**

*   `save_text_file(file_path: str | Path, data: str | list[str] | dict, mode: str = 'w') -> bool`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу (строка или объект `Path`).
        *   `data`: Данные для записи (строка, список строк или словарь).
        *   `mode`: Режим открытия файла (`'w'` для записи, `'a'` для добавления).
    *   **Возвращает:** `True`, если файл успешно сохранен, `False` в противном случае.
    *   **Назначение:** Сохраняет данные в текстовый файл. Если данные являются списком, каждая строка записывается в файл с новой строки. Если данные являются словарем, они записываются в файл в формате JSON.
    *   **Пример:**
        ```python
        from pathlib import Path
        file_path = Path('example.txt')
        data = 'Пример текста'
        result = save_text_file(file_path, data)
        print(result)  # Вывод: True
        ```
    *   **Потенциальные улучшения**: Добавить возможность указания кодировки при записи JSON.

*   `read_text_file_generator(file_path: str | Path, as_list: bool = False, extensions: Optional[list[str]] = None, chunk_size: int = 8192, recursive: bool = False, patterns: Optional[str | list[str]] = None) -> Generator[str, None, None] | str | list[str] | None`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу или директории (строка или объект `Path`).
        *   `as_list`: Если `True`, возвращает содержимое файла в виде списка строк.
        *   `extensions`: Список расширений файлов для чтения (используется при чтении директории).
        *   `chunk_size`: Размер чанка для чтения файла (в байтах).
        *   `recursive`: Если `True`, выполняет рекурсивный поиск файлов в директории.
        *   `patterns`: Шаблоны для фильтрации файлов при рекурсивном поиске.
    *   **Возвращает:** Генератор строк, строку или `None` в случае ошибки.
    *   **Назначение:** Читает содержимое файла или файлов в директории. Поддерживает чтение больших файлов с использованием генератора для экономии памяти.
    *   **Пример:**
        ```python
        from pathlib import Path
        file_path = Path('example.txt')
        content = read_text_file_generator(file_path)
        if content:
            print(f'File content: {content[:100]}...')
        ```
    *   **Потенциальные улучшения**: Добавить возможность указания кодировки при чтении файла.

*   `read_text_file(file_path: Union[str, Path], as_list: bool = False, extensions: Optional[list[str]] = None, exc_info: bool = True) -> str | list[str] | None`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу или директории (строка или объект `Path`).
        *   `as_list`: Если `True`, возвращает содержимое файла в виде списка строк.
        *   `extensions`: Список расширений файлов для чтения (используется при чтении директории).
        *   `exc_info`: Если `True`, логирует traceback при ошибке.
    *   **Возвращает:** Содержимое файла в виде строки или списка строк, или `None` в случае ошибки.
    *   **Назначение:** Читает содержимое файла или файлов в директории.
    *   **Пример:**
        ```python
        from pathlib import Path
        file_path = Path('example.txt')
        content = read_text_file(file_path)
        if content:
            print(f'File content: {content[:100]}...')
        ```
    *   **Потенциальные улучшения**: Добавить возможность указания кодировки при чтении файла.

*   `yield_text_from_files(file_path: str | Path, as_list: bool = False, chunk_size: int = 8192) -> Generator[str, None, None] | str | None`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу (строка или объект `Path`).
        *   `as_list`: Если `True`, возвращает генератор строк.
        *   `chunk_size`: Размер чанка для чтения файла (в байтах).
    *   **Возвращает:** Генератор строк, объединенную строку или `None` в случае ошибки.
    *   **Назначение:** Читает содержимое файла и возвращает его в виде генератора строк или одной строки.
    *   **Пример:**
        ```python
        from pathlib import Path
        file_path = Path('example.txt')
        for line in yield_text_from_files(file_path, as_list=True):
            print(line)
        ```
    *   **Потенциальные улучшения**: Добавить возможность указания кодировки при чтении файла.

*   `_read_file_content(file_path: Path, chunk_size: int) -> str`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу (объект `Path`).
        *   `chunk_size`: Размер чанка для чтения файла (в байтах).
    *   **Возвращает:** Содержимое файла в виде строки.
    *   **Назначение:** Читает содержимое файла по чанкам и возвращает как строку.

*   `_read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]`:
    *   **Аргументы:**
        *   `file_path`: Путь к файлу (объект `Path`).
        *   `chunk_size`: Размер чанка для чтения файла (в байтах).
    *   **Возвращает:** Генератор строк из файла.
    *   **Назначение:** Читает файл по строкам с помощью генератора.

*   `get_filenames_from_directory(directory: str | Path, ext: str | list[str] = '*') -> list[str]`:
    *   **Аргументы:**
        *   `directory`: Путь к директории (строка или объект `Path`).
        *   `ext`: Расширение файла (строка или список строк). Если `'*'`, возвращает все файлы.
    *   **Возвращает:** Список имен файлов в директории.
    *   **Назначение:** Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.
    *   **Пример:**
        ```python
        from pathlib import Path
        directory = Path('.')
        filenames = get_filenames_from_directory(directory, ['.txt', '.md'])
        print(filenames)  # Вывод: ['example.txt', 'readme.md']
        ```
    *   **Потенциальные улучшения**: Добавить возможность фильтрации по нескольким расширениям одновременно.

*   `recursively_yield_file_path(root_dir: str | Path, patterns: str | list[str] = '*') -> Generator[Path, None, None]`:
    *   **Аргументы:**
        *   `root_dir`: Корневая директория для поиска (строка или объект `Path`).
        *   `patterns`: Шаблоны для фильтрации файлов (строка или список строк).
    *   **Возвращает:** Генератор объектов `Path` для файлов, соответствующих заданным шаблонам.
    *   **Назначение:** Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.
    *   **Пример:**
        ```python
        from pathlib import Path
        root_dir = Path('.')
        for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
            print(path)
        ```

*   `recursively_get_file_path(root_dir: str | Path, patterns: str | list[str] = '*') -> list[Path]`:
    *   **Аргументы:**
        *   `root_dir`: Корневая директория для поиска (строка или объект `Path`).
        *   `patterns`: Шаблоны для фильтрации файлов (строка или список строк).
    *   **Возвращает:** Список объектов `Path` для файлов, соответствующих заданным шаблонам.
    *   **Назначение:** Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.
    *   **Пример:**
        ```python
        from pathlib import Path
        root_dir = Path('.')
        paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
        print(paths)  # Вывод: [Path('./example.txt'), Path('./readme.md')]
        ```

*   `recursively_read_text_files(root_dir: str | Path, patterns: str | list[str], as_list: bool = False) -> list[str]`:
    *   **Аргументы:**
        *   `root_dir`: Корневая директория для поиска (строка или объект `Path`).
        *   `patterns`: Шаблоны для фильтрации файлов (строка или список строк).
        *   `as_list`: Если `True`, возвращает содержимое файлов в виде списка строк.
    *   **Возвращает:** Список содержимого файлов (или список строк, если `as_list=True`), соответствующих заданным шаблонам.
    *   **Назначение:** Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.
    *   **Пример:**
        ```python
        from pathlib import Path
        root_dir = Path('.')
        contents = recursively_read_text_files(root_dir, ['*.txt', '*.md'], as_list=True)
        for line in contents:
            print(line)
        ```
    *   **Потенциальные улучшения**: Добавить возможность указания кодировки при чтении файла.

*   `get_directory_names(directory: str | Path) -> list[str]`:
    *   **Аргументы:**
        *   `directory`: Путь к директории (строка или объект `Path`).
    *   **Возвращает:** Список имен директорий, находящихся в указанной директории.
    *   **Назначение:** Возвращает список имен директорий, находящихся в указанной директории.
    *   **Пример:**
        ```python
        from pathlib import Path
        directory = Path('.')
        directory_names = get_directory_names(directory)
        print(directory_names)  # Вывод: ['dir1', 'dir2']
        ```

*   `remove_bom(path: str | Path) -> None`:
    *   **Аргументы:**
        *   `path`: Путь к файлу или директории (строка или объект `Path`).
    *   **Возвращает:** `None`.
    *   **Назначение:** Удаляет BOM (Byte Order Mark) из текстового файла или из всех файлов Python в указанной директории.
    *   **Пример:**
        ```python
        from pathlib import Path
        file_path = Path('example.txt')
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write('\ufeffПример текста с BOM')
        remove_bom(file_path)
        with open(file_path, 'r', encoding='utf-8') as f:
            print(f.read())  # Вывод: Пример текста с BOM
        ```

*   `main() -> None`:
    *   **Аргументы:** Нет.
    *   **Возвращает:** `None`.
    *   **Назначение:**  Entry point for BOM removal in Python files.
    *   Удаляет BOM из файлов Python в директории `src`.

**Переменные:**

*   `logger`: Объект логгера, используемый для записи информации о событиях, ошибках и предупреждениях.

**Взаимосвязи с другими частями проекта:**

*   Модуль `src.utils.file` использует модуль `src.logger.logger` для логирования.
*   Функции `read_text_file_generator`, `read_text_file`, `yield_text_from_files` используются в других модулях проекта для чтения файлов.
*   Функция `save_text_file` используется в других модулях проекта для записи файлов.
*   Функция `remove_bom` используется для удаления BOM из файлов Python в проекте.

**Потенциальные ошибки и области для улучшения:**

*   Во многих функциях отсутствует возможность указания кодировки при чтении файла.
*   В функциях `read_text_file_generator` и `read_text_file` можно добавить обработку исключений `FileNotFoundError` и `PermissionError`.
*   В функции `save_text_file` можно добавить проверку на существование файла перед записью.
*   В функции `remove_bom` можно добавить возможность указания списка расширений файлов для обработки.
*   Удалить неиспользуемые импорты.
*   В целом, код выглядит достаточно хорошо структурированным и документированным. Однако, можно улучшить обработку ошибок и добавить больше гибкости в настройках функций.