# ניתוח קוד: משחק "CHIEF"

## <algorithm>

**תרשים זרימה של המשחק "CHIEF"**

1.  **התחלה:**
    *   התוכנית מתחילה את ריצתה.
    
2.  **יצירת מספרים רנדומליים:**
    *   מייצרת שלושה מספרים רנדומליים שלמים `targetA`, `targetB`, ו-`targetC` בין 1 ל-10.
    *   לדוגמה: `targetA` = 5, `targetB` = 2, `targetC` = 9.
    
3.  **לולאה ראשית (משחק):**
    *   לולאה אינסופית מתחילה (כל עוד לא ניצחנו).
    
4.  **קבלת קלט מהמשתמש:**
    *   המשתמש מתבקש להזין שלושה מספרים שלמים `userA`, `userB`, ו-`userC`.
        *   לדוגמה: המשתמש מזין 6, 2, 7.
    *   אם הקלט אינו מספר שלם, מוצגת הודעת שגיאה, והלולאה חוזרת להתחלה.
    
5.  **אתחול הודעה:**
    *   משתנה `message` מאותחל למחרוזת ריקה.
        *   `message` = "".
        
6.  **בדיקת `userA`:**
    *   אם `userA` ≠ `targetA`, מוסיפה "A" ל-`message`.
        *   לדוגמה: 6 ≠ 5, אז `message` = "A".
        
7.  **בדיקת `userB`:**
    *   אם `userB` ≠ `targetB`, מוסיפה "B" ל-`message`.
        *   לדוגמה: 2 = 2, אז `message` נשאר "A".
        
8.  **בדיקת `userC`:**
    *   אם `userC` ≠ `targetC`, מוסיפה "C" ל-`message`.
        *   לדוגמה: 7 ≠ 9, אז `message` = "AC".
    
9. **בדיקת הודעה:**
    * אם `message` אינו ריק, זה אומר שהמשתמש טעה באחד המספרים.
        * לדוגמה, `message` = "AC", לכן ההודעה "WRONG ON AC" תוצג.
    
10. **ניצחון:**
    * אם `message` ריק, המשתמש ניחש נכון את כל המספרים.
        * תוצג ההודעה "YOU GOT IT!"
    * הלולאה תסתיים באמצעות הפקודה `break`
        
11. **סוף:**
    * התוכנית מסיימת את ריצתה.

## <mermaid>

```mermaid
flowchart TD
    Start[התחלה] --> GenerateRandomNumbers[יצירת מספרים רנדומליים: <br>targetA, targetB, targetC (1-10)];
    GenerateRandomNumbers --> GameLoop[לולאת המשחק (while True)];
    GameLoop --> GetUserInput[קבלת קלט מהמשתמש: <br>userA, userB, userC];
    GetUserInput -- קלט לא תקין --> GameLoop;
    GetUserInput -- קלט תקין --> InitMessage[אתחול הודעה: <br>message = ""];
    InitMessage --> CheckUserA[בדיקת userA: <br>userA != targetA];
    CheckUserA -- נכון --> AddAtoMessage[הוספת "A" ל-message];
    CheckUserA -- לא נכון --> CheckUserB[בדיקת userB: <br>userB != targetB];
    AddAtoMessage --> CheckUserB;
    CheckUserB -- נכון --> AddBtoMessage[הוספת "B" ל-message];
    CheckUserB -- לא נכון --> CheckUserC[בדיקת userC: <br>userC != targetC];
     AddBtoMessage --> CheckUserC;
    CheckUserC -- נכון --> AddCtoMessage[הוספת "C" ל-message];
    CheckUserC -- לא נכון --> CheckMessage[בדיקת message: <br>message != ""];
     AddCtoMessage --> CheckMessage;
    CheckMessage -- נכון --> WrongMessage[הצגת הודעת שגיאה: <br>"WRONG ON " + message];
    CheckMessage -- לא נכון --> WinMessage[הצגת הודעת ניצחון: <br>"YOU GOT IT!"];
    WrongMessage --> GameLoop;
    WinMessage --> End[סיום המשחק];
```

## <explanation>

**ייבואים (Imports):**

*   `import random`: מייבא את מודול `random` של פייתון, אשר מספק פונקציות ליצירת מספרים אקראיים. מודול זה הכרחי כדי לייצר את מספרי המטרה (`targetA`, `targetB`, `targetC`) בצורה רנדומלית.

**משתנים (Variables):**

*   `targetA`, `targetB`, `targetC`: מספרים שלמים רנדומליים בין 1 ל-10, שנוצרים בתחילת המשחק ומשמשים כמספרי המטרה שהמשתמש צריך לנחש.
*   `userA`, `userB`, `userC`: מספרים שלמים שהמשתמש מזין בניסיון לנחש את מספרי המטרה.
*   `message`: מחרוזת המשמשת לאחסון אינדיקציה לגבי אילו מספרי מטרה לא נוחשו נכון.

**פונקציות (Functions):**

*   `random.randint(1, 10)`: פונקציה המודול `random` אשר מייצרת מספר שלם רנדומלי בין 1 ל-10 (כולל). פונקציה זו משמשת לייצר את מספרי המטרה.
*   `input()`: פונקציה מובנית בפייתון המציגה הודעה למשתמש ומחכה לקלט שלו. במקרה הזה, הפונקציה משמשת לבקש מהמשתמש להזין את הניחושים שלו.
*   `int()`: פונקציה מובנית בפייתון שממירה מחרוזת למספר שלם. היא משמשת כדי להפוך את הקלט מהמשתמש למספרים שלמים.
*   `print()`: פונקציה מובנית בפייתון המציגה הודעה למשתמש. היא משמשת להצגת הודעות על הצלחה/כישלון וגם לבקשת קלט מהמשתמש.

**הסברים מפורטים:**

1.  המשחק מתחיל ביצירת שלושה מספרי מטרה רנדומליים בין 1 ל-10.
2.  לולאה אינסופית מתחילה, ובכל איטרציה, המשתמש מתבקש להזין שלושה ניחושים.
3.  בתוך הלולאה, מתבצעת בדיקה האם הקלט תקין (מספר שלם). אם הקלט לא תקין, מוצגת הודעה למשתמש והלולאה חוזרת להתחלה.
4.  מחרוזת `message` מאותחלת למחרוזת ריקה.
5.  לאחר מכן, מתבצעת סדרה של בדיקות:
    *   אם ניחוש `userA` שונה מ-`targetA`, האות "A" מתווספת למחרוזת `message`.
    *   בדומה, אם ניחוש `userB` שונה מ-`targetB`, האות "B" מתווספת למחרוזת `message`.
    *   בדומה, אם ניחוש `userC` שונה מ-`targetC`, האות "C" מתווספת למחרוזת `message`.
6.  בסוף הבדיקות, מחרוזת `message` משמשת לקביעת תוצאת המשחק:
    *   אם `message` ריקה, המשמעות היא שהמשתמש ניחש נכון את כל המספרים, הודעת ניצחון מוצגת, והמשחק מסתיים.
    *   אם `message` אינה ריקה, ההודעה תציין אילו מספרים המשתמש ניחש לא נכון, והמשחק ימשיך לסיבוב נוסף.

**בעיות אפשריות או תחומים לשיפור:**

*   **קלט לא תקין**: המשחק מטפל רק באפשרות שהמשתמש יזין קלט שאינו מספר שלם. ניתן להוסיף טיפול במקרים בהם המשתמש מזין מספר מחוץ לטווח 1-10.
*   **הודעות למשתמש**: ניתן לחדד את הודעות השגיאה וההצלחה כך שיהיו ידידותיות יותר למשתמש.
*   **מספר ניסיונות מוגבל**: ניתן להוסיף מגבלה על מספר הניסיונות שהמשתמש יכול לבצע.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

*   הקוד עומד בפני עצמו ואינו תלוי בקוד אחר בפרויקט. זהו משחק פשוט שאינו דורש אינטראקציה עם חלקים אחרים.