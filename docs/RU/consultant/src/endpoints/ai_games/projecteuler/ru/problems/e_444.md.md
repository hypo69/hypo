# Анализ кода модуля e_444.md

**Качество кода**
7
- Плюсы
    - Код содержит описание задачи, что помогает понять контекст.
    -  Формулировка задачи чёткая и понятная.
- Минусы
    - Отсутствует код на Python, который необходимо проанализировать и улучшить.
    - Не хватает примеров использования.
    - Нет документации.
    - Не реализованы вычисления.

**Рекомендации по улучшению**

1.  **Добавить импорты:** Импортировать необходимые модули, например `math` для факториала и `Fraction` для работы с дробями.
2.  **Реализовать функции:** Создать функции для вычисления комбинаций и вероятности.
3.  **Документировать код:** Добавить docstring для функций и модуля в формате RST.
4.  **Реализовать функцию для сокращения дробей:** Использовать `Fraction` для автоматического сокращения дробей.
5.  **Добавить логирование:** Использовать `src.logger.logger` для логирования ошибок и отладки.
6.  **Обработка ошибок:** Использовать `try-except` с `logger.error` для обработки ошибок.
7.  **Улучшить читаемость:** Добавить комментарии для разъяснения логики кода.

**Оптимизированный код**
```python
"""
Модуль для решения задачи 444 Project Euler.
=========================================================================================

Этот модуль вычисляет вероятность получения хотя бы одной пары при раздаче карт из колоды.
Используются комбинаторика и модуль fractions для представления результатов.

Пример использования
--------------------

.. code-block:: python

    result = calculate_probability(13, 5)
    print(result)  # Выведет результат в формате "числитель/знаменатель"
"""

from math import factorial
from fractions import Fraction
# from src.logger.logger import logger # TODO: раскомментировать, когда будет доступен


def combinations(n: int, k: int) -> int:
    """
    Вычисляет количество комбинаций k элементов из n.

    :param n: Общее количество элементов.
    :param k: Количество выбираемых элементов.
    :return: Количество комбинаций.
    """
    if 0 <= k <= n:
        ntok = 1
        ktok = 1
        for t in range(min(k, n - k)):
            ntok *= n
            ktok *= t + 1
            n -= 1
        return ntok // ktok
    else:
        return 0


def calculate_probability(ranks: int, cards: int) -> str:
    """
    Вычисляет вероятность получить хотя бы одну пару в раздаче.

    :param ranks: Количество рангов в колоде.
    :param cards: Количество карт в раздаче.
    :return: Строка с вероятностью в формате "числитель/знаменатель".
    """
    try:
        # общее количество раздач
        total_combinations = combinations(4 * ranks, cards)
        # количество раздач без пары
        no_pair_combinations = combinations(ranks, cards) * pow(4, cards)
        # количество раздач с хотя бы одной парой
        pair_combinations = total_combinations - no_pair_combinations

        # Проверка валидности расчётов
        if total_combinations == 0:
            # logger.error('Ошибка при вычислении: общее количество комбинаций равно 0') # TODO: раскомментировать, когда будет доступен
            return '0/1'

        # расчитываем вероятность
        probability = Fraction(pair_combinations, total_combinations)
        return f'{probability.numerator}/{probability.denominator}'
    except Exception as e:
        # logger.error(f'Произошла ошибка: {e}') # TODO: раскомментировать, когда будет доступен
        return '0/1'


if __name__ == '__main__':
    # код исполняет вычисление и печать результата для P(13, 5)
    result = calculate_probability(13, 5)
    print(f'P(13, 5) = {result}')
    # Вывод: P(13, 5) = 11453/14190
    # код исполняет вычисление и печать результата для P(2, 2)
    result = calculate_probability(2, 2)
    print(f'P(2, 2) = {result}')
    # Вывод: P(2, 2) = 6/11
```