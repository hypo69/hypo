# Анализ кода модуля CHOMP

**Качество кода**
- **Соблюдение требований к формату кода (1-10):**
    - **Преимущества:**
        - Код хорошо структурирован и легко читается.
        - Дано понятное описание игры и ее правил.
        - Представлен алгоритм игры и блок-схема, что облегчает понимание процесса.
        - Используется Markdown для форматирования текста и кода.
        - Присутствует описание блок-схемы.
    - **Недостатки:**
        - Отсутствуют docstring и комментарии в стиле reStructuredText (RST).
        - Код не является исполняемым Python кодом.
        - Отсутствуют импорты и проверки на ошибки.

**Рекомендации по улучшению**
1. Добавить docstring в формате reStructuredText (RST) для описания модуля.
2. Реализовать игровую логику в виде исполняемого Python кода.
3. Добавить обработку ошибок, используя `src.logger.logger`.
4. Использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` при работе с JSON (если это необходимо).
5. Добавить комментарии к коду для пояснения логики.
6. Привести структуру кода в соответствие с предыдущими обработанными файлами, например, разбить код на функции и классы, если это необходимо.

**Улучшенный код**
```python
"""
Модуль для реализации игры CHOMP.
=========================================================================================

Модуль содержит логику для игры CHOMP, где два игрока по очереди откусывают куски от шоколадной плитки,
стремясь не съесть отравленную дольку.

Пример использования
--------------------

.. code-block:: python

    chomp_game = CHOMP()
    chomp_game.play()
"""
from src.logger.logger import logger # Импортируем logger для логирования ошибок

class CHOMP:
    """
    Класс, реализующий логику игры CHOMP.

    :ivar board: Игровая доска, представленная в виде списка списков.
    :ivar rows: Количество строк на игровой доске.
    :ivar cols: Количество столбцов на игровой доске.
    :ivar current_player: Текущий игрок (1 или 2).
    """
    def __init__(self, rows=None, cols=None):
        """
        Инициализация игры CHOMP.

        :param rows: Количество строк на доске. Если не указано, запрашивается ввод.
        :param cols: Количество столбцов на доске. Если не указано, запрашивается ввод.
        """
        self.rows = rows or self.get_board_size('Введите количество строк: ') # Запрос количества строк
        self.cols = cols or self.get_board_size('Введите количество столбцов: ') # Запрос количества столбцов
        self.board = [['X' for _ in range(self.cols)] for _ in range(self.rows)] # Инициализация игровой доски
        self.board[0][0] = 'O' # Обозначаем отравленную дольку
        self.current_player = 1 # Инициализируем первого игрока

    def get_board_size(self, prompt: str) -> int:
        """
        Запрашивает у пользователя размер доски.

        :param prompt: Сообщение для вывода пользователю.
        :return: Введенный пользователем размер.
        """
        while True:
            try:
                size = int(input(prompt)) # Запрос размера доски у пользователя
                if size > 0:
                    return size
                else:
                    logger.error('Размер доски должен быть положительным числом.') # Логирование ошибки
            except ValueError:
                logger.error('Некорректный ввод. Введите целое число.') # Логирование ошибки

    def display_board(self):
        """
        Выводит текущее состояние игровой доски на экран.
        """
        for row in self.board:
            print(' '.join(row)) # Вывод доски

    def get_move(self) -> tuple:
        """
        Запрашивает у текущего игрока координаты хода.

        :return: Кортеж (row, col) с координатами хода.
        """
        while True:
            try:
                row = int(input(f'Игрок {self.current_player}, введите строку: ')) - 1 # Запрос строки от пользователя
                col = int(input(f'Игрок {self.current_player}, введите столбец: ')) - 1 # Запрос столбца от пользователя
                if 0 <= row < self.rows and 0 <= col < self.cols and self.board[row][col] == 'X': # Проверка корректности хода
                     return row, col
                else:
                    logger.error('Некорректный ход. Попробуйте еще раз.') # Логирование ошибки
            except ValueError:
                logger.error('Некорректный ввод. Введите целые числа.') # Логирование ошибки
            except Exception as ex:
                logger.error(f'Неизвестная ошибка при вводе хода {ex}') # Логирование ошибки

    def update_board(self, row: int, col: int):
        """
        Обновляет состояние игровой доски после хода игрока.

        :param row: Строка выбранного хода.
        :param col: Столбец выбранного хода.
        """
        for i in range(row, self.rows):
             for j in range(col, self.cols): # Обновление доски
                  self.board[i][j] = ' '

    def check_win(self) -> bool:
        """
        Проверяет, не съел ли текущий игрок отравленную дольку.

        :return: True, если текущий игрок проиграл, иначе False.
        """
        return self.board[0][0] == ' ' # Проверка на проигрыш

    def switch_player(self):
        """
        Переключает текущего игрока.
        """
        self.current_player = 3 - self.current_player # Переключение игрока

    def play(self):
        """
        Запускает игровой процесс.
        """
        while True: # Цикл игры
            self.display_board() # Вывод доски
            row, col = self.get_move() # Получение хода
            self.update_board(row, col) # Обновление доски
            if self.check_win(): # Проверка на проигрыш
                self.display_board() # Вывод доски
                print(f'Игрок {3 - self.current_player} победил!') # Вывод победителя
                break
            self.switch_player() # Смена игрока

if __name__ == '__main__':
    game = CHOMP() # Создание экземпляра игры
    game.play() # Запуск игры
```