# Модуль `Qwen_QVQ_72B`

## Обзор

Модуль `Qwen_QVQ_72B` предоставляет класс `Qwen_QVQ_72B`, который является асинхронным провайдером для взаимодействия с моделью Qwen QVQ-72B через API. Модуль поддерживает отправку текстовых запросов и запросов с изображениями, используя API эндпоинт, предоставляемый сервисом.

## Подробнее

Этот модуль предназначен для интеграции с моделью Qwen QVQ-72B, предоставляя удобный интерфейс для отправки запросов и получения ответов в асинхронном режиме. Он использует `aiohttp` для выполнения асинхронных HTTP-запросов и поддерживает загрузку изображений через `FormData`. Модуль также обрабатывает ошибки, возникающие при взаимодействии с API, и предоставляет результаты в виде асинхронного генератора.

## Классы

### `Qwen_QVQ_72B`

**Описание**: Класс `Qwen_QVQ_72B` является асинхронным провайдером и реализует методы для взаимодействия с моделью Qwen QVQ-72B.

**Наследует**:
- `AsyncGeneratorProvider`: Предоставляет базовую функциональность для асинхронных провайдеров, возвращающих результаты в виде генератора.
- `ProviderModelMixin`: Предоставляет миксин для работы с моделями провайдера.

**Атрибуты**:
- `label` (str): Метка провайдера, `"Qwen QVQ-72B"`.
- `url` (str): URL эндпоинта API, `"https://qwen-qvq-72b-preview.hf.space"`.
- `api_endpoint` (str): Путь к API эндпоинту, `"/gradio_api/call/generate"`.
- `working` (bool): Флаг, указывающий, работает ли провайдер, `True`.
- `default_model` (str): Модель по умолчанию, `"qwen-qvq-72b-preview"`.
- `default_vision_model` (str): Модель для работы с изображениями по умолчанию, `"qwen-qvq-72b-preview"`.
- `model_aliases` (dict): Псевдонимы моделей, `{"qvq-72b": default_vision_model}`.
- `vision_models` (list): Список моделей для работы с изображениями, `list(model_aliases.keys())`.
- `models` (list): Список всех поддерживаемых моделей, `vision_models`.

**Методы**:

- `create_async_generator(model: str, messages: Messages, media: MediaListType = None, api_key: str = None, proxy: str = None, **kwargs) -> AsyncResult`: Создает асинхронный генератор для получения ответов от модели.

## Функции

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls, model: str, messages: Messages,
    media: MediaListType = None,
    api_key: str = None, 
    proxy: str = None,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для получения ответов от модели.

    Args:
        model (str): Имя используемой модели.
        messages (Messages): Список сообщений для отправки в модель.
        media (MediaListType, optional): Список медиафайлов для отправки. По умолчанию `None`.
        api_key (str, optional): API ключ для аутентификации. По умолчанию `None`.
        proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.
        **kwargs: Дополнительные параметры.

    Returns:
        AsyncResult: Асинхронный генератор, выдающий части ответа модели.

    Raises:
        ResponseError: Если при запросе к API произошла ошибка.
        RuntimeError: Если не удалось обработать ответ от API.
    """
```

**Назначение**: Функция `create_async_generator` создает и возвращает асинхронный генератор, который отправляет запросы к API Qwen QVQ-72B и выдает полученные ответы. Она поддерживает отправку текстовых сообщений и изображений, а также обработку ошибок, возникающих при взаимодействии с API.

**Параметры**:
- `model` (str): Имя используемой модели.
- `messages` (Messages): Список сообщений для отправки в модель.
- `media` (MediaListType, optional): Список медиафайлов для отправки. По умолчанию `None`.
- `api_key` (str, optional): API ключ для аутентификации. По умолчанию `None`.
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.
- `**kwargs`: Дополнительные параметры.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, выдающий части ответа модели.

**Вызывает исключения**:
- `ResponseError`: Если при запросе к API произошла ошибка.
- `RuntimeError`: Если не удалось обработать ответ от API.

**Как работает функция**:

1. **Инициализация**:
   - Функция начинает с подготовки заголовков запроса, включая указание типа контента (`application/json`) и добавление API-ключа, если он предоставлен.
   - Создается асинхронная сессия `aiohttp.ClientSession` с заданными заголовками.

2. **Обработка медиафайлов (если есть)**:
   - Если в запросе присутствуют медиафайлы (изображения):
     - Формируется объект `FormData` для отправки файла.
     - Медиафайл преобразуется в байты и добавляется в `FormData`.
     - Выполняется POST-запрос к эндпоинту `/gradio_api/upload` для загрузки изображения.
     - Полученный ответ содержит информацию о загруженном изображении, включая его путь.

3. **Формирование данных для запроса**:
   - Если медиафайлы были загружены, данные для запроса формируются с указанием пути к изображению и текста сообщения.
   - Если медиафайлов нет, данные формируются только на основе текста сообщения.

4. **Отправка запроса к API**:
   - Выполняется POST-запрос к эндпоинту `/gradio_api/call/generate` с сформированными данными.
   - Полученный ответ содержит `event_id`, который используется для получения последующих событий.

5. **Получение и обработка событий**:
   - Выполняется GET-запрос к эндпоинту `/gradio_api/call/generate/{event_id}` для получения событий, связанных с запросом.
   - Функция ожидает получения чанков данных из ответа.
   - Каждый чанк данных обрабатывается для извлечения событий (`event`) и данных (`data`).

6. **Обработка ошибок и результатов**:
   - Если событие указывает на ошибку (`error`), выбрасывается исключение `ResponseError`.
   - Если событие указывает на генерацию (`generating`):
     - Данные JSON парсятся и извлекается текст ответа.
     - Выдается часть текста ответа, начиная с позиции `text_position`.
     - Обновляется позиция `text_position` для следующей итерации.
   - Если событие указывает на завершение (`complete`), цикл завершается.

7. **Обработка ошибок парсинга**:
   - Если при парсинге JSON возникает ошибка, выбрасывается исключение `RuntimeError`.

8. **Завершение**:
   - Функция возвращает асинхронный генератор, который выдает части ответа модели по мере их получения.

**ASCII Flowchart**:

```
    Инициализация сессии и заголовков
    ↓
    Есть ли медиафайлы?
    ├── Нет → Формирование данных только с текстом
    │   ↓
    └── Да → Формирование FormData и загрузка изображения
        ↓
    Отправка POST-запроса к /gradio_api/call/generate
    ↓
    Получение event_id из ответа
    ↓
    Отправка GET-запроса к /gradio_api/call/generate/{event_id}
    ↓
    Получение чанков данных
    ↓
    Обработка каждого чанка:
    ├── event == "error" → Выброс ResponseError
    │   ↓
    ├── event == "generating" → Парсинг JSON и выдача части текста ответа
    │   ↓
    └── event == "complete" → Завершение цикла
        ↓
    Выдача частей ответа через генератор
```

**Примеры**:

1. **Отправка текстового запроса**:

```python
from src.endpoints.gpt4free.g4f.Provider.hf_space.Qwen_QVQ_72B import Qwen_QVQ_72B
messages = [{"role": "user", "content": "Translate to Russian: Hello, world!"}]
async for chunk in Qwen_QVQ_72B.create_async_generator(model="qwen-qvq-72b-preview", messages=messages):
    print(chunk, end="")
```

2. **Отправка запроса с изображением**:

```python
from src.endpoints.gpt4free.g4f.Provider.hf_space.Qwen_QVQ_72B import Qwen_QVQ_72B
from typing import List, Tuple
from PIL import Image
import io

# Функция для загрузки изображения (замените на свой способ)
async def load_image(path: str) -> Image.Image:
    # Это всего лишь пример, используйте вашу фактическую реализацию
    with open(path, "rb") as f:
        img_bytes = f.read()
    return Image.open(io.BytesIO(img_bytes))

# Замените 'path_to_image.jpg' на путь к вашему изображению
image_path = 'path_to_image.jpg'
image = await load_image(image_path)
media: List[Tuple[Image.Image, str]] = [(image, "image.jpg")]

messages = [{"role": "user", "content": "Describe this image."}]
async for chunk in Qwen_QVQ_72B.create_async_generator(model="qwen-qvq-72b-preview", messages=messages, media=media):
    print(chunk, end="")