# Модуль исполнения сценария создания мехирона для Сергея Казаринова

## Обзор

Модуль `from_supplier_to_prestashop.py` предназначен для автоматизации процесса получения данных о товарах от поставщиков, их обработки и последующей публикации в интернет-магазине PrestaShop. Он включает в себя функциональность для парсинга данных с веб-страниц поставщиков, использования AI для обработки и улучшения описаний товаров, а также интеграцию с PrestaShop API для создания новых товаров.

## Подробнее

Модуль является частью проекта `hypotez` и выполняет следующие основные задачи:

1.  **Извлечение данных о товарах**: Получение информации о товарах с сайтов поставщиков с использованием специализированных граберов.
2.  **Обработка данных с использованием AI**: Использование модели Google Gemini для улучшения описаний товаров, их классификации и приведения к требуемому формату.
3.  **Публикация товаров в PrestaShop**: Автоматическое создание новых товаров в PrestaShop с использованием API.

Модуль предназначен для упрощения и ускорения процесса добавления новых товаров в PrestaShop, минимизируя ручной ввод данных и улучшая качество представленной информации.

## Классы

### `SupplierToPrestashopProvider`

**Описание**: Класс `SupplierToPrestashopProvider` инкапсулирует логику извлечения, разбора и сохранения данных о продуктах поставщиков. Он отвечает за взаимодействие с веб-драйвером, AI-моделью и API PrestaShop.

**Как работает класс**:

1.  **Инициализация**: При создании экземпляра класса происходит загрузка конфигурации, инициализация веб-драйвера и AI-модели.
2.  **Выполнение сценария**: Метод `run_scenario` координирует процесс получения данных о товарах, их обработки и сохранения.
3.  **Взаимодействие с AI**: Методы `initialise_ai_model` и `process_ai` отвечают за взаимодействие с AI-моделью Gemini для обработки текстовых данных о товарах.
4.  **Сохранение данных**: Методы `save_product_data` и `save_in_prestashop` отвечают за сохранение данных о товарах в формате JSON и их публикацию в PrestaShop соответственно.

**Атрибуты**:

*   `driver` (Driver): Экземпляр Selenium WebDriver для взаимодействия с веб-страницами.
*   `export_path` (Path): Путь для экспорта данных о товарах в формате JSON.
*   `mexiron_name` (str): Название товара.
*   `price` (float): Цена товара.
*   `timestamp` (str): Временная метка, используемая для организации данных.
*   `products_list` (list): Список обработанных данных о товарах.
*   `model` (GoogleGenerativeAI): Экземпляр AI-модели Google Gemini.
*   `config` (SimpleNamespace): Конфигурация модуля, загруженная из JSON-файла.
*   `local_images_path` (Path): Путь к локальному хранилищу изображений товаров.
*   `lang` (str): Язык, используемый для обработки данных.
*   `gemini_api` (str): Ключ API для доступа к Google Gemini.
*   `presta_api` (str): Ключ API для доступа к PrestaShop.
*   `presta_url` (str): URL адрес PrestaShop.

### `__init__`

```python
def __init__(
    self,
    lang: str,
    gemini_api: str,
    presta_api: str,
    presta_url: str,
    driver: Optional[Driver] = None,
) -> None:
    """
    Инициализирует класс SupplierToPrestashopProvider с необходимыми компонентами.

    Args:
        lang (str): Язык, используемый для обработки данных.
        gemini_api (str): Ключ API для доступа к Google Gemini.
        presta_api (str): Ключ API для доступа к PrestaShop.
        presta_url (str): URL адрес PrestaShop.
        driver (Optional[Driver], optional): Экземпляр Selenium WebDriver. Если не указан, создается новый экземпляр Firefox. Defaults to None.

    """
```

### `initialise_ai_model`

```python
def initialise_ai_model(self) -> GoogleGenerativeAI | None:
    """Инициализация модели Gemini

    Args:
        Нет

    Returns:
         GoogleGenerativeAI | None:  Возвращает экземпляр GoogleGenerativeAI или None в случае ошибки.
    """
```

**Как работает функция**:
Функция `initialise_ai_model` инициализирует и настраивает модель Google Gemini для дальнейшего использования в процессах обработки данных о товарах.

1.  **Чтение системной инструкции**:
    *   Функция пытается прочитать содержимое файла с системной инструкцией для модели Gemini. Файл находится по пути `(gs.path.endpoints / 'emil' / 'instructions' / f'system_instruction_mexiron.{self.lang}.md')`. Инструкция читается в кодировке UTF-8.
    *   Системная инструкция содержит указания для модели о том, как обрабатывать и генерировать ответы.
2.  **Инициализация GoogleGenerativeAI**:
    *   Если чтение инструкции прошло успешно, функция создает экземпляр класса `GoogleGenerativeAI`.
    *   При создании экземпляра передаются следующие параметры:
        *   `api_key`: Ключ API для доступа к Google Gemini, берется из `gs.credentials.gemini.emil`.
        *   `system_instruction`: Прочитанная системная инструкция.
        *   `generation_config`: Конфигурация генерации ответов, указывающая на то, что модель должна возвращать ответы в формате `application/json`.
3.  **Обработка ошибок**:
    *   Если в процессе чтения файла или инициализации модели происходит ошибка, функция перехватывает исключение.
    *   В случае ошибки, в лог записывается сообщение об ошибке с использованием `logger.error`.
    *   Функция возвращает `None` в случае ошибки.
4.  **Возврат значения**:
    *   Если инициализация модели прошла успешно, функция возвращает экземпляр класса `GoogleGenerativeAI`.

### `run_scenario`

```python
async def run_scenario(
    self,
    urls: list[str],
    price: Optional[str] = '',
    mexiron_name: Optional[str] = '',
) -> bool:
    """
    Исполняет сценарий: парсит продукты, обрабатывает их с помощью AI и сохраняет данные.

    Args:
        urls (list[str]): Список URL-адресов страниц продуктов.
        price (Optional[str], optional): Цена товара. Defaults to ''.
        mexiron_name (Optional[str], optional): Название товара. Defaults to ''.

    Returns:
        bool: True, если сценарий выполнен успешно, False в противном случае.

    """
```

**Как работает функция**:
Функция `run_scenario` является асинхронной и выполняет основной сценарий обработки данных о товарах, начиная с их извлечения с веб-страниц поставщиков и заканчивая сохранением обработанных данных.

1.  **Инициализация**:
    *   Определяется кортеж `required_fields`, содержащий имена полей, которые обязательно должны быть извлечены для каждого товара (`id_product`, `name`, `description_short`, `description`, `specification`, `local_image_path`).
    *   Инициализируется пустой список `products_list`, который будет использоваться для хранения обработанных данных о товарах.
2.  **Сбор товаров**:
    *   Функция перебирает URL-адреса, переданные в аргументе `urls`.
    *   Для каждого URL-адреса определяется граббер с помощью функции `get_graber_by_supplier_url(url)`. Граббер — это объект, который умеет извлекать данные с конкретного сайта поставщика.
    *   Если для URL-адреса не найден граббер, в лог записывается сообщение об ошибке, и функция переходит к следующему URL-адресу.
3.  **Извлечение данных**:
    *   Для каждого URL-адреса вызывается метод `grab_page` граббера, который извлекает данные о товаре. Метод `grab_page` принимает `*required_fields` в качестве аргумента, указывая, какие поля необходимо извлечь.
    *   Если в процессе извлечения данных происходит ошибка, она перехватывается, в лог записывается сообщение об ошибке, и функция переходит к следующему URL-адресу.
    *   Если метод `grab_page` возвращает `None` (что означает, что не удалось извлечь данные), в лог записывается сообщение об ошибке, и функция переходит к следующему URL-адресу.
4.  **Преобразование данных**:
    *   Извлеченные данные (переменная `f`) передаются в функцию `self.convert_product_fields(f)` для преобразования в нужный формат.
    *   Если функция `self.convert_product_fields` возвращает `None` (что означает, что не удалось преобразовать данные), в лог записывается сообщение об ошибке, и функция переходит к следующему URL-адресу.
5.  **Сохранение данных**:
    *   Преобразованные данные (переменная `product_data`) передаются в функцию `self.save_product_data(product_data)` для сохранения.
    *   Если функция `self.save_product_data` возвращает `False` (что означает, что не удалось сохранить данные), в лог записывается сообщение об ошибке.
    *   В любом случае, функция переходит к следующему URL-адресу.
6.  **Добавление в список**:
    *   Если данные успешно извлечены, преобразованы и сохранены, они добавляются в список `products_list`.
7.  **Завершение**:
    *   После обработки всех URL-адресов функция завершает свою работу.

### `save_product_data`

```python
async def save_product_data(self, product_data: dict) -> Optional[bool]:
    """
    Сохраняет данные об отдельном продукте в файл.

    Args:
        product_data (dict): Отформатированные данные продукта.

    Returns:
        Optional[bool]: None, если не удалось сохранить, True если сохранение выполнено.

    """
```

**Как работает функция**:

1.  **Определение пути к файлу**:
    *   Функция формирует путь к файлу, в который будут сохранены данные о продукте. Путь состоит из базового пути `self.export_path`, поддиректории `products` и имени файла, которое формируется на основе значения `product_data['product_id']` с добавлением расширения `.json`.
2.  **Сохранение данных в файл**:
    *   Функция использует функцию `j_dumps` для сохранения данных о продукте в формате JSON в файл, путь к которому был определен на предыдущем шаге.
    *   При сохранении данных указывается параметр `ensure_ascii=False`, чтобы избежать экранирования Unicode-символов.
3.  **Обработка ошибок**:
    *   Если функция `j_dumps` возвращает `False` (что означает, что не удалось сохранить данные), в лог записывается сообщение об ошибке с использованием `logger.error`.
    *   В случае ошибки функция возвращает `None`.
4.  **Возврат значения**:
    *   Если сохранение данных прошло успешно, функция возвращает `True`.

### `process_ai`

```python
async def process_ai(self, products_list: List[str], lang: str, attempts: int = 3) -> dict | bool:
    """
    Обрабатывает список продуктов через AI модель.

    Args:
        products_list (List[str]): Список словарей с данными о продуктах в виде строки.
        lang (str): Язык, на котором нужно получить ответ от модели.
        attempts (int, optional): Количество попыток повтора запроса в случае неудачи. Defaults to 3.

    Returns:
        dict | bool: Обработанный ответ в формате словаря или False, если не удалось получить валидный ответ после нескольких попыток.

    """
```

**Как работает функция**:

1.  **Проверка количества попыток**:
    *   Функция проверяет, осталось ли еще попытки для запроса к AI-модели. Если `attempts` меньше 1, это означает, что все попытки исчерпаны, и функция возвращает пустой словарь `{}`.
2.  **Формирование запроса к модели**:
    *   Функция формирует запрос к AI-модели, объединяя команду (инструкцию) и данные о продуктах.
    *   Команда считывается из файла, путь к которому формируется на основе языка `lang` и базового пути к файлам инструкций.
    *   Данные о продуктах преобразуются в строку с помощью `str(products_list)`.
    *   Команда и данные объединяются с помощью символа новой строки `\n`.
3.  **Отправка запроса к модели**:
    *   Функция отправляет запрос к AI-модели с помощью метода `self.model.ask(q)`.
    *   Результат запроса сохраняется в переменной `response`.
4.  **Обработка ответа от модели**:
    *   Если ответ от модели пустой, в лог записывается сообщение об ошибке, и функция возвращает пустой словарь `{}`.
    *   Если ответ не пустой, функция пытается распарсить его с помощью `j_loads(response)`. Результат парсинга сохраняется в переменной `response_dict`.
5.  **Обработка ошибок парсинга**:
    *   Если не удалось распарсить ответ от модели, в лог записывается сообщение об ошибке.
    *   Если остались еще попытки, функция рекурсивно вызывает саму себя с уменьшенным на 1 количеством попыток.
    *   Если попыток больше не осталось, функция возвращает пустой словарь `{}`.
6.  **Возврат результата**:
    *   Если ответ от модели успешно распарсен, функция возвращает словарь `response_dict`.

### `read_data_from_json`

```python
async def read_data_from_json(self) -> None:
    """Загружаю JSON файлы и фотки, которые я сделал через телеграм"""
```

**Как работает функция**:
Функция `read_data_from_json` предназначена для загрузки данных из JSON-файлов и, предположительно, фотографий, которые были получены через Telegram.

1.  **Загрузка данных из JSON**:
    *   Функция использует `j_loads_ns(self.local_images_path)` для загрузки данных из JSON-файла. Предполагается, что `self.local_images_path` содержит путь к файлу, который необходимо загрузить.
    *   Загруженные данные сохраняются в переменной `raw_data`.
    *   Содержимое `raw_data` выводится в консоль с использованием `print(raw_data)`.

### `save_in_prestashop`

```python
async def save_in_prestashop(self, products_list: ProductFields | list[ProductFields]) -> bool:
    """Функция, которая сохраняет товары в Prestashop emil-design.com """
```

**Как работает функция**:
Функция `save_in_prestashop` предназначена для сохранения товаров в PrestaShop.

1.  **Преобразование входных данных в список**:
    *   Функция проверяет, является ли `products_list` списком. Если нет, то он преобразуется в список, содержащий один элемент.
2.  **Инициализация PrestaProduct**:
    *   Создается экземпляр класса `PrestaProduct` с использованием API-ключа и домена PrestaShop, хранящихся в `self.presta_api` и `self.presta_url` соответственно.
3.  **Сохранение товаров в PrestaShop**:
    *   Функция перебирает элементы списка `products_list`.
    *   Для каждого элемента вызывается метод `p.add_new_product(f)`, который добавляет новый товар в PrestaShop.

### `post_facebook`

```python
async def post_facebook(self, mexiron: SimpleNamespace) -> bool:
    """Функция исполняет сценарий рекламного модуля `facvebook`."""
```

**Как работает функция**:
Функция `post_facebook` выполняет сценарий рекламного модуля `facebook` для публикации информации о товаре на странице Facebook.

1.  **Переход на страницу Facebook**:
    *   Функция переходит на страницу Facebook, используя URL `https://www.facebook.com/profile.php?id=61566067514123`.
2.  **Формирование заголовка сообщения**:
    *   Формируется заголовок сообщения, который будет опубликован на странице Facebook. Заголовок содержит название товара (`mexiron.title`), описание (`mexiron.description`) и цену (`mexiron.price`) с указанием валюты (шекели).
3.  **Публикация сообщения**:
    *   Вызывается функция `post_message_title(self.d, title)` для публикации заголовка сообщения на странице Facebook. Если публикация не удалась, в лог записывается предупреждение.
4.  **Загрузка медиа-файлов**:
    *   Вызывается функция `upload_post_media(self.d, media=mexiron.products)` для загрузки медиа-файлов (изображений) на страницу Facebook. Если загрузка не удалась, в лог записывается предупреждение.
5.  **Публикация медиа-файлов**:
    *   Вызывается функция `message_publish(self.d)` для публикации медиа-файлов на странице Facebook. Если публикация не удалась, в лог записывается предупреждение.

### `create_report`

```python
async def create_report(self, data: dict, lang: str, html_file: Path, pdf_file: Path) -> Optional[bool]:
    """Функция отправляет задание на создание отчета в формате `html` и `pdf`."""
```

**Как работает функция**:
Функция `create_report` предназначена для создания отчета в форматах HTML и PDF на основе предоставленных данных и последующей отправки PDF-версии отчета боту.

1.  **Инициализация ReportGenerator**:
    *   Создается экземпляр класса `ReportGenerator`, который отвечает за генерацию отчетов.
2.  **Создание отчета**:
    *   Вызывается асинхронный метод `report_generator.create_report(data, lang, html_file, pdf_file)` для создания отчета в форматах HTML и PDF. Метод принимает следующие аргументы:
        *   `data`: Данные, на основе которых будет создан отчет.
        *   `lang`: Язык, на котором будет создан отчет.
        *   `html_file`: Путь к файлу, в который будет сохранен отчет в формате HTML.
        *   `pdf_file`: Путь к файлу, в который будет сохранен отчет в формате PDF.
    *   Если метод `create_report` возвращает `True`, это означает, что отчет был успешно создан.
3.  **Отправка PDF-отчета боту**:
    *   Функция проверяет, существует ли файл PDF-отчета и является ли он файлом (а не директорией).
    *   Если файл существует и является файлом, функция отправляет его боту с помощью метода `self.update.message.reply_document(document=pdf_file)`.
4.  **Обработка ошибок**:
    *   Если файл PDF-отчета не существует или не является файлом, в лог записывается сообщение об ошибке с использованием `logger.error`.

## Функции

### `main`

```python
async def main(suppier_to_presta) -> None:
    """На данный момент функция читает JSON со списком фотографий , которые были получены от Эмиля"""
```

**Как работает функция**:
Функция `main` предназначена для чтения данных о товарах из JSON-файла и сохранения этих товаров в PrestaShop.

1.  **Определение языка**:
    *   Устанавливается язык, который будет использоваться при обработке данных. В данном случае язык установлен на `he` (иврит).
2.  **Загрузка данных о товарах из JSON**:
    *   Функция использует `j_loads_ns(gs.path.external_storage / ENDPOINT / 'out_250108230345305_he.json')` для загрузки данных о товарах из JSON-файла. Предполагается, что `gs.path.external_storage / ENDPOINT / 'out_250108230345305_he.json'` содержит путь к файлу, который необходимо загрузить.
    *   Загруженные данные сохраняются в переменной `products_ns`.
3.  **Создание экземпляра SupplierToPrestashopProvider**:
    *   Создается экземпляр класса `SupplierToPrestashopProvider` с указанным языком.
4.  **Преобразование данных в список**:
    *   Данные о товарах преобразуются в список с использованием генератора списков `[f for f in products_ns]`.
5.  **Сохранение товаров в PrestaShop**:
    *   Вызывается метод `suppier_to_presta.save_in_prestashop(products_list)` для сохранения товаров в PrestaShop.