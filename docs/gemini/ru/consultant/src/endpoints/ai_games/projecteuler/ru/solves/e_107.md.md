# Анализ кода модуля e_107.md

**Качество кода: 7/10**

-   Плюсы
    *   Код хорошо структурирован, разделен на логические блоки, включая анализ задачи, алгоритм решения, реализацию на Python, и блок-схему.
    *   Используется алгоритм Прима для решения задачи о минимальном остовном дереве, что является эффективным подходом.
    *   Код содержит docstring для функций, описывающие их назначение.
    *   Присутствует блок-схема в формате mermaid, что визуализирует алгоритм.

-   Минусы
    *   Отсутствуют необходимые импорты для работы с `j_loads` или `j_loads_ns`.
    *   Не используется `logger` для логирования ошибок.
    *   Не все комментарии соответствуют стандарту reStructuredText (RST).
    *   Используется стандартный `open()` для чтения файла, вместо `j_loads` или `j_loads_ns`.

**Рекомендации по улучшению**

1.  Добавить импорт `j_loads` из `src.utils.jjson`.
2.  Использовать `j_loads` для чтения файла вместо стандартного `open()`.
3.  Добавить логирование ошибок с помощью `logger.error`.
4.  Переписать docstring и комментарии в формате RST.
5.  Добавить подробное описание к переменным.
6.  Убрать лишние комментарии, дублирующие docstring.
7.  Проверить и исправить комментарии в коде, чтобы они описывали *что* делает код, а не *как*.
8.  Улучшить форматирование и структуру docstring.

**Оптимизированный код**

```python
"""
Модуль для решения задачи Project Euler #107: Минимальная стоимость соединения.
==========================================================================

Задача заключается в нахождении минимальной стоимости соединения сети,
при которой все вершины остаются связанными, и определении экономии
по сравнению с полной стоимостью соединения.

Пример использования
--------------------

.. code-block:: python

    min_cost, savings = solve_network_problem("network.txt")
    print(f"Минимальная стоимость соединения: {min_cost}")
    print(f"Экономия по сравнению с полной стоимостью: {savings}")
"""
import heapq
# импорт для использования j_loads для чтения json файлов
from src.utils.jjson import j_loads
# импорт для логирования
from src.logger.logger import logger

def calculate_full_cost(matrix: list[list[int]]) -> int:
    """
    Вычисляет полную стоимость сети.

    :param matrix: Матрица смежности, представляющая сеть.
    :return: Полная стоимость сети (сумма всех ребер, деленная на 2).
    """
    full_cost = 0
    # код итерирует по каждой строке матрицы
    for row in matrix:
        # код итерирует по каждому элементу в строке
        for cost in row:
            # если стоимость больше 0
            if cost > 0:
                # код добавляет стоимость к общей стоимости
                full_cost += cost
    # код возвращает общую стоимость, деленную на 2
    return full_cost // 2

def prim_mst(matrix: list[list[int]]) -> int:
    """
    Вычисляет минимальную стоимость остовного дерева (MST) с использованием алгоритма Прима.

    :param matrix: Матрица смежности, представляющая сеть.
    :return: Минимальная стоимость остовного дерева.
    """
    # количество вершин в графе
    num_vertices = len(matrix)
    # список для отслеживания посещенных вершин
    visited = [False] * num_vertices
    # минимальная стоимость остовного дерева
    min_cost = 0
    # приоритетная очередь для выбора ребер с минимальным весом
    priority_queue = [(0, 0)]  # (cost, vertex)

    # пока очередь не пуста
    while priority_queue:
        # извлекает ребро с наименьшим весом из очереди
        cost, vertex = heapq.heappop(priority_queue)
        # если вершина уже посещена
        if visited[vertex]:
            # пропускает ее
            continue
        # помечает текущую вершину как посещенную
        visited[vertex] = True
        # добавляет стоимость ребра к общей стоимости MST
        min_cost += cost
        # итерирует по всем соседним вершинам
        for next_vertex in range(num_vertices):
            # если ребро существует и следующая вершина не посещена
            if matrix[vertex][next_vertex] > 0 and not visited[next_vertex]:
                # добавляет ребро в очередь
                heapq.heappush(priority_queue, (matrix[vertex][next_vertex], next_vertex))
    # возвращает минимальную стоимость остовного дерева
    return min_cost

def solve_network_problem(filename: str) -> tuple[int, int]:
    """
    Решает задачу о минимальной стоимости соединения сети.

    :param filename: Имя файла с матрицей смежности.
    :return: Кортеж, содержащий минимальную стоимость соединения и экономию по сравнению с полной стоимостью.
    """
    try:
        # читает данные из файла
        matrix = j_loads(filename)
    except Exception as ex:
        # логирование ошибки чтения файла
        logger.error(f"Ошибка чтения файла {filename}", exc_info=ex)
        return 0, 0
    
    # вычисляет полную стоимость сети
    full_cost = calculate_full_cost(matrix)
    # вычисляет минимальную стоимость остовного дерева
    min_cost = prim_mst(matrix)
    # вычисляет экономию
    savings = full_cost - min_cost
    # возвращает минимальную стоимость и экономию
    return min_cost, savings

# Запускаем решение
min_cost, savings = solve_network_problem("network.txt")

print(f"Минимальная стоимость соединения: {min_cost}")
print(f"Экономия по сравнению с полной стоимостью: {savings}")
```