# Анализ кода модуля e_172

**Качество кода**
9
-  Плюсы
    - Код хорошо структурирован и логически понятен.
    - Используется мемоизация для оптимизации производительности.
    - Присутствует подробное описание алгоритма и его реализации.
    - Код соответствует PEP 8 (в основном).
    - Код написан на русском языке.
-  Минусы
    - В коде используется кэширование `@lru_cache`  без указания размера, что может привести к неконтролируемому росту потребления памяти.
    - Комментарии не соответствуют формату reStructuredText (RST).
    - Нет обработки ошибок через `logger.error`.
    - Используется  `counts` как `list` и преобразуется в `tuple`, что может быть не оптимально.
   - Использование `@lru_cache` без указания размера (maxsize=None) может привести к чрезмерному потреблению памяти.

**Рекомендации по улучшению**
1.  **Формат документации:** Переписать комментарии в формате reStructuredText (RST).
2.  **Мемоизация:** Использовать ограниченный кэш `@lru_cache(maxsize=1000)`  или подобрать оптимальный размер, если это необходимо.
3.  **Импорты:** Добавить необходимые импорты.
4.  **Логирование:** Использовать `logger.error` для обработки исключений.
5.  **Типизация:** Добавить аннотации типов для переменных и функций.
6.  **Оптимизация:** Использовать `tuple`  для `counts`  во избежание лишних преобразований.

**Оптимизированный код**
```python
"""
Модуль для решения задачи 172 Project Euler: Распределение цифр
=============================================================

Этот модуль содержит функции для подсчета количества 18-значных чисел,
в которых каждая цифра от 0 до 9 встречается не более трех раз.

Пример использования
--------------------

.. code-block:: python

    from src.endpoints.ai_games.projecteuler.ru.solves.e_172 import solve

    result = solve()
    print(result)

"""
from functools import lru_cache
from typing import Tuple
from src.logger.logger import logger # Добавлен импорт logger


@lru_cache(maxsize=1000)
def count_numbers(digit_index: int, counts_tuple: Tuple[int, ...]) -> int:
    """
    Рекурсивно подсчитывает количество допустимых 18-значных чисел.

    :param digit_index: Текущая позиция цифры (0-17).
    :type digit_index: int
    :param counts_tuple: Кортеж, представляющий количество использований каждой цифры (0-9).
    :type counts_tuple: Tuple[int, ...]
    :return: Количество допустимых чисел.
    :rtype: int
    """
    # если digit_index равен 18, то мы построили 18-значное число, поэтому возвращаем 1
    if digit_index == 18:
        return 1

    total_count: int = 0
    # counts преобразуется из tuple в list чтобы его можно было менять
    counts = list(counts_tuple)
    for digit in range(10):
        # Проверка, что на первой позиции цифра не 0
        if digit_index == 0 and digit == 0:
            continue
        # проверка, что цифра еще может использоваться
        if counts[digit] < 3:
            # увеличиваем счетчик использования цифры
            counts[digit] += 1
            # рекурсивный вызов с обновленным счетчиком цифр
            total_count += count_numbers(digit_index + 1, tuple(counts))
            # уменьшаем счетчик (backtracking)
            counts[digit] -= 1

    return total_count


def solve() -> int:
    """
    Решает задачу подсчета 18-значных чисел, где каждая цифра встречается не более 3 раз.

    :return: Общее количество таких чисел.
    :rtype: int
    """
    # Инициализируем начальные счетчики нулями
    initial_counts: Tuple[int, ...] = (0,) * 10
    # вызываем рекурсивную функцию и возвращаем результат
    return count_numbers(0, initial_counts)


if __name__ == "__main__":
    result: int = solve()
    print(result)
```