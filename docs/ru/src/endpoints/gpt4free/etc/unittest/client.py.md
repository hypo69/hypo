# Модуль для модульного тестирования клиента g4f (gpt4free)

## Обзор

Модуль содержит набор тестов для проверки корректности работы асинхронного и синхронного клиентов `g4f` (gpt4free), а также различных аспектов их функционирования, таких как обработка ответов, передача моделей, ограничение количества токенов, потоковая передача данных и остановка генерации.

## Подробнее

Этот модуль использует библиотеку `unittest` для определения тестовых случаев. Он включает тесты для асинхронного и синхронного клиентов, охватывая различные сценарии использования, такие как:

- Проверка корректности получения ответов от асинхронных и синхронных клиентов.
- Тестирование передачи модели в запросе.
- Проверка ограничения количества токенов в ответах.
- Тестирование потоковой передачи данных.
- Проверка остановки генерации текста по заданным стоп-словам.
- Тестирование обработки ошибок, связанных с отсутствием модели.
- Проверка выбора наилучшего провайдера и модели.

## Классы

### `AsyncTestPassModel`

**Описание**: Класс для тестирования асинхронного клиента `g4f`.

**Принцип работы**:
Класс `AsyncTestPassModel` наследуется от `unittest.IsolatedAsyncioTestCase` и содержит асинхронные тесты для проверки функциональности асинхронного клиента `g4f`. Каждый тест проверяет определенный аспект работы клиента, используя моки провайдеров для имитации ответов от API.

**Методы**:

- `test_response`: Тестирует получение ответа от асинхронного клиента с использованием мок-провайдера `AsyncGeneratorProviderMock`.
- `test_pass_model`: Тестирует передачу модели в запросе к асинхронному клиенту с использованием мок-провайдера `ModelProviderMock`.
- `test_max_tokens`: Тестирует ограничение количества токенов в ответе от асинхронного клиента с использованием мок-провайдера `YieldProviderMock`.
- `test_max_stream`: Тестирует потоковую передачу данных от асинхронного клиента с использованием мок-провайдера `YieldProviderMock`.
- `test_stop`: Тестирует остановку генерации текста по заданным стоп-словам от асинхронного клиента с использованием мок-провайдера `YieldProviderMock`.

#### `test_response`

```python
    async def test_response(self):
        """
        Тестирует получение ответа от асинхронного клиента.

        Args:
            self: Экземпляр класса AsyncTestPassModel.

        Returns:
            None

        Как работает функция:
        1. Создается инстанс AsyncClient с мок-провайдером AsyncGeneratorProviderMock.
        2. Отправляется запрос chat.completions.create с предопределенными сообщениями DEFAULT_MESSAGES и пустой строкой.
        3. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        4. Проверяется, что содержимое ответа соответствует ожидаемому значению "Mock".
        """
```

#### `test_pass_model`

```python
    async def test_pass_model(self):
        """
        Тестирует передачу модели в запросе к асинхронному клиенту.

        Args:
            self: Экземпляр класса AsyncTestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс AsyncClient с мок-провайдером ModelProviderMock.
        2. Отправляется запрос chat.completions.create с предопределенными сообщениями DEFAULT_MESSAGES и строкой "Hello".
        3. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        4. Проверяется, что содержимое ответа соответствует переданной строке "Hello".
        """
```

#### `test_max_tokens`

```python
    async def test_max_tokens(self):
        """
        Тестирует ограничение количества токенов в ответе от асинхронного клиента.

        Args:
            self: Экземпляр класса AsyncTestPassModel.

        Returns:
            None

        Как работает функция:
        1. Создается инстанс AsyncClient с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с ограничением max_tokens=1.
        4. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        5. Проверяется, что содержимое ответа соответствует ожидаемому значению "How ".
        6. Отправляется запрос chat.completions.create с ограничением max_tokens=2.
        7. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        8. Проверяется, что содержимое ответа соответствует ожидаемому значению "How are ".
        """
```

#### `test_max_stream`

```python
    async def test_max_stream(self):
        """
        Тестирует потоковую передачу данных от асинхронного клиента.

        Args:
            self: Экземпляр класса AsyncTestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс AsyncClient с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с параметром stream=True.
        4. Итерируется по чанкам ответа и проверяется, что каждый чанк является экземпляром ChatCompletionChunk.
        5. Проверяется, что содержимое каждого чанка является строкой.
        6. Формируются сообщения на основе списка строк ["You ", "You ", "Other", "?"].
        7. Отправляется запрос chat.completions.create с параметрами stream=True и max_tokens=2.
        8. Собираются все чанки в список response_list.
        9. Проверяется, что длина списка равна 3.
        10. Проверяется, что содержимое каждого чанка соответствует ожидаемому значению "You ".
        """
```

#### `test_stop`

```python
    async def test_stop(self):
        """
        Тестирует остановку генерации текста по заданным стоп-словам от асинхронного клиента.

        Args:
            self: Экземпляр класса AsyncTestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс AsyncClient с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с параметром stop=["and"].
        4. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        5. Проверяется, что содержимое ответа соответствует ожидаемому значению "How are you?".
        """
```

### `TestPassModel`

**Описание**: Класс для тестирования синхронного клиента `g4f`.

**Принцип работы**:
Класс `TestPassModel` наследуется от `unittest.TestCase` и содержит синхронные тесты для проверки функциональности синхронного клиента `g4f`. Каждый тест проверяет определенный аспект работы клиента, используя моки провайдеров для имитации ответов от API.

**Методы**:

- `test_response`: Тестирует получение ответа от синхронного клиента с использованием мок-провайдера `AsyncGeneratorProviderMock`.
- `test_pass_model`: Тестирует передачу модели в запросе к синхронному клиенту с использованием мок-провайдера `ModelProviderMock`.
- `test_max_tokens`: Тестирует ограничение количества токенов в ответе от синхронного клиента с использованием мок-провайдера `YieldProviderMock`.
- `test_max_stream`: Тестирует потоковую передачу данных от синхронного клиента с использованием мок-провайдера `YieldProviderMock`.
- `test_stop`: Тестирует остановку генерации текста по заданным стоп-словам от синхронного клиента с использованием мок-провайдера `YieldProviderMock`.
- `test_model_not_found`: Тестирует обработку исключения `ModelNotFoundError` при отсутствии модели.
- `test_best_provider`: Тестирует выбор наилучшего провайдера и модели.
- `test_default_model`: Тестирует использование модели по умолчанию.
- `test_provider_as_model`: Тестирует использование провайдера в качестве модели.
- `test_get_model`: Тестирует получение модели по имени.

#### `test_response`

```python
    def test_response(self):
        """
        Тестирует получение ответа от синхронного клиента.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс Client с мок-провайдером AsyncGeneratorProviderMock.
        2. Отправляется запрос chat.completions.create с предопределенными сообщениями DEFAULT_MESSAGES и пустой строкой.
        3. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        4. Проверяется, что содержимое ответа соответствует ожидаемому значению "Mock".
        """
```

#### `test_pass_model`

```python
    def test_pass_model(self):
        """
        Тестирует передачу модели в запросе к синхронному клиенту.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс Client с мок-провайдером ModelProviderMock.
        2. Отправляется запрос chat.completions.create с предопределенными сообщениями DEFAULT_MESSAGES и строкой "Hello".
        3. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        4. Проверяется, что содержимое ответа соответствует переданной строке "Hello".
        """
```

#### `test_max_tokens`

```python
    def test_max_tokens(self):
        """
        Тестирует ограничение количества токенов в ответе от синхронного клиента.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс Client с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с ограничением max_tokens=1.
        4. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        5. Проверяется, что содержимое ответа соответствует ожидаемому значению "How ".
        6. Отправляется запрос chat.completions.create с ограничением max_tokens=2.
        7. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        8. Проверяется, что содержимое ответа соответствует ожидаемому значению "How are ".
        """
```

#### `test_max_stream`

```python
    def test_max_stream(self):
        """
        Тестирует потоковую передачу данных от синхронного клиента.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None

        Как работает функция:
        1. Создается инстанс Client с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с параметром stream=True.
        4. Итерируется по чанкам ответа и проверяется, что каждый чанк является экземпляром ChatCompletionChunk.
        5. Проверяется, что содержимое каждого чанка является строкой.
        6. Формируются сообщения на основе списка строк ["You ", "You ", "Other", "?"].
        7. Отправляется запрос chat.completions.create с параметрами stream=True и max_tokens=2.
        8. Собираются все чанки в список response_list.
        9. Проверяется, что длина списка равна 3.
        10. Проверяется, что содержимое каждого чанка соответствует ожидаемому значению "You ".
        """
```

#### `test_stop`

```python
    def test_stop(self):
        """
        Тестирует остановку генерации текста по заданным стоп-словам от синхронного клиента.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None
        Как работает функция:
        1. Создается инстанс Client с мок-провайдером YieldProviderMock.
        2. Формируются сообщения на основе списка строк ["How ", "are ", "you", "?"].
        3. Отправляется запрос chat.completions.create с параметром stop=["and"].
        4. Проверяется, что полученный ответ является экземпляром ChatCompletion.
        5. Проверяется, что содержимое ответа соответствует ожидаемому значению "How are you?".
        """
```

#### `test_model_not_found`

```python
    def test_model_not_found(self):
        """
        Тестирует обработку исключения ModelNotFoundError при отсутствии модели.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None

        Как работает функция:
        1. Определяется внутренняя функция run_exception, которая создает инстанс Client и отправляет запрос chat.completions.create без указания модели.
        2. Проверяется, что при вызове run_exception возникает исключение ModelNotFoundError.
        """
```

#### `run_exception` (внутренняя функция `test_model_not_found`)

```python
        def run_exception():
            """
            Внутренняя функция, вызывающая исключение ModelNotFoundError.

            Args:
                None

            Returns:
                None

            Как работает функция:
            1. Создается инстанс Client без указания провайдера.
            2. Вызывается метод chat.completions.create с предопределенными сообщениями и строкой "Hello".
            3. Поскольку провайдер не указан, должно быть вызвано исключение ModelNotFoundError.
            """
```

#### `test_best_provider`

```python
    def test_best_provider(self):
        """
        Тестирует выбор наилучшего провайдера и модели.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None

        Как работает функция:
        1. Определяется переменная not_default_model со значением "gpt-4o".
        2. Вызывается функция get_model_and_provider с указанием not_default_model и параметрами None, False.
        3. Проверяется, что у полученного провайдера есть атрибут create_completion.
        4. Проверяется, что полученная модель соответствует значению not_default_model.
        """
```

#### `test_default_model`

```python
    def test_default_model(self):
        """
        Тестирует использование модели по умолчанию.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None
        Как работает функция:
        1. Определяется переменная default_model с пустым значением.
        2. Вызывается функция get_model_and_provider с указанием default_model и параметрами None, False.
        3. Проверяется, что у полученного провайдера есть атрибут create_completion.
        4. Проверяется, что полученная модель соответствует значению default_model (пустая строка).
        """
```

#### `test_provider_as_model`

```python
    def test_provider_as_model(self):
        """
        Тестирует использование провайдера в качестве модели.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None

        Как работает функция:
        1. Определяется переменная provider_as_model со значением имени класса Copilot.
        2. Вызывается функция get_model_and_provider с указанием provider_as_model и параметрами None, False.
        3. Проверяется, что у полученного провайдера есть атрибут create_completion.
        4. Проверяется, что полученная модель является строкой.
        5. Проверяется, что полученная модель соответствует значению атрибута default_model класса Copilot.
        """
```

#### `test_get_model`

```python
    def test_get_model(self):
        """
        Тестирует получение модели по имени.

        Args:
            self: Экземпляр класса TestPassModel.

        Returns:
            None

        Как работает функция:
        1. Вызывается функция get_model_and_provider с указанием имени модели gpt_4o.name и параметрами None, False.
        2. Проверяется, что у полученного провайдера есть атрибут create_completion.
        3. Проверяется, что полученная модель соответствует значению gpt_4o.name.
        """
```

## Функции

### `get_model_and_provider`

```python
from g4f.client import get_model_and_provider

def get_model_and_provider(model: str, provider_names: Optional[list[str]] = None, force_stream: bool = False) -> tuple[str, object]:
    """
    Получает модель и провайдера на основе заданных параметров.

    Args:
        model (str): Имя модели.
        provider_names (Optional[list[str]]): Список имен провайдеров. По умолчанию `None`.
        force_stream (bool): Флаг принудительной потоковой передачи. По умолчанию `False`.

    Returns:
        tuple[str, object]: Кортеж, содержащий имя модели и объект провайдера.
    """
    # Не отдавай код функции. Только документацию и примеры вызова функции;
    # - Все комментарии и docstring должны быть на русском языке в формате UTF-8
```

**Параметры**:

- `model` (str): Имя модели для получения.
- `provider_names` (Optional[list[str]]): Список имен провайдеров для поиска модели. Если не указан, используется список провайдеров по умолчанию.
- `force_stream` (bool):  Указывает, следует ли принудительно использовать потоковую передачу.

**Возвращает**:

- `tuple[str, object]`: Кортеж, содержащий имя модели и объект провайдера.

**Как работает функция**:

1. Функция принимает имя модели, список провайдеров (необязательный) и флаг принудительной потоковой передачи.
2. Она определяет подходящего провайдера для заданной модели.
3. Если провайдер не найден, возвращается ошибка `ModelNotFoundError`.
4. Функция возвращает кортеж, содержащий имя модели и объект провайдера.

**Примеры**:

```python
# Пример 1: Получение модели и провайдера для конкретной модели
model, provider = get_model_and_provider("gpt-3.5-turbo")
print(f"Model: {model}, Provider: {type(provider)}")

# Пример 2: Получение модели и провайдера с указанием списка провайдеров
model, provider = get_model_and_provider("gpt-3.5-turbo", provider_names=["ChatCompletion"])
print(f"Model: {model}, Provider: {type(provider)}")

# Пример 3: Получение модели и провайдера с принудительной потоковой передачей
model, provider = get_model_and_provider("gpt-3.5-turbo", force_stream=True)
print(f"Model: {model}, Provider: {type(provider)}")
```

## Переменные

### `DEFAULT_MESSAGES`

**Описание**: Список сообщений, используемых по умолчанию в тестах.

**Назначение**: Предоставляет стандартный набор сообщений для использования в тестовых сценариях.

```python
DEFAULT_MESSAGES = [{'role': 'user', 'content': 'Hello'}]
```

## Запуск тестов

Для запуска тестов необходимо выполнить скрипт `client.py` напрямую:

```bash
python client.py
```

Это запустит все тесты, определенные в классах `AsyncTestPassModel` и `TestPassModel`.