# Модуль `minibot.py`

## Обзор

Модуль предоставляет реализацию простого Telegram-бота, предназначенного для обслуживания запросов, связанных с `emil-design.com`.
Бот способен обрабатывать текстовые и голосовые сообщения, а также документы, пересылаемые пользователями.
Для взаимодействия с пользователем бот использует API Telegram, а для обработки текста — модель машинного обучения Google Gemini.

## Подробнее

Модуль состоит из нескольких основных частей:

1.  **`BotHandler`**: Класс, отвечающий за обработку команд и сообщений, поступающих боту.
2.  **`Config`**: Класс конфигурации, содержащий основные параметры бота, такие как токен, ID канала и пути к файлам.
3.  **Основной блок `bot.py`**: Инициализация и запуск бота, обработка входящих запросов и распределение их по соответствующим обработчикам.

## Классы

### `BotHandler`

**Описание**: Класс `BotHandler` предназначен для обработки сообщений и команд, получаемых Telegram-ботом.

**Принцип работы**:
При инициализации класс создает экземпляр `GoogleGenerativeAI` для обработки текстовых сообщений и определяет список вопросов для обработки команды `--next`.
Он содержит методы для обработки URL, отправки user\_flowchart, обработки команды `--next`, помощи, отправки PDF, обработки голосовых сообщений и документов.

**Атрибуты**:

*   `base_dir` (Path): Базовый путь к директории `kazarinov`, где хранятся дополнительные ресурсы, такие как схема user\_flowchart.
*   `scenario` (Scenario): Объект класса `Scenario`, используемый для запуска сценариев обработки URL.
*   `model` (GoogleGenerativeAI): Объект класса `GoogleGenerativeAI`, используемый для обработки текстовых запросов с использованием модели Gemini.
*   `questions_list` (List[str]): Список вопросов, используемых для обработки команды `--next`.

**Методы**:

*   `__init__`: Инициализация обработчика событий телеграм-бота.
*   `handle_message`: Обработка текстовых сообщений.
*   `_send_user_flowchart`: Отправка схемы user\_flowchart.
*   `_handle_url`: Обработка URL, присланного пользователем.
*   `_handle_next_command`: Обработка команды `--next` и её аналогов.
*   `help_command`: Обработка команды `/help`.
*   `send_pdf`: Обработка команды `/sendpdf` для отправки PDF.
*   `handle_voice`: Обработка голосовых сообщений.
*   `_transcribe_voice`: Транскрибирование голосового сообщения (заглушка).
*   `handle_document`: Обработка полученных документов.

#### `__init__`

```python
def __init__(self):
    """Инициализация обработчика событий телеграм-бота."""
    ...
```

**Назначение**: Инициализирует обработчик событий телеграм-бота, создает экземпляры классов `Scenario` и `GoogleGenerativeAI`, а также определяет список вопросов для команды `--next`.

**Параметры**:

*   отсутствуют

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Создает экземпляр класса `Scenario` для обработки сценариев.
2.  Создает экземпляр класса `GoogleGenerativeAI` с использованием API-ключа Gemini, полученного из переменной окружения `GEMINI_API`.
3.  Инициализирует список вопросов `questions_list`, который используется в методе `_handle_next_command`.

**Примеры**:

```python
handler = BotHandler()
```

#### `handle_message`

```python
def handle_message(self, bot: telebot.TeleBot, message: 'message'):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, полученные от пользователя.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются ответы.
*   `message` (message): Объект сообщения, содержащий текст и информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Извлекает текст сообщения.
2.  Проверяет, является ли текст сообщения командой "?", URL-адресом или командой "--next".
3.  Если текст является URL-адресом, вызывает метод `_handle_url` для его обработки.
4.  Если текст является командой "--next", вызывает метод `_handle_next_command` для её обработки.
5.  В противном случае пытается получить ответ от модели Gemini и отправляет его пользователю.
6.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Получение текста сообщения
|
B: Проверка, является ли текст командой "?"
|
C: Проверка, является ли текст URL-адресом
|
D: Проверка, является ли текст командой "--next"
|
E: Получение ответа от модели Gemini
|
F: Отправка ответа пользователю
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(func=lambda message: True)
def echo_all(message):
    handler.handle_message(bot, message)
```

#### `_send_user_flowchart`

```python
def _send_user_flowchart(self, bot, chat_id):
    """Отправка схемы user_flowchart."""
    ...
```

**Назначение**: Отправляет пользователю схему user\_flowchart в виде фотографии.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляется фотография.
*   `chat_id` (int): ID чата пользователя, которому отправляется фотография.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Определяет путь к файлу `user_flowchart.png`.
2.  Пытается открыть файл и отправить его пользователю в виде фотографии.
3.  Если файл не найден, логирует ошибку и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Определение пути к файлу
|
B: Открытие файла
|
C: Отправка фотографии пользователю
|
D: Обработка исключения FileNotFoundError
|
E: Логирование ошибки
|
F: Отправка сообщения об ошибке пользователю
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(commands=['start'])
def send_flowchart(message):
    handler._send_user_flowchart(bot, message.chat.id)
```

#### `_handle_url`

```python
def _handle_url(self, bot, message: 'message'):
    """Обработка URL, присланного пользователем."""
    ...
```

**Назначение**: Обрабатывает URL, присланный пользователем, извлекает данные и запускает сценарий.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются сообщения.
*   `message` (message): Объект сообщения, содержащий URL и информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Извлекает URL из сообщения.
2.  Проверяет, начинается ли URL с `https://one-tab.com` или `https://www.one-tab.com`.
3.  Если URL не соответствует ожидаемому формату, отправляет пользователю сообщение об ошибке и завершает работу.
4.  Извлекает цену, название товара и список URL из страницы OneTab с помощью функции `fetch_target_urls_onetab`.
5.  Отправляет пользователю сообщение с полученной информацией.
6.  Запускает асинхронный сценарий `self.scenario.run_scenario` для обработки списка URL.
7.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Извлечение URL из сообщения
|
B: Проверка формата URL
|
C: Извлечение данных из страницы OneTab
|
D: Отправка сообщения с информацией
|
E: Запуск асинхронного сценария
|
F: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(func=lambda message: True)
def handle_url_message(message):
    handler._handle_url(bot, message)
```

#### `_handle_next_command`

```python
def _handle_next_command(self, bot, message):
    """Обработка команды '--next' и её аналогов."""
    ...
```

**Назначение**: Обрабатывает команду `--next` и её аналоги, выбирает случайный вопрос из списка и запрашивает ответ у модели Gemini.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются сообщения.
*   `message` (message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Выбирает случайный вопрос из списка `self.questions_list`.
2.  Запрашивает ответ у модели Gemini с помощью метода `self.model.ask`.
3.  Отправляет пользователю выбранный вопрос и полученный ответ.
4.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Выбор случайного вопроса
|
B: Запрос ответа у модели Gemini
|
C: Отправка вопроса пользователю
|
D: Отправка ответа пользователю
|
E: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(func=lambda message: message.text in ('--next', '-next', '__next', '-n', '-q'))
def handle_next_command(message):
    handler._handle_next_command(bot, message)
```

#### `help_command`

```python
def help_command(self, bot, message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help` и отправляет пользователю список доступных команд.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются сообщения.
*   `message` (message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Отправляет пользователю сообщение со списком доступных команд и их описанием.

Схема работы функции:

```
A: Отправка сообщения со списком команд
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(commands=['help'])
def handle_help_command(message):
    handler.help_command(bot, message)
```

#### `send_pdf`

```python
def send_pdf(self, bot, message, pdf_file):
    """Обработка команды /sendpdf для отправки PDF."""
    ...
```

**Назначение**: Обрабатывает команду `/sendpdf` и отправляет пользователю PDF-файл.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляется PDF-файл.
*   `message` (message): Объект сообщения, содержащий информацию о пользователе.
*   `pdf_file` (str): Путь к PDF-файлу, который необходимо отправить.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Пытается открыть PDF-файл и отправить его пользователю.
2.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Открытие PDF-файла
|
B: Отправка PDF-файла пользователю
|
C: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(commands=['sendpdf'])
def handle_send_pdf_command(message):
    handler.send_pdf(bot, message, 'example.pdf')
```

#### `handle_voice`

```python
def handle_voice(self, bot, message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются сообщения.
*   `message` (message): Объект сообщения, содержащий голосовое сообщение.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Получает информацию о файле голосового сообщения.
2.  Скачивает файл голосового сообщения.
3.  Сохраняет файл во временную директорию.
4.  Транскрибирует голосовое сообщение с помощью метода `_transcribe_voice`.
5.  Отправляет пользователю распознанный текст.
6.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Получение информации о файле
|
B: Скачивание файла
|
C: Сохранение файла во временную директорию
|
D: Транскрибирование голосового сообщения
|
E: Отправка распознанного текста
|
F: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    handler.handle_voice(bot, message)
```

#### `_transcribe_voice`

```python
def _transcribe_voice(self, file_path):
    """Транскрибирование голосового сообщения (заглушка)."""
    ...
```

**Назначение**: Транскрибирует голосовое сообщение в текст. **ВНИМАНИЕ**: В текущей версии является заглушкой и всегда возвращает сообщение о том, что распознавание голоса ещё не реализовано.

**Параметры**:

*   `file_path` (str): Путь к файлу голосового сообщения.

**Возвращает**:

*   str: Строка с распознанным текстом (в текущей реализации - заглушка).

**Как работает функция**:

1.  Возвращает сообщение о том, что распознавание голоса ещё не реализовано.

Схема работы функции:

```
A: Возврат сообщения о нереализованной функциональности
```

**Примеры**:

```python
handler = BotHandler()
transcribed_text = handler._transcribe_voice('path/to/voice/file.ogg')
print(transcribed_text)  # Вывод: Распознавание голоса ещё не реализовано.
```

#### `handle_document`

```python
def handle_document(self, bot, message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Параметры**:

*   `bot` (telebot.TeleBot): Объект бота, через который отправляются сообщения.
*   `message` (message): Объект сообщения, содержащий документ.

**Возвращает**:

*   bool: `True`, если обработка прошла успешно, `False` в случае ошибки.

**Как работает функция**:

1.  Получает информацию о файле документа.
2.  Скачивает файл документа.
3.  Сохраняет файл во временную директорию.
4.  Отправляет пользователю сообщение об успешном сохранении файла.
5.  При возникновении ошибки логирует её и отправляет пользователю сообщение об ошибке, возвращает `False`.

Схема работы функции:

```
A: Получение информации о файле
|
B: Скачивание файла
|
C: Сохранение файла во временную директорию
|
D: Отправка сообщения об успехе
|
E: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    success = handler.handle_document(bot, message)
    if success:
        print("Document handled successfully.")
    else:
        print("Failed to handle document.")
```

### `Config`

**Описание**: Класс `Config` предназначен для хранения конфигурационных параметров бота.

**Принцип работы**:
При инициализации класс считывает значения параметров из переменных окружения или использует значения по умолчанию.

**Атрибуты**:

*   `BOT_TOKEN` (str): Токен бота, полученный из переменной окружения `TELEGRAM_BOT_TOKEN` или из хранилища `gs.credentials.telegram.hypo69_emil_design_bot`, если `USE_ENV` равен `False`.
*   `CHANNEL_ID` (str): ID канала для отправки уведомлений.
*   `PHOTO_DIR` (Path): Путь к директории с фотографиями.
*   `COMMAND_INFO` (str): Информация о боте, отображаемая по команде `/info`.
*   `UNKNOWN_COMMAND_MESSAGE` (str): Сообщение, отображаемое при вводе неизвестной команды.
*   `START_MESSAGE` (str): Сообщение, отображаемое при старте бота.
*   `HELP_MESSAGE` (str): Сообщение, отображаемое при вызове команды `/help`.

**Методы**:

*   отсутствуют

## Функции

В данном коде функции отсутствуют. Код содержит обработчики сообщений, которые регистрируются с помощью декораторов `bot.message_handler`.

### `command_start`

```python
@bot.message_handler(commands=['start'])
def command_start(message):
    """Обработка команды /start."""
    ...
```

**Назначение**: Обрабатывает команду `/start` и отправляет пользователю приветственное сообщение.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию об использовании команды `/start` пользователем.
2.  Отправляет пользователю сообщение, содержащее приветствие из `config.START_MESSAGE`.

Схема работы функции:

```
A: Логирование команды
|
B: Отправка приветственного сообщения
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')

@bot.message_handler(commands=['start'])
def command_start(message):
    bot.send_message(message.chat.id, "Привет! Как дела?")
```

### `command_help`

```python
@bot.message_handler(commands=['help'])
def command_help(message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help` и вызывает метод `help_command` объекта `handler` для отправки справочной информации пользователю.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию об использовании команды `/help` пользователем.
2.  Вызывает метод `handler.help_command` для отправки справочной информации.

Схема работы функции:

```
A: Логирование команды
|
B: Вызов метода help_command
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(commands=['help'])
def command_help(message):
    handler.help_command(bot, message)
```

### `command_info`

```python
@bot.message_handler(commands=['info'])
def command_info(message):
    """Обработка команды /info."""
    ...
```

**Назначение**: Обрабатывает команду `/info` и отправляет пользователю информацию о боте.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию об использовании команды `/info` пользователем.
2.  Отправляет пользователю сообщение, содержащее информацию о боте из `config.COMMAND_INFO`.

Схема работы функции:

```
A: Логирование команды
|
B: Отправка информации о боте
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')

@bot.message_handler(commands=['info'])
def command_info(message):
    bot.send_message(message.chat.id, "Этот бот предназначен для...")
```

### `command_time`

```python
@bot.message_handler(commands=['time'])
def command_time(message):
    """Обработка команды /time."""
    ...
```

**Назначение**: Обрабатывает команду `/time` и отправляет пользователю текущее время.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию об использовании команды `/time` пользователем.
2.  Получает текущее время.
3.  Форматирует время в строку.
4.  Отправляет пользователю сообщение с текущим временем.

Схема работы функции:

```
A: Логирование команды
|
B: Получение текущего времени
|
C: Форматирование времени
|
D: Отправка времени пользователю
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')

@bot.message_handler(commands=['time'])
def command_time(message):
    now = datetime.datetime.now()
    current_time = now.strftime("%H:%M:%S")
    bot.send_message(message.chat.id, f"Текущее время: {current_time}")
```

### `command_photo`

```python
@bot.message_handler(commands=['photo'])
def command_photo(message):
    """Обработка команды /photo."""
    ...
```

**Назначение**: Обрабатывает команду `/photo` и отправляет пользователю случайную фотографию из директории `config.PHOTO_DIR`.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о пользователе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию об использовании команды `/photo` пользователем.
2.  Пытается получить список файлов в директории `config.PHOTO_DIR`.
3.  Если в директории есть файлы, выбирает случайный файл.
4.  Открывает файл и отправляет его пользователю в виде фотографии.
5.  Если директория не найдена или в ней нет файлов, отправляет пользователю сообщение об ошибке.

Схема работы функции:

```
A: Логирование команды
|
B: Получение списка файлов
|
C: Выбор случайного файла
|
D: Отправка фотографии пользователю
|
E: Обработка ошибок
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
config = Config()
@bot.message_handler(commands=['photo'])
def command_photo(message):
    try:
        photo_files = os.listdir(config.PHOTO_DIR)
        if photo_files:
            random_photo = random.choice(photo_files)
            photo_path = os.path.join(config.PHOTO_DIR, random_photo)
            with open(photo_path, 'rb') as photo:
                bot.send_photo(message.chat.id, photo)
        else:
            bot.send_message(message.chat.id, "Нет фотографий в папке.")
    except FileNotFoundError:
        bot.send_message(message.chat.id, "Фотография не найдена.")
```

### `handle_voice_message`

```python
@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о голосовом сообщении.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию о получении голосового сообщения от пользователя.
2.  Вызывает метод `handle_voice` объекта `handler` для обработки голосового сообщения.

Схема работы функции:

```
A: Логирование сообщения
|
B: Вызов метода handle_voice
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    handler.handle_voice(bot, message)
```

### `handle_document_message`

```python
@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о документе.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию о получении документа от пользователя.
2.  Вызывает метод `handle_document` объекта `handler` для обработки документа.

Схема работы функции:

```
A: Логирование сообщения
|
B: Вызов метода handle_document
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    handler.handle_document(bot, message)
```

### `handle_text_message`

```python
@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, которые не начинаются с символа `/`.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о текстовом сообщении.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию о полученном текстовом сообщении от пользователя.
2.  Вызывает метод `handle_message` объекта `handler` для обработки текстового сообщения.

Схема работы функции:

```
A: Логирование сообщения
|
B: Вызов метода handle_message
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
handler = BotHandler()

@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    handler.handle_message(bot, message)
```

### `handle_unknown_command`

```python
@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    """Обработка неизвестных команд."""
    ...
```

**Назначение**: Обрабатывает неизвестные команды, начинающиеся с символа `/`.

**Параметры**:

*   `message` (telebot.types.Message): Объект сообщения, содержащий информацию о команде.

**Возвращает**:

*   отсутствует

**Как работает функция**:

1.  Логирует информацию о полученной неизвестной команде от пользователя.
2.  Отправляет пользователю сообщение о неизвестной команде из `config.UNKNOWN_COMMAND_MESSAGE`.

Схема работы функции:

```
A: Логирование команды
|
B: Отправка сообщения о неизвестной команде
```

**Примеры**:

```python
bot = telebot.TeleBot('YOUR_BOT_TOKEN')
config = Config()

@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    bot.send_message(message.chat.id, config.UNKNOWN_COMMAND_MESSAGE)