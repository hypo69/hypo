# Модуль для работы с провайдером Airforce
=================================================

Модуль содержит класс `Airforce`, который предоставляет асинхронный генератор для взаимодействия с API Airforce.
Airforce позволяет генерировать как текст, так и изображения.
Модуль включает в себя методы для фильтрации контента, обработки ошибок и управления моделями.

## Оглавление
- [Обзор](#обзор)
- [Классы](#классы)
  - [Airforce](#airforce)
    - [Атрибуты класса](#атрибуты-класса)
    - [Методы класса](#методы-класса)
      - [get_models](#get_models)
      - [get_model](#get_model)
      - [_filter_content](#_filter_content)
      - [_filter_response](#_filter_response)
      - [generate_image](#generate_image)
      - [generate_text](#generate_text)
      - [create_async_generator](#create_async_generator)
- [Функции](#функции)
  - [split_message](#split_message)

## Обзор

Модуль `Airforce` предназначен для асинхронной работы с API Airforce, предоставляя возможности генерации текста и изображений.
Он включает в себя методы для управления моделями, фильтрации контента и обработки ошибок, обеспечивая надежное взаимодействие с API.

## Подробнее

Модуль `Airforce` играет роль адаптера между API Airforce и остальной частью проекта `hypotez`.
Он предоставляет удобный интерфейс для генерации текста и изображений, абстрагируя детали реализации API.
Модуль также включает в себя механизмы для обработки ошибок и фильтрации контента, что делает его более надежным и удобным в использовании.

## Классы

### `Airforce`

**Описание**: Класс `Airforce` является асинхронным провайдером и реализует методы для работы с API Airforce.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию данных.
- `ProviderModelMixin`: Предоставляет функциональность для управления моделями.

#### Атрибуты класса:

- `url` (str): Базовый URL API Airforce.
- `api_endpoint_completions` (str): URL для эндпоинта завершения чата.
- `api_endpoint_imagine2` (str): URL для эндпоинта генерации изображений.
- `working` (bool): Флаг, указывающий, работает ли провайдер.
- `supports_stream` (bool): Флаг, указывающий, поддерживает ли провайдер потоковую передачу данных.
- `supports_system_message` (bool): Флаг, указывающий, поддерживает ли провайдер системные сообщения.
- `supports_message_history` (bool): Флаг, указывающий, поддерживает ли провайдер историю сообщений.
- `default_model` (str): Модель, используемая по умолчанию для генерации текста.
- `default_image_model` (str): Модель, используемая по умолчанию для генерации изображений.
- `models` (List[str]): Список доступных моделей для генерации текста.
- `image_models` (List[str]): Список доступных моделей для генерации изображений.
- `hidden_models` (Set[str]): Набор скрытых моделей.
- `additional_models_imagine` (List[str]): Дополнительные модели для генерации изображений.
- `model_aliases` (Dict[str, str]): Словарь, содержащий псевдонимы моделей.

#### Методы класса:

#### `get_models`

```python
@classmethod
def get_models(cls) -> List[str]:
    """Получает список доступных моделей с обработкой ошибок."""
```

**Назначение**: Получает список доступных моделей для генерации текста и изображений.
Если список моделей не был инициализирован, метод пытается получить его из API.
В случае ошибки возвращается список псевдонимов моделей.

**Как работает функция**:
1. Проверяется, инициализирован ли список моделей изображений `cls.image_models`.
2. Если список не инициализирован, делается попытка получить его из API по адресу `f"{cls.url}/imagine2/models"`.
3. Если запрос успешен, список моделей изображений обновляется. Если произошла ошибка, она логируется, и используется резервный список `cls.additional_models_imagine`.
4. Аналогично проверяется и обновляется список текстовых моделей `cls.models` из API по адресу `f"{cls.url}/models"`.
5. В случае успеха извлекаются идентификаторы моделей из JSON-ответа.
6. Если возникает ошибка, она также логируется, и используется резервный список псевдонимов моделей `cls.model_aliases.keys()`.
7. Возвращается объединенный список моделей текста и изображений, исключая скрытые модели.

```
A: Проверка инициализации cls.image_models
|
B: Получение моделей изображений из API или использование резервного списка
|
C: Проверка инициализации cls.models
|
D: Получение текстовых моделей из API или использование резервного списка псевдонимов
|
E: Объединение и фильтрация моделей
|
F: Возврат списка моделей
```

**Возвращает**:
- `List[str]`: Список доступных моделей.

**Пример**:

```python
models = Airforce.get_models()
print(models)
# ['llama-3.1-70b-chat', 'flux']
```

#### `get_model`

```python
@classmethod
def get_model(cls, model: str) -> str:
    """Получает фактическое имя модели из псевдонима."""
```

**Назначение**: Возвращает фактическое имя модели на основе предоставленного псевдонима. Если псевдоним не найден, возвращается предоставленное имя модели или модель по умолчанию.

**Параметры**:
- `model` (str): Псевдоним модели.

**Возвращает**:
- `str`: Фактическое имя модели.

**Пример**:

```python
model_name = Airforce.get_model("openchat-3.5")
print(model_name)
# openchat-3.5-0106
```

#### `_filter_content`

```python
@classmethod
def _filter_content(cls, part_response: str) -> str:
    """Фильтрует нежелательный контент из частичного ответа."""
```

**Назначение**: Фильтрует нежелательный контент из частичного ответа, удаляя сообщения о превышении лимита символов и ограничении скорости.

**Параметры**:
- `part_response` (str): Частичный ответ, который необходимо отфильтровать.

**Возвращает**:
- `str`: Отфильтрованный частичный ответ.

**Как работает функция**:

1.  Удаляет сообщения о превышении лимита символов в сообщении.

2.  Удаляет сообщения об ограничении скорости.

```
A: Получение частичного ответа
|
B: Удаление сообщений о превышении лимита символов
|
C: Удаление сообщений об ограничении скорости
|
D: Возврат отфильтрованного ответа
```

**Пример**:

```python
filtered_content = Airforce._filter_content("One message exceeds the \\d+chars per message limit...")
print(filtered_content)
# ''
```

#### `_filter_response`

```python
@classmethod
def _filter_response(cls, response: str) -> str:
    """Фильтрует полный ответ для удаления системных ошибок и другого нежелательного текста."""
```

**Назначение**: Фильтрует полный ответ, удаляя системные ошибки и другой нежелательный текст.

**Параметры**:
- `response` (str): Полный ответ, который необходимо отфильтровать.

**Возвращает**:
- `str`: Отфильтрованный полный ответ.

**Вызывает исключения**:
- `ValueError`: Если ответ содержит сообщение об ошибке "Model not found or too long input. Or any other error (xD)".

**Как работает функция**:

1.  Проверяет наличие сообщения об ошибке "Model not found or too long input. Or any other error (xD)" в ответе. Если такое сообщение присутствует, вызывается исключение `ValueError`.

2.  Удаляет идентификаторы ошибок, начинающиеся с "\\[ERROR\\]".

3.  Удаляет токены `<|im_end|>` и `</s>`.

4.  Удаляет префиксы "Assistant: ", "AI: ", "ANSWER: ", "Output: " из ответа.

5.  Вызывает метод `_filter_content` для дальнейшей фильтрации контента.

```
A: Проверка наличия сообщения об ошибке
|
B: Удаление идентификаторов ошибок
|
C: Удаление токенов <|im_end|> и </s>
|
D: Удаление префиксов
|
E: Вызов _filter_content
|
F: Возврат отфильтрованного ответа
```

**Пример**:

```python
filtered_response = Airforce._filter_response("[ERROR] '12345678-1234-1234-1234-123456789012'</s>Assistant: Hello")
print(filtered_response)
# Hello
```

#### `generate_image`

```python
@classmethod
async def generate_image(
    cls,
    model: str,
    prompt: str,
    size: str,
    seed: int,
    proxy: str = None
) -> AsyncResult:
    """Генерирует изображение на основе предоставленных параметров."""
```

**Назначение**: Асинхронно генерирует изображение на основе предоставленных параметров, используя API Airforce.

**Параметры**:
- `model` (str): Модель для генерации изображения.
- `prompt` (str): Текстовое описание изображения (prompt).
- `size` (str): Размер изображения.
- `seed` (int): Зерно для генерации случайных чисел.
- `proxy` (str, optional): HTTP-прокси для подключения к API. По умолчанию `None`.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий объект `ImageResponse` с URL изображения и альтернативным текстом.

**Вызывает исключения**:
- `RuntimeError`: Если генерация изображения не удалась (HTTP-статус не 200).

**Как работает функция**:

1.  Формирует заголовки HTTP-запроса, включая User-Agent, Accept, Accept-Language, Accept-Encoding и Content-Type.

2.  Формирует параметры запроса, включая модель, подсказку, размер и начальное число.

3.  Использует `ClientSession` для выполнения асинхронного GET-запроса к API `cls.api_endpoint_imagine2` с указанными параметрами и заголовками.

4.  Если HTTP-статус равен 200 (успех), извлекает URL изображения из ответа и возвращает объект `ImageResponse` через асинхронный генератор.

5.  Если HTTP-статус не равен 200, извлекает текст ошибки из ответа и вызывает исключение `RuntimeError`.

```
A: Формирование заголовков и параметров запроса
|
B: Отправка GET-запроса к API
|
C: Проверка статуса ответа
|
D: Извлечение URL изображения и возврат ImageResponse (успех)
|
E: Вызов исключения RuntimeError (ошибка)
```

**Пример**:

```python
async for result in Airforce.generate_image(model='flux', prompt='A cat', size='1:1', seed=123):
    print(result)
# ImageResponse(images='https://example.com/image.png', alt='A cat')
```

#### `generate_text`

```python
@classmethod
async def generate_text(
    cls,
    model: str,
    messages: Messages,
    max_tokens: int,
    temperature: float,
    top_p: float,
    stream: bool,
    proxy: str = None
) -> AsyncResult:
    """Генерирует текст, буферизует ответ, фильтрует его и возвращает окончательный результат."""
```

**Назначение**: Асинхронно генерирует текст на основе предоставленных параметров, используя API Airforce.

**Параметры**:
- `model` (str): Модель для генерации текста.
- `messages` (Messages): Список сообщений для генерации текста.
- `max_tokens` (int): Максимальное количество токенов в ответе.
- `temperature` (float): Температура для генерации текста.
- `top_p` (float): Top-p для генерации текста.
- `stream` (bool): Флаг, указывающий, использовать ли потоковую передачу данных.
- `proxy` (str, optional): HTTP-прокси для подключения к API. По умолчанию `None`.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий сгенерированный текст.

**Как работает функция**:

1.  Формирует заголовки HTTP-запроса, включая User-Agent, Accept, Accept-Language, Accept-Encoding и Content-Type.

2.  Разбивает длинные сообщения на более мелкие части (до 1000 символов), чтобы соответствовать ограничениям API.

3.  Формирует данные запроса, включая сообщения, модель, температуру, top_p и флаг потоковой передачи.

4.  Использует `ClientSession` для выполнения асинхронного POST-запроса к API `cls.api_endpoint_completions` с указанными данными и заголовками.

5.  Если `stream` равен `True` (использовать потоковую передачу), обрабатывает ответ построчно:

    *   Декодирует каждую строку из формата UTF-8.

    *   Если строка начинается с `data: `, извлекает JSON-строку и преобразует ее в объект Python.

    *   Извлекает содержимое из объекта и фильтрует его с помощью метода `_filter_response`.

    *   Возвращает отфильтрованное содержимое через асинхронный генератор.

6.  Если `stream` равен `False` (не использовать потоковую передачу), обрабатывает ответ как JSON:

    *   Извлекает информацию об использовании токенов и возвращает ее в виде объекта `Usage`.

    *   Извлекает содержимое сообщения и фильтрует его с помощью метода `_filter_response`.

    *   Возвращает отфильтрованное содержимое через асинхронный генератор.

```
A: Формирование заголовков и подготовка данных запроса
|
B: Отправка POST-запроса к API
|
C: Проверка флага stream
|
D1: Обработка потокового ответа (stream=True)
|   |
|   D1.1: Чтение и декодирование строк
|   |
|   D1.2: Извлечение JSON и фильтрация содержимого
|   |
|   D1.3: Возврат отфильтрованного содержимого
|
D2: Обработка не потокового ответа (stream=False)
|   |
|   D2.1: Извлечение информации об использовании токенов
|   |
|   D2.2: Извлечение и фильтрация содержимого
|   |
|   D2.3: Возврат отфильтрованного содержимого
```

**Пример**:

```python
messages = [{"role": "user", "content": "Hello"}]
async for result in Airforce.generate_text(model='llama-3.1-70b-chat', messages=messages, max_tokens=100, temperature=0.7, top_p=0.9, stream=False):
    print(result)
# Hello, how can I help you today?
```

#### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    prompt: str = None,
    proxy: str = None,
    max_tokens: int = 512,
    temperature: float = 1,
    top_p: float = 1,
    stream: bool = True,
    size: str = "1:1",
    seed: int = None,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для генерации текста или изображений."""
```

**Назначение**: Создает асинхронный генератор для генерации текста или изображений в зависимости от указанной модели.

**Параметры**:
- `model` (str): Модель для генерации текста или изображения.
- `messages` (Messages): Список сообщений для генерации текста.
- `prompt` (str, optional): Текстовое описание изображения (prompt). Используется только для генерации изображений. По умолчанию `None`.
- `proxy` (str, optional): HTTP-прокси для подключения к API. По умолчанию `None`.
- `max_tokens` (int, optional): Максимальное количество токенов в ответе. Используется только для генерации текста. По умолчанию 512.
- `temperature` (float, optional): Температура для генерации текста. По умолчанию 1.
- `top_p` (float, optional): Top-p для генерации текста. По умолчанию 1.
- `stream` (bool, optional): Флаг, указывающий, использовать ли потоковую передачу данных. По умолчанию `True`.
- `size` (str, optional): Размер изображения. Используется только для генерации изображений. По умолчанию "1:1".
- `seed` (int, optional): Зерно для генерации случайных чисел. Используется только для генерации изображений. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий сгенерированный текст или изображение.

**Как работает функция**:

1.  Получает фактическое имя модели с помощью метода `get_model`.

2.  Проверяет, является ли модель моделью изображения (содержится ли в списке `cls.image_models`).

3.  Если модель является моделью изображения:

    *   Если `prompt` не указан, использует содержимое последнего сообщения из списка `messages` в качестве `prompt`.

    *   Если `seed` не указан, генерирует случайное число в диапазоне от 0 до 10000.

    *   Вызывает метод `generate_image` для генерации изображения и возвращает результат через асинхронный генератор.

4.  Если модель не является моделью изображения:

    *   Вызывает метод `generate_text` для генерации текста и возвращает результат через асинхронный генератор.

```
A: Получение фактического имени модели
|
B: Проверка, является ли модель моделью изображения
|
C1: Генерация изображения (модель изображения)
|   |
|   C1.1: Извлечение prompt и seed
|   |
|   C1.2: Вызов generate_image
|
C2: Генерация текста (не модель изображения)
|   |
|   C2.1: Вызов generate_text
```

**Пример**:

```python
messages = [{"role": "user", "content": "A cat"}]
async for result in Airforce.create_async_generator(model='flux', messages=messages, prompt='A cat', size='1:1', seed=123):
    print(result)
# ImageResponse(images='https://example.com/image.png', alt='A cat')
```

## Функции

### `split_message`

```python
def split_message(message: str, max_length: int = 1000) -> List[str]:
    """Разбивает сообщение на части длиной до (max_length)."""
```

**Назначение**: Разбивает входное сообщение на список подстрок, каждая из которых не превышает `max_length`.

**Параметры**:
- `message` (str): Строка сообщения, которую нужно разбить.
- `max_length` (int, optional): Максимальная длина каждой подстроки. По умолчанию 1000.

**Возвращает**:
- `List[str]`: Список подстрок.

**Как работает функция**:

1.  Инициализирует пустой список `chunks` для хранения подстрок.

2.  В цикле `while` проверяет, длина `message` больше `max_length`.

    *   Если да, то пытается найти последний пробел в `message` в диапазоне от 0 до `max_length`.

    *   Если пробел не найден (`split_point == -1`), то разбивает `message` на позиции `max_length`.

    *   Добавляет первую часть `message` (до `split_point`) в список `chunks`.

    *   Обновляет `message`, удаляя добавленную часть и пробелы в начале.

3.  Если после цикла `while` в `message` что-то осталось, добавляет остаток в список `chunks`.

4.  Возвращает список `chunks`.

```
A: Инициализация списка chunks
|
B: Проверка длины message
|
C: Поиск точки разделения (пробел)
|
D: Добавление части сообщения в chunks
|
E: Обновление message
|
F: Добавление остатка сообщения в chunks (если есть)
|
G: Возврат списка chunks
```

**Пример**:

```python
message = "This is a long message that needs to be split into smaller chunks."
chunks = split_message(message, max_length=20)
print(chunks)
# ['This is a long ', 'message that needs', ' to be split into', ' smaller chunks.']