## Ответ на Задачу No 270: Тетрамино

### 1. Анализ задачи и решение

**Понимание задачи:**
* Задача заключается в нахождении количества способов замощения прямоугольника размером 2 x n тетрамино.
* Тетрамино — это фигуры из четырех квадратов, всего их 7 видов.
* Необходимо учесть, что повороты и отражения тетрамино не дают новых способов замощения.
* Нам нужно вычислить T(10^12) mod 1000000007.
* Поскольку прямое перечисление вариантов при большом `n` невозможно, нужен более эффективный метод.
* Изучение начальных значений T(1)=1, T(2)=3, T(3)=11, T(4)=41, T(5)=153,...  наводит на мысль о рекуррентном соотношении.

**Поиск рекуррентного соотношения:**
После анализа способов укладки тетрамино, можно заметить, что текущее T(n) зависит от предыдущих T(n-1), T(n-2), T(n-3). Рассматривая, как можно добавить тетрамино к прямоугольнику 2 x (n-1), 2 x (n-2) и 2 x (n-3), мы получаем рекуррентное соотношение:
`T(n) = 4 * T(n-1) - T(n-2) + T(n-3)`

**Решение:**
1. **Рекуррентное соотношение:** Используем найденное рекуррентное соотношение: `T(n) = 4 * T(n-1) - T(n-2) + T(n-3)`
2. **Начальные значения:** Используем T(1) = 1, T(2) = 3, T(3) = 11.
3. **Динамическое программирование (DP):** Для расчета T(n) при большом `n` используем DP с сохранением последних трех значений, чтобы избежать рекурсивного вызова.
4. **Модульная арифметика:** На каждом шаге вычисления необходимо брать остаток от деления на 1000000007, чтобы избежать переполнения и получить правильный результат.
5. **Оптимизация:** Поскольку n может быть очень большим, мы можем использовать матричное возведение в степень, чтобы вычислить Tn(n) за O(log n), преобразуем рекуррентное соотношение в матричный вид, чтобы получить быстрый способ вычисления T(n).

**Матричное представление рекуррентного соотношения:**
```
[T(n)   ]   [4 -1  1 ] [ T(n-1) ]
[T(n-1) ] = [1  0  0 ] [ T(n-2) ]
[T(n-2) ]   [0  1  0 ] [ T(n-3) ]
```
Обозначим матрицу `A = [[4, -1, 1], [1, 0, 0], [0, 1, 0]]`, и вектор `T = [T(n-1), T(n-2), T(n-3)]`. Тогда, `[T(n), T(n-1), T(n-2)] = A * [T(n-1), T(n-2), T(n-3)]`. Чтобы получить `T(n)` для большого n, мы должны возвести матрицу `A` в степень n-3 и умножить на вектор `[T(3), T(2), T(1)]`.

### 2. Алгоритм решения
1. Начать.
2. Инициализировать матрицу `A` как `[[4, -1, 1], [1, 0, 0], [0, 1, 0]]`.
3. Инициализировать вектор `initial_values` как `[11, 3, 1]`.
4. Инициализировать `n = 10**12`.
5. Вычислить матрицу `A` в степени `n-3` с помощью быстрого возведения в степень (mod 1000000007).
6. Умножить полученную матрицу на `initial_values`.
7. Взять первый элемент результирующего вектора.
8. Вернуть результат по модулю 1000000007.
9. Конец.

### 3. Реализация на Python 3.12
```python
def matrix_multiply(matrix1, matrix2, mod):
    """Умножение двух матриц."""
    rows1 = len(matrix1)
    cols1 = len(matrix1[0])
    cols2 = len(matrix2[0])
    result = [[0 for _ in range(cols2)] for _ in range(rows1)]
    for i in range(rows1):
        for j in range(cols2):
            for k in range(cols1):
                result[i][j] = (result[i][j] + matrix1[i][k] * matrix2[k][j]) % mod
    return result

def matrix_power(matrix, power, mod):
    """Возведение матрицы в степень."""
    size = len(matrix)
    result = [[1 if i == j else 0 for j in range(size)] for i in range(size)]
    while power > 0:
        if power % 2 == 1:
            result = matrix_multiply(result, matrix, mod)
        matrix = matrix_multiply(matrix, matrix, mod)
        power //= 2
    return result

def solve_tetromino(n):
    """Решает задачу о замощении тетрамино."""
    if n <= 3:
        return [0, 1, 3, 11][n]
    
    mod = 1000000007
    matrix_a = [[4, -1, 1], [1, 0, 0], [0, 1, 0]]
    initial_values = [[11], [3], [1]]
    
    powered_matrix = matrix_power(matrix_a, n - 3, mod)
    
    result_vector = matrix_multiply(powered_matrix, initial_values, mod)
    return result_vector[0][0]

# Пример использования
n = 10**12
result = solve_tetromino(n)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeMatrix((Инициализировать матрицу A и начальные значения))
    InitializeMatrix --> InputN((Ввести n = 10^12))
    InputN --> CheckBaseCase{{"n <= 3?"}}
    CheckBaseCase -- Да --> ReturnBaseCase{{return T(n) из [0, 1, 3, 11]}}
    ReturnBaseCase --> End((Конец))
    CheckBaseCase -- Нет --> MatrixPower((Возвести матрицу A в степень n-3 (mod 1000000007)))
    MatrixPower --> MultiplyMatrixVector((Умножить полученную матрицу на вектор начальных значений))
    MultiplyMatrixVector --> GetResult((Получить первый элемент вектора результата))
    GetResult --> OutputResult((Вывести результат (mod 1000000007)))
    OutputResult --> End
```

**Legenda:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать матрицу A и начальные значения:** Задаем матрицу A и вектор начальных значений `[11, 3, 1]`.
* **Ввести n = 10^12:** Задаем входное значение n равное 10^12.
* **n <= 3?:** Проверка базового случая, когда n меньше или равно 3.
* **return T(n) из [0, 1, 3, 11]:** Возвращает T(n) для n <=3.
* **Возвести матрицу A в степень n-3 (mod 1000000007):** Вычисляем A^(n-3) по модулю.
* **Умножить полученную матрицу на вектор начальных значений:** Перемножаем матрицу A^(n-3) с вектором [11, 3, 1].
* **Получить первый элемент вектора результата:** Получаем T(n) из полученного вектора.
* **Вывести результат (mod 1000000007):** Выводим результат T(n) по модулю 1000000007.
