# Модуль для обработки ответов от GPT4Free

## Обзор

Модуль `response.py` предназначен для обработки и форматирования ответов, полученных от различных провайдеров в рамках проекта `hypotez`. Он содержит классы и функции для преобразования URL-адресов, работы с изображениями, аудио и видео, а также для представления различных типов ответов, таких как JSON, текст, скрытые ответы и т.д. Модуль обеспечивает удобный интерфейс для работы с данными, возвращаемыми API, и их представления в нужном формате.

## Подробней

Этот модуль предоставляет инструменты для стандартизации и обработки ответов, что позволяет упростить интеграцию различных источников данных и представление информации пользователю. Функции модуля охватывают широкий спектр задач, от форматирования ссылок и изображений до обработки аудио- и видеоконтента. Также модуль включает классы для представления различных типов ответов, что позволяет гибко обрабатывать данные в зависимости от их типа и назначения.

## Функции

### `quote_url`

```python
def quote_url(url: str) -> str:
    """
    Экранирует части URL, сохраняя структуру домена.

    Args:
        url (str): URL для экранирования.

    Returns:
        str: Экранированный URL.

    Как работает функция:
    1. Проверяет, содержит ли URL символы процента (`%`). Если да, то URL декодируется с помощью `unquote_plus`, чтобы избежать двойного декодирования.
    2. Разбивает URL на части, используя `"//"` в качестве разделителя, чтобы отделить протокол от остальной части URL.
    3. Если в URL нет `"//"` (т.е. это относительный URL), то экранирует весь URL с помощью `quote_plus`, разрешая символы `/?&=#`.
    4. Если URL содержит протокол, то разбивает остальную часть URL на части, используя `"/"` в качестве разделителя, чтобы отделить домен от пути.
    5. Если после домена нет `"/"` (т.е. это URL домена), то возвращает URL в формате `протокол//домен`.
    6. Если после домена есть путь, то экранирует путь с помощью `quote_plus`, разрешая символы `/?&=#`, и возвращает URL в формате `протокол//домен/экранированный_путь`.
    ```
    ```
    URL -> Проверка наличия '%' -> Декодирование URL (если нужно) -> Разделение на протокол и остальную часть ->
    Относительный URL? -> Экранирование URL -> Конец
    Да:                                                                                                |
    Нет: -> Разделение на домен и путь -> URL домена? -> Возврат протокола и домена -> Конец
    Да:                                                        |
    Нет: -> Экранирование пути -> Возврат протокола, домена и экранированного пути -> Конец
    ```
    Example:
        >>> quote_url("https://example.com/path?query=value")
        'https://example.com/path%3Fquery%3Dvalue'
        >>> quote_url("/relative/path?query=value")
        '%2Frelative%2Fpath%3Fquery%3Dvalue'
    """
    ...

### `quote_title`

```python
def quote_title(title: str) -> str:
    """
    Нормализует пробелы в заголовке.

    Args:
        title (str): Заголовок для нормализации.

    Returns:
        str: Заголовок с нормализованными пробелами.

    Как работает функция:
    1. Проверяет, является ли заголовок непустой строкой.
    2. Если заголовок непустой, разбивает его на слова, используя пробелы в качестве разделителя, и объединяет их обратно в строку с одним пробелом между словами.
    3. Если заголовок пустой, возвращает пустую строку.
    ```
    ```
    Заголовок -> Проверка на пустоту -> Разбиение на слова -> Объединение с одним пробелом -> Конец
    Да:                                                                                                |
    Нет: -> Возврат пустой строки -> Конец
    ```

    Example:
        >>> quote_title("  Multiple   Spaces  ")
        'Multiple Spaces'
        >>> quote_title("")
        ''
    """
    ...

### `format_link`

```python
def format_link(url: str, title: Optional[str] = None) -> str:
    """
    Форматирует URL и заголовок в виде markdown-ссылки.

    Args:
        url (str): URL для ссылки.
        title (Optional[str]): Заголовок для отображения. Если `None`, извлекается из URL.

    Returns:
        str: Отформатированная markdown-ссылка.

    Как работает функция:
    1. Если заголовок не указан (`None`), пытается извлечь его из URL.
    2. Если извлечь заголовок не удалось, использует сам URL в качестве заголовка.
    3. Экранирует URL с помощью `quote_url` и заголовок с помощью `quote_title`.
    4. Форматирует URL и заголовок в виде markdown-ссылки: `[экранированный_заголовок](экранированный_URL)`.
    ```
    ```
    URL, Заголовок -> Заголовок указан? -> Экранирование URL и заголовка -> Форматирование в markdown-ссылку -> Конец
    Да:                 |
    Нет: -> Извлечение заголовка из URL -> Экранирование URL и заголовка -> Форматирование в markdown-ссылку -> Конец
    ```
    Example:
        >>> format_link("https://example.com", "Example")
        '[Example](https://example.com)'
        >>> format_link("https://example.com/path?query=value")
        '[example.compath](https://example.com/path%3Fquery%3Dvalue)'
    """
    ...

### `format_image`

```python
def format_image(image: str, alt: str, preview: Optional[str] = None) -> str:
    """
    Форматирует данное изображение в виде markdown-строки.

    Args:
        image (str): Изображение для форматирования.
        alt (str): Альтернативный текст для изображения.
        preview (Optional[str]): URL превью изображения. Если не указан, используется оригинальное изображение.

    Returns:
        str: Отформатированная markdown-строка.

    Как работает функция:
    1. Если указан URL превью изображения, заменяет `{image}` в URL превью на URL оригинального изображения.
    2. Экранирует URL превью изображения и альтернативный текст с помощью `quote_url` и `quote_title` соответственно.
    3. Форматирует изображение в виде markdown-строки: `[![экранированный_alt_text](экранированный_preview_url)](экранированный_image_url)`.
    ```
    ```
    Изображение, Alt текст, Preview URL -> Preview URL указан? -> Замена '{image}' в Preview URL ->
    Экранирование Preview URL, Alt текста и URL изображения -> Форматирование в markdown-строку -> Конец
    Да:                                                                        |
    Нет: -> Экранирование Preview URL, Alt текста и URL изображения -> Форматирование в markdown-строку -> Конец
    ```

    Example:
        >>> format_image("https://example.com/image.jpg", "Example Image")
        '[![Example Image](https://example.com/image.jpg)](https://example.com/image.jpg)'
        >>> format_image("https://example.com/image.jpg", "Example Image", "https://example.com/preview/{image}")
        '[![Example Image](https://example.com/preview/https%3A//example.com/image.jpg)](https://example.com/image.jpg)'
    """
    ...

### `format_images_markdown`

```python
def format_images_markdown(images: Union[str, List[str]], alt: str,
                           preview: Union[str, List[str]] = None) -> str:
    """
    Форматирует данные изображения в виде markdown-строки.

    Args:
        images (Union[str, List[str]]): Изображение или список изображений для форматирования.
        alt (str): Альтернативный текст для изображений.
        preview (Union[str, List[str]]): URL превью или список URL превью. Если не указан, используются оригинальные изображения.

    Returns:
        str: Отформатированная markdown-строка.

    Как работает функция:
    1. Если `images` - это список, состоящий из одного элемента, то он извлекается из списка.
    2. Если `images` - это строка, то форматирует ее как одно изображение с помощью `format_image`.
    3. Если `images` - это список, то проходит по списку и форматирует каждое изображение с помощью `format_image`.
       Если `preview` - это список, то использует соответствующий URL превью для каждого изображения.
       Если `preview` - это строка, то использует ее для всех изображений.
    4. Добавляет флаги начала и конца сгенерированных изображений (`<!-- generated images start -->` и `<!-- generated images end -->`) вокруг отформатированных изображений.

    ```
    Изображения, Alt текст, Preview URL -> Список изображений из одного элемента? -> Извлечение элемента ->
    Изображения - строка? -> Форматирование одного изображения -> Добавление флагов -> Конец
    Да:                                                            |
    Нет: -> Изображения - список? -> Перебор изображений -> Preview URL - список? -> Использование соответствующего Preview URL ->
    Форматирование изображения -> Добавление флагов -> Конец
    Да:                                      |
    Нет: -> Использование одного Preview URL -> Форматирование изображения -> Добавление флагов -> Конец
    ```
    Example:
        >>> format_images_markdown("https://example.com/image.jpg", "Example Image")
        '\\n<!-- generated images start -->\\n[![Example Image](https://example.com/image.jpg)](https://example.com/image.jpg)\\n<!-- generated images end -->\\n\\n'
        >>> format_images_markdown(["https://example.com/image1.jpg", "https://example.com/image2.jpg"], "Example Image", "https://example.com/preview/{image}")
        '\\n<!-- generated images start -->\\n[![#1 Example Image](https://example.com/preview/https%3A//example.com/image1.jpg)](https://example.com/image1.jpg)\\n[![#2 Example Image](https://example.com/preview/https%3A//example.com/image2.jpg)](https://example.com/image2.jpg)\\n<!-- generated images end -->\\n\\n'
    """
    ...

## Классы

### `ResponseType`

**Описание**:
Абстрактный базовый класс для всех типов ответов.

**Принцип работы**:
Определяет интерфейс для преобразования ответа в строковое представление.

**Методы**:
- `__str__`: Преобразует ответ в строковое представление. Должен быть переопределен в подклассах. Вызывает исключение `NotImplementedError`, если не переопределен.

### `JsonMixin`

**Описание**:
Миксин для классов, которые могут быть представлены в формате JSON.

**Принцип работы**:
Предоставляет методы для работы с атрибутами класса как со словарем.

**Методы**:
- `__init__`: Инициализирует атрибуты класса на основе переданных именованных аргументов.
- `get_dict`: Возвращает словарь, содержащий все не приватные атрибуты класса (атрибуты, не начинающиеся с `__`).
- `reset`: Сбрасывает все атрибуты класса, удаляя их из `__dict__`.

### `RawResponse`

**Описание**:
Класс для представления "сырого" ответа.

**Принцип работы**:
Наследует `ResponseType` и `JsonMixin`, предоставляя возможность представления ответа в виде JSON.

### `HiddenResponse`

**Описание**:
Базовый класс для скрытых ответов.

**Принцип работы**:
Наследует `ResponseType` и всегда возвращает пустую строку при преобразовании в строку.

**Методы**:
- `__str__`: Возвращает пустую строку.

### `FinishReason`

**Описание**:
Класс для представления причины завершения.

**Принцип работы**:
Наследует `HiddenResponse` и `JsonMixin`, представляя причину завершения в виде JSON.

**Методы**:
- `__init__`: Инициализирует объект с указанной причиной.

### `ToolCalls`

**Описание**:
Класс для представления вызовов инструментов.

**Принцип работы**:
Наследует `HiddenResponse`, хранит список вызовов инструментов и предоставляет метод для его получения.

**Методы**:
- `__init__`: Инициализирует объект списком вызовов инструментов.
- `get_list`: Возвращает список вызовов инструментов.

### `Usage`

**Описание**:
Класс для представления информации об использовании.

**Принцип работы**:
Наследует `HiddenResponse` и `JsonMixin`, представляя информацию об использовании в виде JSON.

### `AuthResult`

**Описание**:
Класс для представления результата аутентификации.

**Принцип работы**:
Наследует `HiddenResponse` и `JsonMixin`, представляя результат аутентификации в виде JSON.

### `TitleGeneration`

**Описание**:
Класс для представления сгенерированного заголовка.

**Принцип работы**:
Наследует `HiddenResponse` и хранит сгенерированный заголовок.

**Методы**:
- `__init__`: Инициализирует объект с указанным заголовком.

### `DebugResponse`

**Описание**:
Класс для представления отладочного сообщения.

**Принцип работы**:
Наследует `HiddenResponse` и хранит отладочное сообщение.

**Методы**:
- `__init__`: Инициализирует объект с указанным отладочным сообщением.

### `Reasoning`

```python
class Reasoning(ResponseType):
    def __init__(
            self,
            token: Optional[str] = None,
            label: Optional[str] = None,
            status: Optional[str] = None,
            is_thinking: Optional[str] = None
        ) -> None:
        """Initialize with token, status, and thinking state."""
        self.token = token
        self.label = label
        self.status = status
        self.is_thinking = is_thinking

    def __str__(self) -> str:
        """Return string representation based on available attributes."""
        if self.is_thinking is not None:
            return self.is_thinking
        if self.token is not None:
            return self.token
        if self.status is not None:
            if self.label is not None:
                return f"{self.label}: {self.status}\\n"
            return f"{self.status}\\n"
        return ""

    def __eq__(self, other: Reasoning):
        return (self.token == other.token and
                self.status == other.status and
                self.is_thinking == other.is_thinking)

    def get_dict(self) -> Dict:
        """Return a dictionary representation of the reasoning."""
        if self.label is not None:
            return {"label": self.label, "status": self.status}
        if self.is_thinking is None:
            if self.status is None:
                return {"token": self.token}
            return {"token": self.token, "status": self.status}
        return {"token": self.token, "status": self.status, "is_thinking": self.is_thinking}
```

**Описание**:
Класс для представления этапа рассуждения.

**Принцип работы**:
Предоставляет атрибуты для хранения токена, статуса, метки и состояния "размышления" и метод для их строкового представления.

**Методы**:
- `__init__`: Инициализирует объект с указанными токеном, статусом, меткой и состоянием "размышления".
- `__str__`: Возвращает строковое представление объекта в зависимости от доступных атрибутов.
    - Если `is_thinking` не `None`, возвращает `is_thinking`.
    - Иначе, если `token` не `None`, возвращает `token`.
    - Иначе, если `status` не `None`, возвращает `label: status`, если `label` не `None`, иначе возвращает `status`.
    - В противном случае возвращает пустую строку.
- `__eq__`: Определяет, равны ли два объекта `Reasoning`.
- `get_dict`: Возвращает словарь, представляющий состояние рассуждения.

Как работает класс:
1. Инициализация объекта `Reasoning` с атрибутами: `token`, `label`, `status`, `is_thinking`.
2. Метод `__str__` определяет, какое строковое представление вернуть в зависимости от заполненности атрибутов.
3. Метод `__eq__` сравнивает два объекта `Reasoning` на основе их атрибутов.
4. Метод `get_dict` возвращает словарь, представляющий состояние рассуждения.

```
Reasoning -> Инициализация (token, label, status, is_thinking) -> __str__():
                                                                  |
                                                                  |-> is_thinking != None? -> return is_thinking
                                                                  |
                                                                  |-> token != None? -> return token
                                                                  |
                                                                  |-> status != None? -> label != None? -> return f"{label}: {status}\\n" : return f"{status}\\n"
                                                                  |
                                                                  |-> return ""
```

### `Sources`

```python
class Sources(ResponseType):
    def __init__(self, sources: List[Dict[str, str]]) -> None:
        """Initialize with a list of source dictionaries."""
        self.list = []
        for source in sources:
            self.add_source(source)

    def add_source(self, source: Union[Dict[str, str], str]) -> None:
        """Add a source to the list, cleaning the URL if necessary."""
        source = source if isinstance(source, dict) else {"url": source}
        url = source.get("url", source.get("link", None))
        if url is not None:
            url = re.sub(r"[&?]utm_source=.+", "", url)
            source["url"] = url
            self.list.append(source)

    def __str__(self) -> str:
        """Return formatted sources as a string."""
        if not self.list:
            return ""
        return "\\n\\n\\n\\n" + ("\\n>\\n".join([
            f"> [{idx}] {format_link(link['url'], link.get('title', None))}"
            for idx, link in enumerate(self.list)
        ]))
```

**Описание**:
Класс для представления источников информации.

**Принцип работы**:
Хранит список источников в виде словарей и предоставляет методы для добавления источников и форматирования их в строку.

**Методы**:
- `__init__`: Инициализирует объект списком источников.
- `add_source`: Добавляет источник в список, очищая URL от параметров `utm_source`.
- `__str__`: Возвращает отформатированный список источников в виде строки.

**Как работает класс**:
1. При инициализации класса `Sources` создается пустой список `self.list` для хранения источников.
2. Затем происходит итерация по переданному списку источников, и каждый источник добавляется с помощью метода `self.add_source(source)`.
3. В методе `add_source`:
   - Если переданный `source` является строкой, он преобразуется в словарь `{"url": source}`.
   - Извлекается URL из `source` (сначала ищется ключ "url", затем "link").
   - Если URL существует, из него удаляются параметры `utm_source`.
   - Очищенный `source` добавляется в список `self.list`.
4. Метод `__str__` формирует строковое представление списка источников:
   - Если список `self.list` пуст, возвращается пустая строка.
   - Иначе формируется строка, в которой каждый источник представлен в формате `"> [{idx}] {format_link(link['url'], link.get('title', None))}"`, где `idx` - индекс источника, а `format_link` - функция для форматирования ссылки.

```
Sources -> Инициализация (sources) -> Для каждого source в sources: add_source(source)
add_source -> source - строка? -> source = {"url": source} -> url = source.get("url", source.get("link", None))
                                 |
                                 Нет
url != None? -> url = re.sub(r"[&?]utm_source=.+", "", url) -> self.list.append(source)
Нет

__str__ -> self.list пуст? -> return ""
            Да
            Нет -> Формирование строки с источниками в формате Markdown
```

### `YouTube`

**Описание**:
Класс для представления YouTube-видео.

**Принцип работы**:
Наследует `HiddenResponse`, хранит список идентификаторов видео и предоставляет метод для их форматирования в виде HTML-вставок.

**Методы**:
- `__init__`: Инициализирует объект списком идентификаторов видео.
- `to_string`: Возвращает список HTML-вставок для каждого видео.

### `AudioResponse`

**Описание**:
Класс для представления аудио-ответа.

**Принцип работы**:
Хранит аудиоданные в виде байтов или URI и предоставляет методы для их преобразования в URI данных и HTML-элемент.

**Методы**:
- `__init__`: Инициализирует объект аудиоданными.
- `to_uri`: Возвращает аудиоданные в виде URI данных, закодированного в base64.
- `__str__`: Возвращает аудиоданные в виде HTML-элемента `<audio>`.

### `BaseConversation`

**Описание**:
Базовый класс для представлений бесед.

**Принцип работы**:
Наследует `ResponseType` и возвращает пустую строку по умолчанию.

**Методы**:
- `__str__`: Возвращает пустую строку.

### `JsonConversation`

**Описание**:
Класс для представления бесед в формате JSON.

**Принцип работы**:
Наследует `BaseConversation` и `JsonMixin`, предоставляя возможность представления беседы в виде JSON.

### `SynthesizeData`

**Описание**:
Класс для представления синтезированных данных.

**Принцип работы**:
Наследует `HiddenResponse` и `JsonMixin`, хранит провайдера и данные.

**Методы**:
- `__init__`: Инициализирует объект с указанным провайдером и данными.

### `SuggestedFollowups`

**Описание**:
Класс для представления предложенных вариантов продолжения беседы.

**Принцип работы**:
Хранит список предложений для продолжения беседы.

**Методы**:
- `__init__`: Инициализирует объект списком предложений.

### `RequestLogin`

**Описание**:
Класс для представления запроса на авторизацию.

**Принцип работы**:
Наследует `HiddenResponse`, хранит метку и URL авторизации и предоставляет метод для их форматирования в виде markdown-ссылки.

**Методы**:
- `__init__`: Инициализирует объект с указанной меткой и URL авторизации.
- `to_string`: Возвращает отформатированную markdown-ссылку для авторизации.

### `MediaResponse`

**Описание**:
Базовый класс для ответов, содержащих медиафайлы (изображения, видео и т.д.).

**Принцип работы**:
Хранит URL-адреса медиафайлов, альтернативный текст и параметры и предоставляет методы для доступа к ним.

**Методы**:
- `__init__`: Инициализирует объект URL-адресами медиафайлов, альтернативным текстом и параметрами.
- `get`: Возвращает значение параметра по ключу.
- `get_list`: Возвращает URL-адреса медиафайлов в виде списка.

### `ImageResponse`

**Описание**:
Класс для представления ответа с изображением.

**Принцип работы**:
Наследует `MediaResponse` и предоставляет метод для форматирования изображений в виде markdown.

**Методы**:
- `__str__`: Возвращает изображения в виде markdown, используя функцию `format_images_markdown`.

### `VideoResponse`

**Описание**:
Класс для представления видео-ответа.

**Принцип работы**:
Наследует `MediaResponse` и предоставляет метод для форматирования видео в виде HTML-элементов.

**Методы**:
- `__str__`: Возвращает видео в виде HTML-элементов `<video>`.

### `ImagePreview`

**Описание**:
Класс для представления превью изображения.

**Принцип работы**:
Наследует `ImageResponse` и возвращает пустую строку при преобразовании в строку.

**Методы**:
- `__str__`: Возвращает пустую строку.
- `to_string`: Возвращает изображения в виде markdown, используя метод `__str__` базового класса `ImageResponse`.

### `PreviewResponse`

**Описание**:
Класс для представления ответа с превью.

**Принцип работы**:
Наследует `HiddenResponse` и хранит данные превью.

**Методы**:
- `__init__`: Инициализирует объект данными превью.
- `to_string`: Возвращает данные превью в виде строки.

### `Parameters`

**Описание**:
Класс для представления параметров.

**Принцип работы**:
Наследует `ResponseType` и `JsonMixin` и возвращает пустую строку при преобразовании в строку.

**Методы**:
- `__str__`: Возвращает пустую строку.

### `ProviderInfo`

**Описание**:
Класс для представления информации о провайдере.

**Принцип работы**:
Наследует `JsonMixin` и `HiddenResponse`.