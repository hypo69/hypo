# Классы в `python`

Классы — это один из основных механизмов объектно-ориентированного программирования (ООП) в Python. Класс можно представить как "шаблон" или "чертеж" для создания объектов, которые имеют атрибуты (данные) и методы (функции). Объекты, созданные на основе класса, называются экземплярами (инстанциями) класса. Классы позволяют структурировать код, улучшать его повторное использование и облегчать его поддержку.

### Структура класса

```python
class ClassName:
    # Атрибуты класса
    def __init__(self, param1, param2):
        # Конструктор (инициализатор) класса
        self.param1 = param1
        self.param2 = param2

    # Методы класса
    def method(self):
        return f'{self.param1} и {self.param2}'
```

1. **Конструктор** (`__init__`):
   Конструктор `__init__` является специальным методом, который автоматически вызывается при создании нового объекта. Он используется для инициализации атрибутов объекта.

   - `self`: параметр, который является ссылкой на текущий экземпляр класса. В Python обязательно передавать его как первый параметр во всех методах класса (он не передается при вызове метода).
   - Атрибуты, такие как `param1` и `param2`, присваиваются объекту через `self`. Эти атрибуты затем могут быть использованы другими методами класса.

2. **Атрибуты класса**:
   Атрибуты — это переменные, которые принадлежат объектам этого класса. Они определяются внутри конструктора (`__init__`) и могут быть доступны с помощью ссылки на объект.

3. **Методы класса**:
   Методы — это функции, которые могут манипулировать атрибутами объекта. Методы могут использовать данные объекта, изменять их или выполнять другие операции.

### Создание объекта класса

Когда класс определен, можно создавать объекты этого класса. Объекты являются экземплярами класса.

```python
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def description(self):
        return f'{self.year} {self.make} {self.model}'

# Создание объекта
my_car = Car('Toyota', 'Corolla', 2020)
print(my_car.description())  # Вывод: 2020 Toyota Corolla
```

- В этом примере мы создали объект `my_car` класса `Car`. При создании объекта передаются значения для атрибутов `make`, `model`, и `year`, которые сохраняются в объекте.
- Метод `description()` позволяет получить строковое представление автомобиля.

### Типы методов

1. **Методы экземпляра**: Это обычные методы, которые действуют на экземпляры класса. Они принимают ссылку на объект как первый параметр (обычно это `self`).

   Пример:
   ```python
   def method(self):
       pass
   ```

2. **Методы класса**: Методы, которые принимают сам класс как первый параметр. Для определения таких методов используется декоратор `@classmethod`. Они могут изменять состояние самого класса, а не отдельных его экземпляров.

   Пример:
   ```python
   class MyClass:
       @classmethod
       def class_method(cls):
           pass
   ```

3. **Статические методы**: Это методы, которые не используют `self` или `cls` (то есть они не имеют доступа ни к экземпляру, ни к классу). Статические методы объявляются с помощью декоратора `@staticmethod`. Они могут быть полезны, когда метод не зависит от состояния объекта или класса, но связан с логикой, принадлежащей классу.

   Пример:
   ```python
   class MyClass:
       @staticmethod
       def static_method():
           pass
   ```

### Наследование

Один из ключевых принципов ООП — **наследование**. Класс может наследовать поведение другого класса, расширяя или изменяя его функциональность. Это позволяет повторно использовать код, избегая дублирования.

```python
class Animal:
    def speak(self):
        return 'Голос животного'

class Dog(Animal):  # Класс Dog наследует от класса Animal
    def speak(self):
        return 'Гав'

# Создание объектов
dog = Dog()
print(dog.speak())  # Вывод: Гав
```

- Класс `Dog` наследует метод `speak` от класса `Animal`, но переопределяет его, чтобы вернуть строку `'Гав'`.

### Полиморфизм

**Полиморфизм** означает способность объектов разных классов использовать одинаковые методы с разной реализацией. В Python это возможно благодаря наследованию и переопределению методов.

```python
class Cat(Animal):
    def speak(self):
        return 'Мяу'

# Создание объектов
cat = Cat()
print(cat.speak())  # Вывод: Мяу
```

Здесь `Cat` также переопределяет метод `speak`, но возвращает другое значение. Это позволяет вызвать метод `speak` независимо от типа объекта.

### Инкапсуляция

**Инкапсуляция** позволяет скрывать внутренние детали реализации и предоставлять доступ к данным через публичные методы. Это помогает предотвратить неправильное использование данных.

```python
class Car:
    def __init__(self, make, model):
        self._make = make  # Защищённый атрибут
        self._model = model

    def get_make(self):
        return self._make

    def set_make(self, make):
        self._make = make

# Создание объекта
my_car = Car('Toyota', 'Corolla')
print(my_car.get_make())  # Вывод: Toyota
my_car.set_make('Honda')
print(my_car.get_make())  # Вывод: Honda
```

Здесь атрибуты `_make` и `_model` являются защищёнными (обычно в Python подчеркивание означает, что эти атрибуты не должны использоваться напрямую за пределами класса), но доступ к ним можно получить и изменить через методы `get_make` и `set_make`.

### Прочие особенности классов

1. **Деструктор** (`__del__`):
   Специальный метод, который вызывается, когда объект уничтожается (например, при выходе из области видимости). Он может быть использован для очистки ресурсов.

   Пример:
   ```python
   class MyClass:
       def __del__(self):
           print("Объект уничтожен")

   obj = MyClass()
   del obj  # Объект будет уничтожен и вызовется метод __del__
   ```

2. **Магические методы**:
   Это специальные методы с двумя подчеркиваниями (например, `__init__`, `__str__`, `__repr__`, `__eq__`). Они позволяют переопределять стандартное поведение операций, таких как создание объектов, сравнение, вывод объектов в строковом виде и т.д.

   Пример:
   ```python
   class Point:
       def __init__(self, x, y):
           self.x = x
           self.y = y

       def __repr__(self):
           return f'Point({self.x}, {self.y})'

   p = Point(3, 4)
   print(p)  # Вывод: Point(3, 4)
   ```

 ---

  [К оглавлению](https://github.com/hypo69/101_python_computer_games_ru/blob/master/cheat_sheets#readme)
