# Анализ кода модуля `chief.py`

**Качество кода**
   - Соответствие требованиям к формату кода (1-10):
     - **Плюсы:**
       - Код в целом структурирован и легко читается.
       - Присутствуют комментарии, объясняющие основные шаги программы.
       - Используется стандартный цикл `while` для игровой логики.
       - Присутствует обработка ошибок ввода (`try-except`).
     - **Минусы:**
       - Отсутствует документация в формате reStructuredText (RST).
       - Нет явного импорта `logger` для логирования ошибок.
       - Использование `print` для вывода сообщений вместо `logger.info`.
       - Нет разделения кода на функции для улучшения модульности.
       - Использование `while True` с `break` для выхода из цикла может быть заменено на более ясное условие.

**Рекомендации по улучшению**
1. **Формат документации:** Переписать комментарии в формате RST и добавить docstrings к функциям (которых пока нет).
2. **Логирование:** Заменить `print` на использование `logger` для вывода сообщений и ошибок. Добавить импорт `logger` из `src.logger.logger`.
3. **Структуризация:** Выделить логику игры в отдельные функции (например, для ввода данных, проверки, вывода результатов).
4. **Упрощение цикла:** Заменить `while True` на цикл с условием, которое отражает состояние игры (например, `while not game_won:`).
5. **Обработка ошибок:** Использовать `logger.error` для логирования ошибок ввода вместо простого вывода сообщения на консоль.
6. **Переменные:** Добавить явные типы переменных.

**Улучшенный код**
```python
"""
Модуль игры "CHIEF"
====================

Игра "CHIEF" - это игра, в которой игрок выступает в роли начальника,
планирующего производство на фабрике. Игрок устанавливает количество
произведенных изделий каждого типа, и компьютер определяет, соответствуют ли эти значения
необходимым требованиям. Если нет, игроку сообщается, какие именно значения были неверны.
Цель игры - достичь оптимального производства, правильно угадывая количество изделий.

Правила игры:
1. Компьютер загадывает три значения в диапазоне от 1 до 10: `targetA`, `targetB` и `targetC`.
2. Игрок вводит свои предположения о значениях `userA`, `userB` и `userC`.
3. Компьютер проверяет, совпадают ли введенные значения с загаданными.
4. Если все три значения угаданы, игра заканчивается победой.
5. Если хотя бы одно значение не совпадает, компьютер выводит, какие именно значения были неверными.
6. Игра продолжается до тех пор, пока игрок не угадает все три значения.

Алгоритм:
1. Сгенерировать случайные целые числа `targetA`, `targetB` и `targetC` в диапазоне от 1 до 10.
2. Начать цикл "пока не угаданы все числа":
   2.1 Запросить у игрока ввод трех целых чисел: `userA`, `userB` и `userC`.
   2.2 Инициализировать строку `message` как пустую.
   2.3 Если `userA` не равно `targetA`, добавить "A" к `message`.
   2.4 Если `userB` не равно `targetB`, добавить "B" к `message`.
   2.5 Если `userC` не равно `targetC`, добавить "C" к `message`.
   2.6 Если `message` не пустая, вывести сообщение "WRONG ON " и `message`.
   2.7 Иначе, вывести сообщение "YOU GOT IT!".
3. Конец игры.
"""
import random
from src.logger.logger import logger #  Импортируем logger для логирования

def generate_targets() -> tuple[int, int, int]:
    """
    Генерирует три случайных целых числа от 1 до 10.

    :return: Кортеж из трех случайных целых чисел.
    :rtype: tuple[int, int, int]
    """
    target_a: int = random.randint(1, 10) # Генерирует случайное целое число от 1 до 10 и присваивает его переменной target_a
    target_b: int = random.randint(1, 10) # Генерирует случайное целое число от 1 до 10 и присваивает его переменной target_b
    target_c: int = random.randint(1, 10) # Генерирует случайное целое число от 1 до 10 и присваивает его переменной target_c
    return target_a, target_b, target_c

def get_user_inputs() -> tuple[int, int, int]:
    """
    Запрашивает ввод трех целых чисел от пользователя.

    :return: Кортеж из трех целых чисел, введенных пользователем.
    :rtype: tuple[int, int, int]
    """
    while True:
        try:
            user_a: int = int(input('Введите число для A (от 1 до 10): '))  # Запрашивает у пользователя ввод числа для A, преобразует его в целое число и сохраняет в переменной user_a
            user_b: int = int(input('Введите число для B (от 1 до 10): '))  # Запрашивает у пользователя ввод числа для B, преобразует его в целое число и сохраняет в переменной user_b
            user_c: int = int(input('Введите число для C (от 1 до 10): '))  # Запрашивает у пользователя ввод числа для C, преобразует его в целое число и сохраняет в переменной user_c
            return user_a, user_b, user_c
        except ValueError as e: # Обрабатываем возможную ошибку, если пользователь ввел не целое число
            logger.error('Пожалуйста, введите целые числа.', exc_info=e) # логируем ошибку
            print("Пожалуйста, введите целые числа.")
            continue


def check_answers(user_a: int, user_b: int, user_c: int, target_a: int, target_b: int, target_c: int) -> str:
    """
    Проверяет, совпадают ли введенные пользователем числа с загаданными.

    :param user_a: Число, введенное пользователем для A.
    :type user_a: int
    :param user_b: Число, введенное пользователем для B.
    :type user_b: int
    :param user_c: Число, введенное пользователем для C.
    :type user_c: int
    :param target_a: Загаданное число A.
    :type target_a: int
    :param target_b: Загаданное число B.
    :type target_b: int
    :param target_c: Загаданное число C.
    :type target_c: int
    :return: Строка с указанием неверных ответов (если есть) или пустая строка.
    :rtype: str
    """
    message: str = '' # Инициализируем пустую строку message, которая будет использоваться для хранения информации о том, какие числа были введены неправильно

    if user_a != target_a: # Проверяет, не равно ли введенное пользователем число user_a загаданному числу target_a
        message += 'A' # Если user_a не равно target_a, добавляет символ "A" к строке message, указывая, что число A было введено неверно

    if user_b != target_b: # Проверяет, не равно ли введенное пользователем число user_b загаданному числу target_b
        message += 'B' # Если user_b не равно target_b, добавляет символ "B" к строке message, указывая, что число B было введено неверно

    if user_c != target_c: # Проверяет, не равно ли введенное пользователем число user_c загаданному числу target_c
        message += 'C' # Если user_c не равно target_c, добавляет символ "C" к строке message, указывая, что число C было введено неверно
    return message


def play_game():
    """
     Запускает игру.
    """
    target_a, target_b, target_c = generate_targets() #  Генерируем случайные числа
    game_won: bool = False #  Инициализируем флаг, что игра еще не выиграна

    while not game_won: #  Основной игровой цикл
        user_a, user_b, user_c = get_user_inputs() #  Запрашиваем ввод трех чисел от пользователя
        message: str = check_answers(user_a, user_b, user_c, target_a, target_b, target_c) # Проверяем введенные числа
        if message:
            print(f'WRONG ON {message}')  # Выводим сообщение об ошибках
        else:
            print('YOU GOT IT!') # Выводим сообщение о победе
            game_won = True #  Устанавливаем флаг, что игра выиграна


if __name__ == '__main__':
    play_game() # Запускаем игру, если файл запущен как скрипт
```