# Анализ кода модуля jquery-3.5.1.slim.min.js

**Качество кода**
8
 -  Плюсы
    - Код является минифицированной версией библиотеки jQuery, что подразумевает хорошую оптимизацию размера и производительности.
    - Использование IIFE для изоляции области видимости и предотвращения конфликтов имен.
    - Применение условных операторов для поддержки разных сред выполнения (Node.js, браузер).
 -  Минусы
    - Код сложен для чтения и понимания из-за минификации (отсутствуют пробелы и переносы строк, используются короткие имена переменных).
    - Отсутствие документации и комментариев, что затрудняет его поддержку и модификацию.
    - Использование устаревших подходов, не всегда соответствующих современным стандартам JavaScript.
    - Высокая связанность и сложность логики, что затрудняет отладку и рефакторинг.

**Рекомендации по улучшению**

1. **Деминификация кода:**
   - Использовать инструменты для деминификации кода, чтобы сделать его более читаемым.
   - Разделить длинные строки на несколько более коротких для лучшего восприятия.

2. **Добавление комментариев:**
   - Добавить reStructuredText (RST) комментарии к функциям и блокам кода.
   - Описать назначение и логику ключевых функций и переменных.

3. **Улучшение читаемости:**
   - Переименовать короткие переменные в более описательные имена.
   - Добавить отступы для логических блоков кода.

4. **Рефакторинг:**
    - Разбить длинные функции на более мелкие и специализированные, если это возможно.
    - Использовать современные возможности JavaScript, такие как `const` и `let` вместо `var`.
    - Рассмотреть возможность использования более простых конструкций для логических выражений.

5. **Логирование:**
    -  Добавить логирование для отладки и анализа работы кода.
    -  Использовать `src.logger.logger` для вывода ошибок и предупреждений.

6. **Тестирование:**
    - Добавить модульные тесты для ключевых функций, чтобы обеспечить стабильность кода.
    - Использовать систему контроля версий для отслеживания изменений.

**Оптимизированный код**

```python
"""
Модуль содержит минифицированную версию библиотеки jQuery v3.5.1.
=================================================================

Этот модуль предназначен для использования в качестве вебдрайверного расширения
и содержит базовую функциональность jQuery. Код был деминифицирован для улучшения
читаемости и понимания, но сохраняет оригинальную структуру и логику.

Пример использования
--------------------

Используется как часть вебдрайверного расширения, добавляя функциональность jQuery
в контекст веб-страницы.
"""
# Используем `j_loads_ns` для чтения файлов
# from src.utils.jjson import j_loads_ns  #  Не используется в данном файле

# Используем `logger` для логирования ошибок
from src.logger.logger import logger

# Файл является минифицированной версией, поэтому большая часть изменений это только форматирование
# !function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(g,e){"use strict";
# Начало обертки
(function(global, factory) {
    'use strict';

    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function(global) {
            if (!global.document) {
                raise new Error('jQuery requires a window with a document');
            }
            return factory(global);
        };
    } else {
        factory(global);
    }
})(typeof window !== 'undefined' ? window : this, function(global, noGlobal) {
    'use strict';

    var arr = [];  #  Объявление пустого массива
    var getProto = Object.getPrototypeOf; #  Получение прототипа объекта
    var slice = arr.slice; #  Создание копии массива
    var flat = arr.flat ? function(arr) { #  Метод для преобразования многомерного массива в одномерный
            return arr.flat();
        } : function(arr) {
            return arr.concat.apply([], arr);
        };
    var push = arr.push; #  Метод добавления элемента в конец массива
    var indexOf = arr.indexOf; #  Метод поиска индекса элемента в массиве
    var class2type = {}; #  Объект для хранения типов данных
    var toString = class2type.toString; #  Метод преобразования в строку
    var hasOwn = class2type.hasOwnProperty; #  Метод проверки наличия собственного свойства
    var fnToString = hasOwn.toString; #  Получение метода `toString`
    var ObjectFunctionString = fnToString.call(Object);  #  Сравнение строк `toString`
    var isFunction = function(obj) { #  Проверяем, является ли obj функцией
            return typeof obj === 'function' && typeof obj.nodeType !== 'number';
        };
    var isWindow = function(obj) { #  Проверяем, является ли obj окном
            return obj != null && obj === obj.window;
        };
    var document = global.document;  #  Получение объекта document
    var scriptTypes = { type: true, src: true, nonce: true, noModule: true }; #  Список типов для скриптов

    /**
     *  Создание скрипта и добавление в DOM.
     *
     *  :param code: Код скрипта.
     *  :param attrs: Атрибуты скрипта.
     *  :param doc: Объект document.
     */
    function createAndAppendScript(code, attrs, doc) {
        var attr, value, script = (doc || document).createElement('script');
        script.text = code;
        if (attrs) {
            for (attr in scriptTypes) {
                if ((value = attrs[attr] || (attrs.getAttribute && attrs.getAttribute(attr)))) {
                    script.setAttribute(attr, value);
                }
            }
        }
        (doc || document).head.appendChild(script).parentNode.removeChild(script);
    }

    /**
     *  Определение типа объекта.
     *
     *  :param obj: Объект для проверки типа.
     *  :return: Строка, представляющая тип объекта.
     */
    function type(obj) {
        if (obj == null) {
            return String(obj);
        }
        return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
    }

    var version = '3.5.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector'; #  версия Jquery
    var jQuery = function(selector, context) { #  Объявление главного конструктора Jquery
            return new jQuery.fn.init(selector, context);
        };

    /**
    * Проверяет, является ли объект массивоподобным.
    *
    * :param obj: Объект для проверки.
    * :return: `True`, если объект массивоподобный, `False` в противном случае.
    */
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length;
        var objType = type(obj);
        return !isFunction(obj) && !isWindow(obj) && (objType === 'array' || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj);
    }

    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(index) {
            return index == null ? slice.call(this) : index < 0 ? this[index + this.length] : this[index];
        },
        pushStack: function(elems) {
            var result = jQuery.merge(this.constructor(), elems);
            result.prevObject = this;
            return result;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, index) {
                return callback.call(elem, index, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        even: function() {
            return this.pushStack(jQuery.grep(this, function(elem, index) {
                return (index + 1) % 2 === 0;
            }));
        },
        odd: function() {
            return this.pushStack(jQuery.grep(this, function(elem, index) {
                return index % 2 !== 0;
            }));
        },
        eq: function(index) {
            var length = this.length;
            var newIndex = +index + (index < 0 ? length : 0);
            return this.pushStack(newIndex >= 0 && newIndex < length ? [this[newIndex]] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var src, copyIsArray, copy, name, options, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }

        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }

        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    if (Object.hasOwnProperty.call(options, name)) {
                        src = target[name];
                        copy = options[name];
                        if (target !== copy) {
                            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && Array.isArray(src) ? src : [];
                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }
                                target[name] = jQuery.extend(deep, clone, copy);
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }
            }
        }
        return target;
    };

    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function(message) {
            raise new Error(message);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== '[object Object]') {
                return false;
            }
            proto = getProto(obj);
            if (!proto) {
                return true;
            }
            Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        globalEval: function(code, attrs, doc) {
             createAndAppendScript(code, attrs, doc);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length;

            invert = !!invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== invert) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },
        map: function(elems, callback, arg) {
            var value,
                i = 0,
                length = elems.length,
                ret = [];

            if (isArrayLike(elems)) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            return flat(ret);
        },
        guid: 1,
        support: {}
    });

    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function(i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });

    var Sizzle = function(doc) { # Обьявление Sizzle
        var i,
            support,
            Expr,
            getText,
            isXML,
            setDocument,
            document,
            documentElement,
            sortOrder,
            has,
            expando = 'sizzle' + 1 * new Date(),
            cache = 0,
            cacheLength = 50,
            whitespace = '[\\x20\\t\\r\\n\\f]',
            identifier = '(?:\\\\\\\\[\\\\da-fA-F]{1,6}' + whitespace + '?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+',
            attributes = '\\\\[(?:' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(' + identifier + '))|)' + whitespace + '*\\\\]',
            pseudos = ':(' + identifier + ')(?:\\\\(((\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' + attributes + ')*)|.*)\\\\)|)',
            rWhitespace = new RegExp(whitespace + '+', 'g'),
            rTrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$', 'g'),
            rComma = new RegExp('^' + whitespace + '*,?' + whitespace + '*'),
            rCombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),
            rDescendent = new RegExp(whitespace + '|>'),
            rPseudo = new RegExp(pseudos),
            rIdentifier = new RegExp('^' + identifier + '$'),
            rChild = new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' + whitespace + '*(even|odd|(([+-]|)(\\\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\\\d+)|))' + whitespace + '*\\\\)|)', 'i'),
            rBoolean = new RegExp('^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$', 'i'),
            rNeedsContext = new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' + whitespace + '*((?:-\\\\d)?\\\\d*)' + whitespace + '*\\\\)|)(?=[^-]|$)', 'i'),
            rHtml = /HTML$/i,
            rInputs = /^(?:input|select|textarea|button)$/i,
            rHeader = /^h\\d$/i,
            rNative = /^[^{]+\\{\\s*\\[native \\w/,
            rQuickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,
            rAdjacent = /[+~]/,
            rEscapes = new RegExp('\\\\\\\\[\\\\da-fA-F]{1,6}' + whitespace + '?|\\\\\\\\([^\\\\r\\\\n\\\\f])', 'g'),
            rEntity = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,
            rcssescape = function(str, escape) {
                return escape ?
                    '\0' === str ?
                    '\ufffd' :
                    str.slice(0, -1) + '\\' + str.charCodeAt(str.length - 1).toString(16) + ' ' :
                    '\\' + str;
            },
            runescape = function(str, esc) {
                var hex = '0x' + str.slice(1) - 0x10000;
                return esc || hex < 0 ?
                    String.fromCharCode(hex + 0x10000) :
                    String.fromCharCode(hex >> 10 | 0xD800, 0x3FF & hex | 0xDC00);
            },
            fCleanup = function() {
                setDocument();
            },
            isImmediatePropagationStopped = function(el) {
                return true === el.disabled && 'fieldset' === el.nodeName.toLowerCase();
            },
            matches = function(element, tag) {
                return element === tag && (sortOrder = !0), 0;
            },
            hasOwnProperty = {}.hasOwnProperty,
            arrPop = arr.pop,
            arrPush = arr.push,
            arrSlice = arr.slice,
            arrIndexOf = function(list, elem) {
                for (var i = 0, len = list.length; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            },
            supportBoolean = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped';
            try {
               arrPush.apply(arr = arrSlice.call(document.childNodes), document.childNodes),
               arr[document.childNodes.length].nodeType;
            }
             catch(e) {
                arrPush = arr.length ? function(target, el) {
                    arrPush.apply(target, arrSlice.call(el));
                } : function(target, el) {
                    var i = target.length, j = 0;
                    while (target[i++] = el[j++]);
                    target.length = i - 1;
                };
             }

            function addHandle(element) {
                element[expando] = !0;
                return element;
            }

            function isAttached(element) {
                var container = document.createElement('fieldset');
                try {
                    return !!element(container);
                } catch (error) {
                    return false;
                } finally {
                    container.parentNode && container.parentNode.removeChild(container);
                    container = null;
                }
            }

            function createAttrHandle(selector, fn) {
                 var n = selector.split('|'), l = n.length;
                while (l--) {
                    Expr.attrHandle[n[l]] = fn;
                }
            }

            function sortDetached(a, b) {
                var n = b && a;
                var res = n && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
                if (res) return res;
                if (n) while (n = n.nextSibling) if (n === b) return -1;
                return a ? 1 : -1;
            }

            function buildMatcher(type) {
                return function(element) {
                    var name = element.nodeName.toLowerCase();
                    return 'input' === name && element.type === type;
                };
            }

            function buildButtonMatcher(type) {
                 return function(element) {
                     var name = element.nodeName.toLowerCase();
                    return ('input' === name || 'button' === name) && element.type === type;
                };
            }

            function buildFormMatcher(inverse) {
                return function(element) {
                   var nodeName = element.nodeName.toLowerCase();
                   return 'form' in element ?
                       element.parentNode && false === element.disabled ?
                       'label' in element ?
                       'label' in element.parentNode ?
                       element.parentNode.disabled === inverse :
                       element.disabled === inverse :
                       element.isDisabled === inverse ||
                       element.isDisabled !== !inverse &&
                       isImmediatePropagationStopped(element) === inverse:
                        element.disabled === inverse :
                      'label' in element && element.disabled === inverse;
                };
            }

            function buildNth(callback) {
                 return addHandle(function(element) {
                    element = +element;
                     return addHandle(function(elem, list) {
                       var cur,
                         matches = callback([], elem.length, element),
                         l = matches.length;
                       while (l--) {
                         elem[cur = matches[l]] && (elem[cur] = !(list[cur] = elem[cur]));
                       }
                     });
                 });
            }

            function getElementRoot(el) {
               return el &&
                    typeof el.getElementsByTagName !== 'undefined' &&
                   el;
            }

        for(i in support = Sizzle.support = {},
        isXML = Sizzle.isXML = function(element) {
               var namespace = element.namespaceURI,
                   docEle = (element.ownerDocument || element).documentElement;
                   return !rHtml.test(namespace || docEle && docEle.nodeName || 'HTML');
           },

        setDocument = Sizzle.setDocument = function(element) {
            var doc, parent, docIsHTML, win, isTopWin, sortDetached;
            doc = element ? element.ownerDocument || element : document;
           if (doc != document && 9 === doc.nodeType && doc.documentElement) {
                documentElement = doc.documentElement;
                docIsHTML = !isXML(doc);
               if(document != doc) {
                    parent = doc.defaultView;
                    win = parent && parent.top !== parent;
                if(win) {
                    win.addEventListener ? win.addEventListener('unload', fCleanup, false) : win.attachEvent && win.attachEvent('onunload', fCleanup);
                }
            }

                support.scope = isAttached(function(container) {
                        documentElement.appendChild(container).appendChild(document.createElement('div'));
                        return typeof container.querySelectorAll !== 'undefined' && !container.querySelectorAll(':scope fieldset div').length;
                });

                support.attributes = isAttached(function(container) {
                       container.className = 'i';
                       return !container.getAttribute('className');
                   });

                   support.getElementsByTagName = isAttached(function(container) {
                      container.appendChild(document.createComment(''));
                    return !container.getElementsByTagName('*').length;
                 });

                support.getElementsByClassName = rNative.test(document.getElementsByClassName);

                   support.getById = isAttached(function(container) {
                       documentElement.appendChild(container).id = expando;
                       return !document.getElementsByName || !document.getElementsByName(expando).length;
                   });

                    if (support.getById) {
                        Expr.filter.ID = function(id) {
                            var match = id.replace(rEscapes, runescape);
                            return function(element) {
                                return element.getAttribute('id') === match;
                            };
                        };
                        Expr.find.ID = function(id, context) {
                            if (typeof context.getElementById !== 'undefined' && docIsHTML) {
                                var el = context.getElementById(id);
                                return el ? [el] : [];
                            }
                        };
                   } else {
                           Expr.filter.ID = function(id) {
                               var match = id.replace(rEscapes, runescape);
                            return function(element) {
                                var node = typeof element.getAttributeNode !== 'undefined' && element.getAttributeNode('id');
                                return node && node.value === match;
                            };
                        };

                        Expr.find.ID = function(id, context) {
                            if (typeof context.getElementById !== 'undefined' && docIsHTML) {
                                var node, i, res, el = context.getElementById(id);
                                if (el) {
                                        if ((node = el.getAttributeNode('id')) && node.value === id) return [el];
                                        res = context.getElementsByName(id), i = 0;
                                     while (el = res[i++]) {
                                            if ((node = el.getAttributeNode('id')) && node.value === id) return [el];
                                    }
                                }
                                return [];
                            }
                        };
                    }

                    Expr.find.TAG = support.getElementsByTagName ?
                         function(tag, context) {
                              return typeof context.getElementsByTagName !== 'undefined' ?
                                  context.getElementsByTagName(tag) :
                                  support.qsa ? context.querySelectorAll(tag) :
                                  void 0;
                         } :
                         function(tag, context) {
                            var i, res = [], tmp = 0, els = context.getElementsByTagName(tag);
                            if ('*' === tag) {
                                while(i = els[tmp++]) if(1 === i.nodeType) res.push(i);
                                return res;
                            }
                            return els;
                        };

                    Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                        if (typeof context.getElementsByClassName !== 'undefined' && docIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };
                arr = [],
                sortDetached = [],
                (support.qsa = rNative.test(document.querySelectorAll)) && isAttached(function(container) {
                    var input;
                    documentElement.appendChild(container).innerHTML = '<a id=\'' + expando + '\'></a><select id=\'' + expando + '-\\r\\\\\'' + ' msallowcapture=\'\'><option selected=\'\'></option></select>';
                    if(container.querySelectorAll('[msallowcapture^=\'\']').length) sortDetached.push('[*^$]=' + whitespace + '*(?:\'\'|\\"\\")');
                    if(!container.querySelectorAll('[selected]').length) sortDetached.push('\\\\[(?:' + whitespace + '*(?:value|' + supportBoolean + '))');
                    if(!container.querySelectorAll('[id~=' + expando + '-]').length) sortDetached.push('~=');
                    input = document.createElement('input');
                    input.setAttribute('name', '');
                    container.appendChild(input);
                     if(!container.querySelectorAll('[name=\'\']').length) sortDetached.push('\\\\[(?:' + whitespace + '*name' + whitespace + '*=' + whitespace + '*(?:\'\'|\\"\\"))');
                     if(!container.querySelectorAll(':checked').length) sortDetached.push(':checked');
                     if(!container.querySelectorAll('a#' + expando + '+*').length) sortDetached.push('.#.+[+~]');
                   container.querySelectorAll('\\\\\\f');
                   sortDetached.push('[\\\\r\\\\n\\\\f]');
                }),

                isAttached(function(container) {
                     container.innerHTML = '<a href=\'\' disabled=\'disabled\'></a><select disabled=\'disabled\'><option/></select>';
                    var hidden = document.createElement('input');
                   hidden.setAttribute('type','hidden');
                   container.appendChild(hidden).setAttribute('name','D');
                   if(container.querySelectorAll('[name=d]').length) sortDetached.push('name' + whitespace + '*[*^$|!~]?=');
                  if(2 !== container.querySelectorAll(':enabled').length) sortDetached.push(':enabled', ':disabled');
                  documentElement.appendChild(container).disabled = true;
                  if(2 !== container.querySelectorAll(':disabled').length) sortDetached.push(':enabled', ':disabled');
                  container.querySelectorAll('*,:x');
                  sortDetached.push(',.*:');
                });
                sortDetached = sortDetached.length && new RegExp(sortDetached.join('|'));
                arr = arr.length && new RegExp(arr.join('|'));

                support.matchesSelector = rNative.test(
                sortDetached = documentElement.matches ||
                    documentElement.webkitMatchesSelector ||
                    documentElement.mozMatchesSelector ||
                    documentElement.oMatchesSelector ||
                    documentElement.msMatchesSelector);
               if (support.matchesSelector) {
                  isAttached(function(container) {
                        support.disconnectedMatch = sortDetached.call(container, '*');
                        sortDetached.call(container, '[s!=\'\']:x');
                        arrPush.push('!=', pseudos);
                  });
               }

                sortDetached = rNative.test(documentElement.compareDocumentPosition),

                has = sortDetached || rNative.test(documentElement.contains) ?
                    function(a, b) {
                       var node = 9 === a.nodeType ? a.documentElement : a;
                    var nodeParent = b && b.parentNode;
                        return a === nodeParent || !!(nodeParent && 1 === nodeParent.nodeType &&
                            (node.contains ? node.contains(nodeParent) : a.compareDocumentPosition &&
                                16 & a.compareDocumentPosition(nodeParent)));
                   } : function(a, b) {
                        if(b) {
                            while(b = b.parentNode) if(b === a) return true;
                        }
                        return false;
                    };

                sortOrder = sortDetached ?
                    function(a, b) {
                         if (a === b) return matches = !0, 0;
                        var res = !a.compareDocumentPosition - !b.compareDocumentPosition;
                         return res ||
                             (1 & (res =
                                (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                a.compareDocumentPosition(b) :
                                1) || !support.sortDetached &&
                             b.compareDocumentPosition(a) === res ?
                             a == documentElement || a.ownerDocument == document && has(document, a) ? -1 :
                             b == documentElement || b.ownerDocument == document && has(document, b) ? 1 :
                             sortDetached ? arrIndexOf(sortDetached, a) - arrIndexOf(sortDetached, b) : 0 :
                           4 & res ? -1 : 1);

                    } :
                    function(a, b) {
                        if(a === b) return matches = !0, 0;
                       var i, n = 0, pA = a.parentNode, pB = b.parentNode, ancestorsA = [a], ancestorsB = [b];
                    if (!pA || !pB) {
                          return a == documentElement ? -1 : b == documentElement ? 1 : pA ? -1 : pB ? 1 : sortDetached ? arrIndexOf(sortDetached, a) - arrIndexOf(sortDetached, b) : 0;
                    }
                        if (pA === pB) {
                            return sortDetached(a,b);
                        }
                    i = a;
                     while(i = i.parentNode) ancestorsA.unshift(i);
                    i = b;
                    while(i = i.parentNode) ancestorsB.unshift(i);

                     while (ancestorsA[n] === ancestorsB[n]) n++;
                    return n ? sortDetached(ancestorsA[n], ancestorsB[n]) :
                    ancestorsA[n] == document ? -1 : ancestorsB[n] == document ? 1 : 0;
                };