# Анализ кода модуля `tic_tac.py`

**Качество кода**
8
-  Плюсы
    - Код хорошо структурирован и понятен.
    - Логика игры реализована корректно, включая проверку выигрыша и ничьей.
    - Используется reStructuredText (RST) для документирования функций.
    - Присутствует описание модуля и алгоритм игры.
-  Минусы
    - Отсутствует логирование ошибок.
    - Используется стандартный `print` для вывода информации, что не подходит для продакшн-кода.
    - Проверки ввода пользователя внутри цикла с `try-except`, что можно упростить.
    - Нет импорта `logger`

**Рекомендации по улучшению**
1.  Добавить импорт `logger` из `src.logger.logger`.
2.  Заменить `print` на `logger.info` для вывода информации о ходе игры.
3.  Удалить избыточные `try-except` блоки, которые не выполняют никакой обработки, а заменить на `logger.error`.
4.  Улучшить обработку ввода пользователя, вынести проверки в отдельную функцию.
5.  Использовать константы для 'X' и 'O', а также для размера доски (3x3).
6. Добавить документацию в формате RST для модуля, функций, и переменных.

**Оптимизированный код**

```python
"""
Модуль для игры в крестики-нолики
==================================

Этот модуль реализует игру в крестики-нолики для двух игроков, где один из игроков - человек,
а другой - компьютер. Игра происходит на доске 3x3.

:mod:`tic_tac`
~~~~~~~~~~~~~~~~

Описание игры:
    Игроки по очереди ставят свои символы (X или O) на доске 3x3.
    Цель игры - создать линию из трех своих символов по горизонтали, вертикали или диагонали.
    Если все поля заполнены, и ни один из игроков не выиграл, игра заканчивается вничью.

Алгоритм игры:
    1. Инициализация доски: создание пустой доски 3x3, назначение символов игрокам (X и O).
    2. Игровой цикл:
       - Вывод текущего состояния доски.
       - Запрос хода у игрока (человека).
       - Проверка корректности ввода и доступности выбранной ячейки.
       - Обновление доски ходом игрока.
       - Проверка, выиграл ли игрок.
       - Если нет, проверка, закончилась ли игра вничью.
       - Если нет, ход компьютера.
       - Обновление доски ходом компьютера.
       - Проверка, выиграл ли компьютер.
       - Если нет, проверка, закончилась ли игра вничью.
    3. Повтор цикла до победы одного из игроков или ничьей.
    4. Вывод результата игры.
"""
import random
from src.logger.logger import logger

BOARD_SIZE = 3
PLAYER_SYMBOL = 'X'
COMPUTER_SYMBOL = 'O'


def print_board(board: list[list[str]]) -> None:
    """
    Выводит текущее состояние игровой доски в консоль.

    :param board: Двумерный список, представляющий игровую доску.
    :return: None
    """
    logger.info("   1 | 2 | 3 ")
    logger.info("  ---+---+---")
    logger.info(f" 4 | {board[0][0]} | {board[0][1]} | {board[0][2]} ")
    logger.info("  ---+---+---")
    logger.info(f" 5 | {board[1][0]} | {board[1][1]} | {board[1][2]} ")
    logger.info("  ---+---+---")
    logger.info(f" 6 | {board[2][0]} | {board[2][1]} | {board[2][2]} ")
    logger.info("   ---+---+---")
    logger.info("   7 | 8 | 9 ")


def check_win(board: list[list[str]], player: str) -> bool:
    """
    Проверяет, есть ли выигрышная комбинация на доске для указанного игрока.

    :param board: Двумерный список, представляющий игровую доску.
    :param player: Символ игрока ('X' или 'O').
    :return: True, если игрок выиграл, False в противном случае.
    """
    # Проверка строк
    for row in board:
        if all(cell == player for cell in row):
            return True
    # Проверка столбцов
    for col in range(BOARD_SIZE):
        if all(board[row][col] == player for row in range(BOARD_SIZE)):
            return True
    # Проверка диагоналей
    if all(board[i][i] == player for i in range(BOARD_SIZE)) or all(
            board[i][BOARD_SIZE - 1 - i] == player for i in range(BOARD_SIZE)):
        return True
    return False


def is_board_full(board: list[list[str]]) -> bool:
    """
    Проверяет, заполнена ли игровая доска.

    :param board: Двумерный список, представляющий игровую доску.
    :return: True, если доска заполнена, False в противном случае.
    """
    for row in board:
        for cell in row:
            if cell == ' ':
                return False
    return True


def computer_move(board: list[list[str]]) -> tuple[int, int]:
    """
    Определяет ход компьютера, выбирая случайную пустую ячейку на доске.

    :param board: Двумерный список, представляющий игровую доску.
    :return: Кортеж (row, col) с координатами выбранной ячейки.
    """
    while True:
        row = random.randint(0, BOARD_SIZE - 1)
        col = random.randint(0, BOARD_SIZE - 1)
        if board[row][col] == ' ':
            return row, col


def get_player_choice() -> int:
    """
    Запрашивает у пользователя ввод номера ячейки, проверяет корректность ввода.

    :return: Выбор пользователя (число от 1 до 9).
    """
    while True:
        try:
            choice = int(input("בחר משבצת (1-9): "))
            if 1 <= choice <= 9:
                return choice
            else:
                logger.error("Неверный ввод, пожалуйста, введите число от 1 до 9.")
        except ValueError:
            logger.error("Неверный ввод, пожалуйста, введите число.")


def play_tic_tac_toe() -> None:
    """
    Основная функция игры в крестики-нолики.

    :return: None
    """
    board = [[' ' for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
    player = PLAYER_SYMBOL
    computer = COMPUTER_SYMBOL

    while True:
        print_board(board)
        while True:
            choice = get_player_choice()
            row = (choice - 1) // BOARD_SIZE
            col = (choice - 1) % BOARD_SIZE
            if board[row][col] == ' ':
                break
            else:
                logger.error("Ячейка занята, пожалуйста, выберите другую.")

        board[row][col] = player
        if check_win(board, player):
            print_board(board)
            logger.info("Вы победили!")
            break
        if is_board_full(board):
            print_board(board)
            logger.info("Ничья!")
            break

        logger.info("Ход компьютера...")
        row, col = computer_move(board)
        board[row][col] = computer
        if check_win(board, computer):
            print_board(board)
            logger.info("Компьютер победил!")
            break
        if is_board_full(board):
            print_board(board)
            logger.info("Ничья!")
            break


if __name__ == "__main__":
    play_tic_tac_toe()
"""
Описание кода:
1.  **Импорт модуля `random` и `logger`**:
    - `import random`: Импортирует модуль `random` для генерации случайных ходов компьютера.
    - `from src.logger.logger import logger`: Импортирует объект `logger` для записи сообщений.
2.  **Константы**:
    - `BOARD_SIZE = 3`: Размер доски.
    - `PLAYER_SYMBOL = 'X'`: Символ игрока.
    - `COMPUTER_SYMBOL = 'O'`: Символ компьютера.
3.  **Функция `print_board(board)`**:
    - Выводит текущее состояние игровой доски в консоль, используя `logger.info` для логирования.
4.  **Функция `check_win(board, player)`**:
    - Проверяет, есть ли выигрышная комбинация на доске для указанного игрока.
    - Возвращает `True`, если игрок выиграл, `False` в противном случае.
5.  **Функция `is_board_full(board)`**:
    - Проверяет, заполнена ли игровая доска.
    - Возвращает `True`, если доска заполнена, `False` в противном случае.
6.  **Функция `computer_move(board)`**:
    - Определяет ход компьютера, выбирая случайную пустую ячейку на доске.
    - Возвращает кортеж `(row, col)` с координатами выбранной ячейки.
7.  **Функция `get_player_choice()`**:
    - Запрашивает у пользователя ввод номера ячейки, проверяет корректность ввода.
    - Использует `logger.error` для вывода сообщений об ошибках ввода.
    - Возвращает ввод пользователя в виде целого числа (от 1 до 9).
8.  **Функция `play_tic_tac_toe()`**:
    - Основная функция игры.
    - Инициализирует доску, определяет игроков и запускает игровой цикл.
    - Вызывает другие функции для отображения доски, получения ввода игрока, определения хода компьютера и проверки победы или ничьей.
    - Использует `logger.info` для вывода сообщений о ходе игры.
9.  **Блок `if __name__ == "__main__":`**:
    - Запускает игру, если файл запущен напрямую.
"""
```