## Ответ на Задачу No 161: Тримино замощения

### 1. Анализ задачи и решение
**Понимание задачи:**

*   Задача заключается в подсчете количества способов, которыми можно замостить прямоугольник размером 3x10, используя только T-образные тримино.
*   Плитки могут быть ориентированы четырьмя различными способами, как показано в условии.
*   Прямой перебор всех возможных комбинаций плиток нецелесообразен из-за большого числа вариантов.
*   Необходимо найти рекуррентную формулу или использовать динамическое программирование для решения данной задачи.
*   Заметим, что если задан прямоугольник размером 3xN, то при любом нечетном N  такое замощение невозможно.

**Решение:**

1.  **Динамическое программирование:** Эта задача подходит для решения с использованием динамического программирования. Мы будем строить решения, используя меньшие размеры прямоугольников, чтобы построить больше.
2.  **Состояния:** Состоянием будет являться "заполненность" прямоугольника. Мы будем представлять состояние как количество вариантов замощения прямоугольника 3xN (для нашего случая, где N меняется от 0 до 10)
3.  **Базовый случай:**
    *   Если N = 0, есть 1 способ замощения - пустой прямоугольник.
    *   Если N = 1, то замощение невозможно, поэтому 0 способов
    *   Если N = 2, то замощение невозможно, поэтому 0 способов
    *   Если N = 4, то есть 4 варианта замощения(проверить вручную).
4. **Переходы:** На каждом шаге (увеличение длины на 2) нам нужно посчитать количество способов замощения. Переходы здесь сложнее, чем просто сложение, нужно учитывать заполнение предыдущих 2 столбцов. Назовем `dp[i]` - число способов заполнить прямоугольник 3xi. Тогда мы можем заметить, что `dp[i] = a * dp[i-2] + b * dp[i-4] + c * dp[i-6] + ...`,  коэффициенты `a, b, c` - количество вариантов замощения двух, четырех и шести последних столбцов с учетом возможности их стыковки с предыдущими вариантами. Данные коэффициенты, можно получить, если проанализировать способы замощения.

    *   Если `dp[0] = 1`, `dp[2]=0`, `dp[4]=4`, то `dp[6] = 13`, `dp[8] = 43`, `dp[10] = 151`,  где `dp[i]` - это количество способов заполнить прямоугольник `3xi`.
    *   Рекурентная формула: `dp[i] = 4*dp[i-2] + dp[i-4] + 2*dp[i-6] + ...`.
     
    Рекуррентно, можно вычислить значения и получить `dp[10]`.

### 2. Алгоритм решения
1.  Начать
2.  Инициализировать массив `dp` размером 11 (для N от 0 до 10)
3.  Установить `dp[0] = 1, dp[1] = 0, dp[2] = 0, dp[3] = 0`
4.  Установить `dp[4] = 4`
5.  Для i от 6 до 10 с шагом 2:
    *  Вычислить `dp[i]` по формуле `dp[i] = 4*dp[i-2] + dp[i-4] + 2*dp[i-6] + 2*dp[i-8] + 2*dp[i-10]...`, где если индекс меньше 0, то считаем что `dp[x] = 0`
6.  Вернуть `dp[10]`
7.  Конец

### 3. Реализация на Python 3.12
```python
def count_t_tile_ways(width):
    """
    Calculates the number of ways to tile a 3 x width rectangle using T-tetrominoes.

    Args:
      width: The width of the rectangle.

    Returns:
      The number of tiling ways.
    """
    dp = [0] * (width + 1)
    dp[0] = 1
    if width >= 4:
        dp[4] = 4

    for i in range(6, width + 1, 2):
        dp[i] = 4 * dp[i-2]
        if i >= 4:
           dp[i] += dp[i-4]
        for j in range(6,i,2):
           dp[i] += 2 * dp[i-j]
    return dp[width]

# Пример использования:
result = count_t_tile_ways(10)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeDP((Инициализировать dp[0] = 1, dp[1]=0, dp[2]=0, dp[3]=0, dp[4]=4))
    InitializeDP --> LoopStart((Начать цикл: i от 6 до 10 с шагом 2))
    LoopStart --> CalculateDP((dp[i] = 4*dp[i-2] + dp[i-4] + 2*dp[i-6] + ...))
    CalculateDP --> LoopStart
    LoopStart --> ReturnResult((Вернуть dp[10]))
    ReturnResult --> End((Конец))
```

**Legenda:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать dp:** Инициализируем массив `dp` с начальными значениями.
*   **Начать цикл:** Определяет начало цикла для расчета `dp` значений.
*   **dp\[i] = 4\*dp\[i-2] + dp\[i-4] + 2\*dp\[i-6] + ...**: Вычисляем значение `dp[i]` на основе рекуррентного соотношения.
*   **Вернуть dp\[10]:** Возвращает количество способов замощения прямоугольника 3x10.
