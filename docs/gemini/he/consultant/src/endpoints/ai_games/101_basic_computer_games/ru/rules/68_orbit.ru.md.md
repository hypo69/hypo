# Анализ кода модуля `68_orbit.ru.md`

**Качество кода**

-   **Соответствие требованиям к формату кода (1-10):**
    -   **Преимущества:**
        -   Документ содержит подробное описание игры ORBIT, включая правила, пошаговую инструкцию, пример работы, возможные ограничения и рекомендации по реализации.
        -   Описаны основные этапы игры, включая инициализацию, ход игрока, захват секторов, проверку условий завершения и завершение игры.
        -   Приведен пример работы программы с начала до конца.
        -   Рекомендованы улучшения и варианты реализации.
    -   **Недостатки:**
        -   Код не представлен в формате, позволяющем его непосредственное выполнение. Это скорее текстовое описание игры и ее логики.
        -   Отсутствует фактический код на Python, поэтому невозможно оценить его качество в соответствии с требованиями (использование reStructuredText, j_loads, логирование ошибок и т.д.)
        -   Не используются форматирование кода, как, например, `` `python` `` для блоков кода.
        -   Нет описания модуля в формате reStructuredText, нет docstring для функций, переменных и классов, так как кода на Python нет.

**Рекомендации по улучшению**

1.  **Добавить код на Python:**
    -   Необходимо предоставить код на Python, реализующий описанную игру.
    -   Код должен включать классы, функции и переменные, необходимые для работы игры.
2.  **Использовать reStructuredText (RST):**
    -   Для docstring и комментариев функций, классов и переменных использовать RST формат.
3.  **Использовать `j_loads` или `j_loads_ns`:**
    -   Если в коде потребуется чтение JSON-файлов, использовать `j_loads` или `j_loads_ns` из `src.utils.jjson` вместо стандартного `json.load`.
4.  **Логирование ошибок:**
    -   Для обработки ошибок использовать `logger.error` из `src.logger.logger`, избегая чрезмерного использования блоков `try-except`.
5.  **Форматирование кода:**
    -   Код должен быть оформлен в блоках с подсветкой синтаксиса (например, ```python ... ```).
6.  **Документирование:**
    -   Добавить описание модуля, функций, методов и переменных в формате RST.
7.  **Комментарии к коду:**
     -   Вставить комментарии после `#` для объяснения кода построчно.

**Улучшенный код**

```python
"""
Модуль, реализующий игру ORBIT (Орбитальная игра).
=========================================================================================

Этот модуль содержит логику для настольной игры ORBIT, в которой игроки захватывают секторы на орбите планеты.
Игроки поочередно выбирают свободные секторы, пока один из них не захватит большинство секторов или не будет достигнуто максимальное количество ходов.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    game = OrbitGame()
    game.play_game()
"""
from typing import List
from src.logger.logger import logger  # Импорт модуля для логирования ошибок
import random  # Импорт модуля для случайных чисел


class OrbitGame:
    """
    Класс для управления игрой ORBIT.

    :ivar int ORBIT_SIZE: Размер орбиты (количество секторов).
    :ivar int MAX_TURNS: Максимальное количество ходов в игре.
    :ivar list orbit: Состояние орбиты, хранящее игроков, владеющих секторами.
    :ivar int current_player: Текущий игрок, делающий ход.
    :ivar int turns_played: Количество ходов, сделанных в игре.
    :ivar dict player_scores: Словарь, хранящий счет каждого игрока.
    """
    ORBIT_SIZE = 12
    MAX_TURNS = 20

    def __init__(self):
        """
        Инициализация игры. Создает орбиту, сбрасывает счет, устанавливает первого игрока.
        """
        self.orbit: List[int] = [0] * self.ORBIT_SIZE  # 0 - свободно, 1 - игрок 1, 2 - игрок 2
        self.current_player: int = 1 # Устанавливаем первого игрока
        self.turns_played: int = 0 # Устанавливаем кол-во ходов
        self.player_scores: dict = {1: 0, 2: 0} # Устанавливаем счет игроков

    def display_welcome_message(self) -> None:
         """
         Выводит приветственное сообщение и правила игры.
         """
         print("Добро пожаловать в ORBIT!")
         print("Ваша задача — захватить как можно больше орбитальных секторов вокруг планеты.")
         print("Игра продолжается до тех пор, пока один из игроков не захватит большинство секторов или не будет достигнуто максимальное количество ходов.")
         print("Удачи!")

    def display_orbit(self) -> None:
        """
        Отображает текущее состояние орбиты.
        """
        print("Текущее состояние орбиты:")
        for i, sector in enumerate(self.orbit):
            if sector == 0:
                print(f"Сектор {i + 1}: Свободен")
            else:
                print(f"Сектор {i + 1}: Игрок {sector}")

    def display_scores(self) -> None:
       """
       Отображает текущие счета игроков.
       """
       print("Текущий счет:")
       for player, score in self.player_scores.items():
           print(f"Игрок {player}: {score} секторов")

    def get_player_move(self) -> int:
      """
      Запрашивает ввод пользователя (номер сектора) и проверяет его корректность.
      :return: Номер выбранного сектора.
      """
      while True:
            try:
              sector = int(input(f"Игрок {self.current_player}, ваш ход. Введите номер сектора, который хотите захватить (от 1 до {self.ORBIT_SIZE}):\n> "))
              if 1 <= sector <= self.ORBIT_SIZE:
                return sector - 1  # Вернем индекс от 0 до 11
              else:
                print("Неверный номер сектора. Попробуйте снова.")
            except ValueError:
              print("Неверный ввод. Введите целое число.")

    def make_move(self, sector_index: int) -> bool:
        """
        Выполняет ход игрока.
        :param int sector_index: Индекс сектора, который хочет захватить игрок.
        :return: bool: True, если ход выполнен успешно, False, если сектор занят.
        """
        if self.orbit[sector_index] == 0:  # Проверяем, что сектор свободен
            self.orbit[sector_index] = self.current_player # Захватываем сектор
            self.player_scores[self.current_player] += 1 # Увеличиваем счет игрока
            print(f"Сектор {sector_index + 1} захвачен Игроком {self.current_player}.")
            return True # Возвращаем true если ход выполнен успешно
        else:
            print("Сектор уже захвачен. Попробуйте снова.")
            return False # Возвращаем false если сектор занят

    def switch_player(self) -> None:
         """
         Переключает текущего игрока.
         """
         self.current_player = 3 - self.current_player # Переключаем игрока (1 <-> 2)

    def check_game_over(self) -> bool:
      """
      Проверяет условия завершения игры: достигнуто ли большинство секторов или максимальное кол-во ходов.
      :return: bool: True, если игра окончена, False, если игра продолжается.
      """
      if self.player_scores[1] > self.ORBIT_SIZE // 2 or self.player_scores[2] > self.ORBIT_SIZE // 2:
         return True # Возвращаем true если один из игроков захватил большинство секторов
      if self.turns_played >= self.MAX_TURNS:
          return True # Возвращаем true если максимальное кол-во ходов достигнуто
      return False # Возвращаем false если игра продолжается

    def display_winner(self) -> None:
      """
      Определяет и отображает победителя игры.
      """
      if self.player_scores[1] > self.player_scores[2]:
        print(f"Игра окончена! Победил Игрок 1 с {self.player_scores[1]} захваченными секторами.")
      elif self.player_scores[2] > self.player_scores[1]:
        print(f"Игра окончена! Победил Игрок 2 с {self.player_scores[2]} захваченными секторами.")
      else:
        print(f"Игра окончена! Ничья. У обоих игроков по {self.player_scores[1]} захваченных секторов.")

    def play_again(self) -> bool:
       """
       Предлагает сыграть еще раз и возвращает выбор пользователя.
       :return: bool: True, если пользователь хочет сыграть еще раз, False, если нет.
       """
       while True:
          play_again = input("Хотите сыграть снова? (да/нет)\n> ").lower()
          if play_again == "да":
             return True  # Возвращаем True, если хотят играть еще раз
          elif play_again == "нет":
             return False # Возвращаем False, если не хотят играть
          else:
             print("Неверный ввод. Введите 'да' или 'нет'.")

    def play_game(self) -> None:
        """
        Основной игровой цикл.
        """
        self.display_welcome_message() # Выводим приветственное сообщение
        while True:
            self.turns_played = 0 # Сбрасываем кол-во ходов
            self.orbit = [0] * self.ORBIT_SIZE # Обнуляем орбиту
            self.player_scores = {1: 0, 2: 0}  # Сбрасываем очки
            self.current_player = 1  # Начинает первый игрок
            while not self.check_game_over(): # Играем, пока не будет конец игры
                self.display_orbit() # Отображаем текущую орбиту
                self.display_scores() # Отображаем текущий счет
                sector_index = self.get_player_move() # Получаем ход игрока
                if self.make_move(sector_index): # Если ход прошел успешно
                    self.turns_played += 1  # Увеличиваем счетчик ходов
                    self.switch_player() # Передаем ход другому игроку
            self.display_winner() # Выводим победителя
            if not self.play_again(): # Запрашиваем, хотят ли играть еще
                print("Спасибо за игру!")
                break # Выходим из игрового цикла

if __name__ == '__main__':
    try:
      game = OrbitGame()
      game.play_game()  # Запуск игры
    except Exception as e:
        logger.error("Произошла ошибка во время игры.", exc_info=e) # Логируем возникшую ошибку

```