# Модуль `Gemini.py`

## Обзор

Модуль `Gemini.py` предназначен для взаимодействия с моделью Google Gemini. Он предоставляет асинхронный генератор для обработки текстовых запросов и изображений, а также функциональность для аутентификации и обновления cookies. Модуль включает в себя классы и функции для отправки запросов к Gemini API, обработки ответов и управления cookies.

## Подробнее

Этот модуль является частью проекта `hypotez` и обеспечивает интеграцию с Google Gemini. Он использует асинхронные запросы для взаимодействия с API, что позволяет эффективно обрабатывать большие объемы данных и обеспечивать неблокирующий ввод-вывод. Модуль также включает в себя механизмы для автоматического обновления cookies, что необходимо для поддержания сессии с Gemini API.

## Классы

### `Gemini`

**Описание**: Класс `Gemini` предоставляет функциональность для взаимодействия с моделью Google Gemini.

**Принцип работы**:
Класс использует асинхронные генераторы для отправки запросов к Gemini API и обработки ответов. Он также управляет аутентификацией и обновлением cookies.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает базовую функциональность для асинхронных генераторов.
- `ProviderModelMixin`: Предоставляет методы для работы с моделями провайдера.

**Атрибуты**:
- `label` (str): Метка провайдера, в данном случае "Google Gemini".
- `url` (str): URL для доступа к Gemini API.
- `needs_auth` (bool): Указывает, требуется ли аутентификация для использования провайдера.
- `working` (bool): Указывает, работает ли провайдер в данный момент.
- `use_nodriver` (bool): Указывает, следует ли использовать `nodriver` для аутентификации.
- `default_model` (str): Модель по умолчанию.
- `default_image_model` (str): Модель для обработки изображений по умолчанию.
- `default_vision_model` (str): Модель для обработки визуальных данных по умолчанию.
- `image_models` (list): Список поддерживаемых моделей для обработки изображений.
- `models` (list): Список поддерживаемых моделей.
- `model_aliases` (dict): Псевдонимы моделей.
- `synthesize_content_type` (str): Тип контента для синтеза речи.
- `_cookies` (Cookies): Cookies для аутентификации.
- `_snlm0e` (str): Значение SNlM0e, необходимое для аутентификации.
- `_sid` (str): Значение SID, необходимое для аутентификации.
- `auto_refresh` (bool): Указывает, следует ли автоматически обновлять cookies.
- `refresh_interval` (int): Интервал обновления cookies в секундах.
- `rotate_tasks` (dict): Словарь задач для ротации cookies.

**Методы**:
- `nodriver_login`: Асинхронный метод для аутентификации с использованием `nodriver`.
- `start_auto_refresh`: Асинхронный метод для запуска задачи автоматического обновления cookies.
- `create_async_generator`: Асинхронный метод для создания асинхронного генератора для обработки запросов.
- `synthesize`: Асинхронный метод для синтеза речи.
- `build_request`: Метод для создания запроса к Gemini API.
- `upload_images`: Асинхронный метод для загрузки изображений.
- `fetch_snlm0e`: Асинхронный метод для получения значения SNlM0e.

### `Conversation`

**Описание**: Класс `Conversation` представляет собой структуру данных для хранения информации о разговоре с Gemini API.

**Принцип работы**:
Класс используется для хранения идентификаторов разговора, ответа и выбора, а также модели, используемой в разговоре.

**Наследует**:
- `JsonConversation`: Базовый класс для представления разговора в формате JSON.

**Атрибуты**:
- `conversation_id` (str): Идентификатор разговора.
- `response_id` (str): Идентификатор ответа.
- `choice_id` (str): Идентификатор выбора.
- `model` (str): Модель, используемая в разговоре.

#### `__init__`
```python
    def __init__(self,
        conversation_id: str,
        response_id: str,
        choice_id: str,
        model: str
    ) -> None:
        """Инициализирует объект Conversation.

        Args:
            conversation_id (str): Идентификатор разговора.
            response_id (str): Идентификатор ответа.
            choice_id (str): Идентификатор выбора.
            model (str): Модель, используемая в разговоре.

        Returns:
            None
        """
```

## Функции

### `nodriver_login`

```python
    @classmethod
    async def nodriver_login(cls, proxy: str = None) -> AsyncIterator[str]:
        """Аутентифицируется в Gemini API с использованием `nodriver`.

        Args:
            proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.

        Yields:
            AsyncIterator[str]: Асинхронный итератор строк, представляющих процесс входа в систему.

        Raises:
            ImportError: Если модуль `nodriver` не установлен.

        Как работает функция:
        1. Проверяет, установлен ли модуль `nodriver`. Если нет, то пропускает вход в систему через `nodriver` и завершает работу.
        2. Получает экземпляр браузера и функцию остановки браузера с помощью `get_nodriver`.
        3. Пытается получить URL для входа из переменной окружения `G4F_LOGIN_URL` и передаёт его через yield.
        4. Переходит на страницу `f"{cls.url}/app"` с помощью браузера.
        5. Выбирает элемент `div.ql-editor.textarea` на странице.
        6. Получает cookies с помощью `nodriver.cdp.network.get_cookies`.
        7. Закрывает страницу.
        8. Сохраняет полученные cookies в атрибуте `cls._cookies`.
        9. В блоке `finally` останавливает браузер.

        ASCII flowchart:

        Проверка наличия nodriver --> Получение экземпляра браузера --> Переход на страницу приложения --> Получение cookies --> Сохранение cookies --> Остановка браузера

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `start_auto_refresh`

```python
    @classmethod
    async def start_auto_refresh(cls, proxy: str = None) -> None:
        """Запускает фоновую задачу для автоматического обновления cookies.

        Args:
            proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.

        Raises:
            Exception: Если не удается обновить cookies.

        Как работает функция:
        1. Запускает бесконечный цикл для обновления cookies.
        2. Пытается обновить cookies с помощью функции `rotate_1psidts`.
        3. В случае ошибки логирует сообщение об ошибке и отменяет фоновую задачу обновления cookies.
        4. Если обновление cookies прошло успешно, обновляет значение `__Secure-1PSIDTS` в атрибуте `cls._cookies`.
        5. Засыпает на интервал `cls.refresh_interval` секунд.

        ASCII flowchart:

        Запуск цикла --> Обновление cookies --> Обработка ошибок --> Обновление значения __Secure-1PSIDTS --> Засыпание

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        proxy: str = None,
        cookies: Cookies = None,
        connector: BaseConnector = None,
        media: MediaListType = None,
        return_conversation: bool = False,
        conversation: Conversation = None,
        language: str = "en",
        **kwargs
    ) -> AsyncResult:
        """Создает асинхронный генератор для взаимодействия с Gemini API.

        Args:
            model (str): Модель для использования.
            messages (Messages): Список сообщений для отправки.
            proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.
            cookies (Cookies, optional): Cookies для аутентификации. По умолчанию `None`.
            connector (BaseConnector, optional): Коннектор для использования. По умолчанию `None`.
            media (MediaListType, optional): Список медиафайлов для отправки. По умолчанию `None`.
            return_conversation (bool, optional): Указывает, следует ли возвращать информацию о разговоре. По умолчанию `False`.
            conversation (Conversation, optional): Объект разговора. По умолчанию `None`.
            language (str, optional): Язык для использования. По умолчанию "en".
            **kwargs: Дополнительные аргументы.

        Yields:
            AsyncResult: Асинхронный результат, представляющий собой ответ от Gemini API.

        Raises:
            MissingAuthError: Если отсутствует или недействительный cookie "__Secure-1PSID".
            RuntimeError: Если не удается получить значение SNlM0e.

        Как работает функция:
        1. Устанавливает cookies из аргумента `cookies` или получает их из `cls._cookies` или `get_cookies`.
        2. Проверяет, совпадает ли модель разговора с текущей моделью. Если нет, то обнуляет разговор.
        3. Форматирует запрос из сообщений или получает последнее сообщение пользователя из разговора.
        4. Создает сессию клиента с заголовками и коннектором.
        5. Если значение `cls._snlm0e` отсутствует, пытается получить его с помощью `cls.fetch_snlm0e`.
        6. Если `cls._snlm0e` по-прежнему отсутствует, пытается войти в систему с помощью `cls.nodriver_login`.
        7. Если cookies отсутствуют или не содержат "__Secure-1PSID", выбрасывает исключение `MissingAuthError`.
        8. Если значение `cls._snlm0e` по-прежнему отсутствует, выбрасывает исключение `RuntimeError`.
        9. Запускает задачу автоматического обновления cookies, если она еще не запущена.
        10. Загружает изображения с помощью `cls.upload_images`.
        11. Отправляет запрос к Gemini API с использованием `ClientSession`.
        12. Обрабатывает ответ от Gemini API и извлекает информацию о разговоре, рассуждениях, контенте и изображениях.
        13. Возвращает асинхронный результат, представляющий собой ответ от Gemini API.

        ASCII flowchart:

        Установка cookies --> Проверка модели разговора --> Форматирование запроса --> Создание сессии клиента --> Получение SNlM0e --> Вход в систему (если необходимо) --> Запуск задачи обновления cookies --> Загрузка изображений --> Отправка запроса к Gemini API --> Обработка ответа --> Возврат результата

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `synthesize`

```python
    @classmethod
    async def synthesize(cls, params: dict, proxy: str = None) -> AsyncIterator[bytes]:
        """Синтезирует речь на основе заданного текста.

        Args:
            params (dict): Параметры для синтеза речи, включая текст.
            proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.

        Yields:
            AsyncIterator[bytes]: Асинхронный итератор байтов, представляющих собой аудиоданные.

        Raises:
            ValueError: Если отсутствует параметр "text".

        Как работает функция:
        1. Проверяет наличие параметра "text" в аргументе `params`.
        2. Создает сессию клиента с cookies, заголовками и коннектором.
        3. Если значение `cls._snlm0e` отсутствует, пытается получить его с помощью `cls.fetch_snlm0e`.
        4. Формирует данные для запроса к API синтеза речи.
        5. Отправляет POST-запрос к API синтеза речи.
        6. Обрабатывает ответ от API и извлекает аудиоданные в формате base64.
        7. Декодирует аудиоданные из base64 и возвращает их в виде асинхронного итератора байтов.

        ASCII flowchart:

        Проверка наличия текста --> Создание сессии клиента --> Получение SNlM0e --> Формирование данных запроса --> Отправка POST-запроса --> Обработка ответа --> Декодирование base64 --> Возврат аудиоданных

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `build_request`

```python
    def build_request(
        prompt: str,
        language: str,
        conversation: Conversation = None,
        uploads: list[list[str, str]] = None,
        tools: list[list[str]] = []
    ) -> list:
        """Строит запрос к Gemini API.

        Args:
            prompt (str): Текст запроса.
            language (str): Язык запроса.
            conversation (Conversation, optional): Объект разговора. По умолчанию `None`.
            uploads (list[list[str, str]], optional): Список загруженных изображений. По умолчанию `None`.
            tools (list[list[str]], optional): Список инструментов для использования. По умолчанию [].

        Returns:
            list: Сформированный запрос в виде списка.

        Как работает функция:
        1. Формирует список изображений из аргумента `uploads`.
        2. Создает структуру запроса, включающую текст запроса, язык, информацию о разговоре, изображения и инструменты.
        3. Возвращает сформированный запрос в виде списка.

        ASCII flowchart:

        Формирование списка изображений --> Создание структуры запроса --> Возврат запроса

        Примеры:
            Примеры работы не требуются, так как функция в основном формирует структуру данных для запроса к API.
        """
```

### `upload_images`

```python
    async def upload_images(connector: BaseConnector, media: MediaListType) -> list:
        """Загружает изображения на сервер Gemini API.

        Args:
            connector (BaseConnector): Коннектор для использования.
            media (MediaListType): Список медиафайлов для загрузки.

        Returns:
            list: Список URL загруженных изображений.

        Как работает функция:
        1. Определяет асинхронную функцию `upload_image` для загрузки одного изображения.
        2. Функция `upload_image` создает сессию клиента с заголовками и коннектором.
        3. Преобразует изображение в байты.
        4. Отправляет OPTIONS-запрос для получения URL загрузки.
        5. Отправляет POST-запрос с заголовками для начала загрузки.
        6. Отправляет POST-запрос с заголовками и данными изображения для завершения загрузки.
        7. Возвращает URL загруженного изображения.
        8. Использует `asyncio.gather` для параллельной загрузки всех изображений из списка `media`.

        ASCII flowchart:

        Определение upload_image --> Создание сессии клиента --> Преобразование изображения в байты --> Отправка OPTIONS-запроса --> Отправка POST-запроса (начало) --> Отправка POST-запроса (завершение) --> Возврат URL --> Параллельная загрузка изображений

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `fetch_snlm0e`

```python
    @classmethod
    async def fetch_snlm0e(cls, session: ClientSession, cookies: Cookies):
        """Получает значение SNlM0e из ответа Gemini API.

        Args:
            session (ClientSession): Сессия клиента для выполнения запроса.
            cookies (Cookies): Cookies для аутентификации.

        Как работает функция:
        1. Отправляет GET-запрос к Gemini API с cookies.
        2. Извлекает текст ответа.
        3. Ищет значение SNlM0e в тексте ответа с помощью регулярного выражения.
        4. Если значение SNlM0e найдено, сохраняет его в атрибуте `cls._snlm0e`.
        5. Ищет значение sid  в тексте ответа с помощью регулярного выражения.
        6. Если значение sid найдено, сохраняет его в атрибуте `cls._sid`.

        ASCII flowchart:

        Отправка GET-запроса --> Извлечение текста ответа --> Поиск SNlM0e --> Сохранение SNlM0e

        Примеры:
            Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
        """
```

### `iter_filter_base64`

```python
async def iter_filter_base64(chunks: AsyncIterator[bytes]) -> AsyncIterator[bytes]:
    """Фильтрует чанки байтов, извлекая данные base64.

    Args:
        chunks (AsyncIterator[bytes]): Асинхронный итератор чанков байтов.

    Yields:
        AsyncIterator[bytes]: Асинхронный итератор отфильтрованных чанков байтов.

    Raises:
        ValueError: Если ответ не содержит ожидаемые данные.

    Как работает функция:
    1. Определяет переменные `search_for` и `end_with` для поиска начала и конца данных base64.
    2. Итерируется по чанкам байтов.
    3. Если `is_started` равно `True`, проверяет, содержит ли чанк `end_with`. Если да, то извлекает данные до `end_with` и завершает итерацию.
    4. Если `search_for` содержится в чанке, устанавливает `is_started` в `True` и извлекает данные после `search_for`.
    5. Если ни одно из условий не выполнено, выбрасывает исключение `ValueError`.

    ASCII flowchart:

    Инициализация переменных --> Итерация по чанкам --> Проверка наличия end_with --> Извлечение данных до end_with --> Проверка наличия search_for --> Извлечение данных после search_for --> Выброс исключения (если необходимо)

    Примеры:
        Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
    """
```

### `iter_base64_decode`

```python
async def iter_base64_decode(chunks: AsyncIterator[bytes]) -> AsyncIterator[bytes]:
    """Декодирует чанки байтов из base64.

    Args:
        chunks (AsyncIterator[bytes]): Асинхронный итератор чанков байтов.

    Yields:
        AsyncIterator[bytes]: Асинхронный итератор декодированных чанков байтов.

    Как работает функция:
    1. Инициализирует буфер и переменную `rest` для хранения остатка данных.
    2. Итерируется по чанкам байтов.
    3. Объединяет буфер с текущим чанком.
    4. Вычисляет остаток от деления длины чанка на 4.
    5. Обновляет буфер остатком данных.
    6. Декодирует данные base64 и возвращает их.
    7. Если после завершения итерации в буфере остались данные, декодирует их и возвращает.

    ASCII flowchart:

    Инициализация переменных --> Итерация по чанкам --> Объединение буфера с чанком --> Вычисление остатка --> Обновление буфера --> Декодирование base64 --> Декодирование остатка (если необходимо)

    Примеры:
        Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
    """
```

### `rotate_1psidts`

```python
async def rotate_1psidts(url, cookies: dict, proxy: str | None = None) -> str:
    """Обновляет cookie __Secure-1PSIDTS.

    Args:
        url: URL для запроса.
        cookies (dict): Словарь cookies.
        proxy (str | None): Прокси-сервер для использования. По умолчанию `None`.

    Returns:
        str: Новое значение cookie __Secure-1PSIDTS.

    Raises:
        MissingAuthError: Если cookies недействительны.

    Как работает функция:
    1. Формирует путь к файлу кэша cookies.
    2. Проверяет, был ли файл кэша изменен в течение последней минуты, чтобы избежать 429 ошибок.
    3. Если файл кэша не существует или был изменен более минуты назад, отправляет POST-запрос для обновления cookies.
    4. Если статус ответа 401, выбрасывает исключение `MissingAuthError`.
    5. Обновляет cookies в словаре `cookies`.
    6. Записывает новые cookies в файл кэша.
    7. Возвращает новое значение cookie `__Secure-1PSIDTS`.

    ASCII flowchart:

    Формирование пути к файлу кэша --> Проверка файла кэша --> Отправка POST-запроса --> Обновление cookies --> Запись cookies в файл кэша --> Возврат нового значения __Secure-1PSIDTS

    Примеры:
        Примеры работы не требуются, так как функция в основном взаимодействует с API и внутренними структурами данных.
    """