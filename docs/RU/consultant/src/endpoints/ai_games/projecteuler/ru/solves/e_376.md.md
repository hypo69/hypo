# Анализ кода модуля e_376.md

**Качество кода**
8
-  Плюсы
    - Код хорошо структурирован и разбит на функции, что облегчает понимание и отладку.
    - Используется бинарное возведение в степень для эффективного вычисления степеней по модулю.
    - Применяется предвычисление факториалов и обратных факториалов, что ускоряет вычисление биномиальных коэффициентов.
    - Присутствует описание алгоритма и блок-схема, что способствует пониманию логики решения.
-  Минусы
    - Отсутствует обработка ошибок.
    - Нет документации в формате reStructuredText (RST) для функций и модуля.
    - Не используется `logger` для логирования.
    - Не все переменные и функции имеют описательные имена.

**Рекомендации по улучшению**

1.  Добавить документацию в формате reStructuredText (RST) для модуля и всех функций.
2.  Использовать `logger` для обработки ошибок и логирования.
3.  Изменить имена переменных и функций на более описательные.
4.  Улучшить обработку ошибок, добавив проверки на корректность входных данных.
5.  Удалить избыточные комментарии, которые повторяют код.

**Оптимизированный код**

```python
"""
Модуль для решения задачи Project Euler #376: Непересекающиеся пути
=================================================================

Этот модуль вычисляет количество непересекающихся путей из (0, 0) в (n, n)
внутри сетки S(n), где 0 <= x, y <= n.
Решение использует биномиальные коэффициенты и модульную арифметику.

Пример использования
--------------------

.. code-block:: python

    python e_376.py

"""
from src.logger.logger import logger  # Import logger
# from src.utils.jjson import j_loads, j_loads_ns #TODO добавить если потребуется


MOD = 1000000007  # Модуль для вычислений


def power(base: int, exp: int, mod: int) -> int:
    """
    Вычисляет base^exp % mod, используя бинарное возведение в степень.

    :param base: Основание.
    :param exp: Показатель степени.
    :param mod: Модуль.
    :return: Результат вычисления base^exp % mod.
    """
    res = 1
    base %= mod
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2
    return res


def mod_inverse(n: int, mod: int) -> int:
    """
    Вычисляет обратное по модулю n для числа n по модулю mod.

    :param n: Число, для которого нужно найти обратное по модулю.
    :param mod: Модуль.
    :return: Обратное по модулю n.
    """
    return power(n, mod - 2, mod)


def binom(n: int, k: int, fact: list, inv_fact: list, mod: int) -> int:
    """
    Вычисляет биномиальный коэффициент C(n, k) % mod, используя предвычисленные факториалы и обратные факториалы.

    :param n: Общее количество элементов.
    :param k: Количество выбираемых элементов.
    :param fact: Список предвычисленных факториалов.
    :param inv_fact: Список предвычисленных обратных факториалов.
    :param mod: Модуль.
    :return: Биномиальный коэффициент C(n, k) % mod.
    """
    if k < 0 or k > n:
        return 0
    num = fact[n]
    den = (inv_fact[k] * inv_fact[n - k]) % mod
    return (num * den) % mod


def calculate_f(n: int, fact: list, inv_fact: list, mod: int) -> int:
    """
    Вычисляет F(n) = C(2n, n) - C(2n, n-1) % mod.

    :param n: Параметр функции F(n).
    :param fact: Список предвычисленных факториалов.
    :param inv_fact: Список предвычисленных обратных факториалов.
    :param mod: Модуль.
    :return: Значение F(n) % mod.
    """
    c1 = binom(2 * n, n, fact, inv_fact, mod)
    c2 = binom(2 * n, n - 1, fact, inv_fact, mod)
    return (c1 - c2 + mod) % mod


def main():
    """
    Основная функция для решения задачи.
    """
    n = 10**6
    max_val = 2 * n
    fact = [1] * (max_val + 1)
    inv_fact = [1] * (max_val + 1)

    #  Предвычисление факториалов
    for i in range(1, max_val + 1):
        fact[i] = (fact[i - 1] * i) % MOD

    #  Предвычисление обратных факториалов
    try:
        inv_fact[max_val] = mod_inverse(fact[max_val], MOD)
    except Exception as e:
        logger.error('Ошибка при вычислении обратного по модулю для факториала', exc_info=True)
        return

    for i in range(max_val - 1, 0, -1):
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

    result = calculate_f(n, fact, inv_fact, MOD)
    print(result)


if __name__ == "__main__":
    main()
```