# Модуль для конвертации HTML в Markdown

## Обзор

Модуль `html2text` предназначен для преобразования HTML-документов в Markdown-форматированный текст. Он включает функции для обработки различных HTML-тегов, атрибутов и стилей, чтобы создать читабельное представление текста в формате Markdown.

## Подробнее

Этот модуль предоставляет класс `_html2text`, который наследуется от `HTMLParser.HTMLParser` и выполняет основную работу по парсингу HTML и преобразованию его в Markdown. Он также включает различные вспомогательные функции для обработки HTML-сущностей, стилей и списков.

## Функции

### `has_key(x, y)`

**Назначение**: Проверяет, содержит ли словарь `x` ключ `y`.

**Параметры**:
- `x` (dict): Словарь, в котором производится поиск.
- `y` (str): Ключ, который нужно найти в словаре.

**Возвращает**:
- `bool`: `True`, если словарь содержит ключ, иначе `False`.

**Как работает функция**:
1. Проверяет, есть ли у объекта `x` метод `has_key`.
2. Если метод `has_key` существует, вызывает его для проверки наличия ключа `y`.
3. Если метод `has_key` не существует, использует оператор `in` для проверки наличия ключа `y` в словаре `x`.

**Примеры**:

```python
>>> has_key({'a': 1, 'b': 2}, 'a')
True
>>> has_key({'a': 1, 'b': 2}, 'c')
False
```

### `name2cp(k)`

**Назначение**: Преобразует имя HTML-сущности в её кодовую точку Unicode.

**Параметры**:
- `k` (str): Имя HTML-сущности.

**Возвращает**:
- `int`: Кодовая точка Unicode для данной сущности.

**Вызывает исключения**:
- `KeyError`: Если сущность не найдена в `htmlentitydefs.entitydefs`.

**Как работает функция**:
1. Проверяет, является ли сущность `'apos'`. Если да, возвращает кодовую точку для апострофа.
2. Проверяет, существует ли атрибут `name2codepoint` в модуле `htmlentitydefs`. Если да, возвращает соответствующую кодовую точку.
3. Если атрибут `name2codepoint` не существует, пытается получить значение сущности из `htmlentitydefs.entitydefs`.
4. Если значение начинается с `'&#'` и заканчивается `';'`, преобразует подстроку между этими символами в целое число и возвращает его.
5. В противном случае декодирует значение как latin-1 и возвращает кодовую точку первого символа.

ASCII flowchart:

```
A (Получено имя сущности k)
|
B (k == 'apos'?)
|
-- C (Да: возвращено ord("'"))
|
D (Нет: hasattr(htmlentitydefs, "name2codepoint")?)
|
-- E (Да: возвращено htmlentitydefs.name2codepoint[k])
|
F (Нет: k = htmlentitydefs.entitydefs[k])
|
G (k.startswith("&#") and k.endswith(";")?)
|
-- H (Да: возвращено int(k[2:-1]))
|
I (Нет: возвращено ord(codecs.latin_1_decode(k)[0]))
```

**Примеры**:

```python
>>> name2cp('copy')
169
>>> name2cp('eacute')
233
```

### `charref(name)`

**Назначение**: Преобразует числовую ссылку на символ в символ Unicode.

**Параметры**:
- `name` (str): Числовая ссылка на символ.

**Возвращает**:
- `str`: Символ Unicode, соответствующий числовой ссылке.

**Как работает функция**:
1. Проверяет, начинается ли `name` с `'x'` или `'X'`.
2. Если да, преобразует подстроку после `'x'` или `'X'` в целое число, используя основание 16.
3. Если нет, преобразует `name` в целое число, используя основание 10.
4. Если `UNICODE_SNOB` равно `False` и полученное число `c` есть в `unifiable_n.keys()`, возвращает соответствующее значение из `unifiable_n[c]`.
5. В противном случае пытается преобразовать число `c` в символ Unicode с помощью функции `chr()`.

ASCII flowchart:

```
A (Получена числовая ссылка name)
|
B (name[0] in ['x', 'X']?)
|
-- C (Да: c = int(name[1:], 16))
|
D (Нет: c = int(name))
|
E (not UNICODE_SNOB and c in unifiable_n.keys()?)
|
-- F (Да: возвращено unifiable_n[c])
|
G (Нет: try chr(c))
|
H (Возвращено chr(c))
```

**Примеры**:

```python
>>> charref('65')
'A'
>>> charref('x41')
'A'
```

### `entityref(c)`

**Назначение**: Преобразует ссылку на HTML-сущность в символ Unicode.

**Параметры**:
- `c` (str): Ссылка на HTML-сущность.

**Возвращает**:
- `str`: Символ Unicode, соответствующий ссылке на сущность.

**Как работает функция**:
1. Если `UNICODE_SNOB` равно `False` и `c` есть в `unifiable.keys()`, возвращает соответствующее значение из `unifiable[c]`.
2. В противном случае пытается получить кодовую точку для сущности `c` с помощью `name2cp(c)`.
3. Если `name2cp(c)` вызывает `KeyError`, возвращает исходную ссылку на сущность в формате `"&" + c + ";"`.
4. Если `name2cp(c)` успешно возвращает кодовую точку, преобразует её в символ Unicode с помощью `chr()`.

ASCII flowchart:

```
A (Получена ссылка на сущность c)
|
B (not UNICODE_SNOB and c in unifiable.keys()?)
|
-- C (Да: возвращено unifiable[c])
|
D (Нет: try name2cp(c))
|
E (KeyError?)
|
-- F (Да: возвращено "&" + c + ";")
|
G (Нет: try chr(name2cp(c)))
|
H (Возвращено chr(name2cp(c)))
```

**Примеры**:

```python
>>> entityref('copy')
'(C)'
>>> entityref('eacute')
'é'
```

### `replaceEntities(s)`

**Назначение**: Заменяет HTML-сущности в строке на соответствующие символы Unicode.

**Параметры**:
- `s` (re.Match): Объект соответствия регулярного выражения, содержащий HTML-сущность.

**Возвращает**:
- `str`: Символ Unicode, соответствующий HTML-сущности.

**Как работает функция**:
1. Извлекает HTML-сущность из объекта соответствия `s`.
2. Если сущность начинается с `'#'`, вызывает `charref()` для преобразования числовой ссылки в символ Unicode.
3. В противном случае вызывает `entityref()` для преобразования ссылки на сущность в символ Unicode.

ASCII flowchart:

```
A (Получен объект соответствия s)
|
B (Извлечена HTML-сущность из s)
|
C (s[0] == '#'? )
|
-- D (Да: возвращено charref(s[1:]))
|
E (Нет: возвращено entityref(s))
```

**Примеры**:

```python
>>> import re
>>> r_unescape = re.compile(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));")
>>> s = r_unescape.search('&eacute;')
>>> replaceEntities(s)
'é'
```

### `unescape(s)`

**Назначение**: Заменяет все HTML-сущности в строке на соответствующие символы Unicode.

**Параметры**:
- `s` (str): Строка, содержащая HTML-сущности.

**Возвращает**:
- `str`: Строка с замененными HTML-сущностями.

**Как работает функция**:
1. Использует регулярное выражение `r_unescape` для поиска всех HTML-сущностей в строке `s`.
2. Для каждой найденной сущности вызывает функцию `replaceEntities()` для её замены на соответствующий символ Unicode.

ASCII flowchart:

```
A (Получена строка s)
|
B (Использовано регулярное выражение r_unescape для поиска HTML-сущностей)
|
C (Для каждой найденной сущности вызвана replaceEntities())
|
D (Возвращена строка с замененными сущностями)
```

**Примеры**:

```python
>>> unescape('&eacute; &#169;')
'é ©'
```

### `onlywhite(line)`

**Назначение**: Проверяет, состоит ли строка только из пробельных символов.

**Параметры**:
- `line` (str): Строка для проверки.

**Возвращает**:
- `bool`: `True`, если строка состоит только из пробельных символов, иначе `False`.

**Как работает функция**:
1. Итерируется по каждому символу `c` в строке `line`.
2. Если символ `c` не является пробелом или двойным пробелом, возвращает `False`.
3. Если все символы в строке являются пробельными, возвращает `True`.

ASCII flowchart:

```
A (Получена строка line)
|
B (Итерация по каждому символу c в line)
|
C (c is not ' ' and c is not '  '?)
|
-- D (Да: возвращено c is ' ')
|
E (Нет: продолжение итерации)
|
F (Все символы проверены: возвращено True)
```

**Примеры**:

```python
>>> onlywhite('   ')
True
>>> onlywhite('  a ')
False
```

### `optwrap(text)`

**Назначение**: Оборачивает текст по заданной ширине `BODY_WIDTH`.

**Параметры**:
- `text` (str): Текст для оборачивания.

**Возвращает**:
- `str`: Обернутый текст.

**Как работает функция**:
1. Проверяет, задана ли ширина `BODY_WIDTH`. Если нет, возвращает исходный текст.
2. Разбивает текст на параграфы по символу новой строки `\n`.
3. Для каждого параграфа проверяет, начинается ли он с пробела, дефиса или звездочки.
4. Если параграф не начинается с этих символов, оборачивает его по ширине `BODY_WIDTH` с помощью функции `wrap()` из модуля `textwrap`.
5. Добавляет к результату обернутый параграф и две новые строки.
6. Если параграф начинается с пробела, дефиса или звездочки, добавляет его к результату как есть.
7. Обрабатывает пустые строки, добавляя одну или две новые строки в зависимости от контекста.

ASCII flowchart:

```
A (Получен текст text)
|
B (not BODY_WIDTH?)
|
-- C (Да: возвращено text)
|
D (Разбиение текста на параграфы)
|
E (Для каждого параграфа)
|
F (para[0] != ' ' and para[0] != '-' and para[0] != '*'?)
|
-- G (Да: Оборачивание параграфа по BODY_WIDTH)
|
H (Добавление обернутого параграфа и двух новых строк к результату)
|
I (Нет: Добавление параграфа как есть к результату)
|
J (Обработка пустых строк)
|
K (Возвращен обернутый текст)
```

**Примеры**:

```python
>>> BODY_WIDTH = 20
>>> optwrap('This is a long line that needs to be wrapped.')
'This is a long line\nthat needs to be\nwrapped.\n\n'
>>> BODY_WIDTH = 0
>>> optwrap('This is a long line that needs to be wrapped.')
'This is a long line that needs to be wrapped.'
```

### `hn(tag)`

**Назначение**: Определяет уровень заголовка HTML-тега.

**Параметры**:
- `tag` (str): HTML-тег.

**Возвращает**:
- `int`: Уровень заголовка (1-9), если тег является заголовком, иначе 0.

**Как работает функция**:
1. Проверяет, начинается ли тег с `'h'` и имеет ли длину 2.
2. Если да, пытается преобразовать второй символ тега в целое число.
3. Если преобразование успешно и число находится в диапазоне от 1 до 9, возвращает это число.
4. В противном случае возвращает 0.

ASCII flowchart:

```
A (Получен HTML-тег tag)
|
B (tag[0] == 'h' and len(tag) == 2?)
|
-- C (Да: try int(tag[1]))
|
D (ValueError?)
|
-- E (Да: возвращено 0)
|
F (Нет: n in range(1, 10)?)
|
-- G (Да: возвращено n)
|
H (Нет: возвращено 0)
|
I (Нет: возвращено 0)
```

**Примеры**:

```python
>>> hn('h1')
1
>>> hn('h6')
6
>>> hn('h10')
0
>>> hn('div')
0
```

### `dumb_property_dict(style)`

**Назначение**: Преобразует строку CSS-стилей в словарь атрибутов.

**Параметры**:
- `style` (str): Строка CSS-стилей.

**Возвращает**:
- `dict`: Словарь, где ключи - это атрибуты CSS, а значения - их значения.

**Как работает функция**:
1. Разделяет строку стилей на пары атрибут-значение, используя разделитель `';'`.
2. Для каждой пары разделяет атрибут и значение, используя разделитель `':'`.
3. Удаляет лишние пробелы в начале и конце атрибута и значения.
4. Создает словарь, используя атрибут в качестве ключа и значение в качестве значения.

ASCII flowchart:

```
A (Получена строка CSS-стилей style)
|
B (Разделение строки на пары атрибут-значение по ';')
|
C (Для каждой пары)
|
D (Разделение пары на атрибут и значение по ':')
|
E (Удаление лишних пробелов)
|
F (Создание словаря)
|
G (Возвращен словарь атрибутов)
```

**Примеры**:

```python
>>> dumb_property_dict('color: red; font-size: 12px;')
{'color': 'red', 'font-size': '12px'}
```

### `dumb_css_parser(data)`

**Назначение**: Преобразует CSS-данные в словарь селекторов и их атрибутов.

**Параметры**:
- `data` (str): Строка CSS-данных.

**Возвращает**:
- `dict`: Словарь, где ключи - это CSS-селекторы, а значения - словари атрибутов CSS.

**Как работает функция**:
1. Удаляет все `@import` предложения из CSS-данных.
2. Разделяет CSS-данные на элементы, используя разделители `'}'` и `'{'`.
3. Для каждого элемента создает пару селектор-атрибуты, где селектор - это часть до `'{'`, а атрибуты - это результат вызова `dumb_property_dict()` для части после `'{'`.
4. Создает словарь, используя селектор в качестве ключа и словарь атрибутов в качестве значения.

ASCII flowchart:

```
A (Получены CSS-данные data)
|
B (Удаление @import предложений)
|
C (Разделение данных на элементы по '}' и '{')
|
D (Для каждого элемента)
|
E (Создание пары селектор-атрибуты)
|
F (Вызов dumb_property_dict() для получения атрибутов)
|
G (Создание словаря)
|
H (Возвращен словарь селекторов и атрибутов)
```

**Примеры**:

```python
>>> dumb_css_parser('body { color: black; } .highlight { font-weight: bold; }')
{'body': {'color': 'black'}, '.highlight': {'font-weight': 'bold'}}
```

### `element_style(attrs, style_def, parent_style)`

**Назначение**: Определяет окончательный стиль элемента на основе атрибутов, определения стилей и стиля родительского элемента.

**Параметры**:
- `attrs` (dict): Атрибуты HTML-элемента.
- `style_def` (dict): Определения стилей CSS.
- `parent_style` (dict): Стиль родительского элемента.

**Возвращает**:
- `dict`: Словарь окончательных стилей элемента.

**Как работает функция**:
1. Создает копию стиля родительского элемента.
2. Если в атрибутах элемента есть класс (`'class'`), итерируется по каждому классу в атрибуте.
3. Для каждого класса получает соответствующие стили из `style_def` и обновляет стиль элемента.
4. Если в атрибутах элемента есть стиль (`'style'`), преобразует его в словарь с помощью `dumb_property_dict()` и обновляет стиль элемента.
5. Возвращает окончательный стиль элемента.

ASCII flowchart:

```
A (Получены атрибуты элемента attrs, определения стилей style_def, стиль родительского элемента parent_style)
|
B (Создание копии стиля родительского элемента)
|
C ('class' in attrs?)
|
-- D (Да: Итерация по каждому классу в attrs['class'])
|
E (Получение стилей класса из style_def)
|
F (Обновление стиля элемента)
|
G ('style' in attrs?)
|
-- H (Да: Преобразование стиля в словарь с помощью dumb_property_dict())
|
I (Обновление стиля элемента)
|
J (Возвращен окончательный стиль элемента)
```

**Примеры**:

```python
>>> attrs = {'class': 'highlight bold', 'style': 'color: red;'}
>>> style_def = {'.highlight': {'background-color': 'yellow'}, '.bold': {'font-weight': 'bold'}}
>>> parent_style = {'font-size': '12px'}
>>> element_style(attrs, style_def, parent_style)
{'font-size': '12px', 'background-color': 'yellow', 'font-weight': 'bold', 'color': 'red'}
```

### `google_list_style(style)`

**Назначение**: Определяет, является ли список упорядоченным или неупорядоченным, на основе CSS-стилей Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `str`: `'ul'`, если список неупорядоченный, и `'ol'`, если список упорядоченный.

**Как работает функция**:
1. Проверяет, есть ли атрибут `'list-style-type'` в словаре стилей.
2. Если атрибут существует, проверяет, является ли его значение одним из `['disc', 'circle', 'square', 'none']`.
3. Если значение атрибута является одним из указанных, возвращает `'ul'`, указывая на неупорядоченный список.
4. В противном случае возвращает `'ol'`, указывая на упорядоченный список.

ASCII flowchart:

```
A (Получен словарь CSS-стилей style)
|
B ('list-style-type' in style?)
|
-- C (Да: list_style = style['list-style-type'])
|
D (list_style in ['disc', 'circle', 'square', 'none']?)
|
-- E (Да: возвращено 'ul')
|
F (Нет: возвращено 'ol')
|
G (Нет: возвращено 'ol')
```

**Примеры**:

```python
>>> google_list_style({'list-style-type': 'disc'})
'ul'
>>> google_list_style({'list-style-type': 'decimal'})
'ol'
>>> google_list_style({})
'ol'
```

### `google_nest_count(style)`

**Назначение**: Вычисляет уровень вложенности списка Google Docs на основе CSS-стилей.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `int`: Уровень вложенности списка.

**Как работает функция**:
1. Проверяет, есть ли атрибут `'margin-left'` в словаре стилей.
2. Если атрибут существует, преобразует его значение в целое число, удалив `'px'` в конце, и делит на `GOOGLE_LIST_INDENT`.
3. Возвращает результат деления в качестве уровня вложенности.
4. Если атрибут `'margin-left'` не существует, возвращает 0.

ASCII flowchart:

```
A (Получен словарь CSS-стилей style)
|
B ('margin-left' in style?)
|
-- C (Да: Вычисление уровня вложенности)
|
D (Возвращен уровень вложенности)
|
E (Нет: возвращено 0)
```

**Примеры**:

```python
>>> GOOGLE_LIST_INDENT = 36
>>> google_nest_count({'margin-left': '72px'})
2.0
>>> google_nest_count({})
0
```

### `google_has_height(style)`

**Назначение**: Проверяет, определен ли атрибут `'height'` в CSS-стилях элемента Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `bool`: `True`, если атрибут `'height'` определен, иначе `False`.

**Как работает функция**:
1. Проверяет, есть ли атрибут `'height'` в словаре стилей.
2. Если атрибут существует, возвращает `True`.
3. В противном случае возвращает `False`.

ASCII flowchart:

```
A (Получен словарь CSS-стилей style)
|
B ('height' in style?)
|
-- C (Да: возвращено True)
|
D (Нет: возвращено False)
```

**Примеры**:

```python
>>> google_has_height({'height': '10px'})
True
>>> google_has_height({})
False
```

### `google_text_emphasis(style)`

**Назначение**: Определяет список модификаторов выделения текста на основе CSS-стилей Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `list`: Список модификаторов выделения текста.

**Как работает функция**:
1. Создает пустой список `emphasis`.
2. Проверяет, есть ли атрибут `'text-decoration'` в словаре стилей. Если да, добавляет его значение в список `emphasis`.
3. Проверяет, есть ли атрибут `'font-style'` в словаре стилей. Если да, добавляет его значение в список `emphasis`.
4. Проверяет, есть ли атрибут `'font-weight'` в словаре стилей. Если да, добавляет его значение в список `emphasis`.
5. Возвращает список `emphasis`.

ASCII flowchart:

```
A (Получен словарь CSS-стилей style)
|
B (Создание пустого списка emphasis)
|
C ('text-decoration' in style?)
|
-- D (Да: Добавление style['text-decoration'] в emphasis)
|
E ('font-style' in style?)
|
-- F (Да: Добавление style['font-style'] в emphasis)
|
G ('font-weight' in style?)
|
-- H (Да: Добавление style['font-weight'] в emphasis)
|
I (Возвращен список emphasis)
```

**Примеры**:

```python
>>> google_text_emphasis({'text-decoration': 'underline', 'font-weight': 'bold'})
['underline', 'bold']
>>> google_text_emphasis({})
[]
```

### `google_fixed_width_font(style)`

**Назначение**: Проверяет, определяет ли CSS текущего элемента шрифт фиксированной ширины.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `bool`: `True`, если шрифт фиксированной ширины определен, иначе `False`.

**Как работает функция**:
1. Получает значение атрибута `'font-family'` из словаря стилей.
2. Если значение равно `'Courier New'` или `'Consolas'`, возвращает `True`.
3. В противном случае возвращает `False`.

ASCII flowchart:

```
A (Получен словарь CSS-стилей style)
|
B (Получение значения атрибута 'font-family')
|
C (font_family == 'Courier New' or font_family == 'Consolas'?)
|
-- D (Да: возвращено True)
|
E (Нет: возвращено False)
```

**Примеры**:

```python
>>> google_fixed_width_font({'font-family': 'Courier New'})
True
>>> google_fixed_width_font({'font-family': 'Arial'})
False
```

### `list_numbering_start(attrs)`

**Назначение**: Извлекает начальный номер из атрибутов элемента списка.

**Параметры**:
- `attrs` (dict): Атрибуты HTML-элемента.

**Возвращает**:
- `int`: Начальный номер списка, если атрибут `'start'` присутствует, иначе 0.

**Как работает функция**:
1. Проверяет, есть ли атрибут `'start'` в словаре атрибутов.
2. Если атрибут существует, преобразует его значение в целое число и вычитает 1.
3. Возвращает полученное число.
4. Если атрибут `'start'` не существует, возвращает 0.

ASCII flowchart:

```
A (Получены атрибуты HTML-элемента attrs)
|
B ('start' in attrs?)
|
-- C (Да: Извлечение и преобразование значения атрибута 'start')
|
D (Возвращено int(attrs['start']) - 1)
|
E (Нет: возвращено 0)
```

**Примеры**:

```python
>>> list_numbering_start({'start': '5'})
4
>>> list_numbering_start({})
0
```

## Классы

### `_html2text`

**Описание**: Класс для преобразования HTML в Markdown.

**Наследует**:
- `HTMLParser.HTMLParser`

**Атрибуты**:
- `out` (function): Функция для вывода текста.
- `outtextlist` (list): Список для хранения выводимых символов.
- `outtext` (str): Строка для хранения выведенного текста.
- `quiet` (int): Флаг для подавления вывода.
- `p_p` (int): Количество символов новой строки для вывода перед следующим выводом.
- `outcount` (int): Счетчик выведенных символов.
- `start` (int): Флаг начала документа.
- `space` (int): Флаг для добавления пробела.
- `a` (list): Список ссылок.
- `astack` (list): Стек ссылок.
- `acount` (int): Счетчик ссылок.
- `list` (list): Список списков.
- `blockquote` (int): Уровень цитирования.
- `pre` (int): Флаг для тега `<pre>`.
- `startpre` (int): Флаг начала тега `<pre>`.
- `code` (bool): Флаг для тега `<code>`.
- `br_toggle` (str): Переключатель для тега `<br>`.
- `lastWasNL` (bool): Флаг, указывающий, был ли последний символ новой строкой.
- `lastWasList` (bool): Флаг, указывающий, был ли последний тег списком.
- `style` (int): Флаг для тега `<style>`.
- `style_def` (dict): Определения стилей CSS.
- `tag_stack` (list): Стек тегов.
- `emphasis` (int): Счетчик выделений текста.
- `drop_white_space` (int): Флаг для удаления пробелов.
- `inheader` (bool): Флаг, указывающий, находится ли парсер внутри заголовка.
- `abbr_title` (str | None): Текущее определение аббревиатуры.
- `abbr_data` (str | None): Последний внутренний HTML (для определяемой аббревиатуры).
- `abbr_list` (dict): Стек аббревиатур для записи позже.
- `baseurl` (str): Базовый URL.

**Методы**:
- `__init__(self, out=None, baseurl='')`: Конструктор класса.
- `feed(self, data)`: Обрабатывает HTML-данные.
- `outtextf(self, s)`: Добавляет текст в список вывода.
- `close(self)`: Завершает обработку HTML и возвращает Markdown.
- `handle_charref(self, c)`: Обрабатывает числовые ссылки на символы.
- `handle_entityref(self, c)`: Обрабатывает ссылки на HTML-сущности.
- `handle_starttag(self, tag, attrs)`: Обрабатывает начальные теги HTML.
- `handle_endtag(self, tag)`: Обрабатывает конечные теги HTML.
- `previousIndex(self, attrs)`: Возвращает индекс набора атрибутов в списке ссылок.
- `drop_last(self, nLetters)`: Удаляет последние символы из вывода.
- `handle_emphasis(self, start, tag_style, parent_style)`: Обрабатывает выделение текста.
- `handle_tag(self, tag, attrs, start)`: Обрабатывает теги HTML.
- `pbr(self)`: Добавляет один символ новой строки.
- `p(self)`: Добавляет два символа новой строки.
- `soft_br(self)`: Добавляет мягкий перенос строки.
- `o(self, data, puredata=0, force=0)`: Выводит данные.
- `handle_data(self, data)`: Обрабатывает данные HTML.
- `unknown_decl(self, data)`: Обрабатывает неизвестные декларации.

#### `__init__(self, out=None, baseurl='')`

```python
 def __init__(self, out=None, baseurl=''):
```

**Назначение**: Инициализирует объект класса `_html2text`.

**Параметры**:
- `out` (function, optional): Функция для вывода текста. По умолчанию `self.outtextf`.
- `baseurl` (str, optional): Базовый URL для ссылок. По умолчанию `''`.

**Как работает функция**:
1. Инициализирует базовый класс `HTMLParser.HTMLParser`.
2. Устанавливает функцию вывода `self.out` в зависимости от переданного аргумента `out`. Если `out` не передан, использует `self.outtextf`.
3. Инициализирует пустой список `self.outtextlist` для хранения выводимых символов.
4. Инициализирует пустую строку `self.outtext` для хранения выведенного текста.
5. Инициализирует различные флаги и счетчики для управления процессом преобразования HTML в Markdown.
6. Если включена опция `options.google_doc`, удаляет сущность `'nbsp'` из `unifiable_n` и заменяет её на `'&nbsp_place_holder;'` в `unifiable`.

ASCII flowchart:

```
A (Получены параметры out, baseurl)
|
B (Инициализация HTMLParser.HTMLParser)
|
C (Установка self.out)
|
D (Инициализация self.outtextlist)
|
E (Инициализация self.outtext)
|
F (Инициализация флагов и счетчиков)
|
G (options.google_doc?)
|
-- H (Да: Модификация unifiable_n и unifiable)
|
I (Конец)
```

**Примеры**:

```python
>>> h = _html2text()
>>> h = _html2text(out=print)
```

#### `feed(self, data)`

```python
    def feed(self, data):
```

**Назначение**: Обрабатывает HTML-данные.

**Параметры**:
- `data` (str): HTML-данные для обработки.

**Как работает функция**:
1. Заменяет все вхождения `</\' + \'script>` на `</ignore>` в данных.
2. Передает данные в базовый класс `HTMLParser.HTMLParser` для дальнейшей обработки.

ASCII flowchart:

```
A (Получены HTML-данные data)
|
B (Замена </\' + \'script> на </ignore>)
|
C (Вызов HTMLParser.HTMLParser.feed(data))
|
D (Конец)
```

**Примеры**:

```python
>>> h = _html2text()
>>> h.feed('<html><body><h1>Hello</h1></body></html>')
```

#### `outtextf(self, s)`

```python
    def outtextf(self, s):
```

**Назначение**: Добавляет текст в список вывода.

**Параметры**:
- `s` (str): Текст для добавления.

**Как работает функция**:
1. Добавляет текст `s` в список `self.outtextlist`.
2. Обновляет флаг `self.lastWasNL`, чтобы указать, заканчивается ли текст `s` символом новой строки.

ASCII flowchart:

```
A (Получен текст s)
|
B (Добавление s в self.outtextlist)
|
C (Обновление self.lastWasNL)
|
D (Конец)
```

**Примеры**:

```python
>>> h = _html2text()
>>> h.outtextf('Hello')
>>> h.outtextlist