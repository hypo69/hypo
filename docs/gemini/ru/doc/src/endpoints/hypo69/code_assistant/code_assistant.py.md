# Модуль для работы с ассистентом программиста

## Обзор

Модуль содержит класс `CodeAssistant`, который используется для взаимодействия с различными AI-моделями (например, Google Gemini и OpenAI) и выполнения задач обработки кода, таких как обучение модели машинного обучения кодовой базе, составление документации к проекту, примеров кода и тестов.

## Подробней

Модуль предназначен для автоматизации задач, связанных с анализом и улучшением кодовой базы, используя возможности AI. Он читает файлы кода, отправляет код в AI-модели для обработки, а затем сохраняет результаты в директории `docs/gemini` в соответствии с заданной ролью. Это позволяет автоматизировать процесс создания документации, проверки кода и генерации тестов.

## Классы

### `Config`

**Описание**: Класс `Config` предназначен для хранения и управления конфигурационными параметрами, используемыми ассистентом программиста. Он загружает конфигурацию из файла `code_assistant.json`, расположенного в директории `src/endpoints/hypo69/code_assistant`, и предоставляет доступ к различным параметрам, таким как список ролей, языков, директорий для обработки, а также инструкций для кода и модели.

**Принцип работы**:
Класс использует `j_loads_ns` для загрузки конфигурации из JSON-файла и хранит параметры в виде атрибутов класса. Он также предоставляет методы для чтения инструкций из файлов, что позволяет обновлять инструкции "на лету".

**Атрибуты**:

- `base_path` (Path): Базовый путь к директории `src/endpoints/hypo69/code_assistant`.
- `config` (SimpleNamespace): Конфигурация, загруженная из `code_assistant.json`.
- `roles_list` (list): Список ролей, определенных в конфигурации.
- `languages_list` (list): Список языков, определенных в конфигурации.
- `role` (str): Текущая роль, по умолчанию `'doc_writer_md'`.
- `lang` (str): Текущий язык, по умолчанию `'ru'`.
- `process_dirs` (list[Path]): Список директорий для обработки.
- `exclude_dirs` (list[Path]): Список директорий, которые следует исключить из обработки.
- `exclude_files_patterns` (list[Path]): Список шаблонов файлов, которые следует исключить из обработки.
- `include_files_patterns` (list[Path]): Список шаблонов файлов, которые следует включить в обработку.
- `exclude_files` (list[Path]): Список файлов, которые следует исключить из обработки.
- `exclude_dirs` (list[Path]): Список директорий, которые следует исключить из обработки.
- `response_mime_type` (str): MIME-тип ответа, по умолчанию из конфигурации.
- `gemini` (SimpleNamespace): Конфигурация для модели Gemini, содержащая имя модели и ключ API.

**Методы**:

- `code_instruction`: Инструкция для кода, читаемая из файла `instruction_{Config.role}_{Config.lang}.md`.
- `system_instruction`: Инструкция для модели, читаемая из файла `CODE_RULES.{Config.lang}.MD`.

### `CodeAssistant`

**Описание**: Класс `CodeAssistant` предназначен для взаимодействия с AI-моделями, такими как Google Gemini и OpenAI, для выполнения задач обработки кода. Он инициализирует модели, отправляет файлы на обработку, получает ответы и сохраняет их.

**Принцип работы**:
Класс инициализируется с заданной ролью и языком, загружает конфигурацию моделей и инструкций, а затем использует эти параметры для обработки файлов. Он поддерживает отправку файлов в AI-модели, получение ответов и сохранение результатов в соответствии с заданной ролью.

**Аттрибуты**:

- `role` (str): Роль ассистента (например, `doc_writer_md`).
- `lang` (str): Язык, используемый ассистентом (например, `ru`).
- `gemini` (GoogleGenerativeAI): Экземпляр класса `GoogleGenerativeAI` для взаимодействия с моделью Gemini.
- `openai` (OpenAIModel): Экземпляр класса `OpenAIModel` для взаимодействия с моделью OpenAI.

**Методы**:

- `__init__`: Инициализирует экземпляр класса `CodeAssistant` с заданными параметрами.
- `_initialize_models`: Инициализирует модели AI на основе заданных параметров.
- `send_file`: Отправляет файл в модель AI для обработки.
- `process_files`: Компилирует, отправляет запрос и сохраняет результат обработки файлов.
- `_create_request`: Создает запрос для отправки в модель AI с учетом роли и языка.
- `_yield_files_content`: Генерирует пути файлов и их содержимое для обработки.
- `_save_response`: Сохраняет ответ модели AI в файл с добавлением суффикса, определяемого ролью.
- `_remove_outer_quotes`: Удаляет внешние кавычки в начале и в конце строки ответа модели.
- `run`: Запускает процесс обработки файлов.
- `_signal_handler`: Обрабатывает прерывание выполнения программы.

## Функции

### `_initialize_models`

```python
def _initialize_models(self, models_list: list, response_mime_type: Optional[str] = '', **kwards) -> bool:
    """
    Инициализация моделей на основе заданных параметров.

    Args:
        models_list (list[str]): Список моделей для инициализации.
        **kwards: Дополнительные аргументы для инициализации моделей.

    Returns:
        bool: Успешность инициализации моделей.

    Raises:
        Exception: Если произошла ошибка при инициализации моделей.
    """
```

**Назначение**: Инициализирует модели AI на основе заданных параметров, таких как имя модели, ключ API и дополнительные аргументы.

**Параметры**:

- `models_list` (list[str]): Список моделей для инициализации (например, `['gemini']`).
- `response_mime_type` (Optional[str], optional): MIME-тип ответа. По умолчанию `''`.
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Возвращает**:

- `bool`: `True`, если инициализация моделей прошла успешно, `False` в противном случае.

**Вызывает исключения**:

- `Exception`: Если произошла ошибка при инициализации моделей.

**Как работает функция**:

1. Проверяет, есть ли в списке моделей модель `gemini`.
2. Если модель `gemini` присутствует, пытается инициализировать модель `GoogleGenerativeAI` с использованием параметров из `kwards` и конфигурации `Config.gemini`.
3. Фильтрует `kwards` для удаления известных аргументов, чтобы избежать конфликтов при инициализации модели.
4. Логирует ошибки, если инициализация не удалась, и возвращает `False`.
5. В случае успеха возвращает `True`.

```
Инициализация Gemini
     ↓
Фильтрация kwards → Создание экземпляра GoogleGenerativeAI
     ↓
   Обработка исключений
     ↓
Возврат результата
```

**Примеры**:

```python
assistant = CodeAssistant()
models = ['gemini']
success = assistant._initialize_models(models_list=models)
print(f"Инициализация Gemini: {success}")  # Вывод: Инициализация Gemini: True (если успешно)
```

```python
assistant = CodeAssistant()
models = ['gemini']
kwargs = {'model_name': 'gemini-1.5-pro-latest'}
success = assistant._initialize_models(models_list=models, **kwargs)
print(f"Инициализация Gemini: {success}")  # Вывод: Инициализация Gemini: True (если успешно)
```

### `send_file`

```python
def send_file(self, file_path: Path) -> Optional[str | None]:
    """
    Отправка файла в модель.

    Args:
        file_path (Path): Абсолютный путь к файлу, который нужно отправить.
        file_name (Optional[str]): Имя файла для отправки. Если не указано и 'src' отсутствует, используется имя файла без изменений.

    Returns:
        Optional[str | None]: URL файла, если успешно отправлен, иначе None.
    """
```

**Назначение**: Отправляет файл в модель AI для обработки и возвращает URL файла, если отправка прошла успешно.

**Параметры**:

- `file_path` (Path): Абсолютный путь к файлу, который нужно отправить.

**Возвращает**:

- `Optional[str | None]`: URL файла, если успешно отправлен, иначе `None`.

**Вызывает исключения**:

- `Exception`: Если произошла ошибка при отправке файла.

**Как работает функция**:

1. Пытается отправить файл в модель `gemini` с помощью метода `upload_file`.
2. Если ответ получен, проверяет, содержит ли он атрибут `url` и возвращает его значение.
3. Логирует ошибки, если отправка не удалась, и возвращает `None`.

```
Отправка файла в модель
     ↓
   Обработка ответа
     ↓
   Обработка исключений
     ↓
Возврат результата
```

**Примеры**:

```python
assistant = CodeAssistant()
file_path = Path('example.txt')
try:
    with open(file_path, 'w') as f:
        f.write('Example text')
    file_url = assistant.send_file(file_path)
    print(f"URL файла: {file_url}")  # Вывод: URL файла: <URL> (если успешно)
except Exception as ex:
    print(f"Ошибка при отправке файла: {ex}")
```

### `process_files`

```python
async def process_files(
    self, process_dirs: Optional[str | Path | list[str | Path]] = None, start_from_file: Optional[int] = 1
) -> bool:
    """компиляция, отправка запроса и сохранение результата."""
```

**Назначение**: Компилирует, отправляет запросы и сохраняет результаты обработки файлов в указанных директориях.

**Параметры**:

- `process_dirs` (Optional[str | Path | list[str | Path]], optional): Список директорий для обработки. По умолчанию `None`.
- `start_from_file` (Optional[int], optional): Номер файла, с которого начинается обработка. По умолчанию `1`.

**Возвращает**:

- `bool`: Всегда возвращает `True` (судя по коду).

**Как работает функция**:

1. Устанавливает директории для обработки из аргумента `process_dirs` или из конфигурации `Config.process_dirs`.
2. Итерируется по каждой директории для обработки.
3. Проверяет существование и тип директории. Если директория не существует или не является директорией, переходит к следующей.
4. Итерируется по содержимому файлов в директории с использованием метода `_yield_files_content`.
5. Пропускает файлы до номера `start_from_file`.
6. Создает запрос с использованием метода `_create_request` и отправляет его в модель `gemini` с использованием `ask_async`.
7. Удаляет внешние кавычки из ответа с использованием метода `_remove_outer_quotes`.
8. Сохраняет ответ с использованием метода `_save_response`.
9. В случае ошибок логирует их и переходит к следующему файлу.
10. Делает паузу в 20 секунд перед обработкой следующего файла.

```
Установка директорий
     ↓
Итерация по директориям
     ↓
  Проверка директории
     ↓
Итерация по содержимому файлов
     ↓
Пропуск файлов до start_from_file
     ↓
Создание и отправка запроса
     ↓
   Удаление кавычек из ответа
     ↓
Сохранение ответа
     ↓
Обработка ошибок
     ↓
Пауза
```

**Примеры**:

```python
assistant = CodeAssistant()
process_dirs = ['src']
asyncio.run(assistant.process_files(process_dirs=process_dirs))
```

```python
assistant = CodeAssistant()
process_dirs = ['src']
start_from_file = 5
asyncio.run(assistant.process_files(process_dirs=process_dirs, start_from_file=start_from_file))
```

### `_create_request`

```python
def _create_request(self, file_path: str, content: str) -> str:
    """Создание запроса с учетом роли и языка."""
```

**Назначение**: Создает запрос для отправки в модель AI с учетом роли и языка.

**Параметры**:

- `file_path` (str): Путь к файлу.
- `content` (str): Содержимое файла.

**Возвращает**:

- `str`: Строковое представление запроса.

**Вызывает исключения**:

- `Exception`: Если произошла ошибка при составлении запроса.

**Как работает функция**:

1. Создает словарь `content_request`, содержащий роль, язык, путь к файлу и содержимое файла.
2. Преобразует словарь в строку и возвращает ее.
3. В случае ошибки логирует ее и возвращает содержимое файла.

```
Создание словаря запроса
     ↓
Преобразование в строку
     ↓
Обработка исключений
     ↓
Возврат результата
```

**Примеры**:

```python
assistant = CodeAssistant()
file_path = 'example.py'
content = 'def hello(): print("Hello")'
request = assistant._create_request(file_path, content)
print(f"Запрос: {request}")
```

### `_yield_files_content`

```python
def _yield_files_content(
    self,
    process_directory: str | Path,
) -> Iterator[tuple[Path, str]]:
    """
    Генерирует пути файлов и их содержимое по указанным шаблонам.

    Args:
        process_directory (Path | str): Абсолютный путь к стартовой директории

    Returns:
        bool: Iterator
    """
```

**Назначение**: Генерирует пути файлов и их содержимое для обработки, учитывая шаблоны включения и исключения.

**Параметры**:

- `process_directory` (str | Path): Абсолютный путь к стартовой директории.

**Возвращает**:

- `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортежи, содержащие путь к файлу и его содержимое.

**Как работает функция**:

1. Преобразует `process_directory` в объект `Path`.
2. Компилирует шаблоны исключаемых файлов из `Config.exclude_files_patterns`.
3. Итерируется по всем файлам в директории с использованием `rglob('*')`.
4. Проверяет соответствие шаблонам включения из `Config.include_files_patterns`.
5. Проверяет, не находится ли файл в исключенных директориях из `Config.exclude_dirs`.
6. Проверяет, не соответствует ли имя файла шаблонам исключения из `exclude_files_patterns`.
7. Проверяет, не находится ли имя файла в списке исключенных файлов из `Config.exclude_files`.
8. Читает содержимое файла и возвращает его вместе с путем к файлу.
9. В случае ошибки логирует ее и возвращает `None, None`.

```
Преобразование process_directory в Path
     ↓
Компиляция шаблонов исключения
     ↓
  Итерация по файлам
     ↓
Проверка шаблонов включения
     ↓
Проверка исключенных директорий
     ↓
Проверка шаблонов исключения файлов
     ↓
Проверка исключенных файлов
     ↓
Чтение содержимого файла
     ↓
Обработка ошибок
     ↓
Возврат результата
```

**Примеры**:

```python
assistant = CodeAssistant()
process_directory = 'src'
for file_path, content in assistant._yield_files_content(process_directory):
    if file_path and content:
        print(f"Файл: {file_path}, Содержимое: {content[:50]}...")
    else:
        print("Ошибка при чтении файла")
```

### `_save_response`

```python
async def _save_response(self, file_path: Path, response: str, model_name: str) -> bool:
    """
    Сохранение ответа модели в файл с добавлением суффикса.

    Метод сохраняет ответ модели в файл, добавляя к текущему расширению файла
    дополнительный суффикс, определяемый ролью.

    Args:
        file_path (Path): Исходный путь к файлу, в который будет записан ответ.
        response (str): Ответ модели, который необходимо сохранить.
        model_name (str): Имя модели, использованной для генерации ответа.

    Raises:
        OSError: Если не удаётся создать директорию или записать в файл.
    """
```

**Назначение**: Сохраняет ответ модели AI в файл с добавлением суффикса, зависящего от роли.

**Параметры**:

- `file_path` (Path): Исходный путь к файлу, в который будет записан ответ.
- `response` (str): Ответ модели, который необходимо сохранить.
- `model_name` (str): Имя модели, использованной для генерации ответа.

**Возвращает**:

- `bool`: `True`, если сохранение прошло успешно, `False` в противном случае.

**Вызывает исключения**:

- `OSError`: Если не удаётся создать директорию или записать в файл.

**Как работает функция**:

1. Преобразует `file_path` в объект `Path`.
2. Получает шаблон директории вывода из `Config.output_directory_patterns` в зависимости от роли.
3. Формирует целевую директорию, заменяя `<model>` и `<lang>` в шаблоне.
4. Заменяет часть пути файла на целевую директорию.
5. Определяет суффикс для добавления к имени файла в зависимости от роли.
6. Создает директорию, если она не существует.
7. Записывает ответ модели в файл с добавленным суффиксом.
8. Логирует успешное или неуспешное сохранение.

```
Преобразование file_path в Path
     ↓
Получение шаблона директории вывода
     ↓
Формирование целевой директории
     ↓
Замена части пути файла
     ↓
Определение суффикса
     ↓
Создание директории (если необходимо)
     ↓
Запись ответа в файл
     ↓
Логирование результата
```

**Примеры**:

```python
assistant = CodeAssistant()
file_path = Path('src/example.py')
response = 'def hello(): print("Hello")'
model_name = 'gemini'
success = asyncio.run(assistant._save_response(file_path, response, model_name))
print(f"Сохранение: {success}")
```

### `_remove_outer_quotes`

```python
def _remove_outer_quotes(self, response: str) -> str:
    """
    Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

    Args:
        response (str): Ответ модели, который необходимо обработать.

    Returns:
        str: Очищенный контент как строка.

    Example:
        >>> _remove_outer_quotes('```md some content ```')
        'some content'
        >>> _remove_outer_quotes('some content')
        'some content'
        >>> _remove_outer_quotes('```python def hello(): print("Hello") ```')
        '```python def hello(): print("Hello") ```'
    """
```

**Назначение**: Удаляет внешние кавычки в начале и в конце строки ответа модели.

**Параметры**:

- `response` (str): Ответ модели, который необходимо обработать.

**Возвращает**:

- `str`: Очищенный контент как строка.

**Как работает функция**:

1. Удаляет пробелы в начале и в конце строки.
2. Если строка начинается с `'```python'` или `'```mermaid'`, возвращает ее без изменений.
3. Загружает конфигурацию из `code_assistant.json`.
4. Итерируется по префиксам для удаления из конфигурации.
5. Если строка начинается с префикса, удаляет его и суффикс `'```'`, если он есть.
6. Возвращает очищенную строку или исходную строку, если условия не выполнены.

```
Удаление пробелов
     ↓
Проверка префиксов python/mermaid
     ↓
Загрузка конфигурации
     ↓
Итерация по префиксам
     ↓
  Удаление префикса и суффикса
     ↓
Возврат результата
```

**Примеры**:

```python
assistant = CodeAssistant()
response = '```md some content ```'
cleaned_response = assistant._remove_outer_quotes(response)
print(f"Очищенный ответ: {cleaned_response}")  # Вывод: Очищенный ответ: some content
```

```python
assistant = CodeAssistant()
response = 'some content'
cleaned_response = assistant._remove_outer_quotes(response)
print(f"Очищенный ответ: {cleaned_response}")  # Вывод: Очищенный ответ: some content
```

```python
assistant = CodeAssistant()
response = '```python def hello(): print("Hello") ```'
cleaned_response = assistant._remove_outer_quotes(response)
print(f"Очищенный ответ: {cleaned_response}")  # Вывод: Очищенный ответ: ```python def hello(): print("Hello") ```
```

### `run`

```python
def run(self, start_from_file: int = 1) -> None:
    """Запуск процесса обработки файлов."""
```

**Назначение**: Запускает процесс обработки файлов.

**Параметры**:

- `start_from_file` (int, optional): Номер файла, с которого начинается обработка. По умолчанию `1`.

**Как работает функция**:

1. Устанавливает обработчик сигнала `SIGINT` для прерывания выполнения программы.
2. Запускает асинхронную обработку файлов с использованием метода `process_files`.

```
Установка обработчика сигнала
     ↓
Запуск асинхронной обработки файлов
```

**Примеры**:

```python
assistant = CodeAssistant()
assistant.run()
```

```python
assistant = CodeAssistant()
assistant.run(start_from_file=5)
```

### `_signal_handler`

```python
def _signal_handler(self, signal, frame) -> None:
    """Обработка прерывания выполнения."""
```

**Назначение**: Обрабатывает прерывание выполнения программы (например, при нажатии Ctrl+C).

**Параметры**:

- `signal`: Сигнал прерывания.
- `frame`: Фрейм стека вызовов.

**Как работает функция**:

1. Логирует сообщение о прерывании процесса.
2. Завершает программу с кодом `0`.

```
Логирование сообщения о прерывании
     ↓
Завершение программы
```

**Примеры**:

```python
assistant = CodeAssistant()
# Эмулируем прерывание
assistant._signal_handler(signal.SIGINT, None)
```

### `parse_args`

```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
```

**Назначение**: Разбирает аргументы командной строки и возвращает их в виде словаря.

**Возвращает**:

- `dict`: Словарь, содержащий аргументы командной строки.

**Как работает функция**:

1. Создает объект `ArgumentParser` для разбора аргументов командной строки.
2. Добавляет аргументы `--role`, `--lang`, `--model`, `--start-dirs`, `--start-file-number`.
3. Разбирает аргументы с использованием `parser.parse_args()`.
4. Преобразует результат в словарь и возвращает его.

```
Создание ArgumentParser
     ↓
Добавление аргументов
     ↓
Разбор аргументов
     ↓
Преобразование в словарь
     ↓
Возврат результата
```

**Примеры**:

```python
import sys
sys.argv = ['script.py', '--role', 'doc_writer', '--lang', 'en', '--model', 'gemini', 'openai', '--start-dirs', 'src', 'tests', '--start-file-number', '5']
args = parse_args()
print(f"Аргументы: {args}")
```

### `main`

```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
```

**Назначение**: Запускает бесконечный цикл обработки файлов с учетом ролей и языков, указанных в конфигурации.

**Как работает функция**:

1. Запускает бесконечный цикл `while True`.
2. Итерируется по списку языков `Config.languages_list`.
3. Итерируется по списку ролей `Config.roles_list`.
4. Для каждой комбинации языка и роли создает экземпляр класса `CodeAssistant`.
5. Запускает обработку файлов с использованием метода `process_files`.

```
Бесконечный цикл
     ↓
Итерация по языкам
     ↓
  Итерация по ролям
     ↓
Создание экземпляра CodeAssistant
     ↓
Запуск обработки файлов
```

**Примеры**:

```python
# Для запуска функции main необходимо вызвать ее напрямую
# main()