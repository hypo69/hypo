# Модуль code_assistant

## Обзор

Модуль предназначен для обучения моделей машинного обучения на кодовой базе, создания документации к проекту, примеров кода и тестов. Он содержит класс `CodeAssistant`, который читает файлы кода, передает код в модели, модель обрабатывает код и возвращает его в класс. Класс сохраняет результат в директории `docs/gemini` в зависимости от роли.

## Подробнее

Этот модуль является ключевым компонентом в процессе автоматизации создания документации и обучения моделей машинного обучения на основе кодовой базы проекта. Класс `CodeAssistant` отвечает за взаимодействие с различными AI-моделями (в данном случае, Google Gemini), обработку файлов с кодом и сохранение результатов их анализа и обработки.

## Классы

### `Config`

**Описание**: Класс, предназначенный для хранения конфигурационных параметров, используемых модулем `CodeAssistant`.

**Как работает класс**:
Класс `Config` содержит статические параметры конфигурации, такие как пути к файлам, имена моделей, ключи API и системные инструкции. Он использует `j_loads_ns` для загрузки конфигурации из JSON-файла.

**Параметры**:
- `base_path` (Path): Базовый путь к директории `code_assistant`.
- `config` (SimpleNamespace): Конфигурация, загруженная из `code_assistant.json`.
- `role` (str): Роль по умолчанию - `'doc_writer_md'`.
- `lang` (str): Язык по умолчанию - `'ru'`.
- `system_instruction` (str): Системная инструкция (изначально пустая строка).
- `gemini` (SimpleNamespace): Конфигурация для модели Gemini, включающая имя модели и ключ API.

**Примеры**:
```python
config = Config()
print(config.role)  # Вывод: doc_writer_md
print(config.gemini.model_name)  # Вывод: значение из переменной окружения GEMINI_MODEL или config.gemini_model_name
```

### `CodeAssistant`

**Описание**: Класс для работы ассистента программиста с моделями ИИ.

**Как работает класс**:
Класс `CodeAssistant` инициализируется с заданной ролью, языком и списком моделей. Он содержит методы для чтения файлов, отправки кода в модель, получения ответа и сохранения результата. Класс использует модели Google Gemini и OpenAI для обработки кода.

**Методы**:
- `__init__`: Инициализация ассистента с заданными параметрами.
- `_initialize_models`: Инициализация моделей на основе заданных параметров.
- `code_instruction`: Чтение инструкции для кода.
- `translations`: Загрузка переводов для ролей и языков.
- `send_file`: Отправка файла в модель.
- `process_files`: Компиляция, отправка запроса и сохранение результата.
- `_create_request`: Создание запроса с учетом роли и языка.
- `_yield_files_content`: Генерация путей файлов и их содержимого по указанным шаблонам.
- `_save_response`: Сохранение ответа модели в файл с добавлением суффикса.
- `_remove_outer_quotes`: Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.
- `run`: Запуск процесса обработки файлов.
- `_signal_handler`: Обработка прерывания выполнения.

**Параметры**:
- `role` (str): Роль для выполнения задачи.
- `lang` (str): Язык выполнения.
- `base_path` (Path): Базовый путь к директории `code_assistant`.
- `config` (SimpleNamespace): Конфигурация, загруженная из `code_assistant.json`.
- `gemini_model` (GoogleGenerativeAI): Экземпляр модели Google Gemini.
- `openai_model` (OpenAIModel): Экземпляр модели OpenAI.

**Примеры**:
```python
assistant = CodeAssistant(role='code_checker', lang='ru', models_list=['gemini'])
```

## Функции

### `_initialize_models`

```python
def _initialize_models(self, models_list: list, **kwards) -> bool:
    """
    Инициализация моделей на основе заданных параметров.

    Args:
        models_list (list[str]): Список моделей для инициализации.
        **kwards: Дополнительные аргументы для инициализации моделей.

    Returns:
        bool: Успешность инициализации моделей.

    Raises:
        Exception: Если произошла ошибка при инициализации моделей.
    """
    ...
```

**Описание**: Инициализирует модели, указанные в списке `models_list`.

**Как работает функция**:
Функция проверяет, есть ли в списке модель `gemini`. Если есть, то она пытается инициализировать модель `GoogleGenerativeAI` с параметрами, переданными в `kwards` или взятыми из `Config`. Если инициализация прошла успешно, возвращает `True`, иначе - `False`.

**Параметры**:
- `models_list` (list[str]): Список моделей для инициализации.
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Возвращает**:
- `bool`: `True`, если инициализация прошла успешно, `False` в противном случае.

**Вызывает исключения**:
- `Exception`: Если произошла ошибка при инициализации моделей.

**Примеры**:
```python
assistant = CodeAssistant()
success = assistant._initialize_models(['gemini'], model_name='gemini-1.5-pro-latest')
print(success)  # Вывод: True или False в зависимости от успешности инициализации
```

### `send_file`

```python
def send_file(self, file_path: Path) -> Optional[str | None]:
    """
    Отправка файла в модель.

    Args:
        file_path (Path): Абсолютный путь к файлу, который нужно отправить.
        file_name (Optional[str]): Имя файла для отправки. Если не указано и 'src' отсутствует, используется имя файла без изменений.

    Returns:
        Optional[str | None]: URL файла, если успешно отправлен, иначе None.
    """
    ...
```

**Описание**: Отправляет указанный файл в модель Gemini для обработки.

**Как работает функция**:
Функция пытается отправить файл по указанному пути в модель Gemini с помощью метода `upload_file`. Если отправка прошла успешно и в ответе есть URL, возвращает этот URL. В случае ошибки логирует ошибку и возвращает `None`.

**Параметры**:
- `file_path` (Path): Абсолютный путь к файлу, который нужно отправить.

**Возвращает**:
- `Optional[str | None]`: URL файла, если успешно отправлен, иначе `None`.

**Вызывает исключения**:
- `Exception`: Если произошла ошибка при отправке файла.

**Примеры**:
```python
assistant = CodeAssistant()
file_path = Path('example.txt')
file_url = assistant.send_file(file_path)
if file_url:
    print(f'File URL: {file_url}')
else:
    print('Failed to send file')
```

### `process_files`

```python
async def process_files(
    self, start_dirs: str | Path | list[str, str] | list[Path, Path] = None, start_from_file: Optional[int] = 1
) -> bool:
    """компиляция, отправка запроса и сохранение результата."""
    ...
```

**Описание**: Обрабатывает файлы, начиная с указанных директорий, отправляет запросы в модель и сохраняет результаты.

**Как работает функция**:
Функция принимает список директорий для обработки, итерируется по файлам в этих директориях, формирует запросы к модели Gemini, отправляет запросы и сохраняет ответы. Если в процессе возникают ошибки (например, ошибка чтения файла или ошибка ответа модели), они логируются.

**Параметры**:
- `start_dirs` (str | Path | list[str, str] | list[Path, Path], optional): Список директорий для начала обработки. По умолчанию `None`.
- `start_from_file` (Optional[int], optional): Номер файла, с которого начать обработку. По умолчанию 1.

**Возвращает**:
- `bool`: `True`, если обработка прошла успешно, `False` в противном случае.

**Вызывает исключения**:
- `Exception`: Если произошла ошибка во время обработки файлов.

**Примеры**:
```python
import asyncio
assistant = CodeAssistant()
asyncio.run(assistant.process_files(start_dirs=['src/']))
```

### `_create_request`

```python
def _create_request(self, file_path: str, content: str) -> str:
    """Создание запроса с учетом роли и языка."""
    ...
```

**Описание**: Создает запрос к модели с учетом роли и языка.

**Как работает функция**:
Функция формирует запрос к модели, используя роль, язык, путь к файлу и содержимое файла. Она также добавляет инструкции из файла `instruction_{role}_{lang}.md`.

**Параметры**:
- `file_path` (str): Путь к файлу.
- `content` (str): Содержимое файла.

**Возвращает**:
- `str`: Сформированный запрос.

**Вызывает исключения**:
- `Exception`: Если произошла ошибка при создании запроса.

**Примеры**:
```python
assistant = CodeAssistant()
file_path = 'example.py'
content = 'def hello(): print("Hello")'
request = assistant._create_request(file_path, content)
print(request)
```

### `_yield_files_content`

```python
def _yield_files_content(
    self,
    process_driectory: str | Path,
) -> Iterator[tuple[Path, str]]:
    """
    Генерирует пути файлов и их содержимое по указанным шаблонам.

    Args:
        process_driectory (Path | str): Абсолютный путь к стартовой директории

    Returns:
        bool: Iterator
    """
    ...
```

**Описание**: Генерирует пути файлов и их содержимое в указанной директории.

**Как работает функция**:
Функция итерируется по всем файлам в указанной директории, проверяет их на соответствие шаблонам включения и исключения, и возвращает путь к файлу и его содержимое.

**Параметры**:
- `process_driectory` (str | Path): Абсолютный путь к стартовой директории.

**Возвращает**:
- `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортежи (путь к файлу, содержимое файла).

**Вызывает исключения**:
- `Exception`: Если произошла ошибка при чтении файла или компиляции регулярных выражений.

**Примеры**:
```python
assistant = CodeAssistant()
for file_path, content in assistant._yield_files_content('src/'):
    print(f'File: {file_path}')
    print(f'Content: {content[:100]}...')
```

### `_save_response`

```python
async def _save_response(self, file_path: Path, response: str, model_name: str) -> bool:
    """
    Сохранение ответа модели в файл с добавлением суффикса.

    Метод сохраняет ответ модели в файл, добавляя к текущему расширению файла
    дополнительный суффикс, определяемый ролью.

    Args:
        file_path (Path): Исходный путь к файлу, в который будет записан ответ.
        response (str): Ответ модели, который необходимо сохранить.
        model_name (str): Имя модели, использованной для генерации ответа.

    Raises:
        OSError: Если не удаётся создать директорию или записать в файл.
    """
    ...
```

**Описание**: Сохраняет ответ модели в файл с добавлением суффикса, соответствующего роли.

**Как работает функция**:
Функция сохраняет ответ модели в файл, добавляя суффикс к имени файла в зависимости от роли (`code_checker`, `doc_writer_md` и т.д.).  Суффикс определяет формат документа, например `.md` для Markdown или `.rst` для reStructuredText.

**Параметры**:
- `file_path` (Path): Исходный путь к файлу, в который будет записан ответ.
- `response` (str): Ответ модели, который необходимо сохранить.
- `model_name` (str): Имя модели, использованной для генерации ответа.

**Возвращает**:
- `bool`: `True`, если сохранение прошло успешно, `False` в противном случае.

**Вызывает исключения**:
- `OSError`: Если не удается создать директорию или записать в файл.

**Примеры**:
```python
import asyncio
assistant = CodeAssistant()
file_path = Path('example.py')
response = 'This is an example response'
asyncio.run(assistant._save_response(file_path, response, 'gemini'))
```

### `_remove_outer_quotes`

```python
def _remove_outer_quotes(self, response: str) -> str:
    """
    Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

    Args:
        response (str): Ответ модели, который необходимо обработать.

    Returns:
        str: Очищенный контент как строка.

    Example:
        >>> _remove_outer_quotes('```md some content ```')
        'some content'
        >>> _remove_outer_quotes('some content')
        'some content'
        >>> _remove_outer_quotes('```python def hello(): print("Hello") ```')
        '```python def hello(): print("Hello") ```'
    """
    ...
```

**Описание**: Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

**Как работает функция**:
Функция удаляет обрамляющие строку кавычки, но только если строка не начинается с `'```python'` или `'```mermaid'`.

**Параметры**:
- `response` (str): Ответ модели, который необходимо обработать.

**Возвращает**:
- `str`: Очищенный контент как строка.

**Вызывает исключения**:
- `Exception`: Если произошла ошибка при обработке строки.

**Примеры**:
```python
assistant = CodeAssistant()
response = '```md some content ```'
cleaned_response = assistant._remove_outer_quotes(response)
print(cleaned_response)  # Вывод: some content

response = 'some content'
cleaned_response = assistant._remove_outer_quotes(response)
print(cleaned_response)  # Вывод: some content

response = '```python def hello(): print("Hello") ```'
cleaned_response = assistant._remove_outer_quotes(response)
print(cleaned_response)  # Вывод: ```python def hello(): print("Hello") ```
```

### `run`

```python
def run(self, start_from_file: int = 1) -> None:
    """Запуск процесса обработки файлов."""
    ...
```

**Описание**: Запускает процесс обработки файлов.

**Как работает функция**:
Функция устанавливает обработчик сигнала `SIGINT` для прерывания процесса (Ctrl+C) и запускает асинхронную функцию `process_files`.

**Параметры**:
- `start_from_file` (int, optional): Номер файла, с которого начать обработку. По умолчанию 1.

**Возвращает**:
- `None`

**Примеры**:
```python
assistant = CodeAssistant()
assistant.run()
```

### `_signal_handler`

```python
def _signal_handler(self, signal, frame) -> None:
    """Обработка прерывания выполнения."""
    ...
```

**Описание**: Обрабатывает прерывание выполнения (например, при нажатии Ctrl+C).

**Как работает функция**:
Функция логирует сообщение о прерывании процесса и завершает программу.

**Параметры**:
- `signal`: Сигнал прерывания.
- `frame`: Текущий фрейм стека вызовов.

**Возвращает**:
- `None`

**Примеры**:
```python
assistant = CodeAssistant()
assistant._signal_handler(signal.SIGINT, None)
```

### `parse_args`

```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
    ...
```

**Описание**: Разбирает аргументы командной строки.

**Как работает функция**:
Функция использует `argparse` для разбора аргументов командной строки, таких как роль, язык, список моделей и список директорий для обработки.

**Параметры**:
- `None`

**Возвращает**:
- `dict`: Словарь с аргументами командной строки.

**Примеры**:
```python
args = parse_args()
print(args['role'])
print(args['lang'])
```

### `main`

```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
    ...
```

**Описание**: Запускает бесконечный цикл обработки файлов с учетом конфигурации.

**Как работает функция**:
Функция загружает конфигурацию из файла `code_assistant.json`, итерируется по языкам и ролям, создает экземпляры класса `CodeAssistant` и запускает обработку файлов для каждой комбинации языка и роли.

**Параметры**:
- `None`

**Возвращает**:
- `None`

**Примеры**:
```python
main()