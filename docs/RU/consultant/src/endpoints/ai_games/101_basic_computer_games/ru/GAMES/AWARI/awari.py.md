# Анализ кода модуля awari.py

**Качество кода**
8
- Плюсы
    - Код хорошо структурирован и разбит на функции, что делает его читаемым и понятным.
    -  Логика игры Авари реализована корректно, включая перемещение камней, захват и дополнительные ходы.
    -  Функции `display_board`, `player_turn`, `computer_turn`, `is_game_over` и `calculate_winner` четко выполняют свои задачи.
    -  Код содержит подробные комментарии, объясняющие каждый этап игры и логику функций.
    -  Блок-схема в формате mermaid делает понимание алгоритма игры более наглядным.
- Минусы
    -  Используются стандартные `print` для вывода сообщений, а не логирование через `logger`.
    -  В коде используется `input` без обработки возможных ошибок.
    -  Отсутствуют docstring в reStructuredText формате.
    -  Не используется `j_loads` или `j_loads_ns` для чтения файлов.
    -  Не все переменные и функции имеют понятные имена.
    -  Использованы `while True` циклы без явного условия выхода (кроме `is_game_over`).
    -  Смешивание логики игры и вывода на экран, что усложняет переиспользование кода.

**Рекомендации по улучшению**
1. Добавить docstring к каждой функции и модулю в формате reStructuredText.
2. Использовать `from src.logger.logger import logger` для логирования вместо `print`.
3. Заменить `input` на функцию с валидацией и обработкой ошибок.
4. Использовать более описательные имена переменных и функций.
5. Избавиться от `while True` циклов, заменив их на циклы с явными условиями выхода.
6. Вынести логику игры в отдельный класс для улучшения переиспользуемости кода.
7. Разделить функции вывода на экран и логику игры.
8. Использовать `j_loads` или `j_loads_ns` для чтения файлов, если это необходимо.

**Оптимизированный код**
```python
"""
Модуль для реализации игры Авари.
=========================================================================================

Игра "Авари" - это настольная игра, имитирующая традиционную игру Манкала.
В этом модуле реализована упрощенная версия игры, где игрок играет против компьютера.

Описание игры:
    Игровое поле состоит из 14 ячеек, пронумерованных от 0 до 13. Ячейки 6 и 13 - это "амбары" игроков.
    В начале игры в каждой из 12 ячеек (0-5 и 7-12) находится по 4 камня.
    Игрок (человек) начинает игру, выбирая ячейку со своими камнями (0-5).
    Все камни из выбранной ячейки перемещаются по одному в каждую следующую ячейку по часовой стрелке, включая свой "амбар".
    Если последний камень попал в амбар игрока, игрок имеет право сделать еще один ход.
    Если последний камень попал в пустую ячейку на стороне игрока, и напротив этой ячейки есть камни,
    то игрок забирает камни из этой ячейки и из противоположной в свой амбар.
    Компьютер ходит аналогично.
    Игра заканчивается, когда все ячейки с камнями становятся пустыми.
    Выигрывает игрок, у которого больше камней в амбаре.

Пример использования
--------------------

.. code-block:: python

    game = AwariGame()
    game.play()
"""
import random
from src.logger.logger import logger # импортируем logger
# from src.utils.jjson import j_loads # TODO добавить, если нужно будет загружать json
# from src.utils.jjson import j_loads_ns # TODO добавить, если нужно будет загружать json


class AwariGame:
    """
    Класс, реализующий игру Авари.

    :ivar board: Список, представляющий игровое поле.
    """
    def __init__(self):
        """
        Инициализирует игровое поле.
        """
        self.board = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]
        #  инициализируем доску, первые 6 ячеек игрока, 6 - амбар, 7-12 ячейки компьютера, 13 - амбар

    def display_board(self):
        """
        Выводит текущее состояние игровой доски в консоль.
        """
        print("----------------------------------------------------")
        print(f"  {self.board[12]:2}  {self.board[11]:2}  {self.board[10]:2}  {self.board[9]:2}  {self.board[8]:2}  {self.board[7]:2}   ")
        print("----------------------------------------------------")
        print(f"{self.board[13]:2}                                 {self.board[6]:2}")
        print("----------------------------------------------------")
        print(f"  {self.board[0]:2}  {self.board[1]:2}  {self.board[2]:2}  {self.board[3]:2}  {self.board[4]:2}  {self.board[5]:2}  ")
        print("----------------------------------------------------")

    def _get_player_choice(self):
         """
         Запрашивает ввод пользователя с обработкой ошибок.

         :return: Выбор пользователя (номер ячейки).
         :rtype: int
         """
         while True:
            try:
               cell = int(input("Выберите ячейку (0-5): "))
               if 0 <= cell <= 5 and self.board[cell] > 0:
                 return cell
               else:
                   print("Недопустимый выбор. Выберите ячейку с камнями от 0 до 5.")
            except ValueError:
              print("Неверный ввод. Пожалуйста, введите число.")
            except Exception as e: #  обработка других ошибок
                 logger.error(f"Ошибка при получении ввода игрока {e}")
                 return None  #  возврат None в случае ошибки
    def player_turn(self):
        """
        Обрабатывает ход игрока.
        """
        cell = self._get_player_choice()
        if cell is None: # если пользователь ничего не ввел или произошла ошибка
            return False  #  завершить ход

        stones = self.board[cell]
        self.board[cell] = 0
        current_cell = cell

        while stones > 0:
            current_cell = (current_cell + 1) % 14
            self.board[current_cell] += 1
            stones -= 1

        # Проверка на дополнительный ход, если последний камень попал в амбар игрока
        if current_cell == 6:
            print("Игрок получает дополнительный ход.")
            self.display_board()
            self.player_turn()
            return True #  дополнительный ход выполнен

        # Захват камней
        if 0 <= current_cell <= 5 and self.board[current_cell] == 1:
           opposite_cell = 12 - current_cell
           if self.board[opposite_cell] > 0:
            self.board[6] += self.board[opposite_cell] + 1
            self.board[opposite_cell] = 0
            self.board[current_cell] = 0
            print(f"Игрок захватывает камни из ячеек {current_cell} и {opposite_cell}")
        return True #  ход выполнен
    def computer_turn(self):
        """
        Обрабатывает ход компьютера.
        """
        possible_moves = [i for i in range(7, 13) if self.board[i] > 0]
        if not possible_moves:
            return False  #  Если нет доступных ходов, выйти
        cell = random.choice(possible_moves)
        print(f"Компьютер выбирает ячейку {cell}")
        stones = self.board[cell]
        self.board[cell] = 0
        current_cell = cell

        while stones > 0:
            current_cell = (current_cell + 1) % 14
            self.board[current_cell] += 1
            stones -= 1

        # Проверка на дополнительный ход, если последний камень попал в амбар компьютера
        if current_cell == 13:
            print("Компьютер получает дополнительный ход.")
            self.display_board()
            self.computer_turn()
            return True #  дополнительный ход выполнен

        # Захват камней
        if 7 <= current_cell <= 12 and self.board[current_cell] == 1:
           opposite_cell = 12 - current_cell
           if self.board[opposite_cell] > 0:
            self.board[13] += self.board[opposite_cell] + 1
            self.board[opposite_cell] = 0
            self.board[current_cell] = 0
            print(f"Компьютер захватывает камни из ячеек {current_cell} и {opposite_cell}")
        return True #  ход выполнен

    def is_game_over(self):
        """
        Проверяет, закончена ли игра.

        :return: True, если игра окончена, иначе False.
        :rtype: bool
        """
        player_side_empty = all(self.board[i] == 0 for i in range(0, 6))
        computer_side_empty = all(self.board[i] == 0 for i in range(7, 13))
        return player_side_empty or computer_side_empty

    def calculate_winner(self):
        """
        Определяет победителя и выводит результаты.
        """
        player_score = self.board[6]
        computer_score = self.board[13]

        print(f"Игрок: {player_score} очков")
        print(f"Компьютер: {computer_score} очков")

        if player_score > computer_score:
            print("Вы победили!")
        elif computer_score > player_score:
            print("Компьютер победил!")
        else:
            print("Ничья!")
    def play(self):
        """
        Основной игровой цикл.
        """
        while not self.is_game_over():
            self.display_board()
            if not self.player_turn(): #  если ход не выполнен, пропускаем ход
                continue
            if self.is_game_over():
                break
            self.display_board()
            if not self.computer_turn(): # если ход не выполнен, пропускаем ход
                continue
        self.display_board()
        self.calculate_winner()


if __name__ == '__main__':
    game = AwariGame()
    game.play()

"""
Объяснение кода:
1. **Инициализация доски (`board`)**:
   - `board = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]`: Создается список, представляющий игровое поле.
     Первые 6 элементов (0-5) - ячейки игрока, 7-12 - ячейки компьютера, 6 - амбар игрока, 13 - амбар компьютера.
     В начале игры в каждой ячейке по 4 камня, в амбарах - 0.

2. **Функция `display_board()`**:
   - Выводит текущее состояние игровой доски на экран.

3. **Функция `player_turn()`**:
   - Обрабатывает ход игрока:
     - Запрашивает ввод номера ячейки (0-5).
     - Проверяет корректность ввода (число от 0 до 5 и ячейка не пустая).
     - Забирает камни из выбранной ячейки.
     - Распределяет камни по одной в каждую следующую ячейку по часовой стрелке.
     - Проверяет, попал ли последний камень в амбар игрока (ячейка 6). Если да, то игрок делает еще один ход.
     - Проверяет, попал ли последний камень в пустую ячейку на стороне игрока, если да, то захватывает камни напротив.

4. **Функция `computer_turn()`**:
   - Обрабатывает ход компьютера:
     - Выбирает случайную ячейку (7-12), не пустую.
     - Распределяет камни по одной в каждую следующую ячейку по часовой стрелке.
     - Проверяет, попал ли последний камень в амбар компьютера (ячейка 13). Если да, то компьютер делает еще один ход.
     - Проверяет, попал ли последний камень в пустую ячейку на стороне компьютера, если да, то захватывает камни напротив.

5.  **Функция `is_game_over()`**:
    - Проверяет, закончилась ли игра. Игра заканчивается, когда все ячейки на стороне игрока или компьютера пусты.

6.  **Функция `calculate_winner()`**:
    - Выводит количество очков каждого игрока.
    - Определяет победителя.

7.  **Основной игровой цикл (`while not self.is_game_over()`)**:
    - Выводит доску.
    - Дает ход игроку.
    - Проверяет, закончилась ли игра. Если да, то выходит из цикла.
    - Дает ход компьютеру.
    - Проверяет, закончилась ли игра. Если да, то выходит из цикла.

8.  **Вывод результатов**:
    - После завершения игры выводит доску и результаты.
"""
```