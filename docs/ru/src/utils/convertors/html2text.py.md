# Модуль для конвертации HTML в Markdown

## Обзор

Модуль `html2text` предназначен для преобразования HTML-документов в Markdown-форматированный текст. Он включает классы и функции для парсинга HTML, обработки различных элементов и стилей, а также для форматирования вывода в удобочитаемый Markdown.

## Подробней

Этот модуль используется для извлечения текстового содержимого из HTML-страниц, сохраняя при этом структуру и форматирование, насколько это возможно. Он может быть полезен для автоматической генерации документации, извлечения контента для анализа или для создания читабельных версий веб-страниц.

## Функции

### `has_key`

```python
def has_key(x, y):
    """
    Проверяет, содержит ли объект `x` ключ `y`.

    Args:
        x: Объект, который нужно проверить (словарь или объект с методом `has_key`).
        y: Ключ, наличие которого нужно проверить.

    Returns:
        bool: `True`, если объект `x` содержит ключ `y`, иначе `False`.
    """
    ...
```

**Как работает функция**:

1. Функция `has_key` проверяет, обладает ли объект `x` методом `has_key`.
2. Если метод `has_key` существует, он вызывается с аргументом `y`, и возвращается результат вызова.
3. Если метод `has_key` отсутствует, проверяется, содержится ли `y` в `x` с помощью оператора `in`, и возвращается результат проверки.

**Примеры**:

```python
# Пример 1: Проверка наличия ключа в словаре
my_dict = {'a': 1, 'b': 2}
print(has_key(my_dict, 'a'))  # Вывод: True
print(has_key(my_dict, 'c'))  # Вывод: False

# Пример 2: Проверка наличия элемента в списке
my_list = [1, 2, 3]
print(has_key(my_list, 1))  # Вывод: True
print(has_key(my_list, 4))  # Вывод: False
```

### `name2cp`

```python
def name2cp(k):
    """
    Преобразует имя HTML-сущности в Unicode codepoint.

    Args:
        k (str): Имя HTML-сущности (например, 'apos').

    Returns:
        int: Unicode codepoint сущности.

    Raises:
        KeyError: Если сущность не найдена в `htmlentitydefs`.
    """
    ...
```

**Как работает функция**:

1. Если `k` равно `'apos'`, возвращает Unicode codepoint для апострофа (`\''`).
2. Проверяет, существует ли атрибут `name2codepoint` в модуле `htmlentitydefs`. Если да, возвращает соответствующий codepoint.
3. В противном случае, извлекает значение сущности из `htmlentitydefs.entitydefs`.
4. Если значение начинается с `"&#"` и заканчивается `";"`, преобразует строку между этими символами в целое число и возвращает его.
5. Иначе, декодирует значение как latin-1 и возвращает Unicode codepoint первого символа.

**Примеры**:

```python
# Пример 1: Преобразование имени сущности в codepoint
print(name2cp('copy'))  # Вывод: 169

# Пример 2: Преобразование имени сущности 'apos'
print(name2cp('apos'))  # Вывод: 39
```

### `charref`

```python
def charref(name):
    """
    Преобразует числовую ссылку на символ в символ Unicode.

    Args:
        name (str): Числовая ссылка на символ (например, '160' или 'x20').

    Returns:
        str: Соответствующий символ Unicode.
    """
    ...
```

**Как работает функция**:

1.  Определяет основание системы счисления (16 или 10) в зависимости от префикса `name`.
2.  Преобразует `name` в целое число `c`.
3.  Если `UNICODE_SNOB` равно `False` и `c` есть в `unifiable_n`, возвращает соответствующее значение из `unifiable_n`.
4.  Иначе, пытается преобразовать `c` в символ Unicode с помощью `chr(c)`.
5.  Если происходит исключение `NameError` (Python 3), возвращает `chr(c)`.

**Примеры**:

```python
# Пример 1: Преобразование десятичной ссылки на символ
print(charref('160'))  # Вывод:  (non-breaking space)

# Пример 2: Преобразование шестнадцатеричной ссылки на символ
print(charref('x20'))  # Вывод:
```

### `entityref`

```python
def entityref(c):
    """
    Преобразует ссылку на HTML-сущность в символ Unicode.

    Args:
        c (str): Ссылка на HTML-сущность (например, 'nbsp').

    Returns:
        str: Соответствующий символ Unicode.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, если `UNICODE_SNOB` равно `False` и `c` есть в `unifiable`, возвращает соответствующее значение из `unifiable`.
2.  Иначе, пытается получить Unicode codepoint для `c` с помощью `name2cp(c)`.
3.  Если происходит исключение `KeyError`, возвращает исходную ссылку на сущность в формате `"&" + c + ";"`.
4.  Если codepoint получен успешно, пытается преобразовать его в символ Unicode с помощью `chr()`.
5.  Если происходит исключение `NameError` (Python 3), возвращает `chr(name2cp(c))`.

**Примеры**:

```python
# Пример 1: Преобразование ссылки на сущность 'nbsp'
print(entityref('nbsp'))  # Вывод:

# Пример 2: Преобразование неизвестной ссылки на сущность
print(entityref('unknown'))  # Вывод: &unknown;
```

### `replaceEntities`

```python
def replaceEntities(s):
    """
    Заменяет HTML-сущности в строке соответствующими символами.

    Args:
        s (re.Match): Объект Match, содержащий HTML-сущность.

    Returns:
        str: Соответствующий символ Unicode.
    """
    ...
```

**Как работает функция**:

1.  Извлекает HTML-сущность из группы 1 объекта `Match`.
2.  Если сущность начинается с `"#"`, вызывает `charref` для преобразования числовой ссылки на символ.
3.  Иначе, вызывает `entityref` для преобразования именованной ссылки на сущность.

**Примеры**:

```python
# Пример 1: Замена числовой ссылки на символ
import re
match = re.match(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", "&#160;")
print(replaceEntities(match))  # Вывод:

# Пример 2: Замена именованной ссылки на сущность
match = re.match(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", "&nbsp;")
print(replaceEntities(match))  # Вывод:
```

### `unescape`

```python
def unescape(s):
    """
    Заменяет HTML-сущности в строке соответствующими символами.

    Args:
        s (str): Строка, содержащая HTML-сущности.

    Returns:
        str: Строка с замененными HTML-сущностями.
    """
    ...
```

**Как работает функция**:

1.  Использует регулярное выражение `r_unescape` для поиска HTML-сущностей в строке `s`.
2.  Для каждой найденной сущности вызывает функцию `replaceEntities` для ее замены.
3.  Возвращает строку с замененными HTML-сущностями.

**Примеры**:

```python
# Пример 1: Замена HTML-сущностей в строке
print(unescape("This is &nbsp; a test &copy;"))  # Вывод: This is   a test (C)
```

### `onlywhite`

```python
def onlywhite(line):
    """
    Проверяет, состоит ли строка только из пробельных символов.

    Args:
        line (str): Строка для проверки.

    Returns:
        bool: `True`, если строка состоит только из пробельных символов, иначе `False`.
    """
    ...
```

**Как работает функция**:

1.  Проходит по каждому символу в строке `line`.
2.  Если символ не является пробелом или двойным пробелом, возвращает `False`.
3.  Если все символы являются пробелами, возвращает `True`.

**Примеры**:

```python
# Пример 1: Строка, состоящая только из пробельных символов
print(onlywhite("   "))  # Вывод: True

# Пример 2: Строка, содержащая непробельные символы
print(onlywhite("  a "))  # Вывод: False
```

### `optwrap`

```python
def optwrap(text):
    """
    Оборачивает текст по ширине `BODY_WIDTH`.

    Args:
        text (str): Текст для оборачивания.

    Returns:
        str: Обернутый текст.
    """
    ...
```

**Как работает функция**:

1.  Если `BODY_WIDTH` равно 0, возвращает исходный текст.
2.  Разбивает текст на параграфы по символу новой строки `\n`.
3.  Для каждого параграфа, если он не начинается с пробела, дефиса или звездочки, оборачивает его по ширине `BODY_WIDTH` с помощью `textwrap.wrap`.
4.  Соединяет обернутые строки и добавляет символы новой строки.

**Примеры**:

```python
# Пример 1: Оборачивание текста по ширине 78
BODY_WIDTH = 78
text = "This is a long paragraph that needs to be wrapped to fit within the specified width."
print(optwrap(text))
# Вывод:
# This is a long paragraph that needs to be wrapped to fit within the
# specified width.
#
```

### `hn`

```python
def hn(tag):
    """
    Определяет уровень заголовка HTML-тега.

    Args:
        tag (str): HTML-тег.

    Returns:
        int: Уровень заголовка (1-9), или 0, если тег не является заголовком.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, начинается ли тег с `"h"` и имеет ли длину 2.
2.  Пытается преобразовать второй символ тега в целое число `n`.
3.  Если `n` находится в диапазоне от 1 до 9, возвращает `n`.
4.  Иначе, возвращает 0.

**Примеры**:

```python
# Пример 1: Определение уровня заголовка
print(hn('h1'))  # Вывод: 1
print(hn('h6'))  # Вывод: 6
print(hn('h10')) # Вывод: 0
print(hn('p'))   # Вывод: 0
```

### `dumb_property_dict`

```python
def dumb_property_dict(style):
    """
    Преобразует строку CSS-стилей в словарь.

    Args:
        style (str): Строка CSS-стилей.

    Returns:
        dict: Словарь, где ключи - имена CSS-свойств, а значения - их значения.
    """
    ...
```

**Как работает функция**:

1.  Разбивает строку `style` на отдельные объявления по символу `";"`.
2.  Для каждого объявления разбивает его на имя и значение свойства по символу `":"`.
3.  Создает словарь, где ключи - это имена свойств, а значения - их значения.

**Примеры**:

```python
# Пример 1: Преобразование строки CSS-стилей в словарь
style = "color: red; font-size: 12px;"
print(dumb_property_dict(style))
# Вывод: {'color': 'red', 'font-size': '12px'}
```

### `dumb_css_parser`

```python
def dumb_css_parser(data):
    """
    Парсит CSS-данные и возвращает словарь селекторов CSS и их атрибутов.

    Args:
        data (str): CSS-данные в виде строки.

    Returns:
        dict: Словарь, где ключи - CSS-селекторы, а значения - словари CSS-атрибутов.
    """
    ...
```

**Как работает функция**:

1.  Удаляет все `@import` предложения из CSS-данных.
2.  Разбивает CSS-данные на блоки, разделенные символами `'{'` и `'}'`.
3.  Для каждого блока создает словарь, где ключом является CSS-селектор, а значением - словарь CSS-атрибутов, полученный с помощью функции `dumb_property_dict`.

**Примеры**:

```python
# Пример 1: Парсинг CSS-данных
css_data = "body { color: black; } .highlight { font-weight: bold; }"
print(dumb_css_parser(css_data))
# Вывод: {'body': {'color': 'black'}, '.highlight': {'font-weight': 'bold'}}
```

### `element_style`

```python
def element_style(attrs, style_def, parent_style):
    """
    Определяет окончательный стиль элемента на основе атрибутов, CSS-определений и стиля родительского элемента.

    Args:
        attrs (dict): Словарь атрибутов элемента.
        style_def (dict): Словарь CSS-определений.
        parent_style (dict): Стиль родительского элемента.

    Returns:
        dict: Словарь окончательных стилей элемента.
    """
    ...
```

**Как работает функция**:

1.  Копирует стиль родительского элемента в `style`.
2.  Если в атрибутах элемента есть класс (`'class'`), обновляет `style` стилями из `style_def` для каждого класса.
3.  Если в атрибутах элемента есть стиль (`'style'`), обновляет `style` стилями из атрибута `style`.
4.  Возвращает окончательный стиль элемента.

**Примеры**:

```python
# Пример 1: Определение стиля элемента
attrs = {'class': 'highlight', 'style': 'font-size: 14px;'}
style_def = {'.highlight': {'font-weight': 'bold', 'color': 'blue'}}
parent_style = {'font-family': 'Arial'}
print(element_style(attrs, style_def, parent_style))
# Вывод: {'font-family': 'Arial', 'font-weight': 'bold', 'color': 'blue', 'font-size': '14px'}
```

### `google_list_style`

```python
def google_list_style(style):
    """
    Определяет, является ли список упорядоченным или неупорядоченным на основе CSS-стилей Google Docs.

    Args:
        style (dict): Словарь CSS-стилей элемента.

    Returns:
        str: `'ul'`, если список неупорядоченный, `'ol'`, если список упорядоченный.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, есть ли в стиле атрибут `'list-style-type'`.
2.  Если атрибут есть и его значение равно `'disc'`, `'circle'`, `'square'` или `'none'`, возвращает `'ul'`.
3.  Иначе, возвращает `'ol'`.

**Примеры**:

```python
# Пример 1: Определение стиля списка как неупорядоченного
style = {'list-style-type': 'disc'}
print(google_list_style(style))  # Вывод: ul

# Пример 2: Определение стиля списка как упорядоченного
style = {'list-style-type': 'decimal'}
print(google_list_style(style))  # Вывод: ol
```

### `google_nest_count`

```python
def google_nest_count(style):
    """
    Вычисляет уровень вложенности списка Google Docs на основе CSS-стилей.

    Args:
        style (dict): Словарь CSS-стилей элемента.

    Returns:
        int: Уровень вложенности списка.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, есть ли в стиле атрибут `'margin-left'`.
2.  Если атрибут есть, извлекает значение отступа слева, удаляет `"px"` и преобразует значение в целое число.
3.  Делит значение отступа на `GOOGLE_LIST_INDENT` и возвращает результат в качестве уровня вложенности.

**Примеры**:

```python
# Пример 1: Вычисление уровня вложенности списка
style = {'margin-left': '72px'}
GOOGLE_LIST_INDENT = 36
print(google_nest_count(style))  # Вывод: 2

# Пример 2: Вычисление уровня вложенности списка без отступа
style = {}
GOOGLE_LIST_INDENT = 36
print(google_nest_count(style))  # Вывод: 0
```

### `google_has_height`

```python
def google_has_height(style):
    """
    Проверяет, определен ли атрибут 'height' явно в CSS-стиле элемента.

    Args:
        style (dict): Словарь CSS-стилей элемента.

    Returns:
        bool: `True`, если атрибут 'height' определен, иначе `False`.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, есть ли ключ `'height'` в словаре `style`.
2.  Если ключ есть, возвращает `True`, иначе `False`.

**Примеры**:

```python
# Пример 1: Проверка наличия атрибута 'height'
style = {'height': '10px'}
print(google_has_height(style))  # Вывод: True

# Пример 2: Проверка отсутствия атрибута 'height'
style = {'width': '100px'}
print(google_has_height(style))  # Вывод: False
```

### `google_text_emphasis`

```python
def google_text_emphasis(style):
    """
    Возвращает список модификаторов выделения текста для элемента на основе CSS-стилей Google Docs.

    Args:
        style (dict): Словарь CSS-стилей элемента.

    Returns:
        list: Список модификаторов выделения текста (например, ['line-through', 'italic', 'bold']).
    """
    ...
```

**Как работает функция**:

1.  Создает пустой список `emphasis`.
2.  Проверяет, есть ли в стиле атрибут `'text-decoration'`. Если да, добавляет его значение в список `emphasis`.
3.  Проверяет, есть ли в стиле атрибут `'font-style'`. Если да, добавляет его значение в список `emphasis`.
4.  Проверяет, есть ли в стиле атрибут `'font-weight'`. Если да, добавляет его значение в список `emphasis`.
5.  Возвращает список `emphasis`.

**Примеры**:

```python
# Пример 1: Определение модификаторов выделения текста
style = {'text-decoration': 'line-through', 'font-style': 'italic', 'font-weight': 'bold'}
print(google_text_emphasis(style))  # Вывод: ['line-through', 'italic', 'bold']

# Пример 2: Определение модификаторов выделения текста
style = {'font-style': 'italic'}
print(google_text_emphasis(style))  # Вывод: ['italic']
```

### `google_fixed_width_font`

```python
def google_fixed_width_font(style):
    """
    Проверяет, определяет ли CSS текущего элемента шрифт фиксированной ширины.

    Args:
        style (dict): Словарь CSS-стилей элемента.

    Returns:
        bool: `True`, если шрифт фиксированной ширины, иначе `False`.
    """
    ...
```

**Как работает функция**:

1.  Получает значение атрибута `'font-family'` из словаря `style`.
2.  Если значение равно `'Courier New'` или `'Consolas'`, возвращает `True`.
3.  Иначе, возвращает `False`.

**Примеры**:

```python
# Пример 1: Проверка шрифта фиксированной ширины
style = {'font-family': 'Courier New'}
print(google_fixed_width_font(style))  # Вывод: True

# Пример 2: Проверка шрифта нефиксированной ширины
style = {'font-family': 'Arial'}
print(google_fixed_width_font(style))  # Вывод: False
```

### `list_numbering_start`

```python
def list_numbering_start(attrs):
    """
    Извлекает начальный номер из атрибутов элемента списка.

    Args:
        attrs (dict): Словарь атрибутов элемента.

    Returns:
        int: Начальный номер списка (начинается с 0), или 0, если атрибут 'start' не указан.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, есть ли в словаре `attrs` ключ `'start'`.
2.  Если ключ есть, преобразует его значение в целое число и вычитает 1.
3.  Если ключа нет, возвращает 0.

**Примеры**:

```python
# Пример 1: Извлечение начального номера списка
attrs = {'start': '5'}
print(list_numbering_start(attrs))  # Вывод: 4

# Пример 2: Извлечение начального номера списка без атрибута 'start'
attrs = {}
print(list_numbering_start(attrs))  # Вывод: 0
```

## Классы

### `_html2text`

**Описание**: Парсер HTML для преобразования в Markdown.

**Наследует**: `HTMLParser.HTMLParser`

**Атрибуты**:

-   `out`: Функция для вывода текста.
-   `outtextlist`: Список для хранения выводимых символов.
-   `outtext`: Строка, содержащая выводимый текст.
-   `quiet`: Флаг для подавления вывода.
-   `p_p`: Количество символов новой строки для вывода перед следующим выводом.
-   `outcount`: Счетчик выведенных элементов.
-   `start`: Флаг, указывающий на начало документа.
-   `space`: Флаг, указывающий на необходимость добавления пробела.
-   `a`: Список ссылок.
-   `astack`: Стек ссылок.
-   `acount`: Счетчик ссылок.
-   `list`: Список информации о списках.
-   `blockquote`: Уровень цитирования.
-   `pre`: Флаг, указывающий на режим предварительного форматирования.
-   `startpre`: Флаг, указывающий на начало режима предварительного форматирования.
-   `code`: Флаг, указывающий на режим кода.
-   `br_toggle`: Строка для переключения символа новой строки.
-   `lastWasNL`: Флаг, указывающий на то, что последним символом была новая строка.
-   `lastWasList`: Флаг, указывающий на то, что последним элементом был список.
-   `style`: Флаг, указывающий на наличие стилей.
-   `style_def`: Словарь определений стилей.
-   `tag_stack`: Стек тегов.
-   `emphasis`: Уровень выделения текста.
-   `drop_white_space`: Флаг для удаления пробелов.
-   `inheader`: Флаг, указывающий на нахождение внутри заголовка.
-   `abbr_title`: Заголовок текущего определения аббревиатуры.
-   `abbr_data`: Последний внутренний HTML (для определяемой аббревиатуры).
-   `abbr_list`: Стек аббревиатур для записи позже.
-   `baseurl`: Базовый URL.

**Методы**:

-   `__init__(self, out=None, baseurl='')`: Инициализирует экземпляр класса `_html2text`.
-   `feed(self, data)`: Обрабатывает данные HTML.
-   `outtextf(self, s)`: Добавляет строку `s` в список выводимого текста.
-   `close(self)`: Завершает обработку HTML и возвращает преобразованный текст.
-   `handle_charref(self, c)`: Обрабатывает числовую ссылку на символ.
-   `handle_entityref(self, c)`: Обрабатывает ссылку на HTML-сущность.
-   `handle_starttag(self, tag, attrs)`: Обрабатывает открывающий тег.
-   `handle_endtag(self, tag)`: Обрабатывает закрывающий тег.
-   `previousIndex(self, attrs)`: Возвращает индекс набора атрибутов (ссылки) в списке `self.a`.
-   `drop_last(self, nLetters)`: Удаляет последние `nLetters` символов из выводимого текста.
-   `handle_emphasis(self, start, tag_style, parent_style)`: Обрабатывает различные выделения текста.
-   `handle_tag(self, tag, attrs, start)`: Обрабатывает тег.
-   `pbr(self)`: Добавляет один символ новой строки.
-   `p(self)`: Добавляет два символа новой строки.
-   `soft_br(self)`: Добавляет мягкий перенос строки.
-   `o(self, data, puredata=0, force=0)`: Выводит данные.
-   `handle_data(self, data)`: Обрабатывает текстовые данные.
-   `unknown_decl(self, data)`: Обрабатывает неизвестные объявления.

#### `__init__`

```python
def __init__(self, out=None, baseurl=''):
    """
    Инициализирует объект класса `_html2text`.

    Args:
        out (Callable, optional): Функция для вывода текста. По умолчанию `self.outtextf`.
        baseurl (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию ''.
    """
    ...
```

**Как работает класс**:

1.  Инициализирует родительский класс `HTMLParser.HTMLParser`.
2.  Устанавливает функцию вывода `self.out` в `outtextf`, если `out` не указана, иначе использует предоставленную функцию `out`.
3.  Инициализирует пустой список `self.outtextlist` для хранения выводимых символов.
4.  Инициализирует строку `self.outtext` для хранения выводимого текста.
5.  Устанавливает флаги и счетчики в начальное состояние.
6.  Сохраняет базовый URL `baseurl`.
7.  Если включена опция `options.google_doc`, удаляет символ неразрывного пробела из `unifiable_n` и заменяет его на плейсхолдер в `unifiable`.

**Примеры**:

```python
# Пример 1: Создание экземпляра класса _html2text с функцией вывода по умолчанию
h = _html2text()

# Пример 2: Создание экземпляра класса _html2text с пользовательской функцией вывода
def my_out(s):
    print(s)
h = _html2text(out=my_out)
```

#### `feed`

```python
def feed(self, data):
    """
    Обрабатывает данные HTML, заменяя "</\' + \'script>" на "</ignore>".

    Args:
        data (str): Данные HTML для обработки.
    """
    ...
```

**Как работает функция**:

1.  Заменяет все вхождения строки `"</\' + \'script>"` на `"</ignore>"` в данных HTML.
2.  Вызывает метод `feed` родительского класса `HTMLParser.HTMLParser` для обработки данных.

**Примеры**:

```python
# Пример 1: Обработка данных HTML
h = _html2text()
h.feed("<p>Hello, world!</p>")
```

#### `outtextf`

```python
def outtextf(self, s):
    """
    Добавляет строку `s` в список выводимого текста и обновляет флаг `lastWasNL`.

    Args:
        s (str): Строка для добавления.
    """
    ...
```

**Как работает функция**:

1.  Добавляет строку `s` в список `self.outtextlist`.
2.  Если строка `s` не пуста, устанавливает флаг `self.lastWasNL` в `True`, если последний символ строки `s` является символом новой строки (`\n`), и в `False` в противном случае.

**Примеры**:

```python
# Пример 1: Добавление строки в список выводимого текста
h = _html2text()
h.outtextf("Hello, world!\n")
print(h.outtextlist)  # Вывод: ['Hello, world!\n']
print(h.lastWasNL)    # Вывод: True
```

#### `close`

```python
def close(self):
    """
    Завершает обработку HTML, объединяет выводимый текст и возвращает его.

    Returns:
        str: Преобразованный текст.
    """
    ...
```

**Как работает функция**:

1.  Вызывает метод `pbr` для добавления символа новой строки, если необходимо.
2.  Вызывает метод `o` с аргументами `''`, `0` и `'end'` для завершения вывода.
3.  Объединяет все строки в списке `self.outtextlist` в одну строку `self.outtext`.
4.  Если включена опция `options.google_doc`, заменяет плейсхолдер неразрывного пробела на обычный пробел.
5.  Возвращает строку `self.outtext`.

**Примеры**:

```python
# Пример 1: Завершение обработки HTML и получение преобразованного текста
h = _html2text()
h.feed("<p>Hello, world!</p>")
text = h.close()
print(text)  # Вывод: Hello, world!
```

#### `handle_charref`

```python
def handle_charref(self, c):
    """
    Обрабатывает числовую ссылку на символ, вызывая функцию `charref` и выводя результат.

    Args:
        c (str): Числовая ссылка на символ.
    """
    ...
```

**Как работает функция**:

1.  Вызывает функцию `charref` с аргументом `c` для преобразования числовой ссылки на символ в символ Unicode.
2.  Вызывает метод `o` с полученным символом и аргументом `1` для вывода символа.

**Примеры**:

```python
# Пример 1: Обработка числовой ссылки на символ
h = _html2text()
h.handle_charref("160")  # Выводит неразрывный пробел
```

#### `handle_entityref`

```python
def handle_entityref(self, c):
    """
    Обрабатывает ссылку на HTML-сущность, вызывая функцию `entityref` и выводя результат.

    Args:
        c (str): Ссылка на HTML-сущность.
    """
    ...
```

**Как работает функция**:

1.  Вызывает функцию `entityref` с аргументом `c` для преобразования ссылки на HTML-сущность в символ Unicode.
2.  Вызывает метод `o` с полученным символом и аргументом `1` для вывода символа.

**Примеры**:

```python
# Пример 1: Обработка ссылки на HTML-сущность
h = _html2text()
h.handle_entityref("nbsp")  # Выводит неразрывный пробел
```

#### `handle_starttag`

```python
def handle_starttag(self, tag, attrs):
    """
    Обрабатывает открывающий тег HTML, вызывая метод `handle_tag`.

    Args:
        tag (str): Имя тега.
        attrs (list): Список атрибутов тега.
    """
    ...
```

**Как работает функция**:

1.  Вызывает метод `handle_tag` с аргументами `tag`, `attrs` и `1` для обработки открывающего тега.

**Примеры**:

```python
# Пример 1: Обработка открывающего тега
h = _html2text()
h.handle_starttag("p", [])
```

#### `handle_endtag`

```python
def handle_endtag(self, tag):
    """
    Обрабатывает закрывающий тег HTML, вызывая метод `handle_tag`.

    Args:
        tag (str): Имя тега.
    """
    ...
```

**Как работает функция**:

1.  Вызывает метод `handle_tag` с аргументами `tag`, `None` и `0` для обработки закрывающего тега.

**Примеры**:

```python
# Пример 1: Обработка закрывающего тега
h = _html2text()
h.handle_endtag("p")
```

#### `previousIndex`

```python
def previousIndex(self, attrs):
    """
    Возвращает индекс набора атрибутов (ссылки) в списке `self.a`.

    Args:
        attrs (dict): Словарь атрибутов ссылки.

    Returns:
        int: Индекс набора атрибутов в списке `self.a`, или `None`, если набор не найден.
    """
    ...
```

**Как работает функция**:

1.  Проверяет, есть ли атрибут `'href'` в словаре `attrs`. Если нет, возвращает `None`.
2.  Перебирает ссылки в списке `self.a` и сравнивает их атрибуты с атрибутами в словаре `attrs`.
3.  Если найдена ссылка с совпадающими атрибутами `'href'` и `'title'` (если они указаны), возвращает индекс этой ссылки.
4.  Если совпадение не найдено, возвращает `None`.

**Примеры**:

```python
# Пример 1: