# מערכות מספרים

## סקירה כללית

מסמך זה מספק מבוא מקיף למערכות מספרים שונות, כולל מערכות מספריות אבסטרקטיות וקונקרטיות, עם דוגמאות קוד Python. המטרה היא להסביר את המושגים הבסיסיים של מערכות מספרים, ליישם פונקציות המרה בין מערכות שונות ולספק תרגילים לשיפור ההבנה. המסמך גם בוחן יישומים בעולם האמיתי, כמו ספרות רומיות וקוד מורס.

## תוכן עניינים

1. [מערכות מספריות אבסטרקטיות](#1-מערכות-מספריות-אבסטרקטיות)
2. [מערכות מספריות קונקרטיות](#2-מערכות-מספריות-קונקרטיות)
    *   [מערכת בינארית (בסיס 2)](#21-מערכת-בינארית-בסיס-2)
    *   [מערכת טרינארית (בסיס 3)](#22-מערכת-טרינארית-בסיס-3)
    *   [מערכת ספטנארית (בסיס 7)](#23-מערכת-ספטנארית-בסיס-7)
    *   [מערכת דצימלית (בסיס 10)](#24-מערכת-דצימלית-בסיס-10)
    *   [מערכת הקסדצימלית (בסיס 16)](#25-מערכת-הקסדצימלית-בסיס-16)
    *   [מערכת סקסאגסימלית (בסיס 60)](#26-מערכת-סקסאגסימלית-בסיס-60)
3. [דוגמאות למערכות מספרים בחיי היומיום](#3-דוגמאות-למערכות-מספרים-בחיי-היומיום)
    *   [ספרות רומיות](#31-ספרות-רומיות)
    *   [קוד מורס](#32-קוד-מורס)
4. [תרגילים](#4-תרגילים)
5. [חומר נוסף: ימי השבוע ומערכת ספטנארית](#5-חומר-נוסף-ימי-השבוע-ומערכת-ספטנארית)
6. [דיאגרמה](#6-דיאגרמה)

## 1. מערכות מספריות אבסטרקטיות

מערכת מספרים מופשטת היא שיטה לייצוג מספרים באמצעות סימנים. חוקי המערכת:

*   **בסיס:** מספר הסימנים הייחודיים המשמשים במערכת.
*   **ספרות:** הסימנים המשמשים לייצוג מספרים.
*   **מיקום:** מיקום הספרה משפיע על ערכה.
*   **מדרגות:** כל מיקום נקרא מדרגה (יחידות, עשרות, מאות וכו').

**בניית מערכת מספרים:**

1.  **בחירת בסיס:** בוחרים מספר שלם `b` כבסיס.
2.  **בחירת ספרות:** בוחרים `b` ספרות ייחודיות (בדרך כלל 0, 1, ..., `b`-1).
3.  **רישום מספר:** רושמים מספר כרצף של ספרות, כאשר ערך כל ספרה מוכפל בבסיס בחזקת מיקומה (מתחיל מ-0 מימין).

**חישוב ערך המספר:**

אם המספר הוא `dₙ dₙ₋₁ ... d₁ d₀`, ערכו בשיטה דצימלית:

`ערך = dₙ * bⁿ + dₙ₋₁ * bⁿ⁻¹ + ... + d₁ * b¹ + d₀ * b⁰`

*   `dᵢ` - ספרה במדרגה ה-`i`
*   `b` - בסיס המערכת
*   `i` - מספר המדרגה (מימין לשמאל, מתחיל מ-0)

**דוגמה:**

המספר 123 בשיטה דצימלית: `1 * 10² + 2 * 10¹ + 3 * 10⁰ = 100 + 20 + 3 = 123`

**מדרגות:**

*   `d₀`: יחידות (`b⁰`)
*   `d₁`: `b` (`b¹`)
*   `d₂`: `b²`
*   `d₃`: `b³`
*   וכו'.

**חוקים:**

1.  **טווח ספרות:** ספרות מ-0 עד `b`-1.
2.  **עיקרון מיקום:** ערך הספרה תלוי במיקומה.
3.  **מעבר למדרגה הבאה:** כשמגיעים לערך `b`, עוברים למדרגה הבאה.

### דוגמה: מערכת מספרים פירותית

*   🍎 (תפוח)
*   🍐 (אגס)
*   🍉 (אבטיח)
*   🧺 (סל)

**חוקים:**

1.  3 🍎 = 1 🍐
2.  5 🍐 = 3 🍉
3.  2 🍉 = 1 🧺

**ייצוג מספרים:**

כמחרוזת, כאשר כל תו מייצג פרי. לדוגמה: "🍎🍎🍎" - 3 תפוחים, "🍉🍉" - 2 אבטיחים.

**פעולות אריתמטיות:**

ניתן לבצע חיבור וחיסור.

```python
def normalize_fruits(fruits: str) -> str:
    """
    מנרמל מחרוזת עם פירות לייצוג מינימלי.

    Args:
        fruits: מחרוזת עם פירות (🍎, 🍐, 🍉, 🧺).

    Returns:
        מחרוזת עם כמות מנורמלת של פירות.
    """
    apples = fruits.count('🍎')
    pears = fruits.count('🍐')
    melons = fruits.count('🍉')
    baskets = fruits.count('🧺')

    # המרת תפוחים לאגסים
    pears += apples // 3
    apples %= 3

    # המרת אגסים לאבטיחים
    melons += (pears * 3) // 5
    pears %= 5

    # המרת אבטיחים לסלים
    baskets += melons // 2
    melons %= 2

    # מרכיבים את המחרוזת חזרה
    return (
        "🧺" * baskets
        + "🍉" * melons
        + "🍐" * pears
        + "🍎" * apples
    )

def add_fruits(fruits1: str, fruits2: str) -> str:
    """
    מחבר שתי מחרוזות פירות.

    Args:
        fruits1: מחרוזת עם פירות.
        fruits2: מחרוזת עם פירות.

    Returns:
        מחרוזת עם סכום הפירות.
    """
    return normalize_fruits(fruits1 + fruits2)

def sub_fruits(fruits1: str, fruits2: str) -> str:
    """
    מחסר את המחרוזת השנייה מהראשונה, אם אפשרי.

    Args:
        fruits1: מחרוזת הפירות שממנה מחסירים.
        fruits2: מחרוזת הפירות שמחסרים.

    Returns:
        מחרוזת עם ההפרש, או "לא ניתן לחסר" אם התוצאה שלילית.
    """

    apples1 = fruits1.count('🍎')
    pears1 = fruits1.count('🍐')
    melons1 = fruits1.count('🍉')
    baskets1 = fruits1.count('🧺')

    apples2 = fruits2.count('🍎')
    pears2 = fruits2.count('🍐')
    melons2 = fruits2.count('🍉')
    baskets2 = fruits2.count('🧺')


    # ייצוג זמני בכמות כוללת של תפוחים
    total_apples1 = apples1 + pears1 * 3 + melons1 * 15 // 3 + baskets1 * 30
    total_apples2 = apples2 + pears2 * 3 + melons2 * 15 // 3 + baskets2 * 30

    if total_apples1 < total_apples2:
        return "לא ניתן לחסר"
    else:
        total_apples = total_apples1 - total_apples2

    # החזרת ייצוג מנורמל של סכום התפוחים
    result_fruits = ""
    baskets = total_apples // 30
    result_fruits += "🧺" * baskets
    total_apples %= 30
    melons = (total_apples*3) // 15
    result_fruits += "🍉" * melons
    total_apples %= 15
    pears = total_apples // 3
    result_fruits += "🍐" * pears
    total_apples %= 3
    result_fruits += "🍎" * total_apples

    return normalize_fruits(result_fruits)


# דוגמאות:
fruits1 = "🍎🍎🍎🍎🍎" # 5 תפוחים
fruits2 = "🍎🍎🍎" # 3 תפוחים
print(f"{fruits1} + {fruits2} = {add_fruits(fruits1, fruits2)}")

fruits3 = "🍐🍐"  # 2 אגסים
fruits4 = "🍎🍎🍎🍎" # 4 תפוחים
print(f"{fruits3} + {fruits4} = {add_fruits(fruits3, fruits4)}")

fruits5 = "🍉🍉" # 2 אבטיחים
fruits6 = "🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎🍎" # 15 תפוחים
print(f"{fruits5} + {fruits6} = {add_fruits(fruits5, fruits6)}")

fruits7 = "🧺🧺" # 2 סלים
fruits8 = "🍉🍉🍉" # 3 אבטיחים
print(f"{fruits7} + {fruits8} = {add_fruits(fruits7, fruits8)}")

fruits9 = "🧺🍉🍐🍎" # סל, אבטיח, אגס, תפוח
fruits10 = "🍉🍐🍎" # אבטיח, אגס, תפוח
print(f"{fruits9} - {fruits10} = {sub_fruits(fruits9, fruits10)}")

fruits11 = "🧺🍉" # סל, אבטיח
fruits12 = "🧺🍉🍎🍎🍎" # סל, אבטיח, 3 תפוחים
print(f"{fruits11} - {fruits12} = {sub_fruits(fruits11, fruits12)}")

fruits13 = "🍉🍉🍉" # 3 אבטיחים
fruits14 = "🍎🍎🍎🍎" # 4 תפוחים
print(f"{fruits13} - {fruits14} = {sub_fruits(fruits13, fruits14)}")

fruits15 = "🍐🍐🍐🍐🍐" # 5 אגסים
fruits16 = "🍉" # 1 אבטיח
print(f"{fruits15} - {fruits16} = {sub_fruits(fruits15, fruits16)}")
```

**הסבר קוד:**

1.  **`normalize_fruits(fruits)`:** ממירה מחרוזת פירות לצורה מינימלית. סופרת כל פרי, משתמשת בחוקים להמרה ליחידות גדולות יותר, ומחזירה מחרוזת מינימלית.
2.  **`add_fruits(fruits1, fruits2)`:** מחברת שתי מחרוזות פירות, ומנרמלת את התוצאה.
3.  **`sub_fruits(fruits1, fruits2)`:** מחסרת מחרוזת פירות אחת מהשנייה, ממירה את הכל ל"כמות תפוחים" לצורך חישוב, ומבצעת את החיסור, תוך כדי בדיקה אם החיסור אפשרי.
4.  **דוגמאות:** מציגות דוגמאות חיבור וחיסור שונות.

**משימות:**

1.  הוסף פונקציה לחישוב כפל פירות במספר שלם.
2.  יישם פונקציה להשוואת מחרוזות פירות.
3.  צור חוקים חדשים להחלפת פירות ושנה את הקוד.
4.  הוסף בדיקה לוודא שהמחרוזת מכילה רק תווים מותרים.
5.  יישם חיסור מתקדם יותר שמאפשר תוצאות שליליות.

## 2. מערכות מספריות קונקרטיות

כעת, נבחן מערכות מספריות קונקרטיות הנמצאות בשימוש נרחב.

### 2.1. מערכת בינארית (בסיס 2)

*   **ספרות:** 0, 1
*   **שימוש:** במחשבים לייצוג נתונים.

**דוגמה:**

`1011₂` (אחד אפס אחד אחד בבסיס 2) = `1 * 2³ + 0 * 2² + 1 * 2¹ + 1 * 2⁰ = 8 + 0 + 2 + 1 = 11₁₀`

```python
def bin_to_dec(binary: str) -> int:
    """
    ממיר מספר בינארי (מחרוזת) למספר דצימלי.

    Args:
        binary: מספר בינארי כמחרוזת.

    Returns:
        ייצוג דצימלי של המספר (מספר שלם).
    """
    decimal = 0  # אתחול ערך דצימלי
    power = 0  # אתחול חזקת 2
    for digit in reversed(binary):  # איטרציה על ספרות המספר הבינארי בסדר הפוך
        if digit == '1':
            decimal += 2 ** power  # הוספת 2 בחזקת המדרגה
        power += 1  # הגדלת המדרגה
    return decimal  # החזרת הערך הדצימלי

binary_number = "1011"
decimal_number = bin_to_dec(binary_number)
print(f"בינארי {binary_number} = דצימלי {decimal_number}")


def dec_to_bin(decimal: int) -> str:
    """
    ממיר מספר דצימלי (שלם) לייצוג בינארי (מחרוזת).

    Args:
        decimal: מספר דצימלי.

    Returns:
        ייצוג בינארי של המספר (מחרוזת).
    """
    if decimal == 0:  # אם המספר שווה ל-0
        return "0"  # החזרת "0"
    binary = ""  # אתחול מחרוזת לייצוג בינארי
    while decimal > 0:  # כל עוד המספר גדול מ-0
        binary = str(decimal % 2) + binary  # הוספת שארית חלוקה ב-2 להתחלה
        decimal = decimal // 2  # חלוקה בשלם של המספר ב-2
    return binary  # החזרת המחרוזת הבינארית

decimal_number = 11
binary_number = dec_to_bin(decimal_number)
print(f"דצימלי {decimal_number} = בינארי {binary_number}")
```

### 2.2. מערכת טרינארית (בסיס 3)

*   **ספרות:** 0, 1, 2
*   **שימוש:** בתחומים מסוימים במתמטיקה ומדעי המחשב.

**דוגמה:**

`210₃` (שתיים אחת אפס בבסיס 3) = `2 * 3² + 1 * 3¹ + 0 * 3⁰ = 18 + 3 + 0 = 21₁₀`

```python
def ternary_to_dec(ternary: str) -> int:
    """
    ממיר מספר טרינארי (מחרוזת) למספר דצימלי.

    Args:
        ternary: מספר טרינארי כמחרוזת.

    Returns:
        ייצוג דצימלי של המספר (מספר שלם).
    """
    decimal = 0  # אתחול ערך דצימלי
    power = 0  # אתחול חזקת 3
    for digit in reversed(ternary):  # איטרציה על ספרות המספר הטרינארי בסדר הפוך
        decimal += int(digit) * (3 ** power)  # הוספת ספרה כפול 3 בחזקת המדרגה
        power += 1  # הגדלת המדרגה
    return decimal  # החזרת הערך הדצימלי


ternary_number = "210"
decimal_number = ternary_to_dec(ternary_number)
print(f"טרינארי {ternary_number} = דצימלי {decimal_number}")


def dec_to_ternary(decimal: int) -> str:
    """
    ממיר מספר דצימלי (שלם) לייצוג טרינארי (מחרוזת).

    Args:
        decimal: מספר דצימלי.

    Returns:
        ייצוג טרינארי של המספר (מחרוזת).
    """
    if decimal == 0:  # אם המספר שווה ל-0
        return "0"  # החזרת "0"
    ternary = ""  # אתחול מחרוזת לייצוג טרינארי
    while decimal > 0:  # כל עוד המספר גדול מ-0
        ternary = str(decimal % 3) + ternary  # הוספת שארית חלוקה ב-3 להתחלה
        decimal = decimal // 3  # חלוקה בשלם של המספר ב-3
    return ternary  # החזרת המחרוזת הטרינארית


decimal_number = 21
ternary_number = dec_to_ternary(decimal_number)
print(f"דצימלי {decimal_number} = טרינארי {ternary_number}")
```

### 2.3. מערכת ספטנארית (בסיס 7)

*   **ספרות:** 0, 1, 2, 3, 4, 5, 6
*   **שימוש:** בתחומים מסוימים, וגם כימי השבוע הם דוגמה למערכת ספטנארית.

**דוגמה:**

`345₇` (שלוש ארבע חמש בבסיס 7) = `3 * 7² + 4 * 7¹ + 5 * 7⁰ = 147 + 28 + 5 = 180₁₀`

```python
def septenary_to_dec(septenary: str) -> int:
    """
    ממיר מספר ספטנארי (מחרוזת) למספר דצימלי.

    Args:
        septenary: מספר ספטנארי כמחרוזת.

    Returns:
        ייצוג דצימלי של המספר (מספר שלם).
    """
    decimal = 0  # אתחול ערך דצימלי
    power = 0  # אתחול חזקת 7
    for digit in reversed(septenary):  # איטרציה על ספרות המספר הספטנארי בסדר הפוך
        decimal += int(digit) * (7 ** power)  # הוספת ספרה כפול 7 בחזקת המדרגה
        power += 1  # הגדלת המדרגה
    return decimal  # החזרת הערך הדצימלי

septenary_number = "345"
decimal_number = septenary_to_dec(septenary_number)
print(f"ספטנארי {septenary_number} = דצימלי {decimal_number}")


def dec_to_septenary(decimal: int) -> str:
    """
    ממיר מספר דצימלי (שלם) לייצוג ספטנארי (מחרוזת).

    Args:
        decimal: מספר דצימלי.

    Returns:
        ייצוג ספטנארי של המספר (מחרוזת).
    """
    if decimal == 0: # אם המספר שווה ל-0
        return "0" # החזרת "0"
    septenary = ""  # אתחול מחרוזת לייצוג ספטנארי
    while decimal > 0:  # כל עוד המספר גדול מ-0
        septenary = str(decimal % 7) + septenary  # הוספת שארית חלוקה ב-7 להתחלה
        decimal = decimal // 7  # חלוקה בשלם של המספר ב-7
    return septenary  # החזרת המחרוזת הספטנארית

decimal_number = 180
septenary_number = dec_to_septenary(decimal_number)
print(f"דצימלי {decimal_number} = ספטנארי {septenary_number}")
```

### 2.4. מערכת דצימלית (בסיס 10)

*   **ספרות:** 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
*   **שימוש:** נפוצה ביום יום.

**דוגמה:**

`789₁₀` = `7 * 10² + 8 * 10¹ + 9 * 10⁰ = 700 + 80 + 9 = 789₁₀`

### 2.5. מערכת הקסדצימלית (בסיס 16)

*   **ספרות:** 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F (A=10, B=11, C=12, D=13, E=14, F=15).
*   **שימוש:** בתכנות לייצוג צבעים, כתובות זיכרון, קודי מכונה וכו'.

**דוגמה:**

`2AF₁₆` (שתיים איי אף בבסיס 16) = `2 * 16² + 10 * 16¹ + 15 * 16⁰ = 512 + 160 + 15 = 687₁₀`

```python
def hex_to_dec(hexadecimal: str) -> int:
    """
    ממיר מספר הקסדצימלי (מחרוזת) למספר דצימלי.

    Args:
        hexadecimal: מספר הקסדצימלי כמחרוזת.

    Returns:
        ייצוג דצימלי של המספר (מספר שלם).
    """
    decimal = 0  # אתחול ערך דצימלי
    power = 0  # אתחול חזקת 16
    for digit in reversed(hexadecimal):  # איטרציה על ספרות המספר ההקסדצימלי בסדר הפוך
        if digit.isdigit():  # אם הספרה היא מספר
            decimal += int(digit) * (16 ** power)  # הוספת ספרה כפול 16 בחזקת המדרגה
        elif digit.upper() == 'A':  # אם הספרה היא 'A'
            decimal += 10 * (16 ** power)  # הוספת 10 כפול 16 בחזקת המדרגה
        elif digit.upper() == 'B':  # אם הספרה היא 'B'
            decimal += 11 * (16 ** power)  # הוספת 11 כפול 16 בחזקת המדרגה
        elif digit.upper() == 'C':  # אם הספרה היא 'C'
            decimal += 12 * (16 ** power)  # הוספת 12 כפול 16 בחזקת המדרגה
        elif digit.upper() == 'D':  # אם הספרה היא 'D'
            decimal += 13 * (16 ** power)  # הוספת 13 כפול 16 בחזקת המדרגה
        elif digit.upper() == 'E':  # אם הספרה היא 'E'
            decimal += 14 * (16 ** power)  # הוספת 14 כפול 16 בחזקת המדרגה
        elif digit.upper() == 'F':  # אם הספרה היא 'F'
            decimal += 15 * (16 ** power)  # הוספת 15 כפול 16 בחזקת המדרגה
        power += 1  # הגדלת המדרגה
    return decimal  # החזרת הערך הדצימלי

hex_number = "2AF"
decimal_number = hex_to_dec(hex_number)
print(f"הקסדצימלי {hex_number} = דצימלי {decimal_number}")


def dec_to_hex(decimal: int) -> str:
    """
    ממיר מספר דצימלי (שלם) לייצוג הקסדצימלי (מחרוזת).

    Args:
        decimal: מספר דצימלי.

    Returns:
        ייצוג הקסדצימלי של המספר (מחרוזת).
    """
    if decimal == 0:  # אם המספר שווה ל-0
        return "0"  # החזרת "0"
    hex_digits = "0123456789ABCDEF"  # מחרוזת להתאמת שאריות וספרות הקסדצימליות
    hexadecimal = ""  # אתחול מחרוזת לייצוג הקסדצימלי
    while decimal > 0:  # כל עוד המספר גדול מ-0
        remainder = decimal % 16  # קבלת שארית חלוקה ב-16
        hexadecimal = hex_digits[remainder] + hexadecimal  # הוספת ספרה תואמת להתחלת המחרוזת ההקסדצימלית
        decimal = decimal // 16  # חלוקה בשלם של המספר ב-16
    return hexadecimal  # החזרת המחרוזת ההקסדצימלית


decimal_number = 687
hex_number = dec_to_hex(decimal_number)
print(f"דצימלי {decimal_number} = הקסדצימלי {hex_number}")
```

### 2.6. מערכת סקסאגסימלית (בסיס 60)

*   **ספרות:** 0-59 (בפועל משתמשים בשילוב סימנים).
*   **שימוש:** היסטורי, שימש בבבל העתיקה, משמש כיום למדידת זמן (שעות, דקות, שניות) וזוויות.

**דוגמה:**

`25:30:15₆₀` (25 מעלות, 30 דקות, 15 שניות) = `25 * 60² + 30 * 60¹ + 15 * 60⁰ = 25 * 3600 + 30 * 60 + 15 * 1 = 90000 + 1800 + 15 = 91815₁₀` (בסך הכל שניות)

## 3. דוגמאות למערכות מספרים בחיי היומיום

מערכות מספרים אינן רק מושגים מופשטים במתמטיקה, אלא גם שיטות המשמשות לקידוד מידע.

### 3.1. ספרות רומיות

מערכת שאינה מיקומית, משתמשת באותיות לטיניות לייצוג מספרים. עדיין משמשת למספור פרקים בספרים או לציון מאות שנים.

```python
import sys

def roman_to_int(roman_str: str) -> int:
    """
    ממיר מספר רומי (מחרוזת) למספר דצימלי.

    Args:
        roman_str: מספר רומי כמחרוזת.

    Returns:
        ייצוג דצימלי של המספר (מספר שלם).
    """
    roman_dict = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }

    number = 0
    roman_str = roman_str.replace("IV","IIII")
    roman_str = roman_str.replace("IX","VIIII")
    roman_str = roman_str.replace("XL","XXXX")
    roman_str = roman_str.replace("XC","LXXXX")
    roman_str = roman_str.replace("CD","CCCC")
    roman_str = roman_str.replace("CM","DCCCC")
    for char in roman_str:
        number += roman_dict[char]

    return number

# דוגמה לשימוש
if __name__ == '__main__':
    roman_number = sys.argv[1] # מקבל מספר רומי מארגומנט שורת הפקודה
    decimal_number = roman_to_int(roman_number)
    print(f"רומי {roman_number} = דצימלי {decimal_number}")
```

### 3.2. קוד מורס

מערכת קידוד תווים באמצעות שילובים של אותות קצרים וארוכים (נקודות וקווים). שימשה להעברת הודעות בטלגרף.

```python
import time
import platform

# מילון קוד מורס עם האלפבית הקירילי
morse_code_dict = {
    'A': '.-',    'А': '.-',
    'B': '-...',   'Б': '-...',
    'C': '-.-.',   'В': '.-',
    'D': '-..',    'Г': '--.',
    'E': '.',      'Д': '-..',
    'F': '..-.',   'Е': '.',
    'G': '--.',    'Ж': '...-',
    'H': '....',   'З': '--..',
    'I': '..',     'И': '..',
    'J': '.---',   'Й': '.---',
    'K': '-.-',    'К': '-.-',
    'L': '.-..',   'Л': '.-..',
    'M': '--',     'М': '--',
    'N': '-.',     'Н': '-.',
    'O': '---',    'О': '---',
    'P': '.--.',   'П': '.--.',
    'Q': '--.-',   'Р': '.-.',
    'R': '.-.',    'С': '...',
    'S': '...',    'Т': '-',
    'T': '-',      'У': '..-',
    'U': '..-',    'Ф': '..-.',
    'V': '...-',   'Х': '....-',
    'W': '.--',    'Ц': '-.-.',
    'X': '-..-',   'Ч': '---.',
    'Y': '-.--',   'Ш': '----',
    'Z': '--..',   'Щ': '--.-',
    '0': '-----',   'Ъ': '--.--',
    '1': '.----',  'Ы': '-.--',
    '2': '..---',  'Ь': '-..-',
    '3': '...--',  'Э': '..-..',
    '4': '....-',  'Ю': '..--',
    '5': '.....',  'Я': '.-.-',
    '6': '-....',
    '7': '--...',
    '8': '---..',
    '9': '----.',
    '.': '.-.-.-',
    ',': '--..--',
    '?': '..--..',
    "'": '.----.',
    '!': '-.-.--',
    '/': '-..-.',
    '(': '-.--.',
    ')': '-.--.-',
    '&': '.-...',
    ':': '---...',
    ';': '-.-.-.',
    '=': '-...-',
    '+': '.-.-.',
    '-': '-....-',
    '_': '..--.-',
    '"': '.-..-.',
    '$': '...-..-',
    '@': '.--.-.',
    ' ': '/'
}

def play_sound(duration):
    """
    מפיק צליל באורך מוגדר.
    """
    # For Windows
    if platform.system() == 'Windows':
        import winsound
        winsound.Beep(1000, duration)  # צפצוף ב-1000 הרץ למשך 'duration' מילישניות
    # For Linux/macOS
    else:
        import os
        os.system('printf "\\a"')  # מפיק צפצוף מערכת

def text_to_morse(text):
    """
    ממיר טקסט לקוד מורס.

    Args:
        text: מחרוזת טקסט.

    Returns:
        מחרוזת עם קוד מורס.
    """
    morse_code = ''
    for char in text.upper():
        if char in morse_code