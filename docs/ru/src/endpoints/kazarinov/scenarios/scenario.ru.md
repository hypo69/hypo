# Сценарий создания мехирона для Сергея Казаринова

## Обзор

Этот скрипт является частью директории `hypotez/src/endpoints/kazarinov/scenarios` и предназначен для автоматизации процесса создания "мехирона" для Сергея Казаринова. Скрипт извлекает, парсит и обрабатывает данные о продуктах от различных поставщиков, подготавливает данные, обрабатывает их через ИИ и интегрирует с Facebook для публикации продуктов.

## Подробней

Данный скрипт автоматизирует процесс сбора, обработки и публикации информации о продуктах. Он предназначен для упрощения и ускорения работы с данными от различных поставщиков, их анализа и представления в удобном для конечного пользователя виде. Код предоставляет возможность гибкой настройки параметров сбора и обработки данных, а также интеграцию с внешними платформами, такими как Facebook.

## Оглавление

- [Класс: `MexironBuilder`](#класс-mexironbuilder)
    - [Атрибуты](#атрибуты)
    - [Метод `__init__`](#метод-__init__)
    - [Метод `run_scenario`](#метод-run_scenario)
    - [Метод `get_graber_by_supplier_url`](#метод-get_graber_by_supplier_url)
    - [Метод `convert_product_fields`](#метод-convert_product_fields)
    - [Метод `save_product_data`](#метод-save_product_data)
    - [Метод `process_ai`](#метод-process_ai)
    - [Метод `post_facebook`](#метод-post_facebook)
    - [Метод `create_report`](#метод-create_report)
- [Использование](#использование)
- [Зависимости](#зависимости)
- [Обработка ошибок](#обработка-ошибок)
- [Вклад](#вклад)
- [Лицензия](#лицензия)

## Классы

### `MexironBuilder`

**Описание**:
Класс `MexironBuilder` предназначен для автоматизации процесса создания и обработки данных о продуктах, включая извлечение информации из различных источников, её обработку с использованием моделей искусственного интеллекта, а также интеграцию с платформой Facebook для публикации.

**Как работает класс**:
Класс инициализируется с использованием экземпляра Selenium WebDriver, который позволяет автоматизировать взаимодействие с веб-страницами. В процессе работы класс загружает конфигурации, устанавливает пути для экспорта данных, инициализирует модель ИИ и выполняет основной сценарий, который включает парсинг данных о продуктах, их обработку через ИИ и сохранение результатов.

#### Атрибуты:
- `driver`: Экземпляр Selenium WebDriver, используемый для автоматизации взаимодействия с веб-страницами.
- `export_path`: Путь для экспорта обработанных данных.
- `mexiron_name`: Пользовательское имя для процесса мехирона.
- `price`: Цена для обработки.
- `timestamp`: Метка времени для процесса.
- `products_list`: Список обработанных данных о продуктах.
- `model`: Модель Google Generative AI, используемая для обработки данных.
- `config`: Конфигурация, загруженная из JSON файла.

#### Методы:

- `__init__(self, driver: Driver, mexiron_name: Optional[str] = None)`

    **Назначение**:
    Инициализирует класс `MexironBuilder` с необходимыми компонентами, такими как драйвер, имя мехирона и параметры конфигурации.

    **Параметры**:
    - `driver` (Driver): Экземпляр Selenium WebDriver для управления браузером.
    - `mexiron_name` (Optional[str], optional): Пользовательское имя для процесса мехирона. По умолчанию `None`.

- `run_scenario(self, system_instruction: Optional[str] = None, price: Optional[str] = None, mexiron_name: Optional[str] = None, urls: Optional[str | List[str]] = None, bot = None) -> bool`

    **Назначение**:
    Выполняет основной сценарий: извлекает данные о продуктах, обрабатывает их через ИИ и сохраняет полученные данные.

    **Параметры**:
    - `system_instruction` (Optional[str], optional): Системные инструкции для модели ИИ. По умолчанию `None`.
    - `price` (Optional[str], optional): Цена для обработки. По умолчанию `None`.
    - `mexiron_name` (Optional[str], optional): Пользовательское имя мехирона. По умолчанию `None`.
    - `urls` (Optional[str | List[str]], optional): URL-ы страниц продуктов для обработки. Может быть строкой или списком строк. По умолчанию `None`.
    - `bot` (Optional[Any], optional): Бот для выполнения задач (тип не указан). По умолчанию `None`.

    **Возвращает**:
    - `bool`: `True`, если сценарий выполнен успешно, иначе `False`.

    **Как работает функция**:
    1. **Проверка источника URL**: Определяет, является ли URL из OneTab. Если да, извлекает данные оттуда.
    2. **Проверка валидности данных**: Убеждается, что полученные данные валидны. Если нет, возвращает сообщение об ошибке.
    3. **Поиск грабера**: Находит соответствующий грабер для заданного URL. Если грабер не найден, логирует ошибку.
    4. **Парсинг страницы**: Извлекает данные со страницы с помощью найденного грабера. В случае неудачи логирует ошибку.
    5. **Преобразование данных**: Конвертирует поля продукта в нужный формат. Логирует ошибку, если преобразование не удалось.
    6. **Сохранение данных**: Сохраняет преобразованные данные. Если данные не сохранены, логируется ошибка.
    7. **Обработка через AI**: Обрабатывает данные с помощью модели ИИ для языков `he` (иврит) и `ru` (русский).
    8. **Сохранение JSON**: Сохраняет результаты обработки в формате JSON для каждого языка. Логирует ошибки, если сохранение не удалось.
    9. **Генерация отчетов**: Создает HTML и PDF отчеты для каждого языка. Логирует ошибки, если создание отчета не удалось.
    10. **Отправка PDF через Telegram**: Отправляет PDF-файлы через Telegram. Логирует ошибки, если отправка не удалась.
    11. **Завершение**: Завершает сценарий, возвращая `True`.

    **Внутренние функции**: Отсутствуют

- `get_graber_by_supplier_url(self, url: str)`

    **Назначение**:
    Возвращает соответствующий грабер для данного URL поставщика.

    **Параметры**:
    - `url` (str): URL страницы поставщика.

    **Возвращает**:
    - Экземпляр грабера, если найден, иначе `None`.

    **Как работает функция**:
    1. Функция проверяет, содержит ли URL поставщика определенные домены или подстроки, чтобы определить, какой грабер следует использовать.
    2. В зависимости от соответствия URL с известными поставщиками, функция создает и возвращает экземпляр соответствующего грабера.
    3. Если URL не соответствует ни одному из известных поставщиков, функция возвращает `None`.

    **Внутренние функции**: Отсутствуют

- `convert_product_fields(self, f: ProductFields) -> dict`

    **Назначение**:
    Конвертирует поля продукта в словарь.

    **Параметры**:
    - `f` (ProductFields): Объект, содержащий парсированные данные о продукте.

    **Возвращает**:
    - `dict`: Форматированный словарь данных о продукте.

    **Как работает функция**:
    1. Функция принимает объект `f` типа `ProductFields`, который содержит парсированные данные о продукте.
    2. Создается словарь `product_data`, в который переносятся значения из объекта `f`.
    3. При переносе данных происходит форматирование, например, добавление префикса "UAH" к цене, если это необходимо.
    4. Функция возвращает словарь `product_data`, содержащий отформатированные данные о продукте.

    **Внутренние функции**: Отсутствуют

- `save_product_data(self, product_data: dict)`

    **Назначение**:
    Сохраняет данные о продукте в файл.

    **Параметры**:
    - `product_data` (dict): Форматированные данные о продукте.

    **Как работает функция**:
    1. Функция принимает словарь `product_data`, содержащий данные о продукте.
    2. Формируется имя файла для сохранения данных, включающее текущую метку времени и имя мехирона.
    3. Данные записываются в JSON-файл с указанным именем.
    4. В случае возникновения исключения при записи данных, функция логирует ошибку и возвращает `False`.

    **Внутренние функции**: Отсутствуют

- `process_ai(self, products_list: List[str], lang: str, attempts: int = 3) -> tuple | bool`

    **Назначение**:
    Обрабатывает список продуктов через модель ИИ.

    **Параметры**:
    - `products_list` (List[str]): Список словарей данных о продуктах в виде строки.
    - `lang` (str): Язык, на котором нужно обработать данные.
    - `attempts` (int, optional): Количество попыток повторного запроса в случае неудачи. По умолчанию `3`.

    **Возвращает**:
    - `tuple | bool`: Обработанный ответ в форматах `ru` и `he`, или `False` в случае неудачи.

    **Как работает функция**:
    1. Функция принимает список продуктов `products_list`, язык `lang` и количество попыток `attempts`.
    2. Внутри функции происходит взаимодействие с моделью Google Generative AI для обработки данных о продуктах.
    3. Функция отправляет запрос к модели с системными инструкциями и данными о продуктах, ожидая получить обработанный ответ.
    4. В случае возникновения ошибки при взаимодействии с моделью, функция повторяет запрос указанное количество раз.
    5. Если после нескольких попыток получить ответ не удается, функция возвращает `False`.

    **Внутренние функции**: Отсутствуют

- `post_facebook(self, mexiron: SimpleNamespace) -> bool`

    **Назначение**:
    Выполняет сценарий публикации в Facebook.

    **Параметры**:
    - `mexiron` (SimpleNamespace): Обработанные данные для публикации.

    **Возвращает**:
    - `bool`: `True`, если публикация успешна, иначе `False`.

    **Как работает функция**:
    1. Функция принимает объект `mexiron`, содержащий обработанные данные, предназначенные для публикации в Facebook.
    2. Внутри функции происходит вызов соответствующего сценария для публикации данных в Facebook.
    3. Функция возвращает `True`, если публикация прошла успешно, и `False` в противном случае.

    **Внутренние функции**: Отсутствуют

- `create_report(self, data: dict, html_file: Path, pdf_file: Path)`

    **Назначение**:
    Генерирует HTML и PDF отчеты из обработанных данных.

    **Параметры**:
    - `data` (dict): Обработанные данные.
    - `html_file` (Path): Путь для сохранения HTML отчета.
    - `pdf_file` (Path): Путь для сохранения PDF отчета.

    **Как работает функция**:
    1. Функция принимает обработанные данные `data`, а также пути для сохранения HTML и PDF отчетов.
    2. Внутри функции происходит генерация HTML-отчета на основе предоставленных данных и сохранение его по указанному пути.
    3. Затем генерируется PDF-отчет на основе HTML-отчета и сохраняется по указанному пути.

    **Внутренние функции**: Отсутствуют

## Использование

Для использования этого скрипта выполните следующие шаги:

1. **Инициализация Driver**: Создайте экземпляр класса `Driver`.
2. **Инициализация MexironBuilder**: Создайте экземпляр класса `MexironBuilder` с драйвером.
3. **Запуск сценария**: Вызовите метод `run_scenario` с необходимыми параметрами.

#### Пример

```python
from src.webdriver.driver import Driver
from src.endpoints.kazarinov.scenarios.scenario_pricelist import MexironBuilder

# Инициализация Driver
driver = Driver(...)

# Инициализация MexironBuilder
mexiron_builder = MexironBuilder(driver)

# Запуск сценария
urls = ['https://example.com/product1', 'https://example.com/product2']
mexiron_builder.run_scenario(urls=urls)
```

## Зависимости

- `selenium`: Для веб-автоматизации.
- `asyncio`: Для асинхронных операций.
- `pathlib`: Для обработки путей к файлам.
- `types`: Для создания простых пространств имен.
- `typing`: Для аннотаций типов.
- `src.ai.gemini`: Для обработки данных через ИИ.
- `src.suppliers.*.graber`: Для извлечения данных от различных поставщиков.
- `src.endpoints.advertisement.facebook.scenarios`: Для публикации в Facebook.

## Обработка ошибок

Скрипт включает надежную обработку ошибок, чтобы обеспечить продолжение выполнения даже в случае, если некоторые элементы не найдены или если возникли проблемы с веб-страницей. Это особенно полезно для обработки динамических или нестабильных веб-страниц.

## Вклад

Вклад в этот скрипт приветствуется. Пожалуйста, убедитесь, что любые изменения хорошо документированы и включают соответствующие тесты.

## Лицензия

Этот скрипт лицензирован под MIT License. Подробности смотрите в файле `LICENSE`.