# Модуль для работы с Qwen Qwen-2.5 через Hugging Face Space
## Обзор

Модуль `Qwen_Qwen_2_5.py` предоставляет асинхронный интерфейс для взаимодействия с моделью Qwen Qwen-2.5, размещенной на Hugging Face Space. Он позволяет генерировать текст на основе предоставленных сообщений, поддерживая потоковую передачу результатов и использование системных сообщений. Модуль использует `aiohttp` для выполнения асинхронных HTTP-запросов и обеспечивает обработку ответов в формате JSON.

## Подробнее

Этот модуль предназначен для интеграции с другими компонентами проекта `hypotez`, которые требуют взаимодействия с языковой моделью Qwen Qwen-2.5. Он обрабатывает запросы к API Hugging Face Space, форматирует входные данные и возвращает сгенерированный текст.

## Классы

### `Qwen_Qwen_2_5`

**Описание**: Класс `Qwen_Qwen_2_5` является асинхронным генератором и предоставляет интерфейс для работы с моделью Qwen Qwen-2.5.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию.
- `ProviderModelMixin`: Предоставляет общие методы для работы с моделями.

**Атрибуты**:
- `label` (str): Метка провайдера, `"Qwen Qwen-2.5"`.
- `url` (str): URL Hugging Face Space, `"https://qwen-qwen2-5.hf.space"`.
- `api_endpoint` (str): URL API для отправки запросов, `"https://qwen-qwen2-5.hf.space/queue/join"`.
- `working` (bool): Флаг, указывающий на работоспособность провайдера, `True`.
- `supports_stream` (bool): Флаг, указывающий на поддержку потоковой передачи, `True`.
- `supports_system_message` (bool): Флаг, указывающий на поддержку системных сообщений, `True`.
- `supports_message_history` (bool): Флаг, указывающий на поддержку истории сообщений, `False`.
- `default_model` (str): Модель по умолчанию, `"qwen-qwen2-5"`.
- `model_aliases` (dict): Псевдонимы моделей, `{"qwen-2.5": default_model}`.
- `models` (list): Список поддерживаемых моделей, `list(model_aliases.keys())`.

**Методы**:

- `create_async_generator(model: str, messages: Messages, proxy: str = None, **kwargs) -> AsyncResult`: Создает асинхронный генератор для получения ответов от модели.

## Функции

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для получения ответов от модели Qwen Qwen-2.5.

    Args:
        model (str): Имя модели.
        messages (Messages): Список сообщений для отправки модели.
        proxy (str, optional): URL прокси-сервера. По умолчанию `None`.
        **kwargs: Дополнительные параметры.

    Returns:
        AsyncResult: Асинхронный генератор, выдающий фрагменты текста.

    Raises:
        aiohttp.ClientError: Если возникает ошибка при выполнении HTTP-запроса.
        json.JSONDecodeError: Если не удается декодировать JSON-ответ.

    """
```

**Назначение**: Функция `create_async_generator` создает и возвращает асинхронный генератор, который отправляет запросы к API Qwen Qwen-2.5 и выдает сгенерированный текст по частям.

**Параметры**:
- `cls`: Ссылка на класс `Qwen_Qwen_2_5`.
- `model` (str): Имя используемой модели.
- `messages` (Messages): Список сообщений, отправляемых модели. Каждое сообщение содержит роль (`"system"`, `"user"`, `"assistant"`) и содержимое (`"content"`).
- `proxy` (str, optional): URL прокси-сервера для использования при подключении. По умолчанию `None`.
- `kwargs` (dict): Дополнительные параметры, которые могут быть переданы в функцию.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, который выдает фрагменты текста, сгенерированные моделью.

**Вызывает исключения**:
- `aiohttp.ClientError`: Если возникает ошибка при выполнении HTTP-запроса (например, при подключении к API или при передаче данных).
- `json.JSONDecodeError`: Если не удается декодировать JSON-ответ, полученный от API.

**Как работает функция**:

1. **Генерация уникального идентификатора сессии (`session_hash`)**:
   - Создается уникальный идентификатор сессии для каждого запроса.

2. **Подготовка заголовков (`headers_join`)**:
   - Формируются заголовки HTTP-запроса, необходимые для подключения к API.

3. **Подготовка промпта**:
   - Извлекается системное сообщение из списка сообщений. Если системное сообщение отсутствует, используется сообщение по умолчанию.
   - Форматируется промпт для отправки в API.

4. **Подготовка полезной нагрузки (`payload_join`)**:
   - Формируется полезная нагрузка для отправки в API, включающая промпт, системное сообщение и идентификатор сессии.

5. **Отправка запроса на присоединение и получение идентификатора события**:
   - Отправляется POST-запрос к API для присоединения к очереди обработки запросов.
   - Получается идентификатор события (`event_id`) из JSON-ответа.

6. **Подготовка запроса потока данных**:
   - Формируются URL и заголовки для запроса потока данных.

7. **Отправка запроса потока данных и обработка ответов**:
   - Отправляется GET-запрос к API для получения потока данных.
   - Читаются строки из потока данных, декодируются и обрабатываются.
   - Извлекаются фрагменты текста из JSON-ответов и выдаются через генератор.
   - Проверяется завершение обработки запроса и выдается оставшаяся часть текста.

8. **Обработка ошибок**:
   - При возникновении ошибок декодирования JSON-ответа, информация об ошибке логируется.

**Внутренние функции**:

- `generate_session_hash()`:
    ```python
    def generate_session_hash():
        """Generate a unique session hash."""
        return str(uuid.uuid4()).replace('-', '')[:10]
    ```
    **Назначение**: Генерирует уникальный идентификатор сессии, используемый для связи между запросами к API.

    **Как работает функция**:
    1. Генерируется UUID (Universally Unique Identifier) с помощью `uuid.uuid4()`.
    2. Удаляются все дефисы из UUID с помощью `replace('-', '')`.
    3. Извлекаются первые 10 символов полученной строки с помощью `[:10]`.
    4. Возвращается полученная строка.

    **Примеры**:
    ```python
    >>> generate_session_hash()
    'a1b2c3d4e5'
    ```

**ASCII flowchart**:

```
    [Начало]
        |
        V
    [Генерация session_hash]
        |
        V
    [Подготовка headers_join]
        |
        V
    [Подготовка prompt]
        |
        V
    [Подготовка payload_join]
        |
        V
    [Отправка POST-запроса к api_endpoint]
        |
        V
    [Получение event_id из ответа]
        |
        V
    [Подготовка url_data, headers_data, params_data]
        |
        V
    [Отправка GET-запроса к url_data]
        |
        V
    [Чтение и декодирование строк из ответа]
        |
        V
    [Обработка JSON-ответов]
        |
        V
    [Извлечение и выдача фрагментов текста]
        |
        V
    [Проверка завершения обработки]
        |
        V
    [Выдача оставшейся части текста]
        |
        V
    [Конец]
```

**Примеры**:

```python
# Пример использования (необходимо запустить в асинхронном контексте)
import asyncio
from src.endpoints.gpt4free.g4f.typing import Messages
async def main():
    model = "qwen-qwen2-5"
    messages: Messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Hello, how are you?"}
    ]
    async for fragment in Qwen_Qwen_2_5.create_async_generator(model=model, messages=messages):
        print(fragment, end="")

if __name__ == "__main__":
    asyncio.run(main())
```
В этом примере создается асинхронный генератор для модели "qwen-qwen2-5" и отправляется запрос с системным сообщением и вопросом пользователя.  Результат выводится на экран по мере поступления фрагментов текста.