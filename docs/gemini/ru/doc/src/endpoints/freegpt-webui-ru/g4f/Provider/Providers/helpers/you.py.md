# Модуль `you.py`

## Обзор

Модуль предназначен для взаимодействия с API `you.com` для получения ответов на запросы, отправленные в формате, совместимом с чат-интерфейсом. Он преобразует входные сообщения, формирует параметры запроса и обрабатывает потоковые ответы, выводя их в консоль.

## Подробней

Этот модуль является частью проекта `hypotez` и используется для обеспечения взаимодействия с `you.com`. Он обрабатывает сообщения, отправленные пользователем, преобразует их в формат, ожидаемый API `you.com`, и отправляет запрос. Полученные ответы обрабатываются и выводятся в консоль. Модуль также содержит механизм повторных попыток в случае возникновения ошибок при отправке запроса.

## Функции

### `transform`

```python
def transform(messages: list) -> list:
    """Преобразует список сообщений в формат, подходящий для API you.com.

    Args:
        messages (list): Список сообщений, где каждое сообщение представляет собой словарь с ключами 'role' и 'content'.

    Returns:
        list: Преобразованный список сообщений в формате, ожидаемом API you.com. Каждое сообщение - это словарь с ключами 'question' и 'answer'.
    """
```

**Назначение**: Преобразование списка сообщений в формат, который понимает API `you.com`.

**Параметры**:
- `messages` (list): Список сообщений, где каждое сообщение представляет собой словарь с ключами `'role'` (роль отправителя: `'user'`, `'assistant'` или `'system'`) и `'content'` (содержимое сообщения).

**Возвращает**:
- `list`: Преобразованный список сообщений, где каждое сообщение представляет собой словарь с ключами `'question'` (вопрос) и `'answer'` (ответ). Если роль сообщения `'user'`, то сообщение разделяется на вопрос и ответ. Если роль `'assistant'`, то сообщение добавляется как ответ. Если роль `'system'`, то сообщение добавляется как вопрос.

**Как работает функция**:

1.  Инициализируется пустой список `result` для хранения преобразованных сообщений и индекс `i` для итерации по списку `messages`.
2.  Цикл `while` проходит по списку сообщений.
3.  Если роль сообщения `'user'`, извлекается содержимое сообщения как вопрос (`question`). Затем проверяется следующее сообщение:
    *   Если следующее сообщение существует и его роль `'assistant'`, извлекается содержимое как ответ (`answer`).
    *   Иначе, ответ устанавливается как пустая строка.
    *   Вопрос и ответ добавляются в `result` как словарь `{'question': question, 'answer': answer}`.
4.  Если роль сообщения `'assistant'`, извлекается содержимое сообщения и добавляется в `result` как словарь `{'question': '', 'answer': messages[i]['content']}`.
5.  Если роль сообщения `'system'`, извлекается содержимое сообщения и добавляется в `result` как словарь `{'question': messages[i]['content'], 'answer': ''}`.
6.  Функция возвращает преобразованный список `result`.

**Пример работы функции**:

```
messages = [
    {'role': 'user', 'content': 'Привет'},
    {'role': 'assistant', 'content': 'Здравствуйте!'},
    {'role': 'system', 'content': 'Как дела?'}
]
transformed_messages = transform(messages)
print(transformed_messages)
# Вывод:
# [{'question': 'Привет', 'answer': 'Здравствуйте!'}, {'question': 'Как дела?', 'answer': ''}]
```

**ASCII flowchart**:

```
Начало
  ↓
Инициализация result = [], i = 0
  ↓
Цикл while i < len(messages)
  │
  ├───> messages[i]['role'] == 'user'?
  │     ├───> Да
  │     │     ↓
  │     │     question = messages[i]['content']
  │     │     ↓
  │     │     i++
  │     │     ↓
  │     │     i < len(messages) and messages[i]['role'] == 'assistant'?
  │     │     ├───> Да
  │     │     │     ↓
  │     │     │     answer = messages[i]['content']
  │     │     │     ↓
  │     │     │     i++
  │     │     │
  │     │     └───> Нет
  │     │           ↓
  │     │           answer = ''
  │     │     ↓
  │     │     result.append({'question': question, 'answer': answer})
  │     │     ↓
  │     └───> Нет
  │           │
  │           ├───> messages[i]['role'] == 'assistant'?
  │           │     ├───> Да
  │           │     │     ↓
  │           │     │     result.append({'question': '', 'answer': messages[i]['content']})
  │           │     │     ↓
  │           │     │     i++
  │           │     │
  │           │     └───> Нет
  │           │           ↓
  │           │           messages[i]['role'] == 'system'?
  │           │           ├───> Да
  │           │           │     ↓
  │           │           │     result.append({'question': messages[i]['content'], 'answer': ''})
  │           │           │     ↓
  │           │           │     i++
  │           │           │
  │           │           └───> Нет
  │           │                 ↓
  │           │                 # Обработка неизвестной роли (опционально, можно добавить логирование)
  │           │
  │           └───> Конец цикла
  │
  ↓
Возврат result
```

### `output`

```python
def output(chunk):
    """Выводит содержимое чанка данных, полученного от API you.com, в консоль.

    Args:
        chunk (bytes): Чанк данных, полученный от API.
    """
```

**Назначение**: Вывод чанка данных, полученного от API `you.com`, в консоль.

**Параметры**:
- `chunk` (bytes): Чанк данных, полученный от API.

**Как работает функция**:

1.  Проверяет, содержит ли чанк байтов строку `b'"youChatToken"'`.
2.  Если содержит, декодирует чанк, разделяет его по строке `'data: '` и загружает JSON из второй части разделенной строки.
3.  Печатает значение ключа `'youChatToken'` из загруженного JSON в консоль, сбрасывая буфер вывода (`flush=True`) и не добавляя символ новой строки в конце (`end = ''`).

**Пример**:

```
chunk = b'data: {"youChatToken": "some_token"}'
output(chunk)  # Выведет: some_token
```

**ASCII flowchart**:

```
Начало
  ↓
chunk содержит b'"youChatToken"'?
  ├───> Да
  │     ↓
  │     Декодировать chunk и разделить по 'data: '
  │     ↓
  │     Загрузить JSON из второй части
  │     ↓
  │     Вывести chunk_json['youChatToken'] в консоль
  │
  └───> Нет
        ↓
Конец
```

## Переменные

### `headers`

```python
headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Sec-Fetch-Site': 'same-origin',
    'Accept-Language': 'en-GB,en;q=0.9',
    'Sec-Fetch-Mode': 'navigate',
    'Host': 'you.com',
    'Origin': 'https://you.com',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15',
    'Referer': 'https://you.com/api/streamingSearch?q=nice&safeSearch=Moderate&onShoppingPage=false&mkt=&responseFilter=WebPages,Translations,TimeZone,Computation,RelatedSearches&domain=youchat&queryTraceId=7a6671f8-5881-404d-8ea3-c3f8301f85ba&chat=%5B%7B%22question%22%3A%22hi%22%2C%22answer%22%3A%22Hello!%20How%20can%20I%20assist%20you%20today%3F%22%7D%5D&chatId=7a6671f8-5881-404d-8ea3-c3f8301f85ba&__cf_chl_tk=ex2bw6vn5vbLsUm8J5rDYUC0Bjzc1XZqka6vUl6765A-1684108495-0-gaNycGzNDtA',
    'Connection': 'keep-alive',
    'Sec-Fetch-Dest': 'document',
    'Priority': 'u=0, i',
}
```

**Описание**: Словарь, содержащий заголовки HTTP-запроса, используемые при взаимодействии с API `you.com`.

**Назначение**: Заголовки необходимы для правильной аутентификации и обработки запросов сервером `you.com`. Они включают в себя информацию о типе контента, принимаемых типах данных, языке, режиме и месте отправки запроса, хосте, источнике запроса, user-agent, реферере, типе соединения, месте назначения запроса и приоритете.

### `params`

```python
params = urllib.parse.urlencode({
    'q': prompt,
    'domain': 'youchat',
    'chat': transform(messages)
})
```

**Описание**: Строка, содержащая параметры запроса, закодированные в формате URL.

**Назначение**: Параметры запроса передаются в URL при отправке запроса к API `you.com`. Они включают в себя вопрос (`q`), домен (`domain`) и историю чата (`chat`), преобразованную функцией `transform`.

## Логика работы модуля:

1.  **Чтение конфигурации**: Модуль начинает с чтения конфигурации из аргументов командной строки. Ожидается, что конфигурация будет передана в формате JSON.
2.  **Преобразование сообщений**: Список сообщений преобразуется в формат, необходимый для API `you.com`, с использованием функции `transform`.
3.  **Формирование параметров запроса**: Формируются параметры запроса, включающие вопрос, домен и преобразованные сообщения.
4.  **Отправка запроса и обработка ответа**: Модуль отправляет GET-запрос к API `you.com` с использованием библиотеки `curl_cffi`. Функция `output` используется для обработки потоковых данных, возвращаемых API.
5.  **Обработка ошибок**: В случае возникновения ошибки при отправке запроса, модуль повторяет попытку.