# Модуль `html2text`

## Обзор

Модуль `html2text` предназначен для конвертации HTML-документов в Markdown-форматированный текст. Он обеспечивает базовую функциональность для преобразования структуры HTML в удобочитаемый текстовый формат, поддерживая различные элементы, такие как заголовки, списки, ссылки и изображения.

## Подробней

Этот модуль полезен для извлечения текста из HTML-контента с сохранением основной структуры документа. Он может быть использован для автоматической генерации документации, создания текстовых превью веб-страниц или для анализа контента веб-сайтов.

## Классы

### `_html2text`

**Описание**:
Класс `_html2text` является основным парсером HTML, который наследуется от `HTMLParser.HTMLParser`. Он отвечает за обработку HTML-тегов и преобразование их в Markdown-форматированный текст.

**Как работает класс**:
Класс `_html2text` инициализируется с возможностью принимать функцию вывода (`out`) и базовый URL (`baseurl`). В процессе работы он использует методы `handle_starttag`, `handle_endtag` и `handle_data` для обработки HTML-тегов, начальных и конечных тегов, а также текстовых данных соответственно. Результат сохраняется во внутреннем буфере и может быть получен после завершения обработки.

**Методы**:
- `__init__(self, out=None, baseurl='')`: Инициализирует экземпляр класса `_html2text`.
- `feed(self, data)`: Обрабатывает HTML-данные, заменяя `<'/+'script>` на `</ignore>`.
- `outtextf(self, s)`: Добавляет текст в буфер вывода.
- `close(self)`: Завершает обработку HTML и возвращает преобразованный текст.
- `handle_charref(self, c)`: Обрабатывает символьные ссылки.
- `handle_entityref(self, c)`: Обрабатывает именованные ссылки на сущности.
- `handle_starttag(self, tag, attrs)`: Обрабатывает начальные теги HTML.
- `handle_endtag(self, tag)`: Обрабатывает конечные теги HTML.
- `previousIndex(self, attrs)`: Проверяет, есть ли заданный набор атрибутов (ссылки) в списке `self.a`.
- `drop_last(self, nLetters)`: Удаляет `nLetters` последних символов из `self.outtext`, если не включен тихий режим.
- `handle_emphasis(self, start, tag_style, parent_style)`: Обрабатывает различные текстовые выделения.
- `handle_tag(self, tag, attrs, start)`: Обрабатывает HTML-теги, определяя их начало и конец.
- `pbr(self)`: Добавляет один перенос строки, если необходимо.
- `p(self)`: Добавляет два переноса строки.
- `soft_br(self)`: Добавляет мягкий перенос строки.
- `o(self, data, puredata=0, force=0)`: Выводит данные с учетом различных условий (тихий режим, предварительное форматирование и т.д.).
- `handle_data(self, data)`: Обрабатывает текстовые данные внутри HTML-тегов.
- `unknown_decl(self, data)`: Обрабатывает неизвестные объявления.

## Функции

### `name2cp`

```python
def name2cp(k) -> int | None:
    """
    Args:
        k (str): Имя символа HTML.

    Returns:
        int | None: Unicode codepoint или None, если не найден.

    Raises:
        KeyError: Если `k` нет в `htmlentitydefs.entitydefs`.

    Example:
        >>> name2cp('copy')
        169
    """
```

**Описание**:
Преобразует имя HTML-сущности в соответствующий код Unicode.

**Как работает функция**:
Функция `name2cp` принимает имя HTML-сущности и возвращает соответствующий код Unicode. Сначала она проверяет, является ли сущность `'apos'`. Затем проверяет, поддерживает ли `htmlentitydefs` прямой словарь `name2codepoint`. В противном случае она ищет имя в `htmlentitydefs.entitydefs`, преобразует его в числовой код, если это необходимо, и возвращает соответствующий символ Unicode.

**Параметры**:
- `k` (str): Имя HTML-сущности.

**Возвращает**:
- `int | None`: Код Unicode, соответствующий имени сущности, или `None`, если сущность не найдена.

**Вызывает исключения**:
- `KeyError`: Если имя сущности отсутствует в `htmlentitydefs.entitydefs`.

### `charref`

```python
def charref(name: str) -> str:
    """
    Args:
        name (str): Имя символьной ссылки.

    Returns:
        str: Символ, соответствующий числовой ссылке.

    Raises:
        NameError: Если `chr` не определен.

    Example:
        >>> charref('169')
        '©'
    """
```

**Описание**:
Преобразует числовую HTML-ссылку на символ в Unicode.

**Как работает функция**:
Функция `charref` принимает числовую ссылку на символ и преобразует её в символ Unicode. Сначала она определяет, является ли ссылка шестнадцатеричной или десятичной. Затем она преобразует ссылку в целое число и возвращает соответствующий символ Unicode. Если `UNICODE_SNOB` не установлен и символ есть в `unifiable_n`, возвращается соответствующее значение из `unifiable_n`.

**Параметры**:
- `name` (str): Числовая ссылка на символ.

**Возвращает**:
- `str`: Символ, соответствующий числовой ссылке.

**Вызывает исключения**:
- `NameError`: Если функция `chr` не определена (например, в Python 2).

### `entityref`

```python
def entityref(c: str) -> str:
    """
    Args:
        c (str): Имя сущности.

    Returns:
        str: Символ, соответствующий имени сущности.

    Raises:
        KeyError: Если имя сущности не найдено.
        NameError: Если `chr` не определен.

    Example:
        >>> entityref('copy')
        '(C)'
    """
```

**Описание**:
Преобразует именованную HTML-ссылку на сущность в Unicode.

**Как работает функция**:
Функция `entityref` принимает имя HTML-сущности и возвращает соответствующий символ Unicode. Если `UNICODE_SNOB` не установлен и имя сущности есть в `unifiable`, возвращается соответствующее значение из `unifiable`. В противном случае функция пытается преобразовать имя сущности в числовой код и вернуть соответствующий символ Unicode.

**Параметры**:
- `c` (str): Имя HTML-сущности.

**Возвращает**:
- `str`: Символ, соответствующий имени сущности.

**Вызывает исключения**:
- `KeyError`: Если имя сущности не найдено.
- `NameError`: Если функция `chr` не определена (например, в Python 2).

### `replaceEntities`

```python
def replaceEntities(s: re.Match) -> str:
    """
    Args:
        s (re.Match): Объект Match, содержащий имя группы.

    Returns:
        str: Символ, соответствующий имени сущности или числовой ссылке.

    Raises:
        Нет явных исключений.

    Example:
        >>> replaceEntities(re.search(r"&(#?[xX]?(?:[0-9a-fA-F]+|\\w{1,8}));", "Example with &#169;"))
        '©'
    """
```

**Описание**:
Заменяет HTML-сущности и числовые ссылки на соответствующие символы.

**Как работает функция**:
Функция `replaceEntities` принимает объект Match, содержащий имя группы, и заменяет HTML-сущности и числовые ссылки на соответствующие символы. Сначала она извлекает имя группы из объекта Match. Затем она проверяет, является ли это числовой ссылкой или именованной сущностью, и вызывает соответствующие функции (`charref` или `entityref`) для преобразования.

**Параметры**:
- `s` (re.Match): Объект Match, содержащий имя группы.

**Возвращает**:
- `str`: Символ, соответствующий имени сущности или числовой ссылке.

### `unescape`

```python
def unescape(s: str) -> str:
    """
    Args:
        s (str): Строка, содержащая HTML-сущности или числовые ссылки.

    Returns:
        str: Строка с замененными HTML-сущностями и числовыми ссылками.

    Raises:
        Нет явных исключений.

    Example:
        >>> unescape("Example with &#169;")
        'Example with ©'
    """
```

**Описание**:
Заменяет HTML-сущности и числовые ссылки в строке на соответствующие символы.

**Как работает функция**:
Функция `unescape` принимает строку, содержащую HTML-сущности и числовые ссылки, и заменяет их на соответствующие символы. Она использует регулярное выражение `r_unescape` для поиска всех HTML-сущностей и числовых ссылок в строке, а затем вызывает функцию `replaceEntities` для каждой найденной сущности или ссылки.

**Параметры**:
- `s` (str): Строка, содержащая HTML-сущности или числовые ссылки.

**Возвращает**:
- `str`: Строка с замененными HTML-сущностями и числовыми ссылками.

### `onlywhite`

```python
def onlywhite(line: str) -> bool:
    """Return true if the line does only consist of whitespace characters."""
```

**Описание**:
Проверяет, состоит ли строка только из пробельных символов.

**Как работает функция**:
Функция `onlywhite` принимает строку и возвращает `True`, если строка состоит только из пробельных символов. В противном случае она возвращает `False`.

**Параметры**:
- `line` (str): Строка для проверки.

**Возвращает**:
- `bool`: `True`, если строка состоит только из пробельных символов, `False` в противном случае.

### `optwrap`

```python
def optwrap(text: str) -> str:
    """Wrap all paragraphs in the provided text."""
```

**Описание**:
Переносит все параграфы в предоставленном тексте.

**Как работает функция**:
Функция `optwrap` принимает текст и переносит все параграфы в соответствии с заданной шириной `BODY_WIDTH`. Если `BODY_WIDTH` равен 0, функция возвращает текст без изменений.

**Параметры**:
- `text` (str): Текст для переноса.

**Возвращает**:
- `str`: Текст с перенесенными параграфами.

### `hn`

```python
def hn(tag: str) -> int | None:
    """
    Args:
        tag (str): HTML тег.

    Returns:
        int | None: Уровень заголовка или None, если тег не является заголовком.

    Raises:
        ValueError: Если tag[1] не является целым числом.

    Example:
        >>> hn('h1')
        1
        >>> hn('div')
    """
```

**Описание**:
Определяет уровень заголовка HTML-тега.

**Как работает функция**:
Функция `hn` принимает HTML-тег и возвращает уровень заголовка, если тег является заголовком (h1-h9). В противном случае она возвращает `None`.

**Параметры**:
- `tag` (str): HTML-тег для проверки.

**Возвращает**:
- `int | None`: Уровень заголовка (1-9) или `None`, если тег не является заголовком.

**Вызывает исключения**:
- `ValueError`: Если второй символ тега не является числом.

### `dumb_property_dict`

```python
def dumb_property_dict(style: str) -> dict:
    """returns a hash of css attributes"""
```

**Описание**:
Возвращает словарь CSS-атрибутов.

**Как работает функция**:
Функция `dumb_property_dict` принимает строку CSS-стилей и возвращает словарь, где ключами являются имена атрибутов, а значениями - значения атрибутов.

**Параметры**:
- `style` (str): Строка CSS-стилей.

**Возвращает**:
- `dict`: Словарь CSS-атрибутов.

### `dumb_css_parser`

```python
def dumb_css_parser(data: str) -> dict:
    """returns a hash of css selectors, each of which contains a hash of css attributes"""
```

**Описание**:
Возвращает словарь CSS-селекторов, каждый из которых содержит словарь CSS-атрибутов.

**Как работает функция**:
Функция `dumb_css_parser` принимает строку CSS-кода и возвращает словарь, где ключами являются CSS-селекторы, а значениями - словари CSS-атрибутов для каждого селектора.

**Параметры**:
- `data` (str): Строка CSS-кода.

**Возвращает**:
- `dict`: Словарь CSS-селекторов и атрибутов.

### `element_style`

```python
def element_style(attrs: dict, style_def: dict, parent_style: dict) -> dict:
    """returns a hash of the 'final' style attributes of the element"""
```

**Описание**:
Возвращает словарь "финальных" атрибутов стиля элемента.

**Как работает функция**:
Функция `element_style` принимает атрибуты элемента, определения стилей и стили родительского элемента и возвращает словарь, содержащий окончательные стили элемента, объединяя стили из CSS-классов и атрибутов `style`.

**Параметры**:
- `attrs` (dict): Атрибуты элемента.
- `style_def` (dict): Определения стилей.
- `parent_style` (dict): Стили родительского элемента.

**Возвращает**:
- `dict`: Словарь "финальных" атрибутов стиля элемента.

### `google_list_style`

```python
def google_list_style(style: dict) -> str:
    """finds out whether this is an ordered or unordered list"""
```

**Описание**:
Определяет, является ли список упорядоченным или неупорядоченным, на основе CSS-стилей Google Docs.

**Как работает функция**:
Функция `google_list_style` анализирует CSS-стили элемента списка и определяет, является ли список упорядоченным (`ol`) или неупорядоченным (`ul`).

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента списка.

**Возвращает**:
- `str`: `'ul'`, если список неупорядоченный, или `'ol'`, если список упорядоченный.

### `google_nest_count`

```python
def google_nest_count(style: dict) -> int:
    """calculate the nesting count of google doc lists"""
```

**Описание**:
Вычисляет уровень вложенности списков Google Docs.

**Как работает функция**:
Функция `google_nest_count` анализирует CSS-стили элемента списка и вычисляет уровень вложенности списка на основе отступа `margin-left`.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента списка.

**Возвращает**:
- `int`: Уровень вложенности списка.

### `google_has_height`

```python
def google_has_height(style: dict) -> bool:
    """check if the style of the element has the 'height' attribute explicitly defined"""
```

**Описание**:
Проверяет, определен ли атрибут `height` в CSS-стилях элемента.

**Как работает функция**:
Функция `google_has_height` проверяет, присутствует ли атрибут `height` в CSS-стилях элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `bool`: `True`, если атрибут `height` определен, `False` в противном случае.

### `google_text_emphasis`

```python
def google_text_emphasis(style: dict) -> list[str]:
    """return a list of all emphasis modifiers of the element"""
```

**Описание**:
Возвращает список всех модификаторов выделения текста элемента.

**Как работает функция**:
Функция `google_text_emphasis` анализирует CSS-стили элемента и возвращает список всех модификаторов выделения текста, таких как `text-decoration`, `font-style` и `font-weight`.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `list[str]`: Список модификаторов выделения текста.

### `google_fixed_width_font`

```python
def google_fixed_width_font(style: dict) -> bool:
    """check if the css of the current element defines a fixed width font"""
```

**Описание**:
Проверяет, определен ли для элемента шрифт фиксированной ширины.

**Как работает функция**:
Функция `google_fixed_width_font` анализирует CSS-стили элемента и проверяет, определен ли для элемента шрифт фиксированной ширины (`Courier New` или `Consolas`).

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `bool`: `True`, если определен шрифт фиксированной ширины, `False` в противном случае.

### `list_numbering_start`

```python
def list_numbering_start(attrs: dict) -> int:
    """extract numbering from list element attributes"""
```

**Описание**:
Извлекает начальный номер из атрибутов элемента списка.

**Как работает функция**:
Функция `list_numbering_start` извлекает начальный номер из атрибутов элемента списка (например, `<ol start="3">`).

**Параметры**:
- `attrs` (dict): Атрибуты элемента списка.

**Возвращает**:
- `int`: Начальный номер списка (уменьшенный на 1).

### `html2text_file`

```python
def html2text_file(html: str, out=..., baseurl: str = '') -> str:
    """
    Args:
        html (str): HTML-код для преобразования.
        out: Функция вывода (по умолчанию `wrapwrite`).
        baseurl (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

    Returns:
        str: Преобразованный текст в формате Markdown.

    Raises:
        Нет явных исключений.

    Example:
        >>> html2text_file("<p>Hello, world!</p>")
        'Hello, world!'
    """
```

**Описание**:
Преобразует HTML-код в текст с Markdown-форматированием, используя указанную функцию вывода.

**Как работает функция**:
Функция `html2text_file` принимает HTML-код, создает экземпляр класса `_html2text`, передает HTML-код для обработки и возвращает преобразованный текст.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `out`: Функция вывода (по умолчанию `wrapwrite`).
- `baseurl` (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

**Возвращает**:
- `str`: Преобразованный текст в формате Markdown.

### `html2text`

```python
def html2text(html: str, baseurl: str = '') -> str:
    """
    Args:
        html (str): HTML-код для преобразования.
        baseurl (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

    Returns:
        str: Преобразованный текст в формате Markdown с переносом строк.

    Raises:
        Нет явных исключений.

    Example:
        >>> html2text("<p>Hello, world!</p>")
        'Hello, world!'
    """
```

**Описание**:
Преобразует HTML-код в текст с Markdown-форматированием и переносит длинные строки.

**Как работает функция**:
Функция `html2text` принимает HTML-код, преобразует его в Markdown-форматированный текст с помощью функции `html2text_file` и переносит длинные строки с помощью функции `optwrap`.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `baseurl` (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию пустая строка.

**Возвращает**:
- `str`: Преобразованный текст в формате Markdown с переносом строк.

### `wrapwrite`

```python
def wrapwrite(text: str):
    """
    Args:
        text (str): Текст для вывода.

    Returns:
        None

    Raises:
        AttributeError: Если sys.stdout не имеет атрибута buffer.

    Example:
        >>> wrapwrite("Hello, world!")
    """
```

**Описание**:
Выводит текст в кодировке UTF-8 в стандартный вывод.

**Как работает функция**:
Функция `wrapwrite` принимает текст, кодирует его в UTF-8 и выводит в стандартный вывод.

**Параметры**:
- `text` (str): Текст для вывода.

**Возвращает**:
- `None`

**Вызывает исключения**:
- `AttributeError`: Если `sys.stdout` не имеет атрибута `buffer` (например, в Python 2).