# Модуль для работы с медиа-контентом
==========================================

Модуль предоставляет инструменты для обработки и рендеринга медиа-контента, включая изображения и аудио, в сообщениях. Он включает функции для рендеринга медиа-файлов из хранилища, обработки отдельных частей сообщений и объединения медиа-данных с сообщениями.

## Обзор

Модуль `media.py` содержит функции, необходимые для обработки различных типов медиа-файлов, связанных с сообщениями. Он включает в себя функции для рендеринга медиа-файлов, обработки отдельных частей сообщений и объединения медиа-данных с сообщениями. Модуль использует другие модули и функции из проекта `hypotez`, такие как `get_bucket_dir`, `read_bucket`, `is_data_an_media`, `is_data_an_audio`, `to_input_audio` и `to_data_uri`.

## Подробнее

Модуль предназначен для работы с медиа-контентом, хранящимся в хранилище данных, и подготовки его для отправки в сообщениях. Он обеспечивает функциональность для чтения медиа-файлов, преобразования их в base64 формат и формирования URL-адресов для доступа к ним.

## Функции

### `render_media`

```python
def render_media(bucket_id: str, name: str, url: str, as_path: bool = False, as_base64: bool = False) -> Union[str, Path]:
    """Рендерит медиа-файл, возвращая URL, путь к файлу или base64 представление данных.

    Args:
        bucket_id (str): ID бакета, где хранится медиа-файл.
        name (str): Имя медиа-файла.
        url (str): URL медиа-файла.
        as_path (bool, optional): Если `True`, возвращает путь к файлу. По умолчанию `False`.
        as_base64 (bool, optional): Если `True`, возвращает base64 представление данных. По умолчанию `False`.

    Returns:
        Union[str, Path]: URL, путь к файлу или base64 представление данных.

    Как работает функция:
    1. Проверяет, нужно ли возвращать путь к файлу или base64 представление.
    2. Если требуется путь или base64, формирует путь к файлу на основе `bucket_id`, типа "media" и имени файла.
    3. Если запрошен путь, возвращает его.
    4. Читает содержимое файла в байтах.
    5. Кодирует данные в base64.
    6. Если запрошен base64, возвращает закодированную строку.
    7. Формирует строку data URI и возвращает её.
    8. Если `as_base64` и `as_path` равны `False` и `url` не начинается с "/", возвращает исходный URL.
    """
```

**Принцип работы**:

Функция `render_media` отвечает за рендеринг медиа-файлов, хранящихся в бакете. Она может возвращать URL, путь к файлу или base64 представление данных в зависимости от переданных аргументов.

**Flowchart**:

```
Начало
    │
    ├── as_base64 или as_path или url.startswith("/")?
    │   └── ДА:
    │       │
    │       ├── Формирование пути к файлу
    │       │
    │       ├── as_path?
    │       │   └── ДА: Возврат пути к файлу
    │       │   └── НЕТ:
    │       │       │
    │       │       ├── Чтение данных файла
    │       │       │
    │       │       ├── Кодирование данных в base64
    │       │       │
    │       │       ├── as_base64?
    │       │       │   └── ДА: Возврат base64 данных
    │       │       │   └── НЕТ:
    │       │       │       │
    │       │       │       └── Формирование data URI и возврат
    │       │
    │   └── НЕТ:
    │       │
    │       └── Возврат исходного URL
    │
Конец
```

**Примеры**:

```python
render_media(bucket_id='test_bucket', name='image.png', url='/media/image.png')
# Возвращает: "data:image/png;base64,<base64_data>"

render_media(bucket_id='test_bucket', name='image.png', url='/media/image.png', as_path=True)
# Возвращает: Path('/path/to/test_bucket/media/image.png')

render_media(bucket_id='test_bucket', name='image.png', url='/media/image.png', as_base64=True)
# Возвращает: "<base64_data>"

render_media(bucket_id='test_bucket', name='image.png', url='http://example.com/image.png')
# Возвращает: "http://example.com/image.png"
```

### `render_part`

```python
def render_part(part: dict) -> dict:
    """Рендерит часть сообщения, преобразуя ее в формат, подходящий для отображения медиа-контента.

    Args:
        part (dict): Часть сообщения, содержащая информацию о медиа-файле.

    Returns:
        dict: Словарь с информацией о медиа-файле в формате, подходящем для отображения.

    Как работает функция:
    1. Проверяет наличие ключа "type" в переданной части сообщения. Если он есть, возвращает часть сообщения без изменений.
    2. Если ключа "type" нет, извлекает имя файла из части сообщения.
    3. Если имя файла отсутствует, формирует путь к бакету и читает содержимое бакета, возвращая текстовую часть сообщения.
    4. Если имя файла присутствует и является аудиофайлом, рендерит аудиофайл и возвращает часть сообщения с информацией об аудио.
    5. Если имя файла присутствует и не является аудиофайлом, рендерит изображение и возвращает часть сообщения с информацией об изображении.
    """
```

**Принцип работы**:

Функция `render_part` принимает часть сообщения и преобразует ее в формат, подходящий для отображения медиа-контента. Она обрабатывает различные типы медиа-файлов, такие как изображения и аудио, и возвращает словарь с информацией о медиа-файле.

**Flowchart**:

```
Начало
    │
    ├── "type" in part?
    │   └── ДА: Возврат part
    │   └── НЕТ:
    │       │
    │       ├── filename = part.get("name")
    │       │
    │       ├── filename is None?
    │       │   └── ДА:
    │       │       │
    │       │       ├── Формирование пути к бакету
    │       │       │
    │       │       ├── Чтение содержимого бакета
    │       │       │
    │       │       └── Возврат текстовой части сообщения
    │       │
    │   └── НЕТ:
    │       │
    │       ├── is_data_an_audio(filename)?
    │       │   └── ДА:
    │       │       │
    │       │       ├── Рендеринг аудио
    │       │       │
    │       │       └── Возврат части сообщения с информацией об аудио
    │       │
    │       └── НЕТ:
    │           │
    │           ├── Рендеринг изображения
    │           │
    │           └── Возврат части сообщения с информацией об изображении
    │
Конец
```

**Примеры**:

```python
part = {"bucket_id": "test_bucket", "name": "audio.mp3"}
render_part(part)
# Возвращает: {'type': 'input_audio', 'input_audio': {'data': '<base64_data>', 'format': 'mp3'}}

part = {"bucket_id": "test_bucket", "name": "image.png"}
render_part(part)
# Возвращает: {'type': 'image_url', 'image_url': {'url': 'data:image/png;base64,<base64_data>'}}

part = {"bucket_id": "test_bucket"}
render_part(part)
# Возвращает: {'type': 'text', 'text': '...'}

part = {"type": "text", "text": "Hello"}
render_part(part)
# Возвращает: {'type': 'text', 'text': 'Hello'}
```

### `merge_media`

```python
def merge_media(media: list, messages: list) -> Iterator:
    """Объединяет медиа-файлы с сообщениями пользователей.

    Args:
        media (list): Список медиа-файлов.
        messages (list): Список сообщений.

    Yields:
        Iterator: Итератор медиа-файлов и URL.

    Как работает функция:
    1. Итерируется по сообщениям.
    2. Если сообщение от пользователя, извлекает контент.
    3. Если контент является списком, итерируется по частям контента.
    4. Если часть контента содержит имя файла, рендерит медиа-файл и добавляет его в буфер.
    5. Если часть контента имеет тип "image_url", добавляет URL изображения в буфер.
    6. Если сообщение не от пользователя, очищает буфер.
    7. После обработки сообщений выдает элементы из буфера.
    8. Если `media` не `None`, выдает элементы из `media`.
    """
```

**Принцип работы**:

Функция `merge_media` объединяет медиа-файлы с сообщениями пользователей. Она анализирует сообщения, извлекает информацию о медиа-файлах и URL-адресах, и возвращает итератор, содержащий медиа-файлы и URL-адреса.

**Flowchart**:

```
Начало
    │
    ├── Итерация по сообщениям
    │   │
    │   ├── message.get("role") == "user"?
    │   │   └── ДА:
    │   │       │
    │   │       ├── content = message.get("content")
    │   │       │
    │   │       ├── isinstance(content, list)?
    │   │       │   └── ДА:
    │   │       │       │
    │   │       │       ├── Итерация по частям контента
    │   │       │       │   │
    │   │       │       │   ├── "name" in part?
    │   │       │       │   │   └── ДА: Рендеринг медиа и добавление в буфер
    │   │       │       │   │   └── НЕТ:
    │   │       │       │   │       │
    │   │       │       │   │       ├── part.get("type") == "image_url"?
    │   │       │       │   │       │   └── ДА: Добавление URL изображения в буфер
    │   │       │       │   │       │   └── НЕТ: Продолжение
    │   │       │       │
    │   │       │       └── Конец итерации по частям
    │   │       │
    │   │       └── НЕТ: Очистка буфера
    │   │
    │   └── Конец итерации по сообщениям
    │
    │
    ├── Выдача элементов из буфера
    │
    ├── media is not None?
    │   └── ДА: Выдача элементов из media
    │   └── НЕТ:
    │
Конец
```

**Примеры**:

```python
media = [("audio.mp3", "audio.mp3")]
messages = [{"role": "user", "content": [{"name": "image.png", "bucket_id": "test_bucket"}]}]
list(merge_media(media, messages))
# Возвращает: [('image.png', 'image.png'), ('audio.mp3', 'audio.mp3')]

media = None
messages = [{"role": "user", "content": [{"name": "image.png", "bucket_id": "test_bucket"}]}]
list(merge_media(media, messages))
# Возвращает: [('image.png', 'image.png')]

media = [("audio.mp3", "audio.mp3")]
messages = [{"role": "assistant", "content": [{"name": "image.png", "bucket_id": "test_bucket"}]}]
list(merge_media(media, messages))
# Возвращает: [('audio.mp3', 'audio.mp3')]
```

### `render_messages`

```python
def render_messages(messages: Messages, media: list = None) -> Iterator:
    """Рендерит сообщения, преобразуя медиа-файлы в нужный формат.

    Args:
        messages (Messages): Список сообщений для рендеринга.
        media (list, optional): Список медиа-файлов для добавления в последнее сообщение. По умолчанию `None`.

    Yields:
        Iterator: Итератор с отрендеренными сообщениями.

    Как работает функция:
    1. Итерируется по сообщениям.
    2. Если контент сообщения является списком, рендерит каждую часть контента с помощью `render_part`.
    3. Если `media` не `None` и это последнее сообщение, добавляет медиа-файлы в контент сообщения, преобразуя их в формат `input_audio` или `image_url`.
    4. Если контент сообщения является строкой, добавляет текстовую часть в контент сообщения.
    5. Выдает отрендеренное сообщение.
    """
```

**Принцип работы**:

Функция `render_messages` рендерит сообщения, преобразуя медиа-файлы в нужный формат. Она обрабатывает каждое сообщение, рендерит его контент и добавляет медиа-файлы, если они предоставлены.

**Flowchart**:

```
Начало
    │
    ├── Итерация по сообщениям
    │   │
    │   ├── isinstance(message["content"], list)?
    │   │   └── ДА:
    │   │       │
    │   │       ├── Рендеринг каждой части контента с помощью render_part
    │   │       │
    │   │       └── Выдача сообщения
    │   │
    │   └── НЕТ:
    │       │
    │       ├── media is not None и idx == len(messages) - 1?
    │       │   └── ДА:
    │       │       │
    │       │       ├── Добавление медиа-файлов в контент сообщения
    │       │       │
    │       │       ├── isinstance(message["content"], str)?
    │       │       │   └── ДА: Добавление текстовой части в контент
    │       │       │   └── НЕТ: Продолжение
    │       │       │
    │   │       └── Выдача сообщения
    │
Конец
```

**Примеры**:

```python
messages = [{"role": "user", "content": [{"name": "image.png", "bucket_id": "test_bucket"}]}]
list(render_messages(messages))
# Возвращает: [{'role': 'user', 'content': [{'type': 'image_url', 'image_url': {'url': 'data:image/png;base64,<base64_data>'}}]}]

messages = [{"role": "user", "content": "Hello"}]
media = [("audio.mp3", "audio.mp3")]
list(render_messages(messages, media))
# Возвращает: [{'role': 'user', 'content': [{'type': 'input_audio', 'input_audio': {'data': '<base64_data>', 'format': 'mp3'}}, {'type': 'text', 'text': 'Hello'}]}]

messages = [{"role": "user", "content": "Hello"}, {"role": "assistant", "content": "World"}]
list(render_messages(messages))
# Возвращает: [{'role': 'user', 'content': 'Hello'}, {'role': 'assistant', 'content': 'World'}]