# Анализ кода модуля `life.py`

**Качество кода: 7/10**

*   **Плюсы:**
    *   Код хорошо структурирован и разбит на функции, что облегчает чтение и понимание.
    *   Имеется подробная документация в виде docstring для модуля и функций.
    *   Реализованы основные правила игры "Жизнь" Конвея.
    *   Присутствует блок-схема в формате Mermaid, что помогает визуализировать алгоритм.
    *   Реализована проверка корректности ввода размеров поля и количества поколений.
    *   Есть возможность ввода начальной конфигурации или использования случайной.
*   **Минусы:**
    *   Не используется логирование ошибок.
    *   Не используются `j_loads` или `j_loads_ns` для загрузки данных (не применимо в данном случае).
    *   Присутствуют стандартные блоки `try-except` без обработки ошибок через `logger.error`.
    *   Ввод начальной конфигурации построчно может быть не очень удобным для пользователя.
    *   Некоторые комментарии после `#` не соответствуют стандарту RST.

**Рекомендации по улучшению:**

1.  **Логирование:**
    *   Добавить логирование ошибок с помощью `from src.logger.logger import logger`.
    *   Заменить `print` в блоках `try-except` на `logger.error`.
2.  **Комментарии:**
    *   Привести все комментарии в соответствие с форматом RST.
    *   Дополнить комментарии после `#` более подробным описанием следующего блока кода.
3.  **Обработка ввода:**
    *   Рассмотреть возможность улучшения пользовательского ввода начальной конфигурации, например, позволить вводить конфигурацию одной строкой, разделяя строки символом.
4.  **Общая структура:**
    *   Оптимизировать создание пустой `new_grid` в функции `next_generation`.

**Оптимизированный код:**

```python
"""
LIFE:
=================
Сложность: 7
-----------------
Игра "Жизнь" - это симуляция клеточного автомата, разработанная Джоном Конвеем.
Игровое поле представляет собой сетку из клеток, каждая из которых может находиться в одном из двух состояний:
"живая" или "мертвая". Состояние каждой клетки в следующем поколении зависит от состояния ее соседей в текущем поколении.
Цель игры - наблюдать за эволюцией начальной конфигурации клеток и исследовать интересные паттерны, возникающие в процессе симуляции.

Правила игры:
1.  Игровое поле состоит из клеток, каждая из которых может быть "живой" (обозначено символом "*") или "мертвой" (обозначено пробелом).
2.  Изначально поле заполняется случайным образом или задается определенная конфигурация клеток.
3.  Переход к следующему поколению осуществляется по следующим правилам:
    -  Живая клетка с менее чем двумя живыми соседями умирает от одиночества.
    -  Живая клетка с двумя или тремя живыми соседями выживает в следующем поколении.
    -  Живая клетка с более чем тремя живыми соседями умирает от перенаселения.
    -  Мертвая клетка с ровно тремя живыми соседями оживает.
4.  Игра продолжается заданное количество поколений.

-----------------
Алгоритм:
1. Запросить у пользователя размеры поля (количество строк и столбцов).
2. Запросить у пользователя количество поколений для симуляции.
3. Создать начальное поколение:
    - если пользователь ввел начальные данные, то использовать их.
    - если нет, то заполнить поле случайным образом живыми и мертвыми клетками.
4. Для каждого поколения от 1 до заданного количества поколений:
    4.1 Вывести на экран текущее поколение (состояние поля).
    4.2 Создать новое поле (следующее поколение), применив правила игры:
        - Для каждой клетки в текущем поле:
            - Подсчитать количество живых соседей.
            - В зависимости от состояния клетки и количества соседей в текущем поколении, определить ее состояние в новом поле согласно правилам игры.
    4.3 Обновить текущее поле новым полем.
5. По завершению симуляции вывести на экран заключительное состояние поля.

-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InputGridSize["Ввод размеров сетки: <code><b>rows, cols</b></code>"]
    InputGridSize --> InputGenerations["Ввод количества поколений: <code><b>generations</b></code>"]
    InputGenerations --> InputInitialConfig{"Ввод начальной конфигурации: <code><b>initial_config</b></code>"}\
    InputInitialConfig --> CreateInitialGrid{"Создание начальной сетки: <code><b>grid</b></code>"}\
    CreateInitialGrid --> LoopStart{"Начало цикла поколений: <code><b>for generation in range(generations)</b></code>"}\
    LoopStart -- Да --> OutputCurrentGrid["Вывод текущей сетки: <code><b>grid</b></code>"]
    OutputCurrentGrid --> CreateNextGenerationGrid["Создание новой сетки: <code><b>next_grid</b></code>"]
    CreateNextGenerationGrid --> LoopCellsStart{"Начало цикла по клеткам: <code><b>for row in range(rows): for col in range(cols)</b></code>"}
    LoopCellsStart --> CountLiveNeighbours["Подсчет живых соседей: <code><b>live_neighbours</b></code>"]
    CountLiveNeighbours --> ApplyRules["Применение правил игры для определения состояния клетки в <code><b>next_grid</b></code>"]
    ApplyRules --> LoopCellsEnd{"Конец цикла по клеткам"}
    LoopCellsEnd --> UpdateCurrentGrid{"Обновление текущей сетки: <code><b>grid = next_grid</b></code>"}
    UpdateCurrentGrid --> LoopEnd{"Конец цикла поколений"}
     LoopEnd -- Да --> LoopStart
    LoopEnd -- Нет --> OutputFinalGrid["Вывод финальной сетки: <code><b>grid</b></code>"]
    OutputFinalGrid --> End["Конец"]

```
Legenda:
    Start - Начало программы.
    InputGridSize - Ввод размеров сетки (количество строк и столбцов) от пользователя.
    InputGenerations - Ввод количества поколений для симуляции от пользователя.
    InputInitialConfig - Ввод начальной конфигурации клеток от пользователя.
    CreateInitialGrid - Создание начальной сетки (grid) на основе введенных размеров и начальной конфигурации. Если начальная конфигурация не предоставлена, поле заполняется случайным образом.
    LoopStart - Начало цикла, который выполняется заданное количество раз (количество поколений).
    OutputCurrentGrid - Вывод на экран текущего состояния сетки (grid).
    CreateNextGenerationGrid - Создание новой сетки (next_grid), которая будет представлять следующее поколение.
    LoopCellsStart - Начало цикла для каждой клетки в сетке.
    CountLiveNeighbours - Подсчет количества живых соседей для текущей клетки.
    ApplyRules - Применение правил игры (Conway\'s Game of Life) для определения состояния клетки в следующем поколении (next_grid) на основе количества живых соседей и текущего состояния клетки.
    LoopCellsEnd - Конец цикла для каждой клетки в сетке.
    UpdateCurrentGrid - Обновление текущей сетки (grid) новой сеткой (next_grid).
    LoopEnd - Конец цикла поколений. Если есть еще поколения, цикл повторяется.
    OutputFinalGrid - Вывод на экран финального состояния сетки (grid) после завершения всех поколений.
    End - Конец программы.
"""
import random
import time
# добавляем импорт logger
from src.logger.logger import logger


def get_grid_size():
    """
    Запрашивает у пользователя размеры сетки.

    :return: Кортеж из количества строк и столбцов.
    :rtype: tuple[int, int]
    """
    while True:
        try:
            rows = int(input("Введите количество строк: "))
            cols = int(input("Введите количество столбцов: "))
            if rows > 0 and cols > 0:
                return rows, cols
            else:
                print("Пожалуйста, введите положительные значения для строк и столбцов.")
        except ValueError as e: # Ловим ошибку ValueError
            logger.error(f'Ошибка ввода размера сетки: {e}') # логируем ошибку
            print("Пожалуйста, введите целое число.")


def get_generations():
    """
    Запрашивает у пользователя количество поколений.

    :return: Количество поколений.
    :rtype: int
    """
    while True:
        try:
            generations = int(input("Введите количество поколений: "))
            if generations > 0:
                return generations
            else:
                print("Пожалуйста, введите положительное количество поколений.")
        except ValueError as e:# Ловим ошибку ValueError
            logger.error(f'Ошибка ввода количества поколений: {e}') # логируем ошибку
            print("Пожалуйста, введите целое число.")


def get_initial_config(rows, cols):
    """
    Запрашивает у пользователя ввод начальной конфигурации или использует случайную.

    :param rows: Количество строк.
    :type rows: int
    :param cols: Количество столбцов.
    :type cols: int
    :return: Список строк, представляющих начальную конфигурацию.
    :rtype: list[str]
    """
    use_random = input("Использовать случайную конфигурацию (y/n)? ").lower()
    if use_random != 'y':
        print("Введите начальную конфигурацию, используя '*' для живых клеток и ' ' для мертвых.")
        print("Введите каждую строку отдельно:")
        initial_config = []
        for _ in range(rows):
            while True:
              row_input = input()
              if len(row_input) == cols and all(cell in ['*', ' '] for cell in row_input):
                  initial_config.append(row_input)
                  break
              else:
                print(f"Неверный ввод. Введите строку длиной {cols} символов '*' или ' '")
        return initial_config
    else:
        return  [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]


def create_grid(rows, cols, initial_config=None):
    """
    Создает сетку на основе заданных размеров и начальной конфигурации.

    :param rows: Количество строк.
    :type rows: int
    :param cols: Количество столбцов.
    :type cols: int
    :param initial_config: Начальная конфигурация (необязательно).
    :type initial_config: list[str], optional
    :return: Сетка (список списков).
    :rtype: list[list[str]]
    """
    if initial_config:
        return [list(row) for row in initial_config]
    else:
        return [['*' if random.random() > 0.5 else ' ' for _ in range(cols)] for _ in range(rows)]


def print_grid(grid):
    """
    Выводит сетку на экран.

    :param grid: Сетка (список списков).
    :type grid: list[list[str]]
    """
    for row in grid:
        print(''.join(row))
    print("-" * len(grid[0]))


def count_live_neighbours(grid, row, col):
    """
    Подсчитывает количество живых соседей для заданной клетки.

    :param grid: Сетка (список списков).
    :type grid: list[list[str]]
    :param row: Индекс строки клетки.
    :type row: int
    :param col: Индекс столбца клетки.
    :type col: int
    :return: Количество живых соседей.
    :rtype: int
    """
    rows = len(grid)
    cols = len(grid[0])
    count = 0
    for i in range(max(0, row - 1), min(rows, row + 2)):
        for j in range(max(0, col - 1), min(cols, col + 2)):
            if (i, j) != (row, col) and grid[i][j] == '*':
                count += 1
    return count


def apply_rules(grid, row, col):
    """
    Применяет правила игры "Жизнь" для определения состояния клетки в следующем поколении.

    :param grid: Сетка (список списков).
    :type grid: list[list[str]]
    :param row: Индекс строки клетки.
    :type row: int
    :param col: Индекс столбца клетки.
    :type col: int
    :return: Новое состояние клетки ('*' - живая, ' ' - мертвая).
    :rtype: str
    """
    live_neighbours = count_live_neighbours(grid, row, col)
    if grid[row][col] == '*':
        if live_neighbours < 2 or live_neighbours > 3:
            return ' '  # Клетка умирает
        else:
            return '*'  # Клетка выживает
    else:
        if live_neighbours == 3:
            return '*'  # Клетка оживает
        else:
            return ' '  # Клетка остается мертвой


def next_generation(grid):
    """
    Создает следующее поколение сетки.

    :param grid: Сетка (список списков).
    :type grid: list[list[str]]
    :return: Сетка следующего поколения (список списков).
    :rtype: list[list[str]]
    """
    rows = len(grid)
    cols = len(grid[0])
    # оптимизация: используем list comprehension для создания новой сетки
    new_grid = [[apply_rules(grid, row, col) for col in range(cols)] for row in range(rows)]
    return new_grid


def play_game_of_life():
  """
  Основная функция, управляющая симуляцией игры "Жизнь".
  """
  rows, cols = get_grid_size() # Запрос размера сетки у пользователя.
  generations = get_generations() # Запрос количества поколений у пользователя.
  initial_config = get_initial_config(rows, cols) # Запрос начальной конфигурации у пользователя
  grid = create_grid(rows, cols, initial_config) # Создание игровой сетки.

  for generation in range(generations):
    print(f"Поколение: {generation + 1}")
    print_grid(grid)
    grid = next_generation(grid)
    time.sleep(0.5)

  print("Симуляция завершена")
  print("Финальное состояние поля:")
  print_grid(grid)

if __name__ == "__main__":
    play_game_of_life()

"""
Объяснение кода:
1. **Импорт модулей**:
    -   `import random`: Импортирует модуль `random` для генерации случайных чисел.
    -   `import time`: Импортирует модуль `time` для добавления задержки между поколениями.
    -   `from src.logger.logger import logger`: Импортирует модуль `logger` для логирования ошибок.
2.  **Функция `get_grid_size()`**:
    - Запрашивает у пользователя размеры сетки (количество строк и столбцов), проверяя корректность ввода.
    - Возвращает кортеж `rows, cols` целых чисел.
    - Добавлено логирование ошибки в блоке `except`
3.  **Функция `get_generations()`**:
    - Запрашивает у пользователя количество поколений для симуляции, проверяя корректность ввода.
    - Возвращает целое число `generations`.
     - Добавлено логирование ошибки в блоке `except`
4.  **Функция `get_initial_config(rows, cols)`**:
   - Запрашивает у пользователя, использовать ли случайную начальную конфигурацию или ввести свою.
   - Если пользователь не выбирает случайную конфигурацию, то запрашивает начальную конфигурацию, построчно, проверяя корректность ввода.
   - Если пользователь выбирает случайную, то возвращает случайную начальную конфигурацию.
   - Возвращает список строк (начальная конфигурация).
5. **Функция `create_grid(rows, cols, initial_config=None)`**:
    -   Создает и возвращает сетку (список списков) на основе заданных размеров `rows`, `cols` и начальной конфигурации `initial_config`.
    -   Если `initial_config` предоставлена, использует её для создания сетки.
    -   Если `initial_config` не предоставлена, генерирует случайную сетку, где каждая клетка имеет 50% шанс быть живой (`'*'`) или мертвой (`' '`).
6. **Функция `print_grid(grid)`**:
    -   Выводит текущую сетку на экран.
    -   Каждая строка сетки выводится на отдельной строке, а также добавляется разделительная линия.
7. **Функция `count_live_neighbours(grid, row, col)`**:
    -   Подсчитывает количество живых соседей у клетки с координатами `row` и `col` в сетке `grid`.
    -   Соседями считаются все клетки, прилегающие к данной клетке по горизонтали, вертикали и диагонали.
    -   Возвращает целое число - количество живых соседей.
8. **Функция `apply_rules(grid, row, col)`**:
    - Применяет правила игры "Жизнь" для клетки с координатами `row` и `col`.
    - Возвращает '*' если клетка должна быть живой, и ' ' если клетка должна быть мертвой.
    -   Возвращает новое состояние клетки.
9. **Функция `next_generation(grid)`**:
    - Создает и возвращает сетку следующего поколения на основе текущей сетки.
    - Применяет функцию apply_rules к каждой клетке.
    -   Создает новую сетку (список списков) и применяет правила игры для определения состояния каждой клетки в следующем поколении.
    -   Оптимизировано создание нового поля.
10. **Функция `play_game_of_life()`**:
    - Основная функция, управляющая симуляцией игры "Жизнь".
    - Вызывает функции get_grid_size(), get_generations() и create_grid() для инициализации игры.
    - В цикле for выводит на экран текущее поколение, рассчитывает и выводит следующее поколение.
    - После цикла for выводит на экран финальное состояние поля.
11. **Запуск игры**:
    -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_game_of_life()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    -  `play_game_of_life()`: Вызывает функцию для начала игры.
"""
```