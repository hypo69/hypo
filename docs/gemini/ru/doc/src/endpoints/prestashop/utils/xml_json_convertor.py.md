# Модуль для конвертации XML в JSON и обратно

## Обзор

Модуль `xml_json_convertor` предоставляет утилиты для преобразования данных XML в словари Python и наоборот. Он включает функции для разбора XML-строк и преобразования деревьев элементов XML в словарные представления. Этот модуль может быть полезен для работы с данными в формате XML, например, при взаимодействии с API PrestaShop.

## Подробнее

Модуль содержит функции для преобразования данных из формата JSON в XML и обратно. Это может быть полезно, когда необходимо взаимодействовать с системами, которые используют XML в качестве формата обмена данными, например, с API PrestaShop.

## Функции

### `dict2xml`

```python
def dict2xml(json_obj: dict, root_name: str = "product") -> str:
    """! Converts a JSON dictionary to an XML string.

    Args:
        json_obj (dict): JSON dictionary to convert.
        root_name (str, optional): Root element name. Defaults to "product".

    Returns:
        str: XML string representation of the JSON.
    """
    ...
```

**Назначение**: Преобразует словарь JSON в строку XML.

**Как работает функция**: Функция принимает словарь JSON и преобразует его в строку XML. Она использует рекурсивную функцию `build_xml_element` для построения элементов XML на основе данных JSON.

Внутри функции происходят следующие действия и преобразования:
A. Определяется внутренняя функция `build_xml_element`.
|
B. Создается корневой элемент XML с именем `root_name`.
|
C. Вызывается функция `build_xml_element` для рекурсивного построения XML-элементов на основе данных JSON.
|
D. Преобразованное XML-дерево преобразуется в строку с кодировкой UTF-8.

#### `build_xml_element`

```python
def build_xml_element(parent, data):
    """Recursively constructs XML elements from JSON data."""
    if isinstance(data, dict):
        for key, value in data.items():
            if key.startswith("@"):  # Attribute
                parent.set(key[1:], value)
            elif key == "#text":  # Text value
                parent.text = value
            else:
                if isinstance(value, list):
                    for item in value:
                        child = ET.SubElement(parent, key)
                        build_xml_element(child, item)
                else:
                    child = ET.SubElement(parent, key)
                    build_xml_element(child, value)
    elif isinstance(data, list):
        for item in data:
            build_xml_element(parent, item)
    else:
        parent.text = str(data)
```

**Назначение**: Рекурсивно строит XML-элементы на основе данных JSON.

**Как работает функция**: Функция принимает родительский XML-элемент и данные JSON. Если данные являются словарем, она перебирает элементы словаря и создает XML-элементы на основе ключей и значений. Если ключ начинается с "@", он рассматривается как атрибут. Если ключ равен "#text", значение устанавливается как текст элемента. Если значение является списком, функция рекурсивно вызывает себя для каждого элемента списка. Если данные не являются ни словарем, ни списком, они преобразуются в строку и устанавливаются как текст родительского элемента.

**Параметры**:
- `parent`: Родительский XML-элемент.
- `data`: Данные JSON для построения XML-элементов.

**Возвращает**:
- `None`

**Параметры**:
- `json_obj` (dict): Словарь JSON для преобразования.
- `root_name` (str, optional): Имя корневого элемента. По умолчанию "product".

**Возвращает**:
- `str`: Строковое представление XML JSON.

### `_parse_node`

```python
def _parse_node(node: ET.Element) -> dict | str:
    """Parse an XML node into a dictionary.

    Args:
        node (ET.Element): The XML element to parse.

    Returns:
        dict | str: A dictionary representation of the XML node, or a string if the node has no attributes or children.
    """
    ...
```

**Назначение**: Преобразует XML-узел в словарь.

**Как работает функция**: Функция принимает XML-элемент и преобразует его в словарь. Она извлекает атрибуты узла, текст и дочерние элементы. Атрибуты сохраняются в словаре под ключом 'attrs'. Дочерние элементы рекурсивно преобразуются в словари и добавляются в словарь результата. Если у узла нет атрибутов и дочерних элементов, возвращается только текст узла.

Внутри функции происходят следующие действия и преобразования:
A. Инициализируется пустой словарь `tree` для хранения результатов.
|
B. Инициализируется пустой словарь `attrs` для хранения атрибутов узла.
|
C. Перебираются атрибуты узла, и каждый атрибут добавляется в словарь `attrs`.
|
D. Извлекается текст узла и удаляются начальные и конечные пробелы.
|
E. Если есть атрибуты, они добавляются в словарь `tree` под ключом 'attrs'.
|
F. Перебираются дочерние элементы узла, и каждый дочерний элемент рекурсивно преобразуется в словарь.
|
G. Если дочерний элемент уже существует в словаре `tree`, он преобразуется в список и новый элемент добавляется в список.
|
H. Если узел не имеет дочерних элементов, текст узла добавляется в словарь `tree` под ключом 'value'.
|
I. Если словарь `tree` содержит только ключ 'value', возвращается только значение этого ключа.

**Параметры**:
- `node` (ET.Element): XML-элемент для разбора.

**Возвращает**:
- `dict | str`: Представление XML-узла в виде словаря или строка, если у узла нет атрибутов или дочерних элементов.

### `_make_dict`

```python
def _make_dict(tag: str, value: any) -> dict:
    """Generate a new dictionary with tag and value.

    Args:
        tag (str): The tag name of the XML element.
        value (any): The value associated with the tag.

    Returns:
        dict: A dictionary with the tag name as the key and the value as the dictionary value.
    """
    ...
```

**Назначение**: Создает новый словарь с тегом и значением.

**Как работает функция**: Функция принимает тег и значение и создает новый словарь, где тег является ключом, а значение - значением словаря. Если тег содержит пространство имен, оно извлекается и добавляется в словарь значения.

Внутри функции происходят следующие действия и преобразования:
A. Присваивает значение переменной `tag_values` значение параметра `value`.
|
B. Использует регулярное выражение для поиска пространства имен в теге.
|
C. Если пространство имен найдено, создается словарь `tag_values` с ключом `value` и значением параметра `value`.
|
D. Извлекает пространство имен и тег из результата поиска регулярного выражения.
|
E. Возвращает словарь с тегом в качестве ключа и `tag_values` в качестве значения.

**Параметры**:
- `tag` (str): Имя тега XML-элемента.
- `value` (any): Значение, связанное с тегом.

**Возвращает**:
- `dict`: Словарь с именем тега в качестве ключа и значением в качестве значения словаря.

### `xml2dict`

```python
def xml2dict(xml: str) -> dict:
    """Parse XML string into a dictionary.

    Args:
        xml (str): The XML string to parse.

    Returns:
        dict: The dictionary representation of the XML.
    """
    ...
```

**Назначение**: Преобразует XML-строку в словарь.

**Как работает функция**: Функция принимает XML-строку и преобразует ее в словарь. Она использует `ET.fromstring` для создания дерева элементов XML из строки, а затем вызывает функцию `ET2dict` для преобразования дерева элементов в словарь.

Внутри функции происходят следующие действия и преобразования:
A. Преобразует XML-строку в дерево элементов с помощью `ET.fromstring`.
|
B. Преобразует дерево элементов в словарь с помощью `ET2dict`.
|
C. Возвращает полученный словарь.

**Параметры**:
- `xml` (str): XML-строка для разбора.

**Возвращает**:
- `dict`: Представление XML в виде словаря.

### `ET2dict`

```python
def ET2dict(element_tree: ET.Element) -> dict:
    """Convert an XML element tree into a dictionary.

    Args:
        element_tree (ET.Element): The XML element tree.

    Returns:
        dict: The dictionary representation of the XML element tree.
    """
    ...
```

**Назначение**: Преобразует дерево элементов XML в словарь.

**Как работает функция**: Функция принимает дерево элементов XML и преобразует его в словарь. Она вызывает функцию `_make_dict` для создания словаря с тегом корневого элемента и результатом вызова функции `_parse_node` для дерева элементов.

Внутри функции происходят следующие действия и преобразования:
A. Вызывает функцию `_make_dict` с тегом корневого элемента и результатом вызова функции `_parse_node` для дерева элементов.
|
B. Возвращает полученный словарь.

**Параметры**:
- `element_tree` (ET.Element): Дерево элементов XML.

**Возвращает**:
- `dict`: Представление дерева элементов XML в виде словаря.

### `presta_fields_to_xml`

```python
def presta_fields_to_xml(presta_fields_dict: dict) -> str:
    """! Converts a JSON dictionary to an XML string with a fixed root name 'prestashop'.

    Args:
        presta_fields_dict (dict): JSON dictionary containing the data (without 'prestashop' key).

    Returns:
        str: XML string representation of the JSON.
    """
    ...
```

**Назначение**: Преобразует словарь JSON в строку XML с фиксированным корневым элементом 'prestashop'.

**Как работает функция**: Функция принимает словарь JSON и преобразует его в строку XML. Она создает корневой элемент "prestashop", а затем добавляет в него элементы на основе данных из словаря JSON.

Внутри функции происходят следующие действия и преобразования:
A. Проверяется, не пуст ли входной словарь `presta_fields_dict`. Если пуст, возвращается пустая строка.
|
B. Получается первый ключ из словаря `presta_fields_dict` (например, 'product', 'category' и т. д.).
|
C. Создается корневой элемент "prestashop".
|
D. Создается динамический подэлемент корневого элемента с именем первого ключа из словаря `presta_fields_dict`.
|
E. Вызывается функция `build_xml_element` для рекурсивного построения XML-элементов на основе данных JSON.
|
F. Преобразованное XML-дерево преобразуется в строку с кодировкой UTF-8.

**Параметры**:
- `presta_fields_dict` (dict): Словарь JSON, содержащий данные (без ключа 'prestashop').

**Возвращает**:
- `str`: Строковое представление XML JSON.