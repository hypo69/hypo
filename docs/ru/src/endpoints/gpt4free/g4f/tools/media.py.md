# Модуль для работы с медиа-контентом
========================================

Модуль содержит функции для обработки и рендеринга медиа-контента, включая изображения и аудио, а также для подготовки сообщений с медиа-вложениями.

## Обзор

Этот модуль предоставляет набор функций для работы с медиа-файлами, включая рендеринг медиа-контента из различных источников (например, из хранилища bucket), преобразование медиа-данных в нужные форматы (например, base64), и объединение медиа-файлов с сообщениями. Он также содержит функции для подготовки сообщений с медиа-вложениями для отправки.

## Подробнее

Модуль `media.py` предназначен для обработки медиа-контента в контексте проекта `hypotez`. Он предоставляет функции для рендеринга медиа, объединения его с сообщениями и подготовки этих сообщений к отправке. Он используется для работы с различными типами медиаданных, такими как изображения и аудио, и обеспечивает их правильное отображение и обработку в системе.

## Функции

### `render_media`

```python
def render_media(bucket_id: str, name: str, url: str, as_path: bool = False, as_base64: bool = False) -> Union[str, Path]:
    """
    Рендерит медиа-контент на основе предоставленных параметров.

    Args:
        bucket_id (str): Идентификатор хранилища.
        name (str): Имя файла.
        url (str): URL файла.
        as_path (bool, optional): Если `True`, возвращает путь к файлу. По умолчанию `False`.
        as_base64 (bool, optional): Если `True`, возвращает данные в формате base64. По умолчанию `False`.

    Returns:
        Union[str, Path]: Строка с URL, base64 представлением данных или путь к файлу.

    Как работает функция:
    1. **Проверка условий рендеринга**: Функция проверяет, нужно ли возвращать путь к файлу (`as_path`), данные в формате base64 (`as_base64`) или если URL начинается с `/`.
    2. **Получение пути к файлу**: Если одно из условий выполнено, формируется путь к файлу в хранилище (`bucket`).
    3. **Чтение данных из файла**: Если запрошен путь к файлу, он возвращается. Иначе файл считывается в виде байтов.
    4. **Кодирование в base64**: Происходит кодирование байтов в base64.
    5. **Формирование data URI**: Если запрошено, формируется data URI строку с mime-типом.

    ASCII Flowchart:
    A[Проверка условий: as_base64, as_path, url.startswith("/")]
    |\n
    B[Получение пути к файлу]
    |\n
    C[Чтение данных из файла]
    |\n
    D[Кодирование в base64]
    |\n
    E[Формирование data URI]
    |\n
    F[Возврат результата: URL, base64, путь]

    Примеры:
    >>> render_media(bucket_id='test_bucket', name='image.png', url='/media/image.png', as_path=True)
    PosixPath('test_bucket/media/image.png')

    >>> render_media(bucket_id='test_bucket', name='image.png', url='/media/image.png', as_base64=True)
    'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
    """
    ...
```

### `render_part`

```python
def render_part(part: dict) -> dict:
    """
    Рендерит часть сообщения, обрабатывая различные типы медиа-контента.

    Args:
        part (dict): Словарь с данными о части сообщения.

    Returns:
        dict: Словарь с информацией о типе и контенте сообщения.

    Как работает функция:

    1. **Проверка наличия типа**: Функция проверяет, есть ли ключ "type" в переданном словаре `part`. Если есть, функция просто возвращает `part` без изменений.
    2. **Обработка текстовых частей**: Если ключа "type" нет, функция пытается получить имя файла из словаря `part`. Если имя файла отсутствует, значит это текстовая часть. Тогда функция получает путь к директории bucket, считывает содержимое bucket и возвращает словарь с типом "text" и содержимым bucket.
    3. **Обработка аудио**: Если имя файла присутствует и это аудиофайл (определяется с помощью `is_data_an_audio`), функция рендерит медиа как аудио и возвращает словарь с типом "input_audio", содержащий base64 данные и формат файла.
    4. **Обработка изображений**: Если имя файла присутствует, но это не аудио, функция считает, что это изображение. В таком случае функция рендерит медиа как изображение и возвращает словарь с типом "image_url" и URL изображения.

    ASCII Flowchart:

    A[Проверка наличия типа в part]
    |\n
    B[Проверка наличия имени файла в part]
    |\n
    C[Обработка текстовой части (чтение bucket)]
    |\n
    D[Проверка, является ли файл аудио]
    |\n
    E[Обработка аудио (рендеринг в base64)]
    |\n
    F[Обработка изображений (рендеринг URL)]
    |\n
    G[Возврат результата: словарь с типом и контентом]

    Примеры:

    >>> render_part({"bucket_id": "test_bucket"})
    {'type': 'text', 'text': 'content of bucket'}

    >>> render_part({"name": "audio.mp3", "bucket_id": "test_bucket"})
    {'type': 'input_audio', 'input_audio': {'data': 'base64_audio_data', 'format': 'mp3'}}
    """
    ...
```

### `merge_media`

```python
def merge_media(media: list, messages: list) -> Iterator:
    """
    Объединяет медиа-файлы с сообщениями, находя медиа-части в сообщениях пользователей.

    Args:
        media (list): Список медиа-файлов.
        messages (list): Список сообщений.

    Yields:
        Iterator: Итератор медиа-файлов.

    Как работает функция:

    1.  **Инициализация буфера**: Функция инициализирует пустой список `buffer` для временного хранения медиа-файлов, найденных в сообщениях пользователей.
    2.  **Итерация по сообщениям**: Функция проходит по каждому сообщению в списке `messages`.
    3.  **Проверка роли**: Для каждого сообщения проверяется, является ли автором сообщения пользователь (role == "user").
    4.  **Извлечение медиа из контента**: Если автором является пользователь, функция проходит по частям контента сообщения. Если часть контента содержит имя файла, то считается медиа-файлом.  Извлекается путь к файлу и имя файла, и добавляется в буфер. Если тип части контента "image_url", то URL изображения добавляется в буфер.
    5.  **Очистка буфера**: Если автором сообщения является не пользователь, буфер очищается.
    6.  **Генерация медиа из буфера**: После обработки всех сообщений, функция генерирует медиа-файлы из буфера.
    7.  **Генерация медиа из входного списка**: После генерации медиа из буфера, функция генерирует медиа-файлы из входного списка `media`.

    ASCII Flowchart:

    A[Инициализация буфера]
    |\n
    B[Итерация по сообщениям]
    |\n
    C[Проверка роли сообщения == "user"]
    |\n
    D[Извлечение медиа из контента]
    |\n
    E[Очистка буфера, если роль != "user"]
    |\n
    F[Генерация медиа из буфера]
    |\n
    G[Генерация медиа из входного списка]
    |\n
    H[Выход]

    Примеры:

    >>> messages = [{"role": "user", "content": [{"name": "image.png", "bucket_id": "test_bucket"}]}, {"role": "assistant", "content": "ok"}]
    >>> list(merge_media(media=None, messages=messages))
    [(PosixPath('test_bucket/media/image.png'), 'image.png')]
    """
    ...
```

### `render_messages`

```python
def render_messages(messages: Messages, media: list = None) -> Iterator:
    """
    Рендерит список сообщений, обрабатывая медиа-вложения и преобразуя их в нужный формат.

    Args:
        messages (Messages): Список сообщений.
        media (list, optional): Список медиа-файлов. По умолчанию `None`.

    Yields:
        Iterator: Итератор обработанных сообщений.

    Как работает функция:

    1.  **Итерация по сообщениям**: Функция проходит по каждому сообщению в списке `messages` с использованием enumerate, чтобы получить индекс текущего сообщения.
    2.  **Обработка контента сообщения**: Если контент сообщения является списком, функция рендерит каждую часть контента с помощью функции `render_part` и возвращает новое сообщение с обработанным контентом.
    3.  **Обработка медиа-вложений**: Если контент сообщения не является списком, и если передан список медиа-файлов, функция проверяет, является ли текущее сообщение последним в списке.
    4.  **Добавление медиа к последнему сообщению**: Если текущее сообщение является последним, функция добавляет медиа-вложения к контенту этого сообщения. Для каждого медиа-файла проверяется, является ли он аудио или изображением, и создается соответствующая структура данных.
    5.  **Возврат обработанного сообщения**: Функция возвращает обработанное сообщение.

    ASCII Flowchart:

    A[Итерация по сообщениям]
    |\n
    B[Проверка, является ли контент сообщения списком]
    |\n
    C[Рендеринг частей контента, если это список]
    |\n
    D[Проверка, является ли текущее сообщение последним и есть ли медиа]
    |\n
    E[Добавление медиа-вложений к последнему сообщению]
    |\n
    F[Возврат обработанного сообщения]

    Примеры:
    >>> messages = [{"role": "user", "content": "hello"}, {"role": "assistant", "content": "hi"}]
    >>> media = [("audio_data", "audio.mp3")]
    >>> list(render_messages(messages, media))
    [{'role': 'user', 'content': 'hello'}, {'role': 'assistant', 'content': [{'type': 'input_audio', 'input_audio': {'data': 'audio_data', 'format': 'mp3'}}]}]
    """
    ...