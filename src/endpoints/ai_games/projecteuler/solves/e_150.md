## Ответ на Задачу No 150: Поиск минимальной суммы в треугольнике

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Необходимо сгенерировать треугольник чисел, используя заданный генератор псевдослучайных чисел.
*   Нужно найти минимальную сумму среди всех возможных подтреугольников. Подтреугольник может начинаться с любого элемента и включать в себя все элементы, расположенные ниже по строкам.
*   Подтреугольник размера 1 состоит только из одного элемента.

**Решение:**

1.  **Генерация треугольника:** Сначала нужно сгенерировать последовательность чисел $s_k$ и построить треугольник из них. Количество элементов в каждой строке треугольника увеличивается на 1.
2.  **Динамическое программирование:** Для эффективного нахождения минимальной суммы подтреугольника можно использовать динамическое программирование. Будем двигаться снизу вверх, для каждого элемента в треугольнике сохранять минимальную сумму подтреугольника, начинающегося с этого элемента.
3.  **Расчет минимальных сумм:** Для каждого элемента в треугольнике минимальная сумма подтреугольника, начинающегося с него, будет равна значению этого элемента плюс минимум из минимальных сумм подтреугольников, начинающихся с двух элементов, находящихся под ним.
4.  **Поиск минимума:** В результате прохода снизу вверх, мы получим для каждого элемента минимальную сумму подтреугольника, который в нем начинается. Из них нужно будет выбрать наименьшее значение.

### 2. Алгоритм решения

1.  **Генерация чисел:**
    *   Инициализировать `t` = 0
    *   Создать пустой список `s`.
    *   Для `k` от 1 до 500500:
        *   `t` = (615949 * `t` + 797807) mod 2^20
        *   `s_k` = `t` - 2^19
        *   Добавить `s_k` в `s`.
2.  **Создание треугольника:**
    *   Создать пустой список `triangle` (список списков).
    *   Индексы элементов `s` для строк треугольника будем получать по формуле: 
        *    n-я строка начинается с элемента с индексом (n * (n - 1)) // 2.
    *   Для `n` от 1, пока не использовали все элементы `s`:
        *    Начальный индекс `start_index` = (n * (n - 1)) // 2.
        *    Конечный индекс `end_index` = start_index + n.
        *   Добавить в `triangle` подсписок элементов из `s` с индексами от `start_index` до `end_index`.
3.  **Динамическое программирование:**
    *   Создать список `dp`  такого же размера, как и `triangle`, в которой будем хранить минимальные суммы подтреугольников.
    *   Пройти по строкам `triangle` снизу вверх. Пусть текущая строка с индексом i.
         *   Для каждого j элемента в строке i:
             *   Если строка последняя, `dp[i][j]` = `triangle[i][j]`
             *   Если строка не последняя, `dp[i][j]` = `triangle[i][j]` + `min(dp[i+1][j], dp[i+1][j+1])`.

4.  **Поиск минимальной суммы:**
    * Найти минимальное значение в списке `dp`.
5.  **Вернуть минимальную сумму.**

### 3. Реализация на Python 3.12

```python
def solve():
    t = 0
    s = []
    for _ in range(500500):
        t = (615949 * t + 797807) % (2**20)
        s.append(t - 2**19)

    triangle = []
    k = 0
    n = 1
    while k < len(s):
        triangle.append(s[k:k+n])
        k += n
        n += 1
    
    rows = len(triangle)
    dp = [[0 for _ in row] for row in triangle]

    for i in range(rows - 1, -1, -1):
        for j in range(len(triangle[i])):
            if i == rows - 1:
                dp[i][j] = triangle[i][j]
            else:
                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])

    min_sum = min(min(row) for row in dp)
    return min_sum

result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeT((Инициализировать t = 0))
    InitializeT --> GenerateS((Генерировать последовательность s))
    GenerateS --> CreateTriangle((Создать треугольник из s))
    CreateTriangle --> InitializeDP((Инициализировать dp))
    InitializeDP --> LoopRows((Начать цикл: i от rows-1 до 0))
     LoopRows --> LoopCols((Начать цикл: j от 0 до len(triangle[i])-1))
    LoopCols --> CheckLastRow((i == rows -1 ?))
    CheckLastRow -- Да --> AssignValueLastRow((dp[i][j] = triangle[i][j]))
    AssignValueLastRow --> LoopCols
    CheckLastRow -- Нет --> AssignValueNotLastRow((dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])))
    AssignValueNotLastRow --> LoopCols
    LoopCols --> LoopRows
    LoopRows --> FindMinSum((Найти минимальную сумму в dp))
    FindMinSum --> Output((Вернуть минимальную сумму))
    Output --> End((Конец))
```

**Легенда:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать t = 0:** Присваиваем начальное значение 0 переменной t для генерации последовательности псевдослучайных чисел.
*  **Генерировать последовательность s:** Генерируем последовательность чисел s согласно заданному правилу.
*   **Создать треугольник из s:** Создаем треугольную структуру данных из последовательности s.
*   **Инициализировать dp:** Инициализируем список dp, который будет использоваться для хранения минимальных сумм подтреугольников.
*   **Начать цикл: i от rows-1 до 0:** Начинаем внешний цикл, который проходит по строкам треугольника снизу вверх.
*   **Начать цикл: j от 0 до len(triangle[i])-1:** Начинаем внутренний цикл, который проходит по элементам текущей строки.
*   **i == rows -1 ?:** Проверяем, является ли текущая строка последней строкой в треугольнике.
*   **dp\[i]\[j] = triangle\[i]\[j]:** Если текущая строка является последней, присваиваем элементу dp минимальную сумму, равную значению элемента в треугольнике.
*   **dp\[i]\[j] = triangle\[i]\[j] + min(dp\[i+1]\[j], dp\[i+1]\[j+1]):** Если текущая строка не является последней, вычисляем минимальную сумму подтреугольника и сохраняем ее в dp.
*   **Найти минимальную сумму в dp:** Находим минимальную сумму среди всех минимальных сумм подтреугольников.
*   **Вернуть минимальную сумму:** Возвращаем найденное минимальное значение.
