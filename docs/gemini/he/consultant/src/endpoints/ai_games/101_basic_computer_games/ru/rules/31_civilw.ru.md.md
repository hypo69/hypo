## Анализ кода модуля `31_civilw.ru.md`

**Качество кода**

-   **Преимущества**
    -   Представлено подробное описание игры `CIVILW`, включая правила, пошаговую инструкцию, пример работы, возможные ограничения и реализацию.
    -   Имеется четкое структурирование текста с использованием заголовков и списков, что облегчает понимание.
    -   Приведены примеры взаимодействия пользователя с программой, что помогает представить игровой процесс.
    -   Указаны возможные ограничения, что помогает пользователю понять особенности игры.

-   **Недостатки**
    -   Отсутствует реализация кода игры, представлено только текстовое описание.
    -   Не используются никакие элементы кода в файле.
    -   Нет примеров использования кода.

**Рекомендации по улучшению**

1.  **Реализация кода:**
    -   Необходимо разработать код на Python, который будет соответствовать описанной логике игры.
    -   Использовать ввод пользователя для выбора стратегии.
    -   Реализовать логику подсчета потерь и определения победителя.
    -   Использовать модуль `random` для создания некоторой вариативности в результатах сражений.
2.  **Форматирование кода:**
    -   Включить код в блоки кода с соответствующей разметкой, например, `python`.
    -   Добавить комментарии к коду, объясняющие его работу.
3.  **Документация:**
    -   Добавить docstring к функциям, классам и модулю, используя формат reStructuredText (RST).
    -   Включить описание параметров и возвращаемых значений.
4.  **Обработка ошибок:**
    -   Добавить обработку возможных ошибок, таких как неверный ввод пользователя.
    -   Использовать `logger.error` для записи ошибок.
5.  **Улучшение игрового процесса:**
    -   Добавить возможность выбора разных битв.
    -   Ввести дополнительные параметры, такие как мораль войск или наличие ресурсов.
    -   Реализовать графический интерфейс, чтобы сделать игру более интересной.

**Улучшенный код**

```python
"""
Модуль для имитации сражений Гражданской войны США.
========================================================

Модуль содержит функции и классы для моделирования игры CIVILW.
Игра основана на исторических фактах и позволяет игроку управлять армией
Конфедератов, принимая стратегические решения.

Пример использования
--------------------

.. code-block:: python

    game = CivilWarGame()
    game.start_game()
"""
import random  # Импортируем модуль random для случайных чисел
from typing import Dict, List, Tuple  # Импортируем типы для аннотаций
from src.logger.logger import logger  # Импортируем logger для отладки
from src.utils.jjson import j_loads_ns # импортируем для работы с json
import os  # Импортируем модуль os для работы с путями

class CivilWarGame:
    """
    Класс для управления игрой "Гражданская война".

    Содержит методы для инициализации игры, обработки ходов и определения победителя.
    """

    def __init__(self):
        """
        Инициализация игры.

        Устанавливает начальные параметры игры, включая доступные сражения.
        """
        self.battles = {
            "Битва при Булл-Ран": {
                "confederate_losses": 400,
                "union_losses": 500,
            },
             "Битва при Шилох": {
                "confederate_losses": 1754,
                "union_losses": 1754,
            }
        } # исторические данные по потерям в сражениях
        self.player_losses = 0 # начальные потери игрока
        self.computer_losses = 0 # начальные потери компьютера
        self.current_battle = None # текущее сражение
        self.game_active = True  # Флаг активности игры

    def start_game(self) -> None:
        """
        Запускает игру.

        Выводит приветствие, выбирает сражение,
        запускает игровой цикл.
        """
        print("Добро пожаловать в игру CIVILW!")
        self._select_battle()
        self._game_loop()

    def _select_battle(self) -> None:
        """
        Выбор сражения.

        Выводит список доступных сражений и позволяет игроку выбрать одно из них.
        """
        print("Выберите сражение:")
        for i, battle in enumerate(self.battles.keys()):
            print(f"{i + 1}. {battle}")
        while True:
            try:
                choice = int(input("> ")) - 1
                if 0 <= choice < len(self.battles):
                    self.current_battle = list(self.battles.keys())[choice] # Выбираем сражение из списка
                    print(f"Вы выбрали битву: {self.current_battle}")
                    break
                else:
                    print("Неверный выбор. Пожалуйста, выберите из списка.")
            except ValueError:
                logger.error("Неверный ввод. Пожалуйста, введите число.")
                print("Неверный ввод. Пожалуйста, введите число.")

    def _get_player_strategy(self) -> int:
         """
         Получает стратегию игрока.

         Выводит список возможных стратегий и запрашивает ввод игрока.
         Возвращает выбранную стратегию в виде числа.

         :return: Выбранная стратегия игрока (int).
         """
         print("Выберите стратегию:")
         print("1. Артиллерийская атака")
         print("2. Укрепления против фронтальной атаки")
         print("3. Укрепления против фланговых маневров")
         print("4. Отступление")
         while True:
            try:
                strategy = int(input("> "))
                if 1 <= strategy <= 4:
                    return strategy
                else:
                    print("Неверный выбор. Пожалуйста, выберите из списка.")
            except ValueError:
                 logger.error("Неверный ввод. Пожалуйста, введите число.")
                 print("Неверный ввод. Пожалуйста, введите число.")

    def _execute_strategy(self, strategy: int) -> Tuple[int, int]:
        """
        Выполняет стратегию.

        Моделирует результаты выбранной стратегии и возвращает потери игрока и компьютера.

        :param strategy: Выбранная стратегия игрока (int).
        :return: Потери игрока и компьютера (Tuple[int, int]).
        """
        # Здесь можно добавить более сложную логику на основе выбранной стратегии
        confederate_losses = self.battles[self.current_battle]["confederate_losses"]
        union_losses = self.battles[self.current_battle]["union_losses"]

        player_losses = confederate_losses + random.randint(-100, 100) # Добавляем случайные числа для потерь
        computer_losses = union_losses + random.randint(-100, 100) # Добавляем случайные числа для потерь

        if strategy == 1: # Артиллерийская атака
            player_losses -= random.randint(0, 50) # Уменьшаем потери игрока в случайном порядке
            computer_losses += random.randint(0, 50) # Увеличиваем потери компьютера в случайном порядке
        elif strategy == 2: # Укрепления против фронтальной атаки
            player_losses += random.randint(0, 50) # Увеличиваем потери игрока в случайном порядке
            computer_losses -= random.randint(0, 50) # Уменьшаем потери компьютера в случайном порядке
        elif strategy == 3: # Укрепления против фланговых маневров
            player_losses += random.randint(0, 50) # Увеличиваем потери игрока в случайном порядке
            computer_losses -= random.randint(0, 50) # Уменьшаем потери компьютера в случайном порядке
        elif strategy == 4: # Отступление
            player_losses += random.randint(0, 100) # Увеличиваем потери игрока в случайном порядке
            computer_losses -= random.randint(0, 100) # Уменьшаем потери компьютера в случайном порядке
        return player_losses, computer_losses

    def _check_winner(self, player_losses: int, computer_losses: int) -> str:
        """
        Определяет победителя.

        Сравнивает потери игрока и компьютера и возвращает результат сражения.

        :param player_losses: Потери игрока (int).
        :param computer_losses: Потери компьютера (int).
        :return: Результат сражения (str).
        """
        if player_losses < computer_losses:
             return "Ваша стратегия была успешной! Вы выиграли сражение."
        elif player_losses > computer_losses:
             return "Ваша стратегия провалилась! Вы проиграли сражение."
        else:
            return "Ничья!"

    def _game_loop(self) -> None:
        """
        Основной игровой цикл.

        Выполняет цикл ходов, пока игра активна. Запрашивает стратегию игрока,
        определяет победителя и выводит результаты.
        """
        while self.game_active:
            strategy = self._get_player_strategy() # Получаем выбранную стратегию игрока
            player_losses, computer_losses = self._execute_strategy(strategy) # Выполняем выбранную стратегию
            self.player_losses += player_losses # Обновляем потери игрока
            self.computer_losses += computer_losses # Обновляем потери компьютера
            result = self._check_winner(player_losses, computer_losses) # Определяем победителя
            print(f"Потери игрока: {player_losses} человек.")
            print(f"Потери компьютера: {computer_losses} человек.")
            print(result)

            if not self._play_again():
                self.game_active = False
                print("Спасибо за игру!")

    def _play_again(self) -> bool:
        """
        Запрашивает, хочет ли игрок играть снова.

        Возвращает True, если игрок хочет играть снова, False в противном случае.

        :return: True, если игрок хочет играть снова, False в противном случае (bool).
        """
        while True:
            choice = input("Хотите сыграть снова? (да/нет)\n> ").lower()
            if choice in ["да", "нет"]:
                return choice == "да"
            else:
                 logger.error("Неверный ввод. Пожалуйста, введите 'да' или 'нет'.")
                 print("Неверный ввод. Пожалуйста, введите 'да' или 'нет'.")


if __name__ == "__main__":
    game = CivilWarGame()
    game.start_game()