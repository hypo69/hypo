"""
<TRAP>:
=================
Сложность: 5
-----------------
Игра "Ловушка" - это игра для двух игроков, в которой каждый игрок по очереди ставит свои метки (цифры 1 и 2) на игровом поле. Цель игры - окружить клетку противника своими клетками. Если игрок окружает клетку противника со всех сторон, клетка противника захватывается.

Правила игры:
1. Игровое поле - это квадратная сетка 7х7.
2. Два игрока по очереди вводят координаты клетки для размещения своей метки (1 или 2).
3. Если клетка окружена с четырех сторон метками противника, то метка захватывается и заменяется меткой захватившего игрока.
4. Игра заканчивается, когда все клетки заняты. Выигрывает тот игрок, у кого больше меток на поле.
-----------------
Алгоритм:
1.  Инициализировать игровое поле как пустую сетку 7x7.
2.  Установить текущего игрока как первого игрока (1).
3.  Начать основной цикл игры:
    3.1 Вывести текущее состояние игрового поля.
    3.2 Запросить у текущего игрока координаты для размещения метки.
    3.3 Проверить, является ли выбранная клетка пустой.
    3.4 Если клетка не пустая, сообщить игроку об ошибке и вернуться к шагу 3.2.
    3.5 Разместить метку текущего игрока на выбранной клетке.
    3.6 Проверить, нужно ли захватить какие-либо клетки противника:
        3.6.1 Для каждой клетки, окружающей текущую клетку:
            3.6.1.1 Если соседняя клетка принадлежит противнику:
                3.6.1.1.1 Проверить, является ли она окруженной со всех сторон метками текущего игрока.
                3.6.1.1.2 Если окружена, заменить метку противника на метку текущего игрока.
    3.7 Переключить текущего игрока (с 1 на 2 или с 2 на 1).
    3.8 Повторять цикл, пока все клетки не будут заняты.
4.  Подсчитать количество меток каждого игрока.
5.  Объявить победителя (игрока с наибольшим количеством меток).
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["Инициализация игрового поля: 7x7 (пустые клетки)"]
    InitializeBoard --> SetCurrentPlayer["Установить текущего игрока: player = 1"]
    SetCurrentPlayer --> GameLoopStart{"Начало игрового цикла: пока не все клетки заполнены"}
    GameLoopStart -- Да --> DisplayBoard["Вывести текущее состояние игрового поля"]
    DisplayBoard --> GetMove["Ввод хода игрока: координаты клетки (row, col)"]
    GetMove --> ValidateMove{"Проверка: клетка (row, col) пуста?"}
    ValidateMove -- Нет --> DisplayError["Вывести сообщение об ошибке: клетка занята"]
    DisplayError --> GetMove
    ValidateMove -- Да --> PlaceMove["Разместить метку текущего игрока на клетке (row, col)"]
    PlaceMove --> CheckCaptureStart{"Начало цикла проверки захвата для соседних клеток"}
    CheckCaptureStart --> CheckNeighbors{"Проверить соседние клетки"}
     CheckNeighbors -- Соседняя клетка принадлежит противнику --> CheckSurrounded{"Проверить, окружена ли клетка противника метками текущего игрока?"}
       CheckSurrounded -- Да --> CaptureCell["Захватить клетку противника"]
        CaptureCell --> CheckCaptureEnd["Конец цикла проверки захвата"]
        CheckSurrounded -- Нет --> CheckCaptureEnd
     CheckNeighbors -- Соседняя клетка не принадлежит противнику --> CheckCaptureEnd
    CheckCaptureEnd --> SwitchPlayer["Переключить текущего игрока: если player=1, то player=2, иначе player=1"]
    SwitchPlayer --> CheckBoardFull{"Проверка: все клетки на поле заполнены?"}
    CheckBoardFull -- Нет --> GameLoopStart
     CheckBoardFull -- Да --> CalculateScores["Подсчитать количество меток каждого игрока"]
    CalculateScores --> DetermineWinner["Определить победителя"]
    DetermineWinner --> End["Конец игры"]
    GameLoopStart -- Нет --> End
```
**Legenda:**
    Start - Начало игры.
    InitializeBoard - Инициализация игрового поля: создание сетки 7x7 и заполнение её пустыми клетками.
    SetCurrentPlayer - Установка текущего игрока как первого игрока (1).
    GameLoopStart - Начало основного игрового цикла, который продолжается, пока все клетки на поле не будут заполнены.
    DisplayBoard - Вывод текущего состояния игрового поля в консоль.
    GetMove - Запрос у текущего игрока координат клетки (строки и столбца), куда он хочет поставить свою метку.
    ValidateMove - Проверка, пуста ли выбранная клетка.
    DisplayError - Вывод сообщения об ошибке, если выбранная клетка уже занята.
    PlaceMove - Размещение метки текущего игрока на выбранной клетке.
    CheckCaptureStart - Начало цикла проверки захвата клеток противника.
    CheckNeighbors - Проверка соседних клеток вокруг только что размещенной метки.
    CheckSurrounded - Проверка, окружена ли соседняя клетка противника со всех сторон метками текущего игрока.
    CaptureCell - Захват клетки противника, заменяя её на метку текущего игрока.
    CheckCaptureEnd - Конец цикла проверки захвата клеток.
    SwitchPlayer - Переключение текущего игрока: если игрок был 1, то становится 2, и наоборот.
    CheckBoardFull - Проверка, все ли клетки на игровом поле заполнены.
    CalculateScores - Подсчет количества клеток, занятых каждым игроком.
    DetermineWinner - Определение победителя на основе подсчета занятых клеток.
    End - Конец игры.
"""
import copy

# Размер игрового поля
BOARD_SIZE = 7

# Функция для создания пустого игрового поля
def create_board():
    # Создаем двумерный список, представляющий игровое поле, заполненный нулями (пустые клетки)
    return [[0 for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]

# Функция для отображения текущего состояния игрового поля
def display_board(board):
    # Выводим номера колонок
    print("  ", end="")
    for col in range(BOARD_SIZE):
        print(f"{col} ", end="")
    print()
    # Для каждой строки игрового поля
    for row in range(BOARD_SIZE):
        # Выводим номер строки
        print(f"{row} ", end="")
        # Для каждой клетки в текущей строке
        for col in range(BOARD_SIZE):
             # Выводим содержимое клетки, заменяя 0 на '.', 1 на '1', 2 на '2'
            print(f"{'.' if board[row][col] == 0 else str(board[row][col])} ", end="")
        # Переход на новую строку
        print()


# Функция для проверки, находится ли координата в пределах игрового поля
def is_valid_move(row, col):
    # Проверяем, находятся ли координаты в допустимом диапазоне (от 0 до BOARD_SIZE - 1)
    return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE

# Функция для проверки, является ли клетка пустой
def is_cell_empty(board, row, col):
    # Возвращаем True, если клетка пуста (значение 0), иначе False
    return board[row][col] == 0

# Функция для получения соседних клеток
def get_neighbors(row, col):
    # Возвращает список координат соседних клеток (сверху, снизу, слева, справа)
    neighbors = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
         new_row, new_col = row + dr, col + dc
         if is_valid_move(new_row, new_col):
             neighbors.append((new_row, new_col))
    return neighbors

# Функция для проверки, может ли клетка противника быть захвачена
def can_capture(board, row, col, current_player):
    # Получаем номер противника (если текущий игрок 1, то противник 2, и наоборот)
    opponent_player = 3 - current_player
     # Если клетка не принадлежит противнику, то она не может быть захвачена
    if board[row][col] != opponent_player:
        return False
    
    # Получаем соседние клетки
    neighbors = get_neighbors(row, col)
    # Проверяем, окружена ли клетка противника клетками текущего игрока
    # Если соседних клеток меньше 4, то клетка не может быть захвачена
    if len(neighbors) < 4:
        return False
    # Проверяем, являются ли все соседние клетки метками текущего игрока
    for neighbor_row, neighbor_col in neighbors:
        if board[neighbor_row][neighbor_col] != current_player:
            return False
    # Если все проверки пройдены, клетка может быть захвачена
    return True

# Функция для захвата клетки
def capture_cell(board, row, col, current_player):
    # Меняем значение клетки на значение текущего игрока
    board[row][col] = current_player

# Функция для выполнения хода игрока
def make_move(board, row, col, current_player):
    # Размещаем метку текущего игрока на выбранной клетке
    board[row][col] = current_player
    # Получаем список соседних клеток
    neighbors = get_neighbors(row, col)
    # Проверяем, может ли клетка противника быть захвачена
    for neighbor_row, neighbor_col in neighbors:
       # Если соседняя клетка может быть захвачена
       if can_capture(board, neighbor_row, neighbor_col, current_player):
            # Захватываем клетку
           capture_cell(board, neighbor_row, neighbor_col, current_player)


# Функция для переключения текущего игрока
def switch_player(current_player):
    # Переключаем игрока с 1 на 2 или с 2 на 1
    return 3 - current_player

# Функция для проверки, заполнено ли игровое поле
def is_board_full(board):
    # Проходим по каждой клетке на поле
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            # Если клетка пуста (значение 0), возвращаем False (поле не заполнено)
            if board[row][col] == 0:
                return False
    # Если все клетки заполнены, возвращаем True
    return True

# Функция для подсчета очков
def calculate_scores(board):
    # Инициализируем счетчики для каждого игрока
    player1_score = 0
    player2_score = 0
    # Проходим по каждой клетке на поле
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            # Если в клетке метка первого игрока, увеличиваем его счетчик
            if board[row][col] == 1:
                player1_score += 1
            # Если в клетке метка второго игрока, увеличиваем его счетчик
            elif board[row][col] == 2:
                player2_score += 1
    # Возвращаем счетчики игроков
    return player1_score, player2_score

# Функция для определения победителя
def determine_winner(player1_score, player2_score):
    # Если у первого игрока больше очков, объявляем его победителем
    if player1_score > player2_score:
        return "Победил игрок 1!"
    # Если у второго игрока больше очков, объявляем его победителем
    elif player2_score > player1_score:
        return "Победил игрок 2!"
    # Если количество очков одинаковое, объявляем ничью
    else:
        return "Ничья!"


# Основная функция игры
def play_trap_game():
    # Создаем новое игровое поле
    board = create_board()
    # Устанавливаем первого игрока
    current_player = 1
    # Начинаем игровой цикл
    while not is_board_full(board):
        # Выводим текущее состояние игрового поля
        display_board(board)
        # Запрашиваем координаты хода у текущего игрока
        while True:
            try:
                row = int(input(f"Игрок {current_player}, введите номер строки (0-{BOARD_SIZE - 1}): "))
                col = int(input(f"Игрок {current_player}, введите номер столбца (0-{BOARD_SIZE - 1}): "))
            except ValueError:
                  print("Некорректный ввод. Пожалуйста, введите целые числа.")
                  continue
            # Проверяем, находится ли введенные координаты в пределах игрового поля
            if not is_valid_move(row, col):
                print("Некорректный ход. Координаты выходят за пределы поля.")
                continue
            # Проверяем, является ли выбранная клетка пустой
            if not is_cell_empty(board, row, col):
                print("Некорректный ход. Клетка уже занята.")
                continue
            # Если все проверки пройдены, выходим из внутреннего цикла
            break
         # Выполняем ход игрока
        make_move(board, row, col, current_player)
        # Переключаем текущего игрока
        current_player = switch_player(current_player)
    
    # Выводим финальное состояние игрового поля
    display_board(board)
    # Подсчитываем количество очков каждого игрока
    player1_score, player2_score = calculate_scores(board)
    # Определяем победителя
    winner = determine_winner(player1_score, player2_score)
    # Выводим результат игры
    print(f"Игрок 1: {player1_score} очков")
    print(f"Игрок 2: {player2_score} очков")
    print(winner)

# Запускаем игру
if __name__ == "__main__":
    play_trap_game()
"""
Объяснение кода:
1. **Импорт модуля `copy`**:
   - `import copy`: Импортирует модуль `copy` для создания глубоких копий списков (игрового поля).
2. **Константы**:
   - `BOARD_SIZE = 7`: Определяет размер игрового поля (7x7).
3. **Функция `create_board()`**:
   - Создает и возвращает пустое игровое поле в виде двумерного списка, заполненного нулями.
4. **Функция `display_board(board)`**:
    - Принимает игровое поле в качестве аргумента.
    - Выводит текущее состояние игрового поля в консоль, используя символы '.' для пустых клеток, '1' для меток первого игрока и '2' для меток второго игрока.
5.  **Функция `is_valid_move(row, col)`**:
   - Проверяет, находятся ли координаты (row, col) в пределах игрового поля.
   - Возвращает `True`, если координаты действительны, иначе `False`.
6.  **Функция `is_cell_empty(board, row, col)`**:
    - Проверяет, является ли клетка с координатами (row, col) пустой (равна 0).
    - Возвращает `True`, если клетка пуста, иначе `False`.
7.  **Функция `get_neighbors(row, col)`**:
    - Возвращает список координат соседних клеток для заданной клетки (сверху, снизу, слева и справа).
    - Исключает координаты, выходящие за границы игрового поля.
8.  **Функция `can_capture(board, row, col, current_player)`**:
   - Проверяет, может ли клетка противника (с координатами row, col) быть захвачена текущим игроком.
   - Возвращает `True`, если клетка может быть захвачена, иначе `False`.
9.  **Функция `capture_cell(board, row, col, current_player)`**:
    - Захватывает клетку противника, изменяя её значение на значение текущего игрока.
10. **Функция `make_move(board, row, col, current_player)`**:
     - Размещает метку текущего игрока на выбранной клетке.
     - Проверяет и захватывает соседние клетки противника, если они могут быть захвачены.
11. **Функция `switch_player(current_player)`**:
    - Меняет текущего игрока (с 1 на 2 или с 2 на 1).
12. **Функция `is_board_full(board)`**:
    - Проверяет, заполнено ли все игровое поле.
    - Возвращает `True`, если все клетки заняты, иначе `False`.
13. **Функция `calculate_scores(board)`**:
    - Подсчитывает количество меток каждого игрока на игровом поле.
    - Возвращает количество очков для каждого игрока.
14. **Функция `determine_winner(player1_score, player2_score)`**:
    - Определяет победителя на основе подсчитанных очков.
    - Возвращает сообщение о победителе или ничьей.
15. **Функция `play_trap_game()`**:
    - Основная функция, управляющая ходом игры.
    - Инициализирует игровое поле, текущего игрока, и запускает основной игровой цикл.
    - Запрашивает ходы игроков, обрабатывает их, проверяет на корректность, захватывает клетки и переключает игроков.
    - Выводит текущее состояние игрового поля и результаты игры.
16. **Запуск игры**:
   -  `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_trap_game()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
   -  `play_trap_game()`: Вызывает функцию для начала игры.
"""
