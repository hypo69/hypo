## Анализ кода модуля `awari.py`

**Качество кода**
-   **Соблюдение требований к формату кода (1-10):**
    -   **Преимущества:**
        -   Код имеет базовую структуру и логику игры Авари.
        -   Функции разделены по логическим блокам: отрисовка доски, ход игрока, ход компьютера, проверка окончания игры, определение победителя.
        -   Используется простой и понятный подход для представления игрового поля (список).
    -   **Недостатки:**
        -   Отсутствует reStructuredText (RST) для документирования модуля, классов и функций.
        -   Не используются `j_loads` или `j_loads_ns` для чтения данных из файла.
        -   Нет обработки ошибок с помощью `logger.error`, что может затруднить отладку и сопровождение.
        -   Используется глобальная переменная `board` для представления игрового поля, что может сделать код менее гибким и тестируемым.
        -   Дублирование кода в `player_turn` и `computer_turn` (логика перемещения камней и захвата).
        -   Нет явной проверки окончания игры после каждого хода, что может приводить к неверному завершению игры при определенных условиях.
        -   Не хватает комментариев, объясняющих логику игры и конкретные шаги в коде.

**Рекомендации по улучшению**

1.  **Документация:**
    -   Добавить docstring в формате RST для модуля, функций и переменных.
    -   Использовать RST для документирования входных и выходных параметров функций, а также для описания их назначения.
2.  **Импорты:**
    -   Добавить импорт `logger` из `src.logger.logger` для записи ошибок.
3.  **Обработка ошибок:**
    -   Заменить `try-except` блоки на использование `logger.error` для отслеживания исключений.
4.  **Структура данных:**
    -   Рассмотреть возможность создания класса `Board` для управления состоянием доски.
5.  **Рефакторинг:**
    -   Вынести общую логику перемещения камней в отдельную функцию, чтобы избежать дублирования кода.
    -   Рассмотреть возможность использования `enum` для определения статусов клеток игрока и компьютера.
6.  **Логика игры:**
    -   Добавить проверку окончания игры после каждого хода, чтобы избежать некорректного завершения.
7.  **Комментарии:**
    -   Добавить более подробные комментарии, объясняющие логику игры и назначение различных частей кода.
    -   Избегать использования вводных слов ("делает", "принимает", "возвращает").

**Улучшенный код**

```python
"""
Модуль для игры в Авари.
=========================================================================================

Модуль имитирует настольную игру Манкала, где два игрока по очереди перемещают "камни" по доске.
Это упрощенная версия игры, где игрок играет против компьютера.

Правила игры:
1. Игровое поле состоит из 14 ячеек, пронумерованных от 0 до 13. Ячейки 6 и 13 - это "амбары" игроков.
2. В начале игры в каждой из 12 ячеек (0-5 и 7-12) находится по 4 камня.
3. Игрок (человек) начинает игру.
4. Выбирает ячейку со своими камнями (0-5).
5. Все камни из выбранной ячейки перемещаются по одному в каждую следующую ячейку по часовой стрелке, включая свой "амбар".
6. Если последний камень попал в амбар игрока, игрок имеет право сделать еще один ход.
7. Если последний камень попал в пустую ячейку на стороне игрока, и напротив этой ячейки есть камни, то игрок забирает камни из этой ячейки и из противоположной в свой амбар.
8. Компьютер ходит аналогично.
9. Игра заканчивается, когда все ячейки с камнями становятся пустыми.
10. Выигрывает игрок, у которого больше камней в амбаре.

Пример использования
--------------------

.. code-block:: python

    # Запуск игры
    play_game()

"""
import random
from src.logger.logger import logger # Добавлен импорт logger #
#from src.utils.jjson import j_loads #  Пример использования j_loads, если бы требовалось чтение из файла
#from enum import Enum # TODO: использование enum для статусов клеток

# Инициализация доски.
# Ячейки 0-5 - ячейки игрока, 6 - амбар игрока
# Ячейки 7-12 - ячейки компьютера, 13 - амбар компьютера
board = [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]  # Игровое поле

def display_board():
    """Выводит текущее состояние игровой доски."""
    print("----------------------------------------------------")
    print(f"  {board[12]:2}  {board[11]:2}  {board[10]:2}  {board[9]:2}  {board[8]:2}  {board[7]:2}   ")
    print("----------------------------------------------------")
    print(f"{board[13]:2}                                 {board[6]:2}")
    print("----------------------------------------------------")
    print(f"  {board[0]:2}  {board[1]:2}  {board[2]:2}  {board[3]:2}  {board[4]:2}  {board[5]:2}  ")
    print("----------------------------------------------------")

def _move_stones(cell: int, is_player: bool):
    """Перемещает камни с выбранной ячейки по доске.

        :param cell: Индекс ячейки, из которой перемещаются камни.
        :param is_player: True, если ход игрока, иначе False.
    """
    stones = board[cell]  # Количество камней в выбранной ячейке #
    board[cell] = 0   # Обнулить выбранную ячейку #
    current_cell = cell  # Текущая ячейка #

    while stones > 0:   # Пока есть камни для перемещения #
        current_cell = (current_cell + 1) % 14  #  Переход к следующей ячейке (по кругу) #
        board[current_cell] += 1   # Увеличение количества камней в текущей ячейке #
        stones -= 1    # Уменьшение количества камней для перемещения #

    # Проверка на дополнительный ход если последний камень попал в амбар игрока/компьютера
    if (is_player and current_cell == 6) or (not is_player and current_cell == 13): # проверка дополнительного хода #
        print("Игрок получает дополнительный ход." if is_player else "Компьютер получает дополнительный ход.")
        display_board()   # Отобразить обновленную доску #
        if is_player:
            player_turn()
        else:
            computer_turn()
        return

    # Захват камней
    if (is_player and 0 <= current_cell <= 5 and board[current_cell] == 1) or \
       (not is_player and 7 <= current_cell <= 12 and board[current_cell] == 1): # проверка захвата камней #
        opposite_cell = 12 - current_cell    # Вычисление индекса противоположной ячейки #
        if board[opposite_cell] > 0:     # Проверка, есть ли камни в противоположной ячейке #
            if is_player:
                board[6] += board[opposite_cell] + 1   # Перемещение камней в амбар игрока #
            else:
                board[13] += board[opposite_cell] + 1    # Перемещение камней в амбар компьютера #
            board[opposite_cell] = 0    # Обнуление противоположной ячейки #
            board[current_cell] = 0     # Обнуление текущей ячейки #
            print(f"Игрок захватывает камни из ячеек {current_cell} и {opposite_cell}" if is_player else  # Вывод сообщения о захвате #
                  f"Компьютер захватывает камни из ячеек {current_cell} и {opposite_cell}")

def player_turn():
    """Обрабатывает ход игрока."""
    while True:
        try:
            cell = int(input("Выберите ячейку (0-5): "))  # Запрос ввода ячейки от пользователя #
            if 0 <= cell <= 5 and board[cell] > 0:   # Проверка валидности ввода #
                break  #  Выход из цикла, если ввод корректен #
            else:
                print("Недопустимый выбор. Выберите ячейку с камнями от 0 до 5.") # Сообщение об ошибке в выборе #
        except ValueError as e: # Обработка ошибки, если ввод не является числом #
             logger.error(f'Неверный ввод при выборе ячейки игроком {e}', exc_info=True)  # Логирование ошибки с помощью logger #
             print("Неверный ввод. Пожалуйста, введите число.")  # Сообщение об ошибке ввода #
             continue

    _move_stones(cell, True) # Вызов функции для выполнения хода игрока #

def computer_turn():
    """Обрабатывает ход компьютера."""
    possible_moves = [i for i in range(7, 13) if board[i] > 0]  # Поиск доступных ходов для компьютера #
    if not possible_moves:  # Проверка, есть ли доступные ходы #
        return   # Выход из функции, если нет доступных ходов #

    cell = random.choice(possible_moves) # Выбор случайной ячейки для хода #
    print(f"Компьютер выбирает ячейку {cell}") # Вывод сообщения о выборе компьютера #
    _move_stones(cell, False)  # Вызов функции для выполнения хода компьютера #


def is_game_over():
    """Проверяет, закончена ли игра."""
    player_side_empty = all(board[i] == 0 for i in range(0, 6))  # Проверка, пусты ли ячейки игрока #
    computer_side_empty = all(board[i] == 0 for i in range(7, 13)) # Проверка, пусты ли ячейки компьютера #
    return player_side_empty or computer_side_empty   # Возврат True, если хотя бы одна сторона пуста #

def calculate_winner():
    """Определяет победителя и выводит результаты."""
    player_score = board[6]    # Количество очков у игрока #
    computer_score = board[13]  # Количество очков у компьютера #

    print(f"Игрок: {player_score} очков") # Вывод количества очков игрока #
    print(f"Компьютер: {computer_score} очков")  # Вывод количества очков компьютера #

    if player_score > computer_score:  # Проверка, кто победил #
        print("Вы победили!")   # Вывод сообщения, если победил игрок #
    elif computer_score > player_score:  # Проверка, кто победил #
        print("Компьютер победил!")    # Вывод сообщения, если победил компьютер #
    else:
        print("Ничья!")  # Вывод сообщения о ничьей #

def play_game():
    """Основной игровой цикл."""
    while True:
        display_board()  # Отображение доски #
        player_turn()  # Ход игрока #
        if is_game_over(): # Проверка окончания игры #
            break # Завершение цикла, если игра окончена #

        display_board() # Отображение доски #
        computer_turn() # Ход компьютера #
        if is_game_over(): # Проверка окончания игры #
            break  # Завершение цикла, если игра окончена #

    # После завершения игры
    display_board() # Отображение доски #
    calculate_winner()  # Определение победителя #

# Запуск игры
if __name__ == '__main__':
    play_game()
```