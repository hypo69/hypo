# Анализ кода модуля `salvo.py`

**Качество кода**
8
-  Плюсы
    - Код хорошо структурирован и разбит на функции, что облегчает понимание и поддержку.
    - Игровой процесс логически понятен и соответствует правилам игры "Морской бой".
    - Используются понятные имена переменных и функций.
    - Присутствует базовая обработка ошибок ввода пользователя.
    - Есть подробное описание алгоритма игры и блок-схема.
-  Минусы
    - Отсутствует reStructuredText (RST) документация для функций, классов и модуля.
    - Используется стандартный `try-except` блок, вместо `logger.error`.
    - В коде не используются константы для размеров поля и типов кораблей.
    - Размещение кораблей является упрощенным, не учитывает ситуации, когда корабли могут располагаться слишком близко друг к другу.
    - Нет обработки повторного ввода одних и тех же координат.

**Рекомендации по улучшению**

1.  **Документирование**:
    - Добавить  RST-совместимую документацию для модуля, функций и переменных.
    - Обновить docstring для всех функций и методов в соответствии со стандартами reStructuredText.
2.  **Логирование**:
    - Заменить `try-except` блоки на использование `logger.error` для обработки ошибок.
3.  **Константы**:
    - Использовать константы для размера игрового поля и длин кораблей, чтобы сделать код более читаемым и поддерживаемым.
4.  **Размещение кораблей**:
    - Улучшить алгоритм размещения кораблей, чтобы избежать их наложения и расположения слишком близко друг к другу.
5. **Обработка повторного ввода**:
    - Добавить проверку, что пользователь не вводит одни и те же координаты несколько раз.

**Оптимизиробанный код**

```python
"""
Модуль для игры в "SALVO" (Морской бой)
======================================

Этот модуль реализует консольную версию игры "Морской бой", где игрок пытается потопить корабли противника,
размещенные на игровом поле.

Основные особенности:
-   Игровое поле размером 10x10.
-   Случайное размещение кораблей разных размеров.
-   Вывод игрового поля в консоль с отображением результатов выстрелов.
-   Подсчет количества выстрелов.
-   Проверка на потопление корабля.

Пример использования
--------------------

.. code-block:: python

    if __name__ == "__main__":
        play_salvo()

"""
import random
from src.logger.logger import logger
#from src.utils.jjson import j_loads, j_loads_ns  # TODO: если нужны будут j_loads
# Константы для размера игрового поля и длин кораблей
BOARD_SIZE = 10
SHIPS_LENGTHS = [2, 3, 4, 5]


def create_board(size: int) -> list[list[int]]:
    """
    Создаёт игровое поле заданного размера.

    :param size: Размер игрового поля (например, 10 для поля 10x10).
    :type size: int
    :return: Двумерный список, представляющий игровое поле, заполненное нулями.
    :rtype: list[list[int]]
    """
    # код возвращает список, представляющий игровое поле, заполненное нулями
    return [[0 for _ in range(size)] for _ in range(size)]


def place_ships(board: list[list[int]], ships_lengths: list[int]) -> list[tuple[int, int, str, int]]:
    """
    Размещает корабли на игровом поле случайным образом.

    :param board: Игровое поле, представленное двумерным списком.
    :type board: list[list[int]]
    :param ships_lengths: Список длин кораблей для размещения.
    :type ships_lengths: list[int]
    :return: Список кортежей, содержащих информацию о размещенных кораблях (строка, столбец, ориентация, длина).
    :rtype: list[tuple[int, int, str, int]]
    """
    ships = []
    for length in ships_lengths:
        placed = False
        while not placed:
            orientation = random.choice(['horizontal', 'vertical'])
            if orientation == 'horizontal':
                row = random.randint(0, len(board) - 1)
                col = random.randint(0, len(board) - length)
                if all(board[row][col + i] == 0 for i in range(length)):
                     for i in range(length):
                         board[row][col + i] = 1
                     ships.append((row, col, orientation, length))
                     placed = True

            elif orientation == 'vertical':
                row = random.randint(0, len(board) - length)
                col = random.randint(0, len(board) - 1)
                if all(board[row + i][col] == 0 for i in range(length)):
                    for i in range(length):
                        board[row + i][col] = 1
                    ships.append((row, col, orientation, length))
                    placed = True

    return ships


def is_sunk(board: list[list[str]], ship: tuple[int, int, str, int]) -> bool:
    """
    Проверяет, потоплен ли корабль.

    :param board: Игровое поле.
    :type board: list[list[str]]
    :param ship: Кортеж, содержащий информацию о корабле (строка, столбец, ориентация, длина).
    :type ship: tuple[int, int, str, int]
    :return: True, если корабль потоплен, иначе False.
    :rtype: bool
    """
    row, col, orientation, length = ship
    if orientation == 'horizontal':
      return all(board[row][col + i] == 'hit' for i in range(length))
    else:
       return all(board[row + i][col] == 'hit' for i in range(length))


def print_board(board: list[list[str]]) -> None:
    """
    Выводит игровое поле в консоль.

    :param board: Игровое поле для вывода.
    :type board: list[list[str]]
    """
    size = len(board)
    print("  " + " ".join(str(i) for i in range(size)))
    for i, row in enumerate(board):
        print(str(i) + " " + " ".join('~' if cell == 0 or cell == 1 else cell for cell in row))


def play_salvo() -> None:
    """
    Основная функция, реализующая игровой процесс "Морского боя".
    """
    #  код устанавливает размер игрового поля
    board_size = BOARD_SIZE
    #  код устанавливает длины кораблей
    ships_lengths = SHIPS_LENGTHS
    #  код создает игровое поле
    board = create_board(board_size)
    # код размещает корабли на поле
    ships = place_ships(board, ships_lengths)
    # код инициализирует счетчик выстрелов
    number_of_shots = 0
    #  код инициализирует счетчик потопленных кораблей
    sunk_ships_count = 0
    #  код выводит игровое поле
    print_board(board)
    # игровой цикл пока не все корабли потоплены
    while sunk_ships_count < len(ships):
        try:
             #  код запрашивает у пользователя координаты выстрела
            x = int(input("Введите координату X (0-9): "))
            y = int(input("Введите координату Y (0-9): "))
            #  код проверяет корректность координат
            if not (0 <= x < board_size and 0 <= y < board_size):
                print("Неверные координаты. Попробуйте снова.")
                continue

        except ValueError as ex:
             #  если пользователь ввел не число, код выводит сообщение об ошибке
            logger.error("Неверный ввод. Пожалуйста, введите числа от 0 до 9.", exc_info=ex)
            continue

        number_of_shots += 1
        if board[x][y] == 1:
             #  код помечает попадание в корабль
            board[x][y] = 'hit'
            ship_sunk = False
            for ship in ships:
              if is_sunk(board, ship):
                  print("SINK")
                  ship_sunk = True
                  sunk_ships_count += 1
                  ships.remove(ship)
                  break
            if not ship_sunk:
              print("HIT")
        elif board[x][y] == 0:
            # код помечает промах
            board[x][y] = 'miss'
            print("MISS")
        else:
           print("Вы уже стреляли по этим координатам")

        print_board(board)
    #  код выводит сообщение о победе и количестве выстрелов
    print(f"YOU SUNK ALL MY SHIPS IN {number_of_shots} SHOTS")

if __name__ == "__main__":
    play_salvo()
"""
Объяснение кода:
1.  **Импорт модуля `random`**:
    -   `import random`: Импортирует модуль `random` для генерации случайных чисел и выбора случайного направления для размещения кораблей.
    -   `from src.logger.logger import logger`: Импортирует логгер для обработки ошибок.
2.  **Константы**:
    - `BOARD_SIZE = 10`: Задает размер игрового поля.
    - `SHIPS_LENGTHS = [2, 3, 4, 5]`: Список длин кораблей для размещения.
3.  **Функция `create_board(size)`**:
    -   `def create_board(size: int) -> list[list[int]]:`: Определяет функцию, которая создает игровое поле в виде двумерного списка.
    -   `:param size: Размер игрового поля (например, 10 для поля 10x10).`: Описание параметра `size`.
    -   `:type size: int`: Указание типа параметра `size`.
    -   `:return: Двумерный список, представляющий игровое поле, заполненное нулями.`: Описание возвращаемого значения.
    -   `:rtype: list[list[int]]`: Указание типа возвращаемого значения.
    -   `return [[0 for _ in range(size)] for _ in range(size)]`: Возвращает список, представляющий игровое поле. Все ячейки инициализируются значением `0`, что означает пустое поле.
4.  **Функция `place_ships(board, ships_lengths)`**:
    -   `def place_ships(board: list[list[int]], ships_lengths: list[int]) -> list[tuple[int, int, str, int]]:`: Определяет функцию для размещения кораблей на игровом поле. Принимает игровое поле `board` и список длин кораблей `ships_lengths`.
    -   `:param board: Игровое поле, представленное двумерным списком.`: Описание параметра `board`.
    -   `:type board: list[list[int]]`: Указание типа параметра `board`.
    -   `:param ships_lengths: Список длин кораблей для размещения.`: Описание параметра `ships_lengths`.
    -   `:type ships_lengths: list[int]`: Указание типа параметра `ships_lengths`.
    -   `:return: Список кортежей, содержащих информацию о размещенных кораблях (строка, столбец, ориентация, длина).`: Описание возвращаемого значения.
    -   `:rtype: list[tuple[int, int, str, int]]`: Указание типа возвращаемого значения.
    -   `ships = []`: Инициализирует список для хранения данных о размещенных кораблях.
    -   `for length in ships_lengths:`: Начинает цикл по длинам кораблей.
    -   `placed = False`: Инициализирует флаг для контроля размещения корабля.
    -   `while not placed:`: Начинает цикл, пока корабль не будет успешно размещен.
    -   `orientation = random.choice(['horizontal', 'vertical'])`: Выбирает случайное направление (горизонтальное или вертикальное) для размещения корабля.
    -   Блоки `if orientation == 'horizontal'` и `elif orientation == 'vertical'` отвечают за попытку размещения корабля в выбранном направлении.
         -  `row = random.randint(0, len(board) - 1)` и `col = random.randint(0, len(board) - length)`: Генерируются случайные начальные координаты для размещения корабля.
        - `all(board[row][col + i] == 0 for i in range(length))`: Проверяется, что все клетки, необходимые для размещения корабля, свободны.
    -   Если все условия выполнены, то корабль размещается (`board[row][col + i] = 1`) на поле, данные о корабле сохраняются в список `ships`, и цикл `while not placed` завершается.
    -   `return ships`: Функция возвращает список с данными о размещенных кораблях.
5.  **Функция `is_sunk(board, ship)`**:
    -  `def is_sunk(board: list[list[str]], ship: tuple[int, int, str, int]) -> bool:`: Функция, которая проверяет, потоплен ли корабль
    -   `:param board: Игровое поле.`: Описание параметра `board`.
    -   `:type board: list[list[str]]`: Указание типа параметра `board`.
    -   `:param ship: Кортеж, содержащий информацию о корабле (строка, столбец, ориентация, длина).`: Описание параметра `ship`.
    -   `:type ship: tuple[int, int, str, int]`: Указание типа параметра `ship`.
    -   `:return: True, если корабль потоплен, иначе False.`: Описание возвращаемого значения.
    -   `:rtype: bool`: Указание типа возвращаемого значения.
    -   `row, col, orientation, length = ship`: распаковывает данные о корабле.
    -   Блоки `if orientation == 'horizontal'` и `else` возвращают  `True`, если все части корабля помечены как `hit`, иначе возвращают `False`.
6.  **Функция `print_board(board)`**:
    -   `def print_board(board: list[list[str]]) -> None:`: Определяет функцию для вывода игрового поля в консоль.
    -   `:param board: Игровое поле для вывода.`: Описание параметра `board`.
    -   `:type board: list[list[str]]`: Указание типа параметра `board`.
    -   `print("  " + " ".join(str(i) for i in range(size)))`: Выводит номера столбцов для удобства пользователя.
    -   `print(str(i) + " " + " ".join('~' if cell == 0 or cell == 1 else cell for cell in row))`: Для каждой строки выводит номер строки и ячейки игрового поля:
        -   `'~'` выводится, если в ячейке `0` или `1` (пустая клетка или неповрежденная часть корабля).
        -   Значение ячейки выводится, если оно не `0` и не `1` (например, `'hit'` или `'miss'`).
7.  **Функция `play_salvo()`**:
    -   `def play_salvo() -> None:`: Определяет главную функцию игры.
    -   код устанавливает размер игрового поля, используя константу `BOARD_SIZE`.
    -   код устанавливает длины кораблей, используя константу `SHIPS_LENGTHS`.
    -   код создает игровое поле.
    -   код размещает корабли на поле.
    -   код инициализирует счетчик выстрелов.
    -   код инициализирует счетчик потопленных кораблей.
    -   код выводит игровое поле.
    -   игровой цикл пока не все корабли потоплены
        -   код запрашивает у пользователя координаты выстрела.
        -   код проверяет корректность координат.
        -  если пользователь ввел не число, код выводит сообщение об ошибке, используя `logger.error`
        -  код увеличивает счетчик выстрелов.
        -   Блок `if board[x][y] == 1:` выполняется, если выстрел попал в корабль.
            - `board[x][y] = 'hit'` - отметка попадания в корабль.
            - перебирает все корабли и проверяет, потоплен ли какой-либо из них, с помощью функции `is_sunk`.
            - если корабль потоплен, то выводит сообщение, увеличивает счетчик потопленных кораблей и удаляет данные о потопленном корабле из списка `ships`.
            - если корабль не потоплен, то выводит сообщение `HIT`.
       - `elif board[x][y] == 0:` выполняется, если выстрел не попал в корабль.
            - `board[x][y] = 'miss'` помечает клетку, как клетку в которую был произведен выстрел, но не было попадания.
            - выводит сообщение `MISS`.
       - `else:` выполняется, если по этим координатам уже был произведен выстрел.
    -   код выводит текущее состояние игрового поля.
    -   код выводит сообщение о победе и количестве выстрелов.
8.  **Условный запуск**:
    -   `if __name__ == "__main__":`: Проверяет, что файл запущен как основной скрипт.
    -   `play_salvo()`: Вызывает функцию для запуска игры.
"""
```