# Модуль `minibot`

## Обзор

Модуль `minibot` предназначен для обработки запросов через Telegram-бот, взаимодействующий с пользователем и AI-моделью Google Gemini.
Он включает в себя обработку текстовых сообщений, URL-адресов (в частности, ссылок OneTab), голосовых сообщений и документов.
В зависимости от режима (`PRODUCTION` или `DEV`) используются разные токены для подключения к Telegram API.

## Подробнее

Модуль состоит из нескольких основных компонентов:

1.  **BotHandler**: Класс, обрабатывающий логику взаимодействия с пользователем, включая разбор команд, обработку URL-адресов и взаимодействие с AI-моделью.
2.  **Config**: Класс, содержащий конфигурационные параметры бота, такие как токены доступа, идентификаторы каналов и пути к файлам.
3.  **Основные обработчики сообщений**: Функции, обрабатывающие различные типы сообщений от пользователей (текст, команды, голосовые сообщения, документы).
4.  **Основной цикл работы бота**: Функция `main`, запускающая бота и обрабатывающая возможные ошибки.

Бот поддерживает следующие функции:

*   Ответы на текстовые запросы пользователей с использованием AI-модели Google Gemini.
*   Обработка URL-адресов OneTab для извлечения информации о мехиронах и URL-адресов комплектующих.
*   Отправка пользователю различных типов контента, включая текст, фотографии и документы.
*   Поддержка команд `/start`, `/help`, `/info`, `/time` и `/photo`.
*   Обработка голосовых сообщений (функциональность транскрибирования не реализована).

## Классы

### `BotHandler`

**Описание**: Класс `BotHandler` обрабатывает команды и сообщения, полученные от Telegram-бота. Он отвечает за взаимодействие с AI-моделью, обработку URL-адресов и отправку ответов пользователю.

**Как работает класс**:

1.  При инициализации создается экземпляр класса `GoogleGenerativeAI` для взаимодействия с AI-моделью.
2.  Метод `handle_message` обрабатывает входящие текстовые сообщения. Если сообщение является командой (`?`), отправляется схема user\_flowchart. Если сообщение содержит URL, вызывается метод `_handle_url`. В противном случае сообщение передается в AI-модель для получения ответа.
3.  Метод `_send_user_flowchart` отправляет пользователю изображение схемы user\_flowchart.
4.  Метод `_handle_url` обрабатывает URL-адреса, извлекая информацию о мехироне и URL-адреса комплектующих, а затем запускает сценарий обработки этих данных.
5.  Метод `_handle_next_command` обрабатывает команду '--next', запрашивая у AI-модели случайный вопрос и ответ.
6.  Методы `help_command`, `send_pdf`, `handle_voice` и `handle_document` обрабатывают соответствующие команды и типы сообщений.

**Методы**:

*   `__init__(self)`
*   `handle_message(self, bot: telebot, message: 'message')`
*   `_send_user_flowchart(self, bot, chat_id)`
*   `_handle_url(self, bot, message: 'message')`
*   `_handle_next_command(self, bot, message)`
*   `help_command(self, bot, message)`
*   `send_pdf(self, bot, message, pdf_file)`
*   `handle_voice(self, bot, message)`
*   `_transcribe_voice(self, file_path)`
*   `handle_document(self, bot, message)`

#### `__init__`

```python
def __init__(self):
    """Инициализация обработчика событий телеграм-бота."""
    ...
```

**Назначение**: Инициализирует экземпляр класса `BotHandler`.

**Как работает функция**:

1.  Инициализирует список вопросов `self.questions_list`.
2.  Создает экземпляр класса `GoogleGenerativeAI` для взаимодействия с AI-моделью, используя API-ключ, полученный из переменной окружения `GEMINI_API` или из `gs.credentials.gemini.kazarinov` в зависимости от значения `USE_ENV`.

**Параметры**:

*   Нет

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

#### `handle_message`

```python
def handle_message(self, bot:telebot, message:'message'):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, полученные от пользователя через Telegram-бот.

**Как работает функция**:

1.  Извлекает текст сообщения из объекта `message`.
2.  Если текст равен `?`, вызывает метод `_send_user_flowchart` для отправки схемы user\_flowchart.
3.  Если текст является URL-адресом, вызывает метод `_handle_url` для обработки URL.
4.  Если текст является одной из команд (`--next`, `-next`, `__next`, `-n`, `-q`), вызывает метод `_handle_next_command`.
5.  В противном случае пытается получить ответ от AI-модели с помощью метода `self.model.chat(text)` и отправляет ответ пользователю.
6.  Если во время взаимодействия с моделью возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot` (telebot): Объект Telegram-бота.
*   `message` ('message'): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка во время взаимодействия с AI-моделью.

#### `_send_user_flowchart`

```python
def _send_user_flowchart(self, bot, chat_id):
    """Отправка схемы user_flowchart."""
    ...
```

**Назначение**: Отправляет пользователю схему `user_flowchart` в виде фотографии.

**Как работает функция**:

1.  Формирует путь к файлу фотографии `user_flowchart.png`.
2.  Пытается открыть файл фотографии и отправить его пользователю с помощью метода `bot.send_photo`.
3.  Если файл не найден, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `chat_id`: Идентификатор чата пользователя.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `FileNotFoundError`: Если файл фотографии не найден.

#### `_handle_url`

```python
def _handle_url(self, bot, message:'message'):
    """Обработка URL, присланного пользователем."""
    ...
```

**Назначение**: Обрабатывает URL-адрес, предоставленный пользователем, извлекая данные о мехироне и запуская сценарий.

**Как работает функция**:

1.  Извлекает URL-адрес из текста сообщения.
2.  Проверяет, начинается ли URL-адрес с `https://one-tab.com` или `https://www.one-tab.com`. Если нет, отправляет пользователю сообщение об ошибке и завершает работу.
3.  Пытается извлечь цену, название мехирона и список URL-адресов комплектующих с помощью функции `fetch_target_urls_onetab`.
4.  Отправляет пользователю сообщение с информацией о полученном мехироне.
5.  Если список URL-адресов пуст, отправляет пользователю сообщение об ошибке и завершает работу.
6.  Создает экземпляр класса `Scenario` и запускает асинхронный сценарий обработки данных, передавая название мехирона, список URL-адресов, цену, объект бота и идентификатор чата пользователя.
7.  Если во время выполнения сценария возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message` ('message'): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка при извлечении данных из URL-адреса или во время выполнения сценария.

#### `_handle_next_command`

```python
def _handle_next_command(self, bot, message):
    """Обработка команды '--next' и её аналогов."""
    ...
```

**Назначение**: Обрабатывает команду `--next` (и её аналоги), запрашивая случайный вопрос у AI-модели и отправляя вопрос и ответ пользователю.

**Как работает функция**:

1.  Выбирает случайный вопрос из списка `self.questions_list`.
2.  Запрашивает ответ у AI-модели с помощью метода `self.model.ask(question)`.
3.  Отправляет пользователю выбранный вопрос и полученный ответ.
4.  Если во время выполнения возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка при чтении вопросов или во время взаимодействия с AI-моделью.

#### `help_command`

```python
def help_command(self, bot, message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, отправляя пользователю список доступных команд.

**Как работает функция**:

1.  Отправляет пользователю сообщение со списком доступных команд.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

#### `send_pdf`

```python
def send_pdf(self, bot, message, pdf_file):
    """Обработка команды /sendpdf для отправки PDF."""
    ...
```

**Назначение**: Обрабатывает команду `/sendpdf`, отправляя пользователю PDF-файл.

**Как работает функция**:

1.  Пытается открыть указанный PDF-файл.
2.  Отправляет файл пользователю с помощью метода `bot.send_document`.
3.  Если во время выполнения возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.
*   `pdf_file`: Путь к PDF-файлу.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка при открытии или отправке PDF-файла.

#### `handle_voice`

```python
def handle_voice(self, bot, message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Как работает функция**:

1.  Получает информацию о файле голосового сообщения с помощью метода `bot.get_file`.
2.  Загружает файл голосового сообщения с помощью метода `bot.download_file`.
3.  Сохраняет файл во временную директорию.
4.  Пытается транскрибировать голосовое сообщение с помощью метода `self._transcribe_voice`.
5.  Отправляет пользователю распознанный текст.
6.  Если во время выполнения возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message`: Объект сообщения, содержащий информацию о голосовом сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка при обработке голосового сообщения.

#### `_transcribe_voice`

```python
def _transcribe_voice(self, file_path):
    """Транскрибирование голосового сообщения (заглушка)."""
    ...
```

**Назначение**: Транскрибирует голосовое сообщение (в текущей версии - заглушка).

**Как работает функция**:

1.  Возвращает строку "Распознавание голоса ещё не реализовано.".

**Параметры**:

*   `file_path`: Путь к файлу голосового сообщения.

**Возвращает**:

*   str: Строка "Распознавание голоса ещё не реализовано.".

**Вызывает исключения**:

*   Нет

#### `handle_document`

```python
def handle_document(self, bot, message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Как работает функция**:

1.  Получает информацию о файле документа с помощью метода `bot.get_file`.
2.  Загружает файл документа с помощью метода `bot.download_file`.
3.  Сохраняет файл во временную директорию.
4.  Отправляет пользователю сообщение с информацией о сохраненном файле.
5.  Если во время выполнения возникает исключение, логирует ошибку и отправляет пользователю сообщение об ошибке.

**Параметры**:

*   `bot`: Объект Telegram-бота.
*   `message`: Объект сообщения, содержащий информацию о документе, отправленном пользователем.

**Возвращает**:

*   bool: `True` в случае успешной обработки документа, `False` в случае ошибки.

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка при обработке документа.

### `Config`

**Описание**: Класс `Config` содержит конфигурационные параметры для Telegram-бота, такие как токены доступа, идентификаторы каналов, пути к файлам и сообщения.

**Как работает класс**:

1.  При инициализации определяются значения параметров в зависимости от режима работы (`PRODUCTION` или `DEV`) и значения переменной `USE_ENV`.
2.  Если `USE_ENV` равно `True`, значения токенов берутся из переменных окружения.
3.  Если `USE_ENV` равно `False`, значения токенов берутся из `gs.credentials.telegram`.

**Методы**:

*   Нет (только атрибуты класса)

**Атрибуты**:

*   `BOT_TOKEN` (str): Токен Telegram-бота.
*   `CHANNEL_ID` (str): Идентификатор канала.
*   `PHOTO_DIR` (Path): Путь к директории с фотографиями.
*   `COMMAND_INFO` (str): Информация о боте для команды `/info`.
*   `UNKNOWN_COMMAND_MESSAGE` (str): Сообщение для неизвестных команд.
*   `START_MESSAGE` (str): Приветственное сообщение для команды `/start`.
*   `HELP_MESSAGE` (str): Сообщение помощи для команды `/help`.

## Функции

### `command_start`

```python
@bot.message_handler(commands=['start'])
def command_start(message):
    """Обработка команды /start."""
    ...
```

**Назначение**: Обрабатывает команду `/start`, отправляя пользователю приветственное сообщение.

**Как работает функция**:

1.  Логирует информацию об использовании команды `/start` пользователем.
2.  Отправляет пользователю приветственное сообщение, хранящееся в `config.START_MESSAGE`.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `command_help`

```python
@bot.message_handler(commands=['help'])
def command_help(message):
    """Обработка команды /help."""
    ...
```

**Назначение**: Обрабатывает команду `/help`, вызывая метод `help_command` объекта `handler` для отправки списка доступных команд пользователю.

**Как работает функция**:

1.  Логирует информацию об использовании команды `/help` пользователем.
2.  Вызывает метод `handler.help_command(bot, message)` для отправки списка доступных команд.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `command_info`

```python
@bot.message_handler(commands=['info'])
def command_info(message):
    """Обработка команды /info."""
    ...
```

**Назначение**: Обрабатывает команду `/info`, отправляя пользователю информацию о боте.

**Как работает функция**:

1.  Логирует информацию об использовании команды `/info` пользователем.
2.  Отправляет пользователю информацию о боте, хранящуюся в `config.COMMAND_INFO`.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `command_time`

```python
@bot.message_handler(commands=['time'])
def command_time(message):
    """Обработка команды /time."""
    ...
```

**Назначение**: Обрабатывает команду `/time`, отправляя пользователю текущее время.

**Как работает функция**:

1.  Логирует информацию об использовании команды `/time` пользователем.
2.  Получает текущее время с помощью `datetime.datetime.now()`.
3.  Форматирует время в строку в формате "HH:MM:SS".
4.  Отправляет пользователю сообщение с текущим временем.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `command_photo`

```python
@bot.message_handler(commands=['photo'])
def command_photo(message):
    """Обработка команды /photo."""
    ...
```

**Назначение**: Обрабатывает команду `/photo`, отправляя пользователю случайную фотографию из указанной директории.

**Как работает функция**:

1.  Логирует информацию об использовании команды `/photo` пользователем.
2.  Пытается получить список файлов в директории `config.PHOTO_DIR`.
3.  Если список файлов не пуст, выбирает случайный файл из списка.
4.  Формирует полный путь к файлу фотографии.
5.  Открывает файл фотографии и отправляет его пользователю.
6.  Если директория не найдена или в ней нет файлов, отправляет пользователю соответствующее сообщение об ошибке.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `FileNotFoundError`: Если директория с фотографиями не найдена.

### `handle_voice_message`

```python
@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    """Обработка голосовых сообщений."""
    ...
```

**Назначение**: Обрабатывает голосовые сообщения, перенаправляя их в метод `handle_voice` объекта `handler`.

**Как работает функция**:

1.  Логирует информацию об отправке голосового сообщения пользователем.
2.  Вызывает метод `handler.handle_voice(bot, message)` для обработки голосового сообщения.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о голосовом сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `handle_document_message`

```python
@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    """Обработка полученных документов."""
    ...
```

**Назначение**: Обрабатывает документы, перенаправляя их в метод `handle_document` объекта `handler`.

**Как работает функция**:

1.  Логирует информацию об отправке документа пользователем.
2.  Вызывает метод `handler.handle_document(bot, message)` для обработки документа.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о документе, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `handle_text_message`

```python
@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    """Обработка текстовых сообщений."""
    ...
```

**Назначение**: Обрабатывает текстовые сообщения, не начинающиеся с символа `/`, перенаправляя их в метод `handle_message` объекта `handler`.

**Как работает функция**:

1.  Логирует информацию об отправке текстового сообщения пользователем.
2.  Вызывает метод `handler.handle_message(bot, message)` для обработки текстового сообщения.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о текстовом сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `handle_unknown_command`

```python
@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    """Обработка неизвестных команд."""
    ...
```

**Назначение**: Обрабатывает неизвестные команды (текстовые сообщения, начинающиеся с символа `/`), отправляя пользователю сообщение о неизвестной команде.

**Как работает функция**:

1.  Логирует информацию об отправке неизвестной команды пользователем.
2.  Отправляет пользователю сообщение о неизвестной команде, хранящееся в `config.UNKNOWN_COMMAND_MESSAGE`.

**Параметры**:

*   `message`: Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   Нет

### `main`

```python
def main():
    """Основная функция запуска бота."""
    ...
```

**Назначение**: Запускает Telegram-бота в режиме опроса (polling).

**Как работает функция**:

1.  Логирует информацию о запуске бота в указанном режиме (`MODE`).
2.  Запускает бота в режиме опроса с помощью метода `bot.polling(none_stop=True)`, что позволяет боту непрерывно опрашивать сервер Telegram на предмет новых сообщений.
3.  Если во время работы бота возникает исключение, логирует ошибку, останавливает бота и перезапускает функцию `main`.

**Параметры**:

*   Нет

**Возвращает**:

*   Нет

**Вызывает исключения**:

*   `Exception`: Если возникает ошибка во время работы бота.