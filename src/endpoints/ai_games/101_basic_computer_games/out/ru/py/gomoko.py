"""
GOMOKO:
=================
Сложность: 7
-----------------
Игра "Гомоку" - это настольная игра для двух игроков, цель которой - первым построить непрерывную линию из пяти своих камней на игровом поле. Игроки по очереди ставят свои камни на пересечения линий доски.

Правила игры:
1. Игровое поле представляет собой доску 10x10.
2. Два игрока играют по очереди, ставя свои камни ('X' или 'O') на пустые клетки поля.
3. Цель игры - первым построить непрерывную линию из пяти своих камней по горизонтали, вертикали или диагонали.
4. Игра заканчивается, когда один из игроков выигрывает или когда все клетки поля заполнены (ничья).
5. Игроки вводят координаты хода, сначала строку, затем столбец. Координаты вводятся в формате "xy", где x - номер строки (1-10), а y - номер столбца (1-10).

-----------------
Алгоритм:
1. Инициализировать игровое поле (массив 10x10, заполненный нулями).
2. Инициализировать текущего игрока (начинает игрок 'X').
3. Начать цикл "пока нет победителя и поле не заполнено":
    3.1. Вывести игровое поле на экран.
    3.2. Запросить у текущего игрока координаты хода.
    3.3. Проверить корректность введенных координат.
    3.4. Если координаты корректны и клетка свободна, поставить камень текущего игрока в выбранную клетку.
    3.5. Проверить, есть ли победитель после текущего хода.
    3.6. Если победитель есть, вывести сообщение о победе и закончить игру.
    3.7. Сменить текущего игрока.
4. Если после окончания цикла не было победителя, вывести сообщение о ничьей.
-----------------
Блок-схема:
```mermaid
flowchart TD
    Start["Начало"] --> InitializeBoard["Инициализация игрового поля (10x10) нулями"]
    InitializeBoard --> SetFirstPlayer["Установка первого игрока ('X')"]
    SetFirstPlayer --> GameLoopStart{"Начало игрового цикла: пока нет победителя или поле не заполнено"}
    GameLoopStart -- Да --> DisplayBoard["Вывод игрового поля на экран"]
    DisplayBoard --> InputMove["Ввод координат хода текущего игрока"]
    InputMove --> ValidateMove{"Проверка корректности координат и свободы клетки"}
    ValidateMove -- Да --> PlaceStone["Поставить камень текущего игрока"]
    PlaceStone --> CheckWin{"Проверка наличия победителя после хода"}
    CheckWin -- Да --> OutputWin["Вывод сообщения о победе"]
    OutputWin --> End["Конец игры"]
    CheckWin -- Нет --> ChangePlayer["Смена текущего игрока"]
    ChangePlayer --> GameLoopStart
    ValidateMove -- Нет --> OutputError["Вывод сообщения об ошибке ввода"]
    OutputError --> GameLoopStart
    GameLoopStart -- Нет --> OutputDraw["Вывод сообщения о ничьей"]
    OutputDraw --> End
```

Legenda:
    Start - Начало программы.
    InitializeBoard - Инициализация игрового поля (массив 10x10), заполненного нулями.
    SetFirstPlayer - Установка первого игрока, который ходит первым (обычно 'X').
    GameLoopStart - Начало игрового цикла, который продолжается до тех пор, пока не будет победителя или пока все поле не заполнится.
    DisplayBoard - Вывод текущего состояния игрового поля на экран.
    InputMove - Запрос у текущего игрока ввода координат его хода.
    ValidateMove - Проверка корректности введенных координат и того, что выбранная клетка свободна.
    PlaceStone - Размещение камня текущего игрока на игровом поле в соответствии с введенными координатами.
    CheckWin - Проверка, есть ли победитель после текущего хода.
    OutputWin - Вывод сообщения о победе и завершение игры.
    ChangePlayer - Смена текущего игрока на противоположного (с 'X' на 'O' или наоборот).
    OutputError - Вывод сообщения об ошибке, если введены некорректные координаты или выбранная клетка занята.
    OutputDraw - Вывод сообщения о ничьей, если игра завершилась без победителя.
    End - Конец игры.
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
"""
Пояснения:
    1. **Инициализация игрового поля:**
        - `board = [[0 for _ in range(10)] for _ in range(10)]`: Создает двумерный список (матрицу) 10x10, представляющую игровое поле. Все ячейки изначально заполнены нулями, что означает пустые клетки.
    2. **Функция `print_board(board)`:**
        - Принимает игровое поле в качестве аргумента.
        - Выводит текущее состояние игрового поля в консоль, где 'X' и 'O' представляют камни игроков, а '.' - пустые клетки.
    3. **Функция `check_win(board, player)`:**
        - Проверяет, выиграл ли игрок `player` ('X' или 'O') после своего последнего хода.
        - Проверяет наличие пяти камней в ряд по горизонтали, вертикали и обеим диагоналям.
        - Возвращает `True`, если есть победа, и `False` в противном случае.
    4. **Основной игровой цикл:**
        - `current_player = 'X'`: Начинает игру с игрока 'X'.
        - `moves_count = 0`: Счетчик ходов.
        - `while moves_count < 100`: Цикл продолжается до тех пор, пока не будет сделано 100 ходов, что гарантирует выход из цикла при ничье.
        - `print_board(board)`: Выводит текущее состояние игрового поля.
        -  Запрашивает у игрока ввод координат хода в формате "xy" (например, "12" для строки 1 и столбца 2).
        - Проверяет корректность ввода и свободу клетки.
        - `board[row][col] = current_player`: Ставит камень текущего игрока на поле.
        - Проверяет, есть ли победитель после текущего хода, и выводит сообщение о победе, если есть.
        - Если победителя нет, меняет текущего игрока (`current_player = 'O' if current_player == 'X' else 'X'`).
        - `moves_count += 1`: Увеличивает счетчик ходов.
    5. **Сообщение о ничьей:**
        - Если цикл завершился без победителя (сделано 100 ходов), выводит сообщение о ничьей.
"""
def print_board(board):
    """Выводит текущее состояние игрового поля."""
    print("   1 2 3 4 5 6 7 8 9 10")
    for i, row in enumerate(board):
        print(f"{i + 1:2d}", end=" ")
        for cell in row:
            if cell == 0:
                print(".", end=" ")
            else:
                print(cell, end=" ")
        print()


def check_win(board, player):
    """Проверяет, есть ли победитель после последнего хода."""
    # Проверка по горизонтали
    for row in board:
        for i in range(len(row) - 4):
            if all(row[i + j] == player for j in range(5)):
                return True

    # Проверка по вертикали
    for col in range(len(board[0])):
        for i in range(len(board) - 4):
            if all(board[i + j][col] == player for j in range(5)):
                return True

    # Проверка по диагонали (слева-сверху вправо-вниз)
    for row in range(len(board) - 4):
        for col in range(len(board[0]) - 4):
            if all(board[row + j][col + j] == player for j in range(5)):
                return True

    # Проверка по диагонали (справа-сверху влево-вниз)
    for row in range(len(board) - 4):
        for col in range(4, len(board[0])):
            if all(board[row + j][col - j] == player for j in range(5)):
                return True

    return False


# Инициализация игрового поля
board = [[0 for _ in range(10)] for _ in range(10)]
current_player = 'X' # Начинает игрок X
moves_count = 0 # счетчик ходов

while moves_count < 100: # Игра продолжается, пока не будет сделано 100 ходов
    print_board(board)
    while True:
        move = input(f"Игрок {current_player}, введите координаты хода (xy): ")
        if len(move) != 2 or not move.isdigit():
            print("Некорректный ввод. Пожалуйста, введите две цифры.")
            continue

        row, col = int(move[0]) - 1, int(move[1]) - 1 # Преобразуем ввод в координаты массива
        if not (0 <= row < 10 and 0 <= col < 10):
            print("Некорректные координаты. Пожалуйста, введите координаты от 1 до 10.")
            continue
        if board[row][col] != 0:
            print("Эта клетка уже занята. Пожалуйста, выберите другую.")
            continue
        break # Выход из цикла, если ввод корректен

    board[row][col] = current_player # Ставим камень текущего игрока
    if check_win(board, current_player):
        print_board(board)
        print(f"Игрок {current_player} победил!")
        break  # Завершаем игру

    current_player = 'O' if current_player == 'X' else 'X' # Смена игрока
    moves_count += 1 # Увеличиваем счетчик ходов

if moves_count == 100:
    print_board(board)
    print("Ничья!")

"""
Пояснения:
1.  **Функция `print_board(board)`:**
   - Эта функция принимает игровое поле `board` в качестве аргумента.
   - Сначала печатает номера столбцов от 1 до 10 для удобства пользователя.
   - Затем она итерируется по каждой строке игрового поля, печатая номер строки и содержимое каждой клетки.
   - Каждая клетка печатается как '.' (пустая клетка), 'X' или 'O' в зависимости от значения в ячейке.
2.  **Функция `check_win(board, player)`:**
    -   Эта функция принимает игровое поле `board` и текущего игрока `player` ('X' или 'O') в качестве аргументов.
    -   Проверяет наличие пяти камней в ряд по горизонтали, вертикали и обеим диагоналям.
    -   **Проверка по горизонтали:** Перебирает каждую строку и проверяет наличие пяти последовательных камней текущего игрока.
    -   **Проверка по вертикали:** Перебирает каждый столбец и проверяет наличие пяти последовательных камней текущего игрока.
    -   **Проверка по диагонали (слева-сверху вправо-вниз):** Проверяет наличие пяти последовательных камней текущего игрока по диагоналям, идущим слева сверху вправо вниз.
    -   **Проверка по диагонали (справа-сверху влево-вниз):** Проверяет наличие пяти последовательных камней текущего игрока по диагоналям, идущим справа сверху влево вниз.
    -   Если найдена победная комбинация, возвращает `True`; в противном случае возвращает `False`.
3.  **Основной игровой цикл:**
    -   `board = [[0 for _ in range(10)] for _ in range(10)]`: Инициализирует игровое поле как двумерный массив 10x10, где каждая ячейка равна 0 (пустая клетка).
    -   `current_player = 'X'`: Устанавливает текущего игрока на 'X'.
    -   `moves_count = 0`: Инициализирует счетчик ходов.
    -   `while moves_count < 100:`: Цикл продолжается, пока не будет сделано 100 ходов, что гарантирует выход из цикла при ничье.
    -   `print_board(board)`: Выводит текущее состояние игрового поля.
    -   **Цикл ввода хода:**
    -   `while True:`: Бесконечный цикл, который продолжается, пока игрок не введет корректные координаты.
    -   `move = input(f"Игрок {current_player}, введите координаты хода (xy): ")`: Запрашивает у текущего игрока ввод координат хода в формате "xy" (например, "12" для строки 1 и столбца 2).
    -   `if len(move) != 2 or not move.isdigit():`: Проверяет, что ввод состоит из двух цифр. Если нет, выводит сообщение об ошибке и просит повторить ввод.
    -   `row, col = int(move[0]) - 1, int(move[1]) - 1`: Преобразует ввод в индексы массива.
    -   `if not (0 <= row < 10 and 0 <= col < 10):`: Проверяет, что координаты находятся в пределах игрового поля. Если нет, выводит сообщение об ошибке и просит повторить ввод.
    -   `if board[row][col] != 0:`: Проверяет, что выбранная ячейка не занята. Если занята, выводит сообщение об ошибке и просит повторить ввод.
    -   `break`: Выход из цикла, если ввод корректен.
    -   `board[row][col] = current_player`: Ставит камень текущего игрока на поле.
    -   `if check_win(board, current_player):`: Проверяет, есть ли победитель после текущего хода.
    -   `print_board(board)`: Выводит игровое поле с текущими изменениями.
    -   `print(f"Игрок {current_player} победил!")`: Выводит сообщение о победе.
    -   `break`: Завершает игру.
    -   `current_player = 'O' if current_player == 'X' else 'X'`: Меняет текущего игрока на противоположного.
    -   `moves_count += 1`: Увеличивает счетчик ходов.
4. **Сообщение о ничьей:**
    -   `if moves_count == 100:`: Если цикл завершился без победителя (сделано 100 ходов), то игра заканчивается ничьей.
    -   `print_board(board)`: Выводит итоговое состояние игрового поля.
    -   `print("Ничья!")`: Выводит сообщение о ничьей.
"""
```