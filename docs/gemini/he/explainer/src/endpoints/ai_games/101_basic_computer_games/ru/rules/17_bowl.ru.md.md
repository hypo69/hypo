# ניתוח קוד: משחק באולינג

## <algorithm>

1.  **אתחול משחק:**
    *   הצגת הודעת פתיחה למשחק הבאולינג.
    *   שאילת המשתמש לגבי מספר השחקנים (1-4).
    *   יצירת משתנה או מבנה נתונים לייצוג כל שחקן וניקודו. לדוגמה: `players = [{id: 1, score: 0}, {id: 2, score: 0}]`.
    *   התחלת לולאה ראשית שתרוץ 10 פעמים (לכל פרים). דוגמא: `for frame in range(10):`.
    *   לולאה נוספת עבור כל שחקן.

2.  **לולאת משחק:**
    *   לכל שחקן בכל פרים, הצגת הודעה "תורך, שחקן X".
    *   שאילת השחקן להזנת "ROLL".
    *   ביצוע זריקה ראשונה וחישוב מספר הפינים שהופלו (ערך אקראי בין 0 ל-10). לדוגמא: `pins_down = random.randint(0, 10)`.
    *   הדפסת מצב הפינים שנותרו בפורמט  "0 + 0 +...+0" או "+ + + ... +".
    *   בדיקת תוצאת הזריקה:
        *   אם כל 10 הפינים הופלו בזריקה הראשונה - **"סטרייק"**.
        *   אם לא, ביצוע זריקה שנייה (אלא אם כן זו הזריקה האחרונה) - חישוב פינים שהופלו בזריקה השנייה.
        *   אם כל 10 הפינים הופלו בשתי הזריקות - **"ספייר"**.
        *   אם נשארו פינים - **"טעות"**.
        *   אם לא פגע כלל - **"גאטר"**.
    *   עדכון ניקוד השחקן.

3.  **סיום המשחק:**
    *   לאחר 10 פריימים, חישוב הניקוד הסופי של כל שחקן.
    *   הצגת הניקוד הסופי של כל שחקן.
    *   הכרזה על המנצח (השחקן עם הניקוד הגבוה ביותר).
    *   שאילת השחקנים אם הם רוצים לשחק שוב.

4.  **חזרה או יציאה:**
    *   אם השחקנים רוצים לשחק שוב - חזרה לשלב האתחול.
    *   אם לא - סיום המשחק.

**זרימת נתונים:**

*   המשתמש מכניס את מספר השחקנים.
*   המשתמש מכניס "ROLL" כדי לבצע זריקה.
*   התוכנית מייצרת מספר אקראי של פינים שהופלו.
*   התוכנית מעדכנת את מצב הפינים והניקוד של השחקן.
*   התוכנית מציגה את תוצאת הזריקה והניקוד הסופי.
*   התוכנית שואלת אם לשחק שוב.

## <mermaid>

```mermaid
flowchart TD
    Start[התחלה] --> InputPlayers[קלט מספר שחקנים];
    InputPlayers --> InitGame[אתחול משחק];
    InitGame --> FrameLoop[לולאת פריימים (10 פריימים)];
    FrameLoop -- עבור כל פרים --> PlayerLoop[לולאת שחקנים];
    PlayerLoop -- עבור כל שחקן --> DisplayTurn[הצג תור השחקן];
    DisplayTurn --> InputRoll[קלט "ROLL"];
    InputRoll --> FirstRoll[זריקה ראשונה - חישוב פינים שהופלו];
    FirstRoll --> DisplayPins[הצג מצב פינים];
    DisplayPins --> CheckStrike[בדיקה: האם סטרייק?];
    CheckStrike -- כן --> UpdateScoreStrike[עדכן ניקוד עבור סטרייק];
    UpdateScoreStrike --> FrameEnd[סיום פרים];
    CheckStrike -- לא --> SecondRollCheck[בדיקה: האם פרים אחרון?];
    SecondRollCheck -- כן --> FrameEnd[סיום פרים];
     SecondRollCheck -- לא --> SecondRoll[זריקה שנייה - חישוב פינים שהופלו];
    SecondRoll --> DisplayPins2[הצג מצב פינים];
    DisplayPins2 --> CheckSpare[בדיקה: האם ספייר?];
     CheckSpare -- כן --> UpdateScoreSpare[עדכן ניקוד עבור ספייר];
     CheckSpare -- לא --> UpdateScoreError[עדכן ניקוד עבור טעות / גאטר];
    UpdateScoreError --> FrameEnd[סיום פרים];
   UpdateScoreSpare --> FrameEnd[סיום פרים];

    FrameEnd --> FrameLoopCheck[בדיקה: האם פרים אחרון?];
    FrameLoopCheck -- לא --> FrameLoop[המשך לפרים הבא];
    FrameLoopCheck -- כן --> EndGame[סיום המשחק];
    EndGame --> CalculateScores[חישוב ניקוד סופי];
    CalculateScores --> DisplayResults[הצג תוצאות];
    DisplayResults --> CheckPlayAgain[שאלה: האם לשחק שוב?];
    CheckPlayAgain -- כן --> InitGame[אתחול משחק];
    CheckPlayAgain -- לא --> Exit[יציאה];
    
    
```

**ניתוח תלויות:**

*   אין תלויות חיצוניות שצריכות ייבוא. המשחק משתמש בפונקציות בסיסיות כמו קלט/פלט וגנרטור מספרים רנדומליים, שכנראה מובנים בשפת התכנות.
*   התרשים משתמש במושגים ברורים ומתאר את הזרימה בצורה ברורה.

## <explanation>

**ייבואים (Imports):**

*   בתיאור הקוד לא מצוין שימוש בייבוא מפורש. בדרך כלל, משחקים כמו זה יסתמכו על ייבוא רנדום עבור יצירת מספרים אקראיים. כמו כן, פונקציות בסיסיות כמו הדפסה וקלט מגיעות כחלק מהשפה עצמה, ללא ייבוא מפורש.
*   במידה וישתמשו ב `random`, יתכן שימוש ב `import random`.

**מחלקות (Classes):**

*   לא קיימות מחלקות בקוד זה. המימוש מתבסס על פונקציות ולולאות. בגרסה מורכבת יותר, אפשר לשקול שימוש במחלקה לייצוג השחקן ומחלקה לייצוג המשחק.

**פונקציות (Functions):**

*   `main()` - הפונקציה הראשית של התוכנית: היא מנהלת את מהלך המשחק כולו.
*   `input_number_of_players()` - קולטת את מספר השחקנים מהמשתמש ומחזירה אותו.
*   `roll()` - מדמה הטלה, מחזירה מספר אקראי של פינים שנפלו.
*   `display_pins()` - מציגה את מצב הפינים לאחר זריקה.
*   `calculate_score()` - מחשבת את הניקוד של שחקן מסוים בהתחשב בתוצאות הפריימים.
*   `check_strike_spare()` - בודקת אם השחקן השיג סטרייק, ספייר או פגע אחר.
*   `play_again()` - שואלת את השחקנים אם הם רוצים לשחק שוב ומחזירה תשובה.

**משתנים (Variables):**

*   `num_players` (מספר שלם): מספר השחקנים שמשתתפים במשחק.
*   `players` (רשימה/מערך): מבנה נתונים שמכיל את נתוני כל השחקנים (שם, ניקוד וכו').
*   `frame` (מספר שלם): מספר הפרים הנוכחי.
*   `pins_down` (מספר שלם): מספר הפינים שהופלו בכל זריקה.
*   `score` (מספר שלם): הניקוד של כל שחקן.
*   `result` (מחרוזת): מחרוזת שמציינת את תוצאת הזריקה (סטרייק, ספייר, טעות או גאטר).
*   `play_again` (מחרוזת): תשובה של המשתמש אם לשחק שוב.

**בעיות אפשריות ותחומים לשיפור:**

*   **קוד לא מודולרי**: הקוד לא מחולק לפונקציות עם אחריות מוגדרת, מה שמקשה על הבדיקה ועל השימוש החוזר.
*   **טיפול שגיאות**: אין טיפול שגיאות תקין בקלט מהמשתמש, כגון הזנה של אותיות במקום מספר.
*   **גמישות**: הקוד קשיח ואינו מאפשר שינוי של חוקי המשחק או הוספת מאפיינים נוספים.
*   **ניקוד**: חישוב הניקוד, במיוחד עבור סטרייקים וספיירים, לא ממומש בצורה מפורשת.
*   **ממשק משתמש**: ממשק המשתמש בסיסי וניתן לשפר אותו.
*   **אובייקטים**: ניתן להשתמש במחלקות לייצוג של שחקנים, משחק ופריימים.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

*   הקוד הזה הוא משחק עצמאי ולכן אין לו תלות ישירה בחלקים אחרים בפרויקט, מלבד ייתכן שקיימת פונקצית קלט/פלט גלובלית.
*   במידה ורוצים לשלב אותו במערכת גדולה יותר, הוא יכול לשמש כמודול עצמאי.
*   יתכן שהוא ישתמש בהגדרות גלובליות.