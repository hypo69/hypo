# Анализ кода модуля `48_hex.ru.md`

**Качество кода**

6
-  Плюсы
    - Документ предоставляет понятное описание игры HEX и пошаговую инструкцию для её реализации.
    - Содержит примеры работы программы, что помогает лучше понять игровой процесс.
    - Описывает возможные ограничения и предлагает рекомендации по реализации и расширению функционала.
-  Минусы
    -  Документ написан в формате Markdown, а не reStructuredText (RST), как требуется в инструкции.
    -  Отсутствует формальное разделение на части с заголовками в формате RST.
    -  Нет подробных комментариев, объясняющих каждый шаг реализации.
    -  Не приведены примеры кода на Python, которые нужно было бы комментировать и улучшать.
    -  Не используются функции логирования.

**Рекомендации по улучшению**

1.  **Перевести в RST**: Переписать документ в формате RST, чтобы он соответствовал требованиям по документации.
2.  **Добавить RST заголовки**: Добавить заголовки разделов в формате RST.
3.  **Привести примеры кода**: Добавить примеры кода на Python, которые демонстрируют ключевые моменты реализации игры (например, инициализация поля, ход игрока, проверка победы).
4.  **Комментарии в коде**: Добавить комментарии в формате RST к примерам кода, объясняющие каждый шаг.
5.  **Логирование**: В примере кода использовать `from src.logger.logger import logger` для логирования ошибок и других важных событий.
6.  **Структура кода**: Описать структуру кода, который будет реализован (функции, классы, методы).
7. **Примеры документации**: Добавить примеры документации в формате RST для модуля, функций и методов.
8. **Формат комментариев**: Переписать комментарии в коде в формате RST, объясняя каждый шаг и назначение переменных.

**Оптимизированный код**

```markdown
# Анализ кода модуля `48_hex.ru.md`

**Качество кода**

6
-  Плюсы
    - Документ предоставляет понятное описание игры HEX и пошаговую инструкцию для её реализации.
    - Содержит примеры работы программы, что помогает лучше понять игровой процесс.
    - Описывает возможные ограничения и предлагает рекомендации по реализации и расширению функционала.
-  Минусы
    -  Документ написан в формате Markdown, а не reStructuredText (RST), как требуется в инструкции.
    -  Отсутствует формальное разделение на части с заголовками в формате RST.
    -  Нет подробных комментариев, объясняющих каждый шаг реализации.
    -  Не приведены примеры кода на Python, которые нужно было бы комментировать и улучшать.
    -  Не используются функции логирования.

**Рекомендации по улучшению**

1.  **Перевести в RST**: Переписать документ в формате RST, чтобы он соответствовал требованиям по документации.
2.  **Добавить RST заголовки**: Добавить заголовки разделов в формате RST.
3.  **Привести примеры кода**: Добавить примеры кода на Python, которые демонстрируют ключевые моменты реализации игры (например, инициализация поля, ход игрока, проверка победы).
4.  **Комментарии в коде**: Добавить комментарии в формате RST к примерам кода, объясняющие каждый шаг.
5.  **Логирование**: В примере кода использовать `from src.logger.logger import logger` для логирования ошибок и других важных событий.
6.  **Структура кода**: Описать структуру кода, который будет реализован (функции, классы, методы).
7. **Примеры документации**: Добавить примеры документации в формате RST для модуля, функций и методов.
8. **Формат комментариев**: Переписать комментарии в коде в формате RST, объясняя каждый шаг и назначение переменных.

**Оптимизированный код**
```python
"""
Модуль, содержащий инструкцию для реализации игры HEX.
=========================================================

Этот модуль описывает правила, пошаговую инструкцию и примеры работы игры HEX.

Пример использования
--------------------

Пример чтения документации:

.. code-block:: python

    # Здесь будет код, демонстрирующий использование инструкций
    # для создания игры HEX.
"""

from src.logger.logger import logger # импортируем логгер

def initialize_game():
    """
    Инициализирует игру HEX.

    :return: None
    """
    print('Добро пожаловать в игру HEX!')
    print('Игроки, выберите фишки: красные или синие.')
    print('Игрок 1 (красные) начинает первым.')
    board = [['.' for _ in range(11)] for _ in range(11)]
    print_board(board)
    # Код исполняет создание игрового поля 11x11, заполненного точками
    return board

def print_board(board):
    """
    Выводит текущее состояние игрового поля.

    :param board: Двумерный список, представляющий игровое поле.
    :return: None
    """
    for row in board:
        print(' '.join(row))
    # Код исполняет вывод каждой строки игрового поля, разделяя элементы пробелами

def player_turn(board, player, player_symbol):
    """
    Обеспечивает ход игрока.

    :param board: Двумерный список, представляющий игровое поле.
    :param player: Номер текущего игрока (1 или 2).
    :param player_symbol: Символ, которым играет игрок ('X' для красных, 'O' для синих).
    :return: Обновленное игровое поле.
    """
    while True:
        try:
            move = input(f'Ваш ход, игрок {player} ({player_symbol}). Выберите клетку для фишки (например, A1): ').upper()
            # Код запрашивает ввод хода игрока, например, A1
            if len(move) < 2:
                print("Неверный формат ввода. Пожалуйста, введите букву и число (например, A1).")
                continue
            column = ord(move[0]) - ord('A') # Преобразование буквы в индекс столбца
            row = int(move[1:]) - 1 # Преобразование номера в индекс строки
            if not (0 <= column < 11 and 0 <= row < 11):
                print('Неверные координаты. Пожалуйста, введите координаты в пределах поля.')
                continue
            # Код преобразует введенные координаты в индексы для использования в массиве, проверят валидность ввода
            if board[row][column] == '.':
                board[row][column] = player_symbol
                print_board(board)
                return board
            else:
                print('Клетка занята. Пожалуйста, выберите другую.')
        except ValueError as e:
            logger.error(f'Ошибка ввода: {e}')
            print("Неверный формат ввода. Пожалуйста, введите букву и число (например, A1).") # обработка исключений, связанных с неверным вводом
        except Exception as ex:
            logger.error(f'Непредвиденная ошибка {ex}')
            print('Произошла непредвиденная ошибка. Пожалуйста, попробуйте еще раз.')

def check_win(board, player_symbol):
    """
    Проверяет, победил ли игрок.

    :param board: Двумерный список, представляющий игровое поле.
    :param player_symbol: Символ текущего игрока ('X' для красных, 'O' для синих).
    :return: True, если игрок победил, False в противном случае.
    """
    # Код исполняет проверку на наличие соединения между сторонами поля для каждого игрока
    if player_symbol == 'X': # проверка победы для красного игрока
        for col in range(11):
           if board[0][col] == 'X':
              if check_path(board,0,col,'X',set()):
                return True
        return False

    elif player_symbol == 'O': # проверка победы для синего игрока
       for row in range(11):
          if board[row][0] == 'O':
            if check_path(board,row,0,'O',set()):
              return True
       return False
    return False

def check_path(board,row,col,player_symbol,visited):
    """
    Рекурсивная функция для проверки наличия пути от начала до конца стороны.

    :param board: Двумерный список, представляющий игровое поле.
    :param row: Индекс текущей строки.
    :param col: Индекс текущего столбца.
    :param player_symbol: Символ текущего игрока ('X' для красных, 'O' для синих).
    :param visited: Множество посещенных позиций.
    :return: True, если путь найден, False в противном случае.
    """
    if (row,col) in visited:
       return False # если ячейка была уже посещена то возвращаем False
    if player_symbol == 'X' and row == 10:
        return True # Если дошли до нижней стороны
    if player_symbol == 'O' and col == 10:
        return True # Если дошли до правой стороны

    visited.add((row,col))

    # Массив смещений для поиска соседних клеток
    moves = [(0,1),(0,-1),(1,0),(-1,0),(1,-1),(-1,1)]

    for move in moves:
        new_row = row + move[0]
        new_col = col + move[1]
        if 0 <= new_row < 11 and 0 <= new_col < 11 and board[new_row][new_col] == player_symbol:
            if check_path(board, new_row,new_col, player_symbol,visited):
                return True
    return False

def play_again():
    """
    Запрашивает, хотят ли игроки сыграть еще раз.

    :return: True, если игроки хотят сыграть еще раз, False в противном случае.
    """
    while True:
        choice = input('Хотите сыграть снова? (да/нет): ').lower()
        if choice == 'да':
            return True
        elif choice == 'нет':
            print('Спасибо за игру!')
            return False
        else:
            print('Неверный ввод. Пожалуйста, введите "да" или "нет".')
            # Код обрабатывает ввод пользователя и спрашивает о повторе игры

def main():
    """
    Основная функция для запуска игры.

    :return: None
    """
    while True:
        board = initialize_game()
        current_player = 1
        player_symbols = ['X','O']

        while True:
            # Код исполняет поочередные ходы игроков, обновляя поле
            board = player_turn(board, current_player, player_symbols[current_player - 1])

            if check_win(board,player_symbols[current_player - 1]):
               print(f'Поздравляем! Игрок {current_player} ({player_symbols[current_player - 1]}) победил, соединяя стороны!')
               break

            current_player = 3 - current_player # переключение игроков

        if not play_again():
            break
if __name__ == '__main__':
    main()
```