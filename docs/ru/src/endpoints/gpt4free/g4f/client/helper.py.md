# Модуль `helper.py`

## Обзор

Модуль `helper.py` содержит набор вспомогательных функций, предназначенных для обработки текста, извлечения информации из кодовых блоков и управления асинхронными генераторами. Эти функции используются для облегчения разбора и фильтрации данных, возвращаемых языковыми моделями, а также для безопасного завершения асинхронных операций.

## Подробней

Модуль предоставляет функции для извлечения данных из Markdown и JSON блоков, поиска стоп-слов в тексте и безопасного закрытия асинхронных генераторов. Он используется в проекте `hypotez` для предварительной обработки и очистки данных, полученных от GPT4Free, перед их дальнейшим использованием.

## Функции

### `filter_markdown`

```python
def filter_markdown(text: str, allowd_types=None, default=None) -> str:
    """
    Parses code block from a string.

    Args:
        text (str): A string containing a code block.
        allowd_types (list, optional): Список разрешенных типов кодовых блоков. По умолчанию `None`.
        default (str, optional): Значение по умолчанию, возвращаемое, если кодовый блок не найден или его тип не разрешен. По умолчанию `None`.

    Returns:
        str: Код извлеченный из кодового блока, или значение по умолчанию, если кодовый блок не найден или его тип не разрешен.
    """
```

**Назначение**: Извлекает код из Markdown блока в строке.

**Параметры**:
- `text` (str): Строка, содержащая кодовый блок.
- `allowd_types` (list, optional): Список разрешенных типов кодовых блоков. Если `None`, разрешены все типы.
- `default` (str, optional): Значение, возвращаемое по умолчанию, если кодовый блок не найден или его тип не соответствует разрешенным.

**Возвращает**:
- `str`: Извлеченный код из кодового блока, если он найден и его тип разрешен, или значение по умолчанию в противном случае.

**Как работает функция**:

1. Функция `filter_markdown` использует регулярное выражение для поиска кодового блока в предоставленной строке `text`. Кодовый блок определяется как текст, заключенный между строками "```" и "```", возможно, с указанием типа блока после первого "```".
2.  Если кодовый блок найден, функция проверяет, указан ли список разрешенных типов `allowd_types`. Если `allowd_types` не указан (то есть равен `None`), считается, что разрешены все типы кодовых блоков.
3.  Если `allowd_types` указан, функция проверяет, соответствует ли тип найденного кодового блока одному из типов в списке `allowd_types`.
4.  Если тип кодового блока разрешен (либо `allowd_types` не указан, либо тип блока есть в списке `allowd_types`), функция возвращает содержимое кодового блока.
5.  Если кодовый блок не найден или его тип не разрешен, функция возвращает значение, указанное в параметре `default`.

**ASCII flowchart функции**:

```
A: Поиск кодового блока с помощью регулярного выражения
│
├── Да: Кодовый блок найден
│   │
│   B: Проверка наличия списка разрешенных типов (allowd_types)
│   │
│   ├── Да: Список allowd_types указан
│   │   │
│   │   C: Проверка соответствия типа блока одному из разрешенных типов
│   │   │
│   │   ├── Да: Тип блока разрешен
│   │   │   │
│   │   │   D: Возврат содержимого кодового блока
│   │   │
│   │   └── Нет: Тип блока не разрешен
│   │       │
│   │       E: Возврат значения по умолчанию (default)
│   │
│   └── Нет: Список allowd_types не указан
│       │
│       F: Возврат содержимого кодового блока
│
└── Нет: Кодовый блок не найден
    │
    G: Возврат значения по умолчанию (default)
```

**Примеры**:

```python
text_with_code = "```python\nprint('Hello, world!')\n```"
text_without_code = "Some text without code blocks."

# Пример 1: Извлечение кода из блока python
code = filter_markdown(text_with_code)
print(f"Код из блока python: {code}")  # Код из блока python: print('Hello, world!')

# Пример 2: Извлечение кода с указанием разрешенных типов
code = filter_markdown(text_with_code, allowd_types=["python"])
print(f"Код из блока python (с указанием типа): {code}")  # Код из блока python (с указанием типа): print('Hello, world!')

# Пример 3: Попытка извлечения кода из текста без кодовых блоков
code = filter_markdown(text_without_code, default="No code found")
print(f"Код из текста без блоков: {code}")  # Код из текста без блоков: No code found

# Пример 4: Извлечение кода с указанием неверного типа
code = filter_markdown(text_with_code, allowd_types=["json"], default="No code found")
print(f"Код из блока python (неверный тип): {code}")  # Код из блока python (неверный тип): No code found
```

### `filter_json`

```python
def filter_json(text: str) -> str:
    """
    Parses JSON code block from a string.

    Args:
        text (str): A string containing a JSON code block.

    Returns:
        dict: A dictionary parsed from the JSON code block.
    """
```

**Назначение**: Извлекает JSON из Markdown блока в строке.

**Параметры**:
- `text` (str): Строка, содержащая JSON кодовый блок.

**Возвращает**:
- `str`: JSON извлеченный из кодового блока, или исходный текст, если кодовый блок не найден или пуст.

**Как работает функция**:

1. Функция `filter_json` вызывает функцию `filter_markdown` с параметрами, настроенными для извлечения JSON кодовых блоков. В частности, она передает список `["", "json"]` в качестве `allowd_types`, что указывает на то, что разрешены кодовые блоки без указания типа (пустая строка) и кодовые блоки с типом "json".
2. Если кодовый блок найден и его тип разрешен, функция `filter_markdown` возвращает содержимое кодового блока. Функция `filter_json` затем удаляет все начальные и конечные пробельные символы, включая символы новой строки, извлеченного содержимого и возвращает результат.
3. Если кодовый блок не найден или его тип не разрешен, функция `filter_markdown` возвращает исходный текст, который затем функция `filter_json` возвращает без изменений.

**ASCII flowchart функции**:

```
A: Вызов filter_markdown с параметрами для извлечения JSON
│
B: Получение результата из filter_markdown
│
C: Удаление пробельных символов в начале и конце строки
│
D: Возврат результата
```

**Примеры**:

```python
text_with_json = "```json\n{\"key\": \"value\"}\n```"
text_without_json = "Some text without JSON blocks."

# Пример 1: Извлечение JSON из блока
json_code = filter_json(text_with_json)
print(f"JSON из блока: {json_code}")  # JSON из блока: {"key": "value"}

# Пример 2: Попытка извлечения JSON из текста без кодовых блоков
json_code = filter_json(text_without_json)
print(f"JSON из текста без блоков: {json_code}")  # JSON из текста без блоков: Some text without JSON blocks.
```

### `find_stop`

```python
def find_stop(stop: Optional[list[str]], content: str, chunk: str = None):
    """
    Находит первое вхождение одного из стоп-слов в строке.

    Args:
        stop (Optional[list[str]]): Список стоп-слов для поиска.
        content (str): Строка, в которой производится поиск.
        chunk (str, optional): Дополнительная строка (часть контента) для поиска. По умолчанию `None`.

    Returns:
        tuple: Кортеж, содержащий индекс первого вхождения стоп-слова,
               обновленное содержимое (обрезанное до первого стоп-слова)
               и обновленный фрагмент (обрезанный до первого стоп-слова), если он был предоставлен.
    """
```

**Назначение**: Находит первое вхождение одного из стоп-слов в строке.

**Параметры**:
- `stop` (Optional[list[str]]): Список стоп-слов для поиска. Если `None`, поиск не производится.
- `content` (str): Строка, в которой производится поиск.
- `chunk` (str, optional): Дополнительная строка (часть контента) для поиска. По умолчанию `None`.

**Возвращает**:
- `tuple`: Кортеж, содержащий:
    - `first` (int): Индекс первого вхождения стоп-слова (или -1, если ни одно стоп-слово не найдено).
    - `content` (str): Обновленное содержимое (обрезанное до первого стоп-слова).
    - `chunk` (str): Обновленный фрагмент (обрезанный до первого стоп-слова), если он был предоставлен.

**Как работает функция**:

1. Функция `find_stop` принимает список стоп-слов `stop`, строку `content` и необязательную строку `chunk`.
2.  Если список стоп-слов `stop` не равен `None`, функция начинает итерировать по каждому слову в списке.
3.  Для каждого стоп-слова функция ищет его первое вхождение в строке `content` с помощью метода `find()`. Если стоп-слово найдено (то есть `first` не равен -1), функция обрезает строку `content` до позиции первого вхождения стоп-слова.
4.  Если также предоставлена строка `chunk`, функция ищет первое вхождение стоп-слова в `chunk`. Если стоп-слово найдено, `chunk` обрезается до позиции первого вхождения стоп-слова. Если стоп-слово не найдено в `chunk`, `first` устанавливается в 0.
5.  Если список стоп-слов `stop` равен `None`, функция возвращает -1 для `first` и исходные `content` и `chunk`.

**ASCII flowchart функции**:

```
A: Проверка, что список стоп-слов (stop) не None
│
├── Да: stop не None
│   │
│   B: Итерация по каждому стоп-слову в списке stop
│   │
│   C: Поиск первого вхождения стоп-слова в строке content
│   │
│   ├── Да: Стоп-слово найдено
│   │   │
│   │   D: Обрезка строки content до позиции стоп-слова
│   │   │
│   │   E: Проверка, что строка chunk не None
│   │   │
│   │   ├── Да: chunk не None
│   │   │   │
│   │   │   F: Поиск первого вхождения стоп-слова в строке chunk
│   │   │   │
│   │   │   ├── Да: Стоп-слово найдено в chunk
│   │   │   │   │
│   │   │   │   G: Обрезка строки chunk до позиции стоп-слова
│   │   │   │
│   │   │   └── Нет: Стоп-слово не найдено в chunk
│   │   │       │
│   │   │       H: Установка first в 0
│   │   │
│   │   └── Нет: chunk is None
│   │
│   I: Возврат first, content, chunk
│
└── Нет: stop is None
    │
    J: Возврат -1, content, chunk
```

**Примеры**:

```python
# Пример 1: Поиск стоп-слов в строке
stop_words = ["stop", "end"]
content = "This is a string with stop word."
first, content, chunk = find_stop(stop_words, content)
print(f"First: {first}, Content: {content}")  # First: 19, Content: This is a string with 

# Пример 2: Поиск стоп-слов с дополнительной строкой chunk
chunk = "stop word in chunk."
first, content, chunk = find_stop(stop_words, content, chunk)
print(f"First: {first}, Content: {content}, Chunk: {chunk}")  # First: 0, Content: This is a string with , Chunk: 

# Пример 3: Без стоп-слов
content = "This is a string without stop words."
first, content, chunk = find_stop(None, content)
print(f"First: {first}, Content: {content}, Chunk: {chunk}")  # First: -1, Content: This is a string without stop words., Chunk: 
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением None.

    Args:
        **kwargs: Произвольные ключевые аргументы.

    Returns:
        dict: Новый словарь, содержащий только элементы с значениями, отличными от None.
    """
```

**Назначение**: Фильтрует словарь, удаляя элементы со значением `None`.

**Параметры**:
- `**kwargs`: Произвольные ключевые аргументы, которые будут преобразованы в словарь.

**Возвращает**:
- `dict`: Новый словарь, содержащий только элементы с значениями, отличными от `None`.

**Как работает функция**:

1. Функция `filter_none` принимает произвольное количество именованных аргументов (`**kwargs`). Эти аргументы преобразуются в словарь.
2.  Функция создает новый словарь, используя генератор словаря. Генератор проходит по всем элементам исходного словаря (`kwargs.items()`) и включает в новый словарь только те элементы, значения которых не равны `None`.

**ASCII flowchart функции**:

```
A: Получение именованных аргументов в виде словаря kwargs
│
B: Создание нового словаря с помощью генератора словаря
│
C: Проверка значения каждого элемента на None
│
├── Да: Значение не None
│   │
│   D: Добавление элемента в новый словарь
│
└── Нет: Значение равно None
│
E: Возврат нового словаря
```

**Примеры**:

```python
# Пример 1: Фильтрация словаря с None значениями
filtered_dict = filter_none(a=1, b=None, c="hello")
print(f"Отфильтрованный словарь: {filtered_dict}")  # Отфильтрованный словарь: {'a': 1, 'c': 'hello'}

# Пример 2: Фильтрация словаря без None значений
filtered_dict = filter_none(a=1, b=2, c="hello")
print(f"Отфильтрованный словарь: {filtered_dict}")  # Отфильтрованный словарь: {'a': 1, 'b': 2, 'c': 'hello'}

# Пример 3: Фильтрация словаря, содержащего только None значения
filtered_dict = filter_none(a=None, b=None)
print(f"Отфильтрованный словарь: {filtered_dict}")  # Отфильтрованный словарь: {}
```

### `safe_aclose`

```python
async def safe_aclose(generator: AsyncGenerator) -> None:
    """
    Безопасно закрывает асинхронный генератор.

    Args:
        generator (AsyncGenerator): Асинхронный генератор для закрытия.
    """
```

**Назначение**: Безопасно закрывает асинхронный генератор.

**Параметры**:
- `generator` (AsyncGenerator): Асинхронный генератор, который нужно закрыть.

**Как работает функция**:

1. Функция `safe_aclose` принимает асинхронный генератор `generator` в качестве аргумента.
2.  Функция пытается закрыть генератор, вызывая метод `aclose()`, при этом предварительно проверяется, что генератор существует (не `None`) и имеет метод `aclose()`.
3.  Если во время закрытия генератора возникает исключение, оно перехватывается, и в лог записывается предупреждение с информацией об ошибке. Это позволяет избежать прерывания выполнения программы из-за ошибок при закрытии генератора.

**ASCII flowchart функции**:

```
A: Проверка, что генератор не None и имеет метод aclose
│
├── Да: Генератор существует и имеет метод aclose
│   │
│   B: Попытка закрытия генератора с помощью aclose()
│   │
│   ├── Успех: Генератор успешно закрыт
│   │
│   └── Ошибка: Во время закрытия возникло исключение
│       │
│       C: Запись предупреждения в лог с информацией об ошибке
│
└── Нет: Генератор None или не имеет метода aclose
```

**Примеры**:

```python
import asyncio
import logging

async def async_generator():
    """Асинхронный генератор для примера."""
    for i in range(3):
        yield i
        await asyncio.sleep(0.1)

async def main():
    """Основная функция для демонстрации."""
    gen = async_generator()
    try:
        async for item in gen:
            print(f"Получено: {item}")
    finally:
        await safe_aclose(gen)  # Безопасное закрытие генератора

if __name__ == "__main__":
    asyncio.run(main())