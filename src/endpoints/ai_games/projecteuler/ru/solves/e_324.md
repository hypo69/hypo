## Ответ на Задачу No 324: Простые числа Фибоначчи

### 1. Анализ задачи и решение

**Понимание задачи:**

*   Задача заключается в определении количества простых чисел среди чисел Фибоначчи, начиная с $F_2$ и заканчивая $F_{k+1}$, для заданного $k$.
*   Числа Фибоначчи вычисляются по формуле $F_n = F_{n-1} + F_{n-2}$, где $F_1 = 1$ и $F_2 = 1$.
*   Простое число - это натуральное число больше 1, которое делится без остатка только на 1 и само себя.

**Решение:**

1.  **Генерация чисел Фибоначчи:** Сначала необходимо сгенерировать последовательность чисел Фибоначчи до $F_{k+1}$. Можно использовать итеративный подход для этого.
2.  **Проверка на простоту:** Для каждого сгенерированного числа Фибоначчи необходимо проверить, является ли оно простым. Наиболее простой способ - проверить делимость числа на все числа от 2 до корня из этого числа.
3.  **Подсчет простых чисел:** Увеличиваем счетчик каждый раз, когда находим простое число Фибоначчи.

**Оптимизация:**
   * Заранее сгенерировать достаточное количество чисел Фибоначчи. Так как нас интересует  $P(10^8)$ то нужно рассмотреть числа Фибоначчи $F_2 ... F_{100000001}$. Очевидно, что в памяти мы не сможем хранить все эти числа, по этому будем вычислять числа Фибоначчи и сразу их проверять на простоту.
   * Для проверки на простоту можно использовать более быстрый алгоритм, например, решето Эратосфена. Однако так как числа Фибоначчи растут достаточно быстро, то для каждого конкретного числа нет смысла использовать решето Эратосфена.

### 2. Алгоритм решения

1.  **Начать**
2.  Инициализировать `count_primes` = 0.
3.  Инициализировать `fib1` = 1, `fib2` = 1.
4.  **Цикл:** Для `i` от 2 до `k+1`
    *   Вычислить `fib_next` = `fib1` + `fib2`
    *   Если `fib_next` простое:
        *   Увеличить `count_primes` на 1
    *   Обновить `fib1` = `fib2` и `fib2` = `fib_next`.
5.  Вернуть `count_primes`
6.  **Конец**

**Алгоритм проверки числа на простоту:**
1.  **Начать**
2.  Если `num` <= 1, вернуть `ложь`.
3.  Для `i` от 2 до корня из `num`
    *  Если `num` делится на `i` без остатка, вернуть `ложь`.
4. Вернуть `истина`
5. **Конец**

### 3. Реализация на Python 3.12

```python
import math

def is_prime(num):
    """Checks if a number is prime."""
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def count_fibonacci_primes(k):
    """Counts the number of prime Fibonacci numbers from F_2 to F_{k+1}."""
    count_primes = 0
    fib1 = 1
    fib2 = 1

    if k >= 1 :
        for i in range(2, k + 2):
            if i==2:
                fib_next = fib2
            else:
                fib_next = fib1 + fib2
                fib1 = fib2
                fib2 = fib_next

            if is_prime(fib_next):
                count_primes += 1
    return count_primes

# Пример использования
k_value = 10**8
result = count_fibonacci_primes(k_value)
print(result)
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeCount((Инициализировать count_primes = 0, fib1 = 1, fib2 = 1))
    InitializeCount --> LoopStart((Начать цикл: i от 2 до k+1))
    LoopStart --> CalculateFibNext((Вычислить fib_next))
    CalculateFibNext --> CheckPrime((Проверить: fib_next простое?))
    CheckPrime -- Да --> IncrementCount((Увеличить count_primes на 1))
    IncrementCount --> UpdateFib((Обновить fib1, fib2))
    CheckPrime -- Нет --> UpdateFib
    UpdateFib --> LoopStart
    LoopStart --> End((Конец, Вернуть count_primes))
    
    subgraph is_prime
        isPrimeStart((Начало is_prime)) --> isPrimeCheck1((Проверить: num <= 1?))
        isPrimeCheck1 -- Да --> isPrimeReturnFalse((Вернуть ложь))
        isPrimeCheck1 -- Нет --> isPrimeLoopStart((Начать цикл: i от 2 до sqrt(num)))
        isPrimeLoopStart --> isPrimeCheckDiv((Проверить: num делится на i без остатка?))
        isPrimeCheckDiv -- Да --> isPrimeReturnFalse
        isPrimeCheckDiv -- Нет --> isPrimeLoopStart
        isPrimeLoopStart --> isPrimeReturnTrue((Вернуть истина))
        isPrimeReturnFalse --> isPrimeEnd((Конец is_prime))
        isPrimeReturnTrue --> isPrimeEnd
    end
    
    CalculateFibNext --> isPrimeStart
    isPrimeEnd --> CheckPrime
    
```

**Legenda:**

*   **Начало, Конец:** Начало и конец основного алгоритма.
*   **Инициализировать count\_primes = 0, fib1 = 1, fib2 = 1:** Инициализация счетчика простых чисел и первых двух чисел Фибоначчи.
*   **Начать цикл: i от 2 до k+1:** Начало цикла перебора от 2 до k+1.
*   **Вычислить fib\_next:** Вычисление следующего числа Фибоначчи.
*   **Проверить: fib\_next простое?:** Проверка текущего числа Фибоначчи на простоту.
*   **Увеличить count\_primes на 1:** Увеличение счетчика простых чисел на 1, если текущее число Фибоначчи простое.
*   **Обновить fib1, fib2:** Обновление значений для вычисления следующего числа Фибоначчи.
*   **Начало is\_prime, Конец is\_prime:** Начало и конец подпрограммы проверки на простоту.
*   **Проверить: num <= 1?:** Проверка если число меньше или равно 1.
*   **Вернуть ложь:** Вернуть если число не простое.
*   **Начать цикл: i от 2 до sqrt(num):** Начало цикла для проверки делителей.
*   **Проверить: num делится на i без остатка?:** Проверка на делимость текущим делителем.
*   **Вернуть истина:** Вернуть если число простое.
