## Ответ на Задачу No 114: Комбинации размещений красных блоков I

### 1. Анализ задачи и решение
**Понимание задачи:**
*   Дана строка из `n` единиц.
*   Нужно разместить черные блоки шириной 1 и красные блоки шириной 3 или более.
*   Красные блоки не должны соприкасаться.
*   Необходимо найти количество способов размещения блоков для `n = 50`.

**Решение:**

1.  **Динамическое программирование:** Использование рекурсивного подхода с мемоизацией или итеративного динамического программирования. Мы будем строить решения для `n` на основе решений для меньших значений `n`.
2.  **Базовые случаи:**
    *   `f(0) = 1` (пустая строка, 1 способ).
    *   `f(1) = 1` (только черные блоки, 1 способ).
    *   `f(2) = 1` (только черные блоки, 1 способ).
    *   `f(3) = 2` (либо все черные, либо один красный блок, 2 способа).
3.  **Рекуррентная формула:**
    *   Для любого `n` мы можем разместить либо черный блок в конце, либо красный блок.
    *   Если добавляем черный блок в конце, то количество вариантов равно `f(n-1)`.
    *   Если добавляем красный блок, то его минимальная ширина 3. После него должен быть хотя бы один черный. Поэтому мы должны посмотреть варианты для `f(n - k - 1)` где `k` это размер красного блока от `3`.
    *  Формула : `f(n) = f(n-1) + sum(f(n - k -1) for k in range(3, n))`. 
4.  **Оптимизация:** Для избежания пересчётов можно использовать динамическое программирование с запоминанием промежуточных результатов.

### 2. Алгоритм решения
1. Начать
2. Создать массив `dp` размера `n+1`, инициализировать его нулями.
3. Установить базовые значения: `dp[0] = 1`, `dp[1] = 1`, `dp[2] = 1`, `dp[3] = 2`
4. Для каждого `i` от 4 до `n`:
    * `dp[i] = dp[i - 1]`
    * Для каждого `k` от 3 до `i`:
        *  `dp[i] += dp[i - k - 1]`, если `i - k -1 >= 0`
5. Вернуть `dp[n]`
6. Конец

### 3. Реализация на Python 3.12
```python
def count_combinations(n):
    """
    Counts the number of ways to arrange black and red blocks in a row of n units.

    Args:
        n: The length of the row.

    Returns:
        The number of possible arrangements.
    """
    dp = [0] * (n + 1)
    dp[0] = 1
    if n >= 1:
        dp[1] = 1
    if n >= 2:
      dp[2] = 1
    if n >= 3:
      dp[3] = 2

    for i in range(4, n + 1):
        dp[i] = dp[i - 1]
        for k in range(3, i + 1):
           if i - k - 1 >=0:
             dp[i] += dp[i - k - 1]

    return dp[n]


# Example usage:
result = count_combinations(50)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeArray((Инициализировать dp[n+1] нулями))
    InitializeArray --> SetBaseCases((dp[0]=1, dp[1]=1, dp[2]=1, dp[3]=2))
    SetBaseCases --> LoopStart((Начать цикл: i от 4 до n))
    LoopStart --> AssignDpI((dp[i] = dp[i - 1]))
    AssignDpI --> InnerLoopStart((Начать цикл: k от 3 до i))
    InnerLoopStart --> CheckIndex((Проверить: i-k-1 >= 0))
    CheckIndex -- Да --> AddToDpI((dp[i] += dp[i - k - 1]))
    AddToDpI --> InnerLoopStart
    CheckIndex -- Нет --> InnerLoopStart
    InnerLoopStart --> LoopStart
    LoopStart --> ReturnResult((Вернуть dp[n]))
    ReturnResult --> End((Конец))
```

**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать dp\[n+1] нулями:** Создание массива `dp` размером `n+1` и заполнение его нулями.
*   **dp\[0]=1, dp\[1]=1, dp\[2]=1, dp\[3]=2:** Установка базовых значений для `dp`.
*   **Начать цикл: i от 4 до n:** Начало внешнего цикла, который проходит от 4 до `n`.
*    **dp\[i] = dp\[i - 1]:** присваивание `dp[i]` значения предыдущего результата `dp[i-1]`.
*   **Начать цикл: k от 3 до i:** Начало внутреннего цикла, который проходит от 3 до `i`.
*   **Проверить: i-k-1 >= 0:** Проверка условия, что индекс не выйдет за границы массива.
*    **dp\[i] += dp\[i - k - 1]:**  добавляем значение `dp[i - k - 1]` к текущему `dp[i]`.
*   **Вернуть dp\[n]:** Возвращение результата, хранящегося в `dp[n]`.
