# Модуль aiohttp

## Обзор

Модуль `aiohttp.py` предоставляет классы и функции для работы с асинхронными HTTP-запросами, включая поддержку потоковой передачи данных и прокси-серверов. Он предназначен для использования с библиотекой `aiohttp` и обеспечивает удобный интерфейс для выполнения сетевых запросов в асинхронном режиме.

## Подробней

Этот модуль расширяет возможности `aiohttp`, добавляя поддержку потоковой обработки ответов и прокси-соединений. Он содержит классы `StreamResponse` и `StreamSession`, которые упрощают работу с потоковыми данными и позволяют использовать прокси-серверы для выполнения запросов.

## Классы

### `StreamResponse`

**Описание**: Класс `StreamResponse` расширяет `aiohttp.ClientResponse`, добавляя методы для асинхронной итерации по строкам и содержимому ответа, а также для обработки Server-Sent Events (SSE).

**Наследует**:
- `aiohttp.ClientResponse`

**Методы**:

- `iter_lines`
- `iter_content`
- `json`
- `sse`

#### `iter_lines`

```python
async def iter_lines(self) -> AsyncIterator[bytes]:
    """Асинхронно итерирует по строкам содержимого ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по строкам содержимого ответа, удаляя завершающие символы новой строки.

**Параметры**:
- Нет

**Возвращает**:
- `AsyncIterator[bytes]`: Асинхронный итератор байтовых строк.

**Как работает функция**:
1. Итерирует по содержимому ответа асинхронно.
2. Для каждой строки удаляет завершающие символы новой строки (`\r\n`).
3. Возвращает строку в виде байтов.

```ascii
Содержимое ответа
    │
    ├── async for line in self.content
    │   │
    │   Удаление завершающих символов новой строки (rstrip(b"\r\n"))
    │   │
    │   Возврат строки в виде байтов (yield line.rstrip(b"\r\n"))
    │
Конец
```

#### `iter_content`

```python
async def iter_content(self) -> AsyncIterator[bytes]:
    """Асинхронно итерирует по содержимому ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по содержимому ответа, возвращая чанки данных.

**Параметры**:
- Нет

**Возвращает**:
- `AsyncIterator[bytes]`: Асинхронный итератор байтовых чанков.

**Как работает функция**:
1. Асинхронно итерирует по содержимому ответа чанками.
2. Возвращает каждый чанк в виде байтов.

```ascii
Содержимое ответа
    │
    ├── async for chunk in self.content.iter_any()
    │   │
    │   Возврат чанка в виде байтов (yield chunk)
    │
Конец
```

#### `json`

```python
async def json(self, content_type: str = None) -> Any:
    """Декодирует JSON-ответ."""
    ...
```

**Назначение**: Декодирует JSON-ответ, используя метод `json` из родительского класса `ClientResponse`.

**Параметры**:
- `content_type` (str, optional): Тип содержимого. По умолчанию `None`.

**Возвращает**:
- `Any`: Декодированный JSON-ответ.

**Как работает функция**:
1. Вызывает метод `json` из родительского класса `ClientResponse` с указанным типом содержимого.
2. Возвращает декодированный JSON-ответ.

```ascii
Вызов super().json(content_type=content_type)
    │
    │
Возврат декодированного JSON-ответа
```

#### `sse`

```python
async def sse(self) -> AsyncIterator[dict]:
    """Асинхронно итерирует по Server-Sent Events ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по Server-Sent Events (SSE) ответа, декодируя каждый event как JSON.

**Параметры**:
- Нет

**Возвращает**:
- `AsyncIterator[dict]`: Асинхронный итератор словарей, представляющих SSE events.

**Как работает функция**:
1. Асинхронно итерирует по строкам содержимого ответа.
2. Проверяет, начинается ли строка с `b"data: "`.
3. Извлекает данные из строки, начиная с 6-го байта.
4. Если данные начинаются с `b"[DONE]"`, прерывает итерацию.
5. Пытается декодировать данные как JSON.
6. Если декодирование успешно, возвращает декодированный JSON.
7. Если декодирование не удалось, продолжает итерацию.

```ascii
Содержимое ответа
    │
    ├── async for line in self.content
    │   │
    │   Проверка, начинается ли строка с b"data: " (line.startswith(b"data: "))
    │   │
    ├── ДА: Извлечение данных (chunk = line[6:])
    │   │
    │   Проверка, начинаются ли данные с b"[DONE]" (chunk.startswith(b"[DONE]"))
    │   │
    ├── НЕТ: Продолжение итерации
    │   │
    ├── ДА: Прерывание итерации (break)
    │   │
    ├── НЕТ: Попытка декодирования данных как JSON (json.loads(chunk))
    │   │
    ├── Успешно: Возврат декодированного JSON (yield json.loads(chunk))
    │   │
    ├── Ошибка: Продолжение итерации
    │
Конец
```

### `StreamSession`

**Описание**: Класс `StreamSession` расширяет `aiohttp.ClientSession`, добавляя поддержку прокси-серверов, пользовательских заголовков и таймаутов.

**Наследует**:
- `aiohttp.ClientSession`

**Атрибуты**:
- `headers` (dict): Заголовки по умолчанию для сессии.
- `timeout` (int, optional): Таймаут для сессии. По умолчанию `None`.
- `connector` (BaseConnector, optional): Коннектор для сессии. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `proxies` (dict, optional): Словарь прокси-серверов. По умолчанию `{}`.
- `impersonate` (optional): Параметр для имитации. По умолчанию `None`.

**Методы**:
- `__init__`

#### `__init__`

```python
def __init__(
    self,
    headers: dict = {},
    timeout: int = None,
    connector: BaseConnector = None,
    proxy: str = None,
    proxies: dict = {},
    impersonate = None,
    **kwargs
):
    """Инициализирует StreamSession с заданными параметрами."""
    ...
```

**Назначение**: Инициализирует `StreamSession` с заданными параметрами, включая заголовки, таймаут, коннектор и прокси.

**Параметры**:
- `headers` (dict, optional): Заголовки по умолчанию для сессии. По умолчанию `{}`.
- `timeout` (int, optional): Таймаут для сессии. По умолчанию `None`. Может быть кортежем `(connect, read)`.
- `connector` (BaseConnector, optional): Коннектор для сессии. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `proxies` (dict, optional): Словарь прокси-серверов. По умолчанию `{}`.
- `impersonate` (optional): Параметр для имитации. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы, передаваемые в конструктор `ClientSession`.

**Как работает функция**:
1. Если указан параметр `impersonate`, добавляет заголовки по умолчанию.
2. Если `timeout` является кортежем, разделяет его на таймаут подключения и таймаут чтения.
3. Создает объект `ClientTimeout` с заданным таймаутом.
4. Определяет URL прокси-сервера из параметров `proxy` или `proxies`.
5. Инициализирует родительский класс `ClientSession` с заданными параметрами, включая таймаут, класс ответа, коннектор и заголовки.

```ascii
Проверка impersonate
    │
    ├── ДА: Объединение заголовков
    │   │
    ├── НЕТ: Пропуск
    │
Проверка timeout как кортеж
    │
    ├── ДА: Разделение на connect, timeout
    │   │
    ├── НЕТ: Пропуск
    │
Создание ClientTimeout
    │
Определение proxy из аргументов
    │
Инициализация ClientSession с параметрами
```

## Функции

### `get_connector`

```python
def get_connector(connector: BaseConnector = None, proxy: str = None, rdns: bool = False) -> Optional[BaseConnector]:
    """Возвращает коннектор для aiohttp с поддержкой прокси."""
    ...
```

**Назначение**: Возвращает коннектор для `aiohttp` с поддержкой прокси-серверов.

**Параметры**:
- `connector` (BaseConnector, optional): Существующий коннектор. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `rdns` (bool, optional): Флаг для использования удаленного разрешения DNS для SOCKS5 прокси. По умолчанию `False`.

**Возвращает**:
- `Optional[BaseConnector]`: Коннектор с поддержкой прокси или `None`, если прокси не указан и коннектор не предоставлен.

**Вызывает исключения**:
- `MissingRequirementsError`: Если указан прокси, но не установлена библиотека `aiohttp_socks`.

**Как работает функция**:
1. Проверяет, указан ли прокси и не предоставлен ли коннектор.
2. Если прокси указан, пытается импортировать `ProxyConnector` из библиотеки `aiohttp_socks`.
3. Если библиотека `aiohttp_socks` не установлена, вызывает исключение `MissingRequirementsError`.
4. Если URL прокси начинается с `socks5h://`, заменяет его на `socks5://` и устанавливает флаг `rdns` в `True`.
5. Создает `ProxyConnector` из URL прокси.
6. Если прокси не указан или коннектор предоставлен, возвращает предоставленный коннектор или `None`.

```ascii
Проверка proxy и connector
    │
    ├── ДА: Попытка импорта ProxyConnector из aiohttp_socks
    │   │
    │   Библиотека установлена?
    │   ├── ДА:
    │   │   │
    │   │   Проверка схемы proxy (socks5h://)
    │   │   │
    │   │   Замена схемы и установка rdns=True если необходимо
    │   │   │
    │   │   Создание ProxyConnector.from_url(proxy, rdns=rdns)
    │   │   │
    │   │   Возврат ProxyConnector
    │   │
    │   ├── НЕТ: Выброс MissingRequirementsError
    │
    ├── НЕТ: Возврат переданного connector или None
    │
Конец
```