# Анализ кода модуля chomp.py

**Качество кода**
-  **Соответствие требованиям к формату кода с 1 по 10**
    -  Преимущества
        - Код хорошо структурирован и читаем.
        - Логика игры реализована четко и понятно.
        - Используются функции для разделения ответственности, что делает код модульным.
        - Добавлены docstring для функций.
    - Недостатки
        - Не используются `j_loads` или `j_loads_ns` из `src.utils.jjson`. # TODO нужно использовать
        - Отсутствуют импорты необходимые для работы модуля. # TODO нужно добавить
        - Используются стандартные `try-except` блоки, что можно заменить на `logger.error`. # TODO нужно заменить
        - Нет подробных комментариев RST. # TODO нужно добавить
        - Отсутствует обработка ошибок через логирование. # TODO нужно добавить логирование
        - Нет проверки типов данных для ввода пользователя. # TODO добавить проверку типов данных

**Рекомендации по улучшению**
1. **Импорты**: Добавить необходимые импорты, такие как `from src.utils.jjson import j_loads, j_loads_ns` и `from src.logger.logger import logger`.
2. **Обработка данных**: Заменить `input` на проверку типа данных через try/except, и в случае ошибки использовать `logger.error`.
3. **Обработка ошибок**: Заменить общие блоки `try-except` на использование `logger.error` для логирования ошибок и добавление `...` для остановки кода.
4. **Документация**: Добавить полное описание модуля в формате RST.
5. **RST комментарии**: Добавить подробные комментарии в формате RST для всех функций, методов и переменных, включая примеры.
6. **Проверка ввода**: Добавить проверку типов данных и границ ввода пользователя.

**Улучшенный код**
```python
"""
Модуль для игры "CHOMP"
=======================

Модуль реализует игру "CHOMP" на прямоугольной доске (шоколадной плитке).
Игроки по очереди откусывают куски шоколада, стремясь заставить противника
съесть отравленную дольку (левый верхний угол).

Правила игры:
    1. Игровое поле представляет собой прямоугольную шоколадную плитку.
    2. Один из углов (нижний левый) считается отравленным.
    3. Игроки по очереди откусывают часть шоколадной плитки.
    4. Игрок выбирает строку и столбец (откусывает кусок шоколада).
    5. Все клетки справа и выше выбранной позиции удаляются.
    6. Цель - заставить противника съесть отравленную дольку.
    7. Игрок, который съедает отравленную дольку, проигрывает.

Пример использования
--------------------
Запустите скрипт, и следуйте инструкциям в консоли для игры.

.. code-block:: python

    if __name__ == "__main__":
        play_chomp()
"""
__author__ = 'hypo69 (hypo69@davidka.net)'

from src.logger.logger import logger # Добавлен импорт для логирования
from typing import List # Добавлен импорт для типизации списков

def initialize_board(rows: int, cols: int) -> List[List[str]]:
    """
    Инициализирует игровое поле (шоколадную плитку).

    :param rows: Количество строк на доске.
    :type rows: int
    :param cols: Количество столбцов на доске.
    :type cols: int
    :return: Список списков, представляющий игровую доску, где 'X' - шоколад, ' ' - пустое место.
    :rtype: List[List[str]]
    
    Пример:
        >>> initialize_board(3, 4)
        [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]
    """
    board = [['X' for _ in range(cols)] for _ in range(rows)] # Создается доска с заданным размером и заполняется 'X'
    return board

def display_board(board: List[List[str]]) -> None:
    """
    Выводит текущее состояние доски на экран.

    :param board: Игровая доска.
    :type board: List[List[str]]
    :return: None
    
    Пример:
        >>> display_board([['X', 'X'], [' ', 'X']])
        X X
         X
    """
    for row in board:
        print(' '.join(row)) # Выводит строку доски

def make_move(board: List[List[str]], row_move: int, col_move: int) -> List[List[str]]:
    """
    Обновляет состояние доски после хода игрока.
    Все клетки справа и выше выбранной позиции удаляются.

    :param board: Игровая доска.
    :type board: List[List[str]]
    :param row_move: Строка, на которую игрок сделал ход.
    :type row_move: int
    :param col_move: Столбец, на который игрок сделал ход.
    :type col_move: int
    :return: Обновленная игровая доска.
    :rtype: List[List[str]]
    
    Пример:
        >>> make_move([['X', 'X'], ['X', 'X']], 0, 1)
        [['X', ' '], ['X', ' ']]
    """
    rows = len(board) # Получает количество строк
    cols = len(board[0]) # Получает количество столбцов
    for row in range(row_move, rows):
        for col in range(col_move, cols):
            board[row][col] = ' ' # Заменяет значения 'X' на ' ' в указанной области
    return board

def is_game_over(board: List[List[str]]) -> bool:
    """
    Проверяет, закончилась ли игра.
    Игра заканчивается, если ядовитая долька (верхний левый угол) съедена.

    :param board: Игровая доска.
    :type board: List[List[str]]
    :return: True, если игра окончена, иначе False.
    :rtype: bool
    
    Пример:
        >>> is_game_over([[' ', 'X'], ['X', 'X']])
        True
        >>> is_game_over([['X', 'X'], ['X', 'X']])
        False
    """
    return board[0][0] == ' ' # Проверяет, пуста ли ячейка с отравленной долькой

def play_chomp() -> None:
    """
    Основная функция игры "CHOMP".
    Реализует игровой процесс, включая ввод размеров доски, отображение доски,
    и обработку ходов игроков.

    :return: None
    """
    while True:
        try:
            rows = int(input("Введите количество строк на доске: ")) # Запрос на ввод количества строк
            cols = int(input("Введите количество столбцов на доске: ")) # Запрос на ввод количества столбцов
            if rows <= 0 or cols <= 0: # Проверяет, что введены положительные числа
                 print("Размер доски должен быть положительным числом.")
                 continue
            break
        except ValueError as e: # Ловит ошибку ValueError
            logger.error('Неверный ввод размера доски', exc_info=True) # Выводит сообщение об ошибке с логированием
            print("Пожалуйста, введите целое число.")
            ...
            return
    board = initialize_board(rows, cols) # Инициализация игровой доски
    current_player = 1  # Начинает первый игрок

    while True:
        print(f"\nХод игрока {current_player}:") # Выводит ход текущего игрока
        display_board(board) # Выводит доску

        while True:
            try:
                row_move = int(input("Введите строку для откусывания (начиная с 0): ")) # Запрос на ввод строки
                col_move = int(input("Введите столбец для откусывания (начиная с 0): ")) # Запрос на ввод столбца
                if row_move < 0 or col_move < 0 or row_move >= rows or col_move >= cols: # Проверка, что введены корректные значения
                    print("Неверный ход. Укажите строку и столбец в пределах доски")
                    continue
                if board[row_move][col_move] == ' ': # Проверка, что не откусывают пустое место
                     print("Вы не можете откусить пустое место. Попробуйте еще раз")
                     continue
                break
            except ValueError as e: # Ловит ошибку ValueError
                logger.error('Неверный ввод хода игрока', exc_info=True) # Выводит сообщение об ошибке с логированием
                print("Пожалуйста, введите целые числа.")
                ...
                return
            except IndexError as e: # Ловит ошибку IndexError
                 logger.error('Неверный индекс хода игрока', exc_info=True) # Выводит сообщение об ошибке с логированием
                 print("Неверный ход. Укажите строку и столбец в пределах доски")
                 ...
                 return
        board = make_move(board, row_move, col_move) # Обновление доски после хода

        if is_game_over(board): # Проверка, что игра окончена
          print(f"Победил игрок {3-current_player}!") # Выводит победителя
          display_board(board)
          break
        current_player = 3 - current_player # Переключает игрока

if __name__ == "__main__":
    play_chomp() # Запуск игры при прямом запуске скрипта

"""
Объяснение кода:
1.  **Инициализация**:
   -  `initialize_board(rows, cols)`: Функция создает игровую доску размером `rows` x `cols`. Изначально все ячейки заполнены символом 'X', представляющим шоколад.
2.  **Отображение доски**:
   -  `display_board(board)`: Функция выводит текущее состояние доски на экран, построчно отображая каждый ряд.
3.  **Ход игрока**:
   -  `make_move(board, row_move, col_move)`: Функция обновляет доску, удаляя все 'X' справа и ниже указанных координат `row_move` и `col_move`, заменяя их на ' '.
4.  **Проверка окончания игры**:
    -  `is_game_over(board)`: Проверяет, съедена ли отравленная долька (верхний левый угол). Если ячейка `board[0][0]` содержит ' ', то игра окончена.
5.  **Основная логика игры `play_chomp()`**:
    -   Запрашивает у пользователя размеры доски.
    -   Инициализирует доску.
    -   Организует цикл игры, в котором игроки по очереди делают ходы.
    -   Выводит текущее состояние доски.
    -   Запрашивает ввод координат хода у игрока.
    -   Обновляет доску после хода.
    -   Проверяет, закончилась ли игра.
    -   Выводит сообщение о победе одного из игроков.
    -   Переключает текущего игрока.
6.  **Обработка исключений**:
   -   Код содержит `try-except` блоки для обработки ошибок ввода (нечисловые значения), которые теперь используют `logger.error` для логирования.
7.  **Запуск игры**:
   -  `if __name__ == "__main__":`:  Этот блок гарантирует, что функция `play_chomp()` будет запущена только при непосредственном запуске скрипта.
"""
```