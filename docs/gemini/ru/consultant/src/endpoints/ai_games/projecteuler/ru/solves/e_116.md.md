# Анализ кода модуля e_116.md

**Качество кода**
9
- Плюсы
    - Код хорошо структурирован и содержит подробное объяснение задачи и решения.
    - Используется динамическое программирование, которое является оптимальным подходом для данной задачи.
    - Присутствует блок-схема в формате mermaid, что улучшает понимание алгоритма.
    - Код содержит docstring для функций, что соответствует стандартам документирования.

- Минусы
    - Отсутствуют необходимые импорты.
    - Нет логирования ошибок.
    - Имена переменных могли бы быть более информативными, например `n` для размера строки.
    - Комментарии внутри кода не приведены к стандарту reStructuredText (RST).

**Рекомендации по улучшению**
1. Добавить необходимые импорты (если они требуются).
2. Внедрить логирование для отслеживания возможных ошибок.
3. Переписать docstring в соответствии со стандартом RST, а также прокомментировать код в стиле RST.
4.  Улучшить имена переменных, если это необходимо для более легкого понимания.
5. Добавить проверку входных данных (например, n > 0).
6. Описать, какие ограничения имеются у программы (например, на максимально допустимое значение n)

**Оптимизированный код**
```python
"""
Модуль для решения задачи Project Euler №116.
=========================================================================================

Этот модуль содержит функции для расчета количества способов размещения плиток разного размера
на последовательности черных квадратов.

Функции:
    - count_red_tile_ways(n: int) -> int: Подсчитывает количество способов размещения только красных плиток размера 2.
    - count_all_tile_ways(n: int) -> int: Подсчитывает количество способов размещения красных (2), зеленых (3) или синих (4) плиток.

Пример использования
--------------------
Для расчета количества способов размещения плиток на 50 квадратах:

.. code-block:: python

    num_squares = 50
    red_only_ways = count_red_tile_ways(num_squares)
    all_tile_ways = count_all_tile_ways(num_squares)

"""
from src.logger.logger import logger
def count_red_tile_ways(n: int) -> int:
    """
    Подсчитывает количество способов размещения только красных плиток размера 2 на n черных квадратах.

    :param n: Количество черных квадратов.
    :type n: int
    :raises TypeError: если `n` не является целым числом.
    :raises ValueError: если `n` меньше 0
    :return: Количество способов размещения.
    :rtype: int
    """
    if not isinstance(n, int):
        logger.error(f'Неверный тип данных {n=}. Ожидается целое число.')
        raise TypeError(f'Неверный тип данных {n=}. Ожидается целое число.')
    if n < 0:
       logger.error(f'Неверное значение n={n}, n должно быть >= 0')
       raise ValueError(f'Неверное значение n={n}, n должно быть >= 0')
    
    red_ways = [0] * (n + 1) # Инициализация массива для хранения количества способов, где индекс - количество квадратов
    red_ways[0] = 1 # Базовый случай: 0 квадратов - 1 способ (не ставить плитки)
    if n > 0: # Если есть хотя бы 1 квадрат
        red_ways[1] = 1 # Базовый случай: 1 квадрат - 1 способ (не ставить плитку)
    for i in range(2, n + 1):
        # Для каждого i от 2 до n вычисляется количество способов: сумма способов для i-1 и i-2
        red_ways[i] = red_ways[i-1] + red_ways[i-2] # кол-во способов разместить плитки на i квадратах, равно сумме кол-ва способов для i-1(не ставим плитку) + i-2(ставим красную)
    return red_ways[n]


def count_all_tile_ways(n: int) -> int:
    """
    Подсчитывает количество способов размещения красных (2), зеленых (3) или синих (4) плиток на n черных квадратах.

    :param n: Количество черных квадратов.
    :type n: int
    :raises TypeError: если `n` не является целым числом.
    :raises ValueError: если `n` меньше 0
    :return: Количество способов размещения.
    :rtype: int
    """
    if not isinstance(n, int):
        logger.error(f'Неверный тип данных {n=}. Ожидается целое число.')
        raise TypeError(f'Неверный тип данных {n=}. Ожидается целое число.')
    if n < 0:
       logger.error(f'Неверное значение n={n}, n должно быть >= 0')
       raise ValueError(f'Неверное значение n={n}, n должно быть >= 0')
    all_ways = [0] * (n + 1) # Инициализация массива для хранения количества способов, где индекс - количество квадратов
    all_ways[0] = 1 # Базовый случай: 0 квадратов - 1 способ (не ставить плитки)
    for i in range(1, n + 1):
        # Для каждого i от 1 до n вычисляется количество способов
        all_ways[i] = all_ways[i - 1] # как если не ставим плитку на i-ю позицию
        if i >= 2: # если i>=2 то можем поставить красную
            all_ways[i] += all_ways[i - 2] # добавляем кол-во способов при котором поставили красную плитку
        if i >= 3: # если i>=3 то можем поставить зеленую
            all_ways[i] += all_ways[i - 3] # добавляем кол-во способов при котором поставили зеленую плитку
        if i >= 4: # если i>=4 то можем поставить синюю
            all_ways[i] += all_ways[i - 4] # добавляем кол-во способов при котором поставили синюю плитку
    return all_ways[n]


# Example usage:
num_squares = 50
red_only_ways = count_red_tile_ways(num_squares)
all_tile_ways = count_all_tile_ways(num_squares)

print(f"Number of ways to place only red tiles: {red_only_ways}")
print(f"Number of ways to place red, green, or blue tiles: {all_tile_ways}")

```