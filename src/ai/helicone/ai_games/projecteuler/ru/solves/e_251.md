## Ответ на Задачу No 251: Треугольники с целочисленными сторонами, имеющими общую площадь

### 1. Анализ задачи и решение

**Понимание задачи:**
*   Нам нужно найти количество целочисленных треугольников (треугольники, у которых все стороны являются целыми числами) с целочисленной площадью, у которых все стороны не превышают заданного числа `n`.
*   Формула Герона позволяет вычислить площадь треугольника по длинам его сторон:
    `area = sqrt(s * (s - a) * (s - b) * (s - c))`
    где `s = (a + b + c) / 2` - полупериметр, а a, b, и c - стороны треугольника.
*   Для того, чтобы площадь была целым числом, подкоренное выражение должно быть полным квадратом.
*   Для решения задачи нам нужно перебрать все возможные сочетания сторон треугольника (a, b, c) таких, что `1 <= a <= n`, `1 <= b <= n`, `1 <= c <= n` и проверить выполняется ли неравенство треугольника и является ли площадь целым числом.
*  Для оптимизации перебора сторон можно применить следующие соображения:
  *  a <= b <= c. Это позволит избежать дублирования (например, {3,4,5} = {4,3,5} = {5,4,3}).
  *  a + b > c  (неравенство треугольника).
  *  a + b + c должно быть четным числом, чтобы полупериметр s был целым.

**Решение:**

1.  **Инициализация:** Создаем переменную `count`, в которой будем накапливать результат (количество подходящих треугольников).
2.  **Перебор:** Организуем три вложенных цикла для перебора сторон `a`, `b`, и `c`, соблюдая ограничение `a <= b <= c <= n`.
3.  **Проверка неравенства треугольника:** Убедимся, что выполняется неравенство треугольника `a + b > c`.
4.  **Проверка четности суммы:** Убедимся, что сумма `a + b + c` является четной.
5.  **Вычисление площади:** Вычисляем полупериметр `s` и площадь треугольника по формуле Герона.
6.  **Проверка целочисленности площади:** Проверяем, является ли площадь целым числом. Для этого можно возвести ее в квадрат и проверить, что корень из этой величины - целое число.
7. **Увеличение счетчика:** Если площадь является целым числом, увеличиваем счетчик `count`.
8.  **Возврат результата:** После окончания перебора всех вариантов возвращаем значение `count`.

### 2. Алгоритм решения
1. Начать
2. Инициализировать переменную `count` со значением 0
3. Для каждого `a` от 1 до `n`:
   * Для каждого `b` от `a` до `n`:
        * Для каждого `c` от `b` до `n`:
            * Если `a + b > c`:
                 * Если `(a + b + c)` делится на 2 без остатка:
                    * Вычислить полупериметр `s = (a + b + c) / 2`
                    * Вычислить `area_squared = s * (s - a) * (s - b) * (s - c)`
                    * Вычислить `area_sqrt = sqrt(area_squared)`
                    * Если `area_sqrt` равно целому числу:
                        * Увеличить `count` на 1
4. Вернуть `count`
5. Конец

### 3. Реализация на Python 3.12
```python
import math

def count_integer_area_triangles(limit):
    """
    Counts the number of integer triangles with integer area and sides <= limit.

    Args:
        limit: The maximum side length.

    Returns:
        The count of such triangles.
    """
    count = 0
    for a in range(1, limit + 1):
        for b in range(a, limit + 1):
            for c in range(b, limit + 1):
                if a + b > c:
                    if (a + b + c) % 2 == 0:
                        s = (a + b + c) / 2
                        area_squared = s * (s - a) * (s - b) * (s - c)
                        area_sqrt = math.sqrt(area_squared)
                        if area_sqrt == int(area_sqrt):
                            count += 1
    return count

# Пример использования:
result = count_integer_area_triangles(10)
print(result)

# Вычисление для T(10^9) (занимает много времени)
# result = count_integer_area_triangles(10**9)
# print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeCount((Инициализировать count = 0))
    InitializeCount --> LoopAStart((Начать цикл: a от 1 до n))
    LoopAStart --> LoopBStart((Начать цикл: b от a до n))
    LoopBStart --> LoopCStart((Начать цикл: c от b до n))
    LoopCStart --> CheckTriangleInequality((Проверить: a + b > c?))
    CheckTriangleInequality -- Да --> CheckSumParity((Проверить: (a+b+c) % 2 == 0?))
    CheckSumParity -- Да --> CalculateSemiperimeter((s = (a + b + c) / 2))
    CalculateSemiperimeter --> CalculateAreaSquared((area_squared = s * (s - a) * (s - b) * (s - c)))
    CalculateAreaSquared --> CalculateAreaSqrt((area_sqrt = sqrt(area_squared)))
     CalculateAreaSqrt --> CheckIntegerArea((Проверить: area_sqrt - целое число?))
    CheckIntegerArea -- Да --> IncrementCount((Увеличить count на 1))
    IncrementCount --> LoopCStart
    CheckIntegerArea -- Нет --> LoopCStart
    CheckSumParity -- Нет --> LoopCStart
    CheckTriangleInequality -- Нет --> LoopCStart
    LoopCStart --> LoopBEnd((Закончить цикл: c))
     LoopBEnd --> LoopAEnd((Закончить цикл: b))
     LoopAEnd --> EndLoopA((Закончить цикл: a))
    EndLoopA --> ReturnCount((Вернуть count))
    ReturnCount --> End((Конец))
```

**Legenda:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать count:** Создаем переменную для хранения количества подходящих треугольников и присваиваем ей значение 0.
*   **Начать цикл: a от 1 до n, Закончить цикл: a:** Определяет начало и конец внешнего цикла перебора стороны `a`.
*   **Начать цикл: b от a до n, Закончить цикл: b:** Определяет начало и конец среднего цикла перебора стороны `b`.
*   **Начать цикл: c от b до n, Закончить цикл: c:** Определяет начало и конец внутреннего цикла перебора стороны `c`.
*   **Проверить: a + b > c?:** Проверяем выполнение неравенства треугольника.
*  **Проверить: (a+b+c) % 2 == 0?:** Проверяем четность суммы длин сторон.
*   **s = (a + b + c) / 2:** Вычисляем полупериметр треугольника.
*   **area\_squared = s * (s - a) * (s - b) * (s - c):** Вычисляем квадрат площади треугольника.
*   **area\_sqrt = sqrt(area\_squared):** Вычисляем квадратный корень из `area_squared`.
*   **Проверить: area\_sqrt - целое число?:** Проверяем, является ли площадь целым числом.
*   **Увеличить count на 1:** Увеличиваем счетчик подходящих треугольников.
*   **Вернуть count:** Возвращаем общее количество найденных треугольников.
