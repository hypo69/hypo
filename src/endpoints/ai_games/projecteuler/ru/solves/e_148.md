## Ответ на Задачу No 148: Треугольники Паскаля, кратные 7

### 1. Анализ задачи и решение
**Понимание задачи:**
* Нам нужно найти количество чисел в первых 10<sup>9</sup> строках треугольника Паскаля, которые **не** делятся на 7.
* Прямое вычисление треугольника Паскаля до 10<sup>9</sup> строк нецелесообразно из-за огромного объема вычислений и памяти.
* Необходимо найти закономерность в распределении чисел, не делящихся на 7, в треугольнике Паскаля.
* Существует связь между треугольником Паскаля и биномиальными коэффициентами, где n-я строка треугольника Паскаля это значения С(n,k) (где k пробегает значения от 0 до n).
*  В треугольнике Паскаля, числа, не делящиеся на 7, образуют фрактальный узор, который повторяется.

**Решение:**

1. **Свойство Люка:** Ключевым моментом является использование Теоремы Люка, которая гласит, что биномиальный коэффициент `C(n, k)` не делится на простое число `p` тогда и только тогда, когда каждый разряд чисел `n` и `k` в `p`-ичной системе счисления (в нашем случае, `p=7`) удовлетворяет условию, что разряд числа `k` меньше или равен разряду числа `n` в соответствующей позиции.
2. **Анализ для p = 7:** Для p=7, число в n-й строке не делится на 7, если при представлении n и k в семеричной системе счисления, каждый семеричный разряд k не превышает соответствующий семеричный разряд n. 
3. **Подсчет для одной строки:** Для данной строки n, мы представляем n в семеричной системе счисления. Число `k` должно быть таким, чтобы для каждого семеричного разряда, соответствующий разряд `k` был от 0 до разряда `n`. Следовательно, в каждой позиции у `k` есть количество вариантов, равное значению разряда `n` + 1. Перемножив количество вариантов для всех разрядов, получим число не делящихся на 7 чисел в строке `n`.
4. **Суммирование:** Нужно просуммировать количество не делящихся на 7 чисел в каждой строке от 0 до 10<sup>9</sup> - 1.
5. **Оптимизация:** Поскольку числа в семеричной системе счисления растут в геометрической прогрессии, мы можем разбивать числа на блоки и считать количество чисел, не делящихся на 7, по блокам.
6. **Рекурсивный подход:** Для эффективности, используем рекурсию. За основу берется формула, описанная в пункте 3. Рекурсия остановится на числе 0, для которого ответ будет 1. Для других чисел рекурсивно вызываем функцию для разрядов числа в семеричной системе счисления.

### 2. Алгоритм решения
1. Начать
2. Определить рекурсивную функцию `count_not_divisible_by_7(number)`:
    * Если `number` равно 0, вернуть 1
    * Инициализировать переменную `result` значением 1
    * Пока `number` больше 0:
        * Вычислить остаток `digit` от деления `number` на 7
        * Умножить `result` на `digit + 1`
        * Разделить `number` на 7 (целочисленное деление)
    * Вернуть `result`
3. Инициализировать переменную `total_count` значением 0
4. Для каждого числа `row` от 0 до 10<sup>9</sup> - 1
    *  Вызвать `count_not_divisible_by_7(row)` и прибавить результат к `total_count`
5. Вернуть `total_count`
6. Конец

### 3. Реализация на Python 3.12
```python
def count_not_divisible_by_7(number):
    """
    Calculates the number of elements not divisible by 7 in a given row of Pascal's triangle using Lucas' theorem.
    """
    if number == 0:
        return 1
    result = 1
    while number > 0:
        digit = number % 7
        result *= (digit + 1)
        number //= 7
    return result


def solve():
    """
    Calculates the total number of elements not divisible by 7 in the first 1 billion rows of Pascal's triangle.
    """
    total_count = 0
    limit = 10**9
    for row in range(limit):
        total_count += count_not_divisible_by_7(row)
    return total_count


if __name__ == "__main__":
    result = solve()
    print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeTotalCount((Инициализировать total_count = 0))
    InitializeTotalCount --> LoopStart((Начать цикл: row от 0 до 999,999,999))
    LoopStart --> CallCountNotDivisible((Вызвать count_not_divisible_by_7(row)))
    CallCountNotDivisible --> AddToTotalCount((Прибавить результат к total_count))
    AddToTotalCount --> LoopStart
    LoopStart --> End((Конец))

    subgraph count_not_divisible_by_7
    StartCount((Начало count_not_divisible_by_7)) --> CheckBaseCase((Проверить: number == 0?))
    CheckBaseCase -- Да --> ReturnOne((Вернуть 1))
    CheckBaseCase -- Нет --> InitializeResult((Инициализировать result = 1))
    InitializeResult --> WhileLoopStart((Начать цикл: пока number > 0))
    WhileLoopStart --> CalculateDigit((digit = number % 7))
    CalculateDigit --> MultiplyResult((result = result * (digit + 1)))
     MultiplyResult --> IntegerDivision((number = number // 7))   
     IntegerDivision --> WhileLoopStart
     WhileLoopStart -- Нет --> ReturnResult((Вернуть result))    
     ReturnOne --> EndCount((Конец count_not_divisible_by_7))
     ReturnResult --> EndCount
    end
    
    CallCountNotDivisible -- > StartCount
    
```

**Легенда:**
* **Начало, Конец:** Начало и конец основного алгоритма.
* **Инициализировать total_count:** Создаем переменную для хранения результата и присваиваем ей значение 0.
* **Начать цикл (row):** Определяет начало цикла перебора строк от 0 до 999,999,999.
* **Вызвать count_not_divisible_by_7(row):** Вызывает рекурсивную функцию для подсчета количества не делящихся на 7 чисел в текущей строке.
* **Прибавить результат к total_count:** Добавляет результат работы функции к общему счетчику.
* **Начало count_not_divisible_by_7:** Начало рекурсивной функции.
* **Проверить: number == 0?** Проверяет базовый случай рекурсии.
* **Вернуть 1:** Возвращает 1 в базовом случае.
* **Инициализировать result = 1:** Инициализирует переменную для подсчета не делящихся на 7.
* **Начать цикл: пока number > 0:** Цикл для разложения числа по семеричным разрядам.
* **digit = number % 7:** Вычисляет текущий семеричный разряд.
* **result = result * (digit + 1):** Обновляет результат умножением на (цифра + 1).
* **number = number // 7:** Переходит к следующему семеричному разряду.
* **Вернуть result:** Возвращает результат работы функции.
* **Конец count_not_divisible_by_7:** Конец рекурсивной функции.
