## <algorithm>

1. **התחלת המשחק**:
   - המשחק מתחיל בהצגת הודעת פתיחה לשחקן ושואל האם הוא מוכן לחשוב על חיה.
   - דוגמה: `"האם אתה מוכן לחשוב על חיה? (כן/לא)"`
   - אם התשובה היא "לא", המשחק מסתיים.

2. **שאילת שאלות**:
    - המחשב מתחיל בשאלה ראשונית (שורש) לדוגמה: `"האם החיה הזו שוחה?"`.
    - השחקן משיב "כן" או "לא".
    - **אם הנוכחי הוא שאלה**:
       - המחשב עובר לשאלה הבאה בהתאם לתשובת השחקן.
       - דוגמה: אם התשובה לשאלה "האם החיה הזו שוחה?" היא "כן", המחשב עשוי לעבור לשאלה "האם החיה הזו חיה במים?"
    - **אם הנוכחי הוא חיה**:
      - המחשב מנחש את החיה.
      - דוגמה: `"האם זו [שם חיה]? (כן/לא)"`
      - אם התשובה היא "כן", המחשב מנצח.
      - דוגמה: `"יש! ניחשתי!"`
      - אם התשובה היא "לא", המשחק עובר לשלב הוספת חיה חדשה.

3. **הוספת חיה חדשה**:
   - אם המחשב טעה בניחוש:
     - הוא שואל את השחקן איזו חיה הוא חשב עליה.
       - דוגמה: `"איזו חיה חשבת עליה?"`
     - השחקן מזין את שם החיה החדשה.
     - המחשב שואל איזו שאלה הייתה עוזרת להבחין בין החיה החדשה לחיה שחשב עליה קודם.
      - דוגמה: `"איזו שאלה הייתה עוזרת להבחין בין [חיה חדשה]?"`
     - השחקן מזין את השאלה החדשה.
     - המחשב מוסיף את השאלה והחיה החדשה לעץ הידע שלו.

4. **שמירת הנתונים**:
   - לאחר הוספת חיה חדשה או לפי בקשת השחקן, המחשב שומר את המידע.
   - דוגמה: `"מאגר הידע עודכן. תודה!"`

5. **משחק חדש**:
    - לאחר סיום סיבוב, המחשב מציע לשחקן לשחק שוב.
      - דוגמה: `"מוכן לחשוב על חיה חדשה? (כן/לא)"`
   
**זרימת נתונים:**

*   המשחק מתחיל בפונקציה ראשית שמתאמת את זרימת המשחק.
*   נתונים כמו תשובות השחקן (כן/לא) מועברים לפונקציות שמטפלות בהמשך השאלות והניחושים.
*   אם ניחוש המחשב שגוי, נתונים חדשים כמו שם החיה והשאלה החדשה מועברים לפונקציה לעדכון עץ הידע.
*   עץ הידע נשמר ונשלף בין סבבים.

## <mermaid>

```mermaid
flowchart TD
    Start --> StartGame[התחלת המשחק: <br>שאל אם מוכנים לחשוב על חיה];
    StartGame -- "לא" --> End[סוף המשחק];
    StartGame -- "כן" --> AskQuestion[שאל שאלה: <br>"האם החיה הזו שוחה?"];
    AskQuestion -- "כן" --> CheckNodeYes{בדוק צומת (שאלה/חיה)};
    AskQuestion -- "לא" --> CheckNodeNo{בדוק צומת (שאלה/חיה)};
     CheckNodeYes -- צומת שאלה --> NextQuestionYes[העבר לשאלה הבאה בהתאם ל"כן"];
    CheckNodeNo  -- צומת שאלה --> NextQuestionNo[העבר לשאלה הבאה בהתאם ל"לא"];
     NextQuestionYes --> AskQuestion;
    NextQuestionNo --> AskQuestion;
    CheckNodeYes -- צומת חיה --> GuessAnimalYes[נחש את החיה: <br>"האם זו [שם חיה]?"];
    CheckNodeNo  -- צומת חיה --> GuessAnimalNo[נחש את החיה: <br>"האם זו [שם חיה]?" ];

    GuessAnimalYes -- "כן" --> Win[ניצחון:<br> "יש! ניחשתי!"];
    GuessAnimalYes -- "לא" --> AddNewAnimal[הוסף חיה חדשה:<br> שאל איזו חיה חשבו, ואיך להבדיל אותה];
    GuessAnimalNo -- "כן" --> Win;
    GuessAnimalNo -- "לא" --> AddNewAnimal;
   
    Win --> PlayAgain[שאל אם לשחק שוב];
    AddNewAnimal --> UpdateKnowledge[עדכן את עץ הידע];
    UpdateKnowledge --> PlayAgain;
    PlayAgain -- "כן" --> StartGame;
    PlayAgain -- "לא" --> End;

    End --> Stop[סיום];
```

**הסבר תלויות:**

*   אין תלויות חיצוניות (כמו `import header` בדוגמה) בקוד הזה. התרשים מתאר את הזרימה הלוגית של משחק "נחש את החיה" בלבד.
*   כל השמות ב-`mermaid` בעלי משמעות:
    *   `Start`: תחילת המשחק.
    *   `StartGame`: שואל אם השחקן מוכן לחשוב על חיה.
    *  `AskQuestion`: שואל שאלה על החיה.
    *   `CheckNodeYes`, `CheckNodeNo`: בודק אם הצומת הנוכחי הוא שאלה או חיה, ופונה בהתאם לתשובה "כן" או "לא".
    *   `NextQuestionYes`, `NextQuestionNo`: מעביר לשאלה הבאה בהתאם לתשובה.
    *   `GuessAnimalYes`, `GuessAnimalNo`: מנחש את החיה.
    *   `Win`: הודעת ניצחון.
    *   `AddNewAnimal`: שלב הוספת חיה חדשה.
    *   `UpdateKnowledge`: עדכון עץ הידע.
    *   `PlayAgain`: שואל אם לשחק שוב.
    *   `End`: סוף המשחק.
    *   `Stop`: עצירה של התוכנית.

## <explanation>

**ייבואים (Imports):**
*   אין ייבוא פה, זה תאור של רעיון המשחק בלבד.

**מחלקות (Classes):**

*   אין מחלקות מוגדרות בקטע הקוד הזה. התאור הזה מציג את ההגיון של המשחק ולא קוד מפורש.

**פונקציות (Functions):**

*   ללא פונקציות מוגדרות.
   *   ניתן ליישם את המשחק הזה בפונקציות, כאשר כל שלב יהיה פונקציה. לדוגמה: `start_game()`, `ask_question()`, `guess_animal()`, `add_new_animal()`, `update_knowledge()`.

**משתנים (Variables):**

*   ללא משתנים מוגדרים.
   *   במימוש, אפשר להשתמש במשתנים כמו:
        *   `current_node` (מייצג את השאלה או החיה הנוכחית).
        *   `tree_knowledge` (מייצג את עץ הידע של המחשב).
        *   `player_answer` (מייצג את תשובת השחקן).
        *   `new_animal` (מייצג את שם החיה החדשה).
        *   `new_question` (מייצג את השאלה החדשה).

**הסברים מפורטים:**

*   **מטרת המשחק:** המשחק נועד לאפשר למחשב ללמוד לזהות חיות באמצעות שאלות, תוך כדי אינטראקציה עם השחקן.
*   **עקרון פעולה:** המחשב מתחיל עם שאלה ראשונית, ובהתאם לתשובת השחקן, הוא מתקדם לשאלה הבאה או מנסה לנחש את החיה. אם הוא טועה, הוא לומד חיה חדשה ושואל שאלה שתעזור לו להבדיל בינה לבין מה שהוא ניחש קודם.
*   **מבנה הנתונים:** עץ הידע הוא מבנה נתונים שבו כל צומת יכול להיות שאלה או חיה. השאלה היא צומת שמוביל לצומת הבא בהתאם לתשובה "כן" או "לא". החיה היא צומת סופי.
*  **דוגמה לזרימה:** השחקן חושב על חיה. המחשב שואל: "האם זו חיה שוחה?". השחקן עונה "כן". המחשב שואל "האם זו חיה שחיה במים?". אם השחקן עונה "לא", המחשב מגיע למסקנה שהוא טעה, השחקן מזין את החיה הנכונה, ושאלה שמבדילה אותה.

**בעיות אפשריות ותחומים לשיפור:**

*   **אימות קלט:** הקוד אינו כולל אימות קלט (למשל, לוודא שהשחקן משיב "כן" או "לא" בלבד).
*   **שמירה לדיסק:** הקוד אינו שומר את עץ הידע לדיסק, ולכן הוא יאבד בין הפעלות.
*   **טיפול במקרים מורכבים:** העץ עשוי לגדול יותר מדי, ולכן יש לטפל במקרה הזה.
*   **שימוש בממשק משתמש:**  המשחק מיוצג בטקסט פשוט. ניתן לשפר אותו על ידי הוספת ממשק משתמש גרפי.

**שרשרת קשרים עם חלקים אחרים בפרויקט:**

*   אין תלות ישירה בחלקים אחרים בפרויקט, אלא אם נרצה לשמור את עץ הידע בצורה קבועה, או להוסיף ממשק משתמש.
*   במקרה של שמירה, נצטרך להוסיף תלות בפונקציה שמאפשרת שמירת נתונים לקובץ (לדוגמה, שימוש בספריות כמו `json` או `pickle`).
*    במקרה של ממשק משתמש, נצטרך להתחבר לספרייה גרפית מתאימה (לדוגמה, tkinter, pygame, PyQt).