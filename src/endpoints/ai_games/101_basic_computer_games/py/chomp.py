"""
<CHOMP>:
=================
Сложность: 5
-----------------
CHOMP - это игра для двух игроков, в которой игроки по очереди "откусывают" от прямоугольной шоколадной плитки. Плитка представлена в виде сетки, а левый верхний угол считается "отравленным". 
Цель игры - вынудить противника откусить отравленный угол. Игроки ходят по очереди, выбирая любую из оставшихся ячеек. После выбора откусываются все ячейки справа и снизу от выбранной ячейки, включая саму выбранную. 
-----------------
Правила игры:
1. Игра начинается с прямоугольной шоколадной плитки, представленной сеткой.
2. Игроки по очереди выбирают ячейку на плитке.
3. После выбора ячейки, все ячейки справа и снизу от выбранной, включая саму выбранную, считаются "откушенными".
4. Проигрывает игрок, который вынужден откусить отравленный левый верхний угол.
-----------------
Алгоритм:
1. Установить размер шоколадной плитки (строки и столбцы).
2. Создать игровую доску, представляющую плитку, где 1 означает, что ячейка доступна, а 0 - откушена.
3. Игроки по очереди делают ход.
4. Игрок выбирает строку и столбец для откусывания.
5. Обновить игровую доску: все ячейки справа и снизу от выбранной становятся откушенными (значение 0).
6. Проверить, не откусил ли текущий игрок отравленный угол (ячейка 1,1). Если да, то он проиграл.
7. Повторить шаги 3-6, пока один из игроков не проиграет.
-----------------
Блок-схема: 
```mermaid
graph TD
    Start(Начало) --> InputSize(Ввод размера плитки: строк и столбцов);
    InputSize --> CreateBoard(Создать игровую доску);
    CreateBoard --> PlayerTurn(Ход игрока);
    PlayerTurn --> InputMove(Ввод хода: строка и столбец);
    InputMove --> UpdateBoard(Обновить игровую доску);
    UpdateBoard --> CheckWin(Проверить, не откусил ли игрок отравленный угол);
    CheckWin -- Да --> GameOver(Конец игры: игрок проиграл);
    CheckWin -- Нет --> NextPlayerTurn(Ход следующего игрока);
    NextPlayerTurn --> PlayerTurn;
    GameOver --> End(Конец);
```
"""
import os

def clear_screen():
    """Очищает экран консоли."""
    os.system('cls' if os.name == 'nt' else 'clear')

def create_board(rows, cols):
    """
    Создает игровую доску (шоколадную плитку).

    Аргументы:
    rows (int): Количество строк на доске.
    cols (int): Количество столбцов на доске.

    Возвращает:
    list of lists: Игровая доска, представленная матрицей, где 1 означает доступную ячейку, а 0 - откушенную.
    """
    board = [[1 for _ in range(cols)] for _ in range(rows)]
    return board

def print_board(board):
    """
    Выводит игровую доску на экран.

    Аргументы:
    board (list of lists): Игровая доска.
    """
    rows = len(board)
    cols = len(board[0])
    print("   ", end="")
    for col in range(cols):
      print(f"{col+1:2}",end=" ")
    print()
    print("   " + "---" * cols)

    for row in range(rows):
        print(f"{row+1:2}|", end="")
        for col in range(cols):
            if board[row][col] == 1:
                print(" O ", end="")  # O представляет доступную ячейку
            else:
                print(" X ", end="")  # X представляет откушенную ячейку
        print()

def get_move(player_number,rows,cols):
    """
    Запрашивает у игрока ход.

    Аргументы:
    player_number (int): Номер игрока.
    rows(int) : Количество строк
    cols(int) : Количество столбцов

    Возвращает:
    tuple: Кортеж с выбранными строкой и столбцом.
    """
    while True:
        try:
            row = int(input(f"Игрок {player_number}, введите строку (1-{rows}): ")) - 1
            col = int(input(f"Игрок {player_number}, введите столбец (1-{cols}): ")) - 1
            if 0 <= row < rows and 0 <= col < cols:
                return row, col
            else:
                print("Некорректный ввод. Пожалуйста, введите значения в пределах размера доски.")
        except ValueError:
            print("Некорректный ввод. Пожалуйста, введите целые числа.")

def update_board(board, row, col):
    """
    Обновляет игровую доску, откусывая выбранную ячейку и все ячейки справа и снизу от нее.

    Аргументы:
    board (list of lists): Игровая доска.
    row (int): Строка выбранной ячейки.
    col (int): Столбец выбранной ячейки.
    """
    rows = len(board)
    cols = len(board[0])
    for i in range(row, rows):
        for j in range(col, cols):
            board[i][j] = 0

def check_win(board):
    """
    Проверяет, не откусил ли текущий игрок отравленный угол.

    Аргументы:
    board (list of lists): Игровая доска.

    Возвращает:
    bool: True, если игрок проиграл, False - если нет.
    """
    return board[0][0] == 0

def play_chomp():
    """
    Основная функция игры CHOMP.
    """
    clear_screen()
    print("Игра CHOMP\n")
    while True:
        try:
            rows = int(input("Введите количество строк шоколадной плитки: "))
            cols = int(input("Введите количество столбцов шоколадной плитки: "))
            if rows > 0 and cols > 0:
                break
            else:
                print("Количество строк и столбцов должно быть больше нуля.")
        except ValueError:
            print("Некорректный ввод. Пожалуйста, введите целые числа.")


    board = create_board(rows, cols)
    current_player = 1  # Начинает игрок 1
    game_over = False
    while not game_over:
        clear_screen()
        print_board(board)
        row, col = get_move(current_player,rows,cols)
        update_board(board, row, col)
        if check_win(board):
            clear_screen()
            print_board(board)
            print(f"Игрок {current_player} проиграл!")
            game_over = True
        else:
            current_player = 3 - current_player  # Переключение на другого игрока

# Запуск игры
play_chomp()
"""
Пояснения:
1.  `clear_screen()`:
    -   Очищает экран консоли, делает игру более приятной для пользователя.
2.  `create_board(rows, cols)`:
    -   Создает игровую доску размером `rows` на `cols`.
    -   Изначально все ячейки заполнены 1, что означает, что они доступны для "откусывания".
3.  `print_board(board)`:
    -   Выводит текущее состояние игровой доски на экран.
    -   "O" - это доступные ячейки, "X" - откушенные.
4.  `get_move(player_number,rows,cols)`:
    -   Запрашивает у текущего игрока номер строки и столбца для хода.
    -   Проверяет корректность ввода (что числа находятся в пределах размера доски).
5.  `update_board(board, row, col)`:
    -   "Откусывает" выбранную ячейку и все ячейки справа и снизу от неё, устанавливая их значение в 0.
6.  `check_win(board)`:
    -   Проверяет, не откусил ли текущий игрок "отравленную" ячейку (левый верхний угол).
    -   Возвращает `True`, если игрок проиграл.
7.  `play_chomp()`:
    -   Основная функция игры.
    -   Запрашивает у пользователя размер доски.
    -   Создаёт доску, инициализирует текущего игрока и флаг окончания игры.
    -   В цикле:
        -   Очищает экран, выводит доску, запрашивает ход.
        -   Обновляет доску, проверяет, не проиграл ли игрок.
        -   Переключает текущего игрока.
    -   Завершает игру и сообщает имя проигравшего.

Переменные:
*   `rows`, `cols`: Количество строк и столбцов игровой доски.
*   `board`: Двумерный список, представляющий игровую доску.
*   `current_player`: Номер текущего игрока (1 или 2).
*   `game_over`: Булевая переменная, определяющая, закончена ли игра.
*   `row`, `col`: Номера строки и столбца, выбранные игроком для хода.
"""
__author__ = 'hypo69 (hypo69@davidka.net)'
```