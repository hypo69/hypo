## <algorithm>

1. **הגדרת מחלקת `Checkerboard`**:
   - מחלקה זו מייצגת את לוח המשחק ומנהלת את מצב המשחק.
   - **אתחול**:
     -  `__init__`: מקבלת לוח משחק ומאתחלת את מונה הכלים שהוסרו ל-0.
       - לדוגמה: `board = [[0 for _ in range(8)] for _ in range(8)]` יוצר לוח ריק.
     - `__post_init__`: מציבה 48 כלים בשורות החיצוניות (1 ו-8).
   - **בדיקת קפיצה חוקית**:
     - `is_valid_jump(start, end)`: בודקת האם קפיצה מנקודת התחלה לנקודת סיום היא חוקית.
       - דוגמה: `is_valid_jump((2, 2), (4, 4))` בודקת אם קפיצה מ-(2,2) ל-(4,4) חוקית.
       - בודקת אם נקודת הסיום בתוך הלוח, ריקה, שיש כלי לקפוץ מעליו, והקפיצה אלכסונית.
   - **ביצוע קפיצה**:
     - `perform_jump(start, end)`: מבצעת קפיצה חוקית.
       - דוגמה: `perform_jump((2, 2), (4, 4))` מעבירה כלי מ-(2,2) ל-(4,4), מסירה את הכלי באמצע ומוסיפה 1 למונה הכלים שהוסרו.
   - **חיפוש קפיצות אפשריות**:
      - `find_possible_jumps()`: מוצאת את כל הקפיצות האפשריות על הלוח.
        - עוברת על כל הלוח, ובודקת עבור כל כלי האם יש קפיצה חוקית בארבעת הכיוונים האלכסוניים.
        - מחזירה רשימה של קפיצות חוקיות.
   - **משחק**:
      - `play()`: מדמה את המשחק על ידי ביצוע קפיצות עד שאין יותר קפיצות אפשריות.
        - משתמשת בפונקציה `find_possible_jumps` כדי למצוא קפיצות חוקיות.
        - אם נמצאו קפיצות, מבצעת את הראשונה.
        - מסיימת כשהרשימה ריקה, ומדפיסה את מספר הכלים שהוסרו.
   - **הצגת הלוח**:
      - `display_board()`: מדפיסה את מצב הלוח הנוכחי.
        - מדפיסה '•' עבור כלי ו'.' עבור משבצת ריקה.
2. **תוכנית ראשית**:
   - מדפיסה "Initial Board:".
   - יוצרת לוח ריק ומאתחלת את המשחק.
   - מציגה את הלוח ההתחלתי.
   - מדפיסה "Playing the game...".
   - מריצה את המשחק.
   - מדפיסה "Final Board:".
   - מציגה את הלוח הסופי.

## <mermaid>

```mermaid
flowchart TD
    subgraph Checkerboard Class
        A[<code>__init__</code><br> אתחול לוח ומונה הסרה] --> B{אתחול כלי משחק <br> בשורות 1 ו-8}
        B --> C[<code>is_valid_jump</code><br> בדיקת תוקף קפיצה]
        C --> D[<code>perform_jump</code><br> ביצוע קפיצה והסרת כלי]
        D --> E[<code>find_possible_jumps</code><br> חיפוש קפיצות אפשריות]
        E --> F[<code>play</code><br> משחק עד שאין קפיצות]
        F --> G[<code>display_board</code><br> הדפסת הלוח]
    end
    
    subgraph Main Program
        H[יצירת לוח ריק] --> I[אתחול אובייקט  <code>Checkerboard</code>]
        I --> J[הדפסת הלוח ההתחלתי]
        J --> K[הדפסת הודעה "Playing the game..."]
        K --> L[הפעלת משחק <code>game.play()</code>]
         L-->M[הדפסת הודעה "Final Board"]
         M-->N[הדפסת הלוח הסופי]

    end
    
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    H --> I
    I --> J
    J --> K
    K --> L
    L-->M
    M-->N
    
    linkStyle 0,1,2,3,4,5,6,7,8,9,10,11,12,13 stroke:#000,stroke-width:2px

```

## <explanation>

**ייבואים (Imports)**:
- `from dataclasses import dataclass`: משמש ליצירת מחלקות נתונים עם פחות קוד boilerplate. המחלקה `Checkerboard` מוגדרת כמחלקת נתונים (dataclass), שמייצרת אוטומטית את הפונקציות `__init__`, `__repr__`, `__eq__` וכו׳.
- `from typing import List, Tuple`: משמש להגדרת טיפוסים, מסייע בהבנת הקוד ובאיתור שגיאות. `List` ו-`Tuple` משמשים לאחסון רשימות וזוגות של נתונים, בהתאמה.

**מחלקות (Classes)**:
- `Checkerboard`:
   - תפקיד: מייצגת את לוח המשחק ואת מצב המשחק.
   - מאפיינים:
      - `board`: רשימה דו-ממדית המייצגת את הלוח (0 = ריק, 1 = כלי).
      - `removed_checkers`: מונה את הכלים שהוסרו מהלוח.
   - שיטות:
      - `__init__(self, board: List[List[int]], removed_checkers: int = 0) -> None`: מאתחלת את לוח המשחק עם רשימת כלים, ומונה הכלים שהוסרו.
      - `__post_init__(self) -> None`: מציבה 48 כלים על הלוח בשורות 1 ו-8 לאחר האתחול.
      - `is_valid_jump(self, start: Tuple[int, int], end: Tuple[int, int]) -> bool`: בודקת אם קפיצה מנקודת ההתחלה לנקודת הסיום היא חוקית. מחזירה `True` אם הקפיצה חוקית, אחרת `False`.
      - `perform_jump(self, start: Tuple[int, int], end: Tuple[int, int]) -> None`: מבצעת קפיצה, מסירה את הכלי שקפצו מעליו ומעדכנת את מונה הכלים שהוסרו.
      - `find_possible_jumps(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]`: מחפשת את כל הקפיצות האפשריות על הלוח ומחזירה רשימה של הקפיצות הללו.
      - `play(self) -> None`: מדמה את המשחק על ידי ביצוע קפיצות עד שאין יותר קפיצות אפשריות. מדפיסה את מספר הכלים שהוסרו.
      - `display_board(self) -> None`: מדפיסה את מצב הלוח הנוכחי על המסך.

**פונקציות (Functions)**:
- הפונקציות נמצאות בתוך מחלקת `Checkerboard`, לכן ההסבר מופיע תחת "מחלקות".
- פונקציות לדוגמה:
  - `is_valid_jump` פרמטרים: `start` (tuple) מיקום התחלתי, `end` (tuple) מיקום סופי. מחזירה `bool` האם קפיצה חוקית.
  - `perform_jump` פרמטרים: `start` (tuple) מיקום התחלתי, `end` (tuple) מיקום סופי. לא מחזירה ערך.

**משתנים (Variables)**:
- `board`: רשימה דו-ממדית של int, מייצגת את לוח המשחק.
- `removed_checkers`: int, מונה את הכלים שהוסרו מהלוח.
- `start`, `end`: tuple, מיקום תחילת וסוף קפיצה.
- `jumps`: רשימה של tuple, רשימה של קפיצות אפשריות.
- `game`: אובייקט מסוג `Checkerboard`, מייצג את המשחק.
- `initial_board`: רשימה דו-ממדית של int, מייצגת לוח ריק.

**בעיות אפשריות ושיפורים**:
- **אופטימיזציה של ביצוע קפיצות**: הפונקציה `play()` מבצעת תמיד את הקפיצה הראשונה ברשימה. ניתן לשפר זאת על ידי בחירת הקפיצה המיטבית, לדוגמה, קפיצה שמובילה להסרה של מספר רב יותר של כלים.
- **GUI**: במקום טקסטואלי, ניתן להוסיף ממשק גרפי למשחק.
- **בדיקות נוספות**: ניתן להוסיף בדיקות יחידה לפונקציות השונות כדי להבטיח תקינות.

**קשרים עם חלקים אחרים בפרויקט**:
- הקוד עומד בפני עצמו, ואין לו קשר ישיר לחלקים אחרים בפרויקט, כפי שניתן לראות שאין שימוש בייבוא מתוך חבילת `src` או מתוך `header.py`. עם זאת, כחלק ממבנה הפרויקט, הוא מיועד להיות משולב עם רכיבי AI. לדוגמה, יכול להיות מיושם אלגוריתם AI שיכול לבצע מהלכים חכמים במשחק ולבחור את הקפיצה הטובה ביותר.