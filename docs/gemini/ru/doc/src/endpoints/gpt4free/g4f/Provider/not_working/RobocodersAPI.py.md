# Модуль `RobocodersAPI.py`

## Обзор

Модуль `RobocodersAPI.py` предназначен для взаимодействия с API Robocoders AI. Он предоставляет асинхронный интерфейс для обмена сообщениями с использованием различных агентов, таких как `GeneralCodingAgent`, `RepoAgent` и `FrontEndAgent`. Модуль поддерживает сохранение истории сообщений и использует кэширование для хранения токенов доступа и идентификаторов сессий, чтобы избежать повторной аутентификации.

## Подробней

Этот модуль является частью проекта `hypotez` и обеспечивает интеграцию с API Robocoders AI для генерации кода и выполнения других задач, связанных с AI-ассистентами для кодирования. Он использует библиотеку `aiohttp` для асинхронных HTTP-запросов и `BeautifulSoup` для парсинга HTML-страниц.

## Классы

### `RobocodersAPI`

**Описание**: Класс `RobocodersAPI` предоставляет интерфейс для взаимодействия с API Robocoders AI. Он позволяет отправлять запросы к API, получать ответы и обрабатывать их. Класс поддерживает асинхронную работу, что позволяет эффективно использовать ресурсы при взаимодействии с API.

**Принцип работы**:
1.  Инициализируется с использованием токена доступа и идентификатора сессии, которые получаются либо из кэша, либо через API.
2.  Использует `aiohttp` для отправки асинхронных POST-запросов к API.
3.  Обрабатывает ответы от API, извлекая сообщения и передавая их вызывающей стороне через асинхронный генератор.
4.  Поддерживает автоматическое продление сессии при достижении лимита ресурсов.
5.  Кэширует токен доступа и идентификатор сессии для повторного использования.

**Атрибуты**:
-   `label` (str): Метка для API Robocoders AI.
-   `url` (str): URL документации API Robocoders AI.
-   `api_endpoint` (str): URL конечной точки API для обмена сообщениями.
-   `working` (bool): Указывает, работает ли API (в данном случае `False`).
-   `supports_message_history` (bool): Указывает, поддерживает ли API историю сообщений (`True`).
-   `default_model` (str): Модель агента по умолчанию (`'GeneralCodingAgent'`).
-   `agent` (List[str]): Список доступных агентов.
-   `models` (List[str]): Список доступных моделей, дублирующий список агентов.
-   `CACHE_DIR` (Path): Путь к директории для хранения кэша.
-   `CACHE_FILE` (Path): Путь к файлу кэша.

**Методы**:

-   `create_async_generator`: Создает асинхронный генератор для взаимодействия с API Robocoders AI.
-   `_get_or_create_access_and_session`: Получает или создает токен доступа и идентификатор сессии.
-   `_fetch_and_cache_access_token`: Получает токен доступа и кэширует его.
-   `_create_and_cache_session`: Создает идентификатор сессии и кэширует его.
-   `_save_cached_data`: Сохраняет данные в кэш.
-   `_update_cached_data`: Обновляет данные в кэше.
-   `_clear_cached_data`: Очищает кэш.
-   `_get_cached_data`: Получает данные из кэша.

## Функции

### `create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        proxy: str = None,
        **kwargs
    ) -> AsyncResult:
```

**Назначение**: Создает асинхронный генератор для обмена сообщениями с API Robocoders AI.

**Параметры**:
-   `cls` (RobocodersAPI): Ссылка на класс `RobocodersAPI`.
-   `model` (str): Модель агента, используемая для генерации ответов.
-   `messages` (Messages): Список сообщений для отправки в API.
-   `proxy` (Optional[str], optional): Прокси-сервер для использования при подключении к API. По умолчанию `None`.
-   `**kwargs`: Дополнительные параметры.

**Возвращает**:
-   `AsyncResult`: Асинхронный генератор, который выдает сообщения от API.

**Вызывает исключения**:
-   `Exception`: Если не удалось инициализировать взаимодействие с API.

**Как работает функция**:

1.  Устанавливает таймаут для HTTP-запросов.
2.  Получает или создает токен доступа и идентификатор сессии, используя метод `_get_or_create_access_and_session`.
3.  Формирует заголовки запроса, включая токен доступа.
4.  Форматирует список сообщений в строку, используя функцию `format_prompt`.
5.  Формирует данные запроса, включая идентификатор сессии, строку запроса и модель агента.
6.  Отправляет POST-запрос к API, используя `aiohttp.ClientSession`.
7.  Обрабатывает ответ от API, извлекая сообщения и передавая их через генератор.
8.  Обрабатывает ошибки, такие как неавторизованный доступ, ошибки валидации и ошибки сервера.
9.  Поддерживает автоматическое продолжение диалога при достижении лимита ресурсов.

```
   Начало
     ↓
   Получение/создание токена и ID сессии (A)
     ↓
   Формирование заголовков и данных запроса (B)
     ↓
   Отправка POST-запроса к API (C)
     ↓
   Обработка ответа (D)
     ├─ Ошибка авторизации → Очистка кэша и повторная попытка
     ├─ Ошибка валидации → Выброс исключения
     ├─ Ошибка сервера → Выброс исключения
     └─ Успех → Извлечение сообщений и передача через генератор
     ↓
   Продолжение диалога при необходимости (E)
     ↓
   Конец
```

**Примеры**:

```python
async for message in RobocodersAPI.create_async_generator(model='GeneralCodingAgent', messages=[{'role': 'user', 'content': 'Напиши функцию на Python, которая вычисляет факториал числа.'}]):
    print(message)
```

### `_get_or_create_access_and_session`

```python
    @staticmethod
    async def _get_or_create_access_and_session(session: aiohttp.ClientSession):
```

**Назначение**: Получает существующий токен доступа и идентификатор сессии из кэша или создает новые, если они не найдены или недействительны.

**Параметры**:
-   `session` (aiohttp.ClientSession): Асинхронная HTTP-сессия для выполнения запросов.

**Возвращает**:
-   `Tuple[str, str]`: Кортеж, содержащий токен доступа и идентификатор сессии.

**Как работает функция**:

1.  Проверяет наличие кэшированных данных в файле `RobocodersAPI.CACHE_FILE`.
2.  Если данные существуют, пытается загрузить токен доступа и идентификатор сессии из кэша.
3.  Если токен доступа и идентификатор сессии найдены в кэше, возвращает их.
4.  Если токен доступа или идентификатор сессии отсутствуют в кэше или кэш не существует, создает новые, вызывая `_fetch_and_cache_access_token` и `_create_and_cache_session`.
5.  Возвращает новые токен доступа и идентификатор сессии.

```
Начало
     ↓
Проверка наличия кэшированных данных (A)
     ├─ Данные существуют → Загрузка токена и ID сессии из кэша (B)
     │   ├─ Токен и ID существуют → Возврат токена и ID
     │   └─ Токен или ID отсутствуют → Создание новых токена и ID (C, D)
     └─ Данные отсутствуют → Создание новых токена и ID (C, D)
     ↓
Создание нового токена доступа (C)
     ↓
Создание нового ID сессии (D)
     ↓
Возврат токена и ID
     ↓
Конец
```

### `_fetch_and_cache_access_token`

```python
    @staticmethod
    async def _fetch_and_cache_access_token(session: aiohttp.ClientSession) -> str:
```

**Назначение**: Получает токен доступа с использованием `BeautifulSoup` для парсинга HTML-страницы и кэширует его.

**Параметры**:
-   `session` (aiohttp.ClientSession): Асинхронная HTTP-сессия для выполнения запросов.

**Возвращает**:
-   `str`: Токен доступа.

**Вызывает исключения**:
-   `MissingRequirementsError`: Если библиотека `beautifulsoup4` не установлена.

**Как работает функция**:

1.  Проверяет, установлена ли библиотека `beautifulsoup4`. Если нет, вызывает исключение `MissingRequirementsError`.
2.  Выполняет GET-запрос к URL аутентификации (`url_auth`).
3.  Извлекает HTML-контент из ответа.
4.  Использует `BeautifulSoup` для парсинга HTML и поиска элемента `<pre>` с `id='token'`.
5.  Извлекает текст из найденного элемента, который представляет собой токен.
6.  Кэширует токен с помощью метода `_save_cached_data`.
7.  Возвращает полученный токен.

```
Начало
     ↓
Проверка наличия BeautifulSoup (A)
     ├─ BeautifulSoup отсутствует → Выброс MissingRequirementsError
     ↓
Выполнение GET-запроса к URL аутентификации (B)
     ↓
Парсинг HTML и поиск элемента с токеном (C)
     ↓
Извлечение токена (D)
     ↓
Кэширование токена (E)
     ↓
Возврат токена
     ↓
Конец
```

### `_create_and_cache_session`

```python
    @staticmethod
    async def _create_and_cache_session(session: aiohttp.ClientSession, access_token: str) -> str:
```

**Назначение**: Создает идентификатор сессии, используя токен доступа, и кэширует его.

**Параметры**:
-   `session` (aiohttp.ClientSession): Асинхронная HTTP-сессия для выполнения запросов.
-   `access_token` (str): Токен доступа, используемый для создания сессии.

**Возвращает**:
-   `str`: Идентификатор сессии.

**Вызывает исключения**:
-   `Exception`: Если токен недействителен или произошла ошибка валидации.

**Как работает функция**:

1.  Выполняет GET-запрос к URL создания сессии (`url_create_session`), передавая токен доступа в заголовке.
2.  Извлекает JSON-данные из ответа.
3.  Извлекает идентификатор сессии (`sid`) из JSON-данных.
4.  Кэширует идентификатор сессии с помощью метода `_update_cached_data`.
5.  Возвращает полученный идентификатор сессии.
6.  Обрабатывает ошибки, такие как неавторизованный доступ и ошибки валидации.

```
Начало
     ↓
Выполнение GET-запроса к URL создания сессии (A)
     ↓
Извлечение ID сессии из JSON-ответа (B)
     ↓
Кэширование ID сессии (C)
     ↓
Возврат ID сессии
     ↓
Конец
```

### `_save_cached_data`

```python
    @staticmethod
    def _save_cached_data(new_data: dict):
```

**Назначение**: Сохраняет новые данные в кэш-файл.

**Параметры**:
-   `new_data` (dict): Словарь с данными для сохранения в кэш.

**Как работает функция**:

1.  Создает директорию для кэша, если она не существует.
2.  Создает файл кэша, если он не существует.
3.  Сохраняет данные в кэш-файл в формате JSON.

### `_update_cached_data`

```python
    @staticmethod
    def _update_cached_data(updated_data: dict):
```

**Назначение**: Обновляет существующие данные в кэш-файле новыми значениями.

**Параметры**:
-   `updated_data` (dict): Словарь с данными для обновления в кэше.

**Как работает функция**:

1.  Пытается загрузить существующие данные из кэш-файла.
2.  Если кэш-файл поврежден, начинает с пустого словаря.
3.  Обновляет существующие данные новыми значениями.
4.  Сохраняет обновленные данные в кэш-файл в формате JSON.

### `_clear_cached_data`

```python
    @staticmethod
    def _clear_cached_data():
```

**Назначение**: Удаляет кэш-файл.

**Как работает функция**:

1.  Проверяет, существует ли кэш-файл.
2.  Если файл существует, пытается его удалить.
3.  Логирует любые ошибки, возникающие при удалении файла.

### `_get_cached_data`

```python
    @staticmethod
    def _get_cached_data() -> dict:
```

**Назначение**: Получает все кэшированные данные.

**Возвращает**:
-   `dict`: Словарь с кэшированными данными.

**Как работает функция**:

1.  Проверяет, существует ли кэш-файл.
2.  Если файл существует, пытается загрузить данные из него.
3.  Если кэш-файл поврежден, возвращает пустой словарь.
4.  Если файл не существует, возвращает пустой словарь.