# Модуль AuxiliaryClasses.py

## Обзор

Модуль `AuxiliaryClasses.py` содержит вспомогательные классы `keyboards` и `PromptsCompressor`, используемые для создания клавиатур для Telegram-бота и обработки текстовых подсказок. Класс `keyboards` отвечает за создание различных типов клавиатур, а класс `PromptsCompressor` используется для формирования текстовых подсказок на основе заданных параметров и вставки HTML-тегов в текст.

## Подробней

Этот модуль предоставляет удобные инструменты для динамического создания клавиатур и обработки текстовых подсказок, что упрощает разработку интерактивных ботов для Telegram.
Расположение файла в структуре проекта указывает на то, что он содержит базовые настройки и вспомогательные классы, необходимые для функционирования Telegram-бота.

## Классы

### `keyboards`

**Описание**: Класс `keyboards` предназначен для создания различных типов клавиатур, используемых в Telegram-боте.

**Принцип работы**:
Класс содержит методы для создания как встроенных клавиатур (`InlineKeyboardMarkup`), так и обычных клавиатур (`ReplyKeyboardMarkup`). Встроенные клавиатуры обычно используются для выполнения действий по нажатию кнопок, а обычные клавиатуры - для предоставления пользователю набора вариантов ответа.

**Методы**:

- `_keyboard_two_blank(self, data: list[str], name: list[str]) -> types.InlineKeyboardMarkup`: Создает встроенную клавиатуру с двумя столбцами.
- `_reply_keyboard(self, name: list[str])`: Создает обычную клавиатуру с кнопками.

#### `_keyboard_two_blank`

```python
def _keyboard_two_blank(self, data: list[str], name: list[str]) -> types.InlineKeyboardMarkup:
    """Создает встроенную клавиатуру с двумя столбцами.

    Args:
        data (list[str]): Список данных, которые будут переданы при нажатии на кнопку.
        name (list[str]): Список названий кнопок.

    Returns:
        types.InlineKeyboardMarkup: Объект встроенной клавиатуры.
    """
```

**Назначение**:
Функция создает встроенную клавиатуру (`InlineKeyboardMarkup`) для Telegram-бота, располагая кнопки в два столбца. Каждая кнопка связана с определенными данными обратного вызова.

**Параметры**:
- `data` (list[str]): Список строк, представляющих данные, которые будут переданы обратно боту при нажатии соответствующей кнопки.
- `name` (list[str]): Список строк, представляющих текст, отображаемый на кнопках клавиатуры.

**Возвращает**:
- `types.InlineKeyboardMarkup`: Объект встроенной клавиатуры, готовый для отправки пользователю.

**Как работает функция**:

1.  Инициализация клавиатуры: Создается объект `types.InlineKeyboardMarkup`.
2.  Создание кнопок: Для каждого элемента в списках `data` и `name` создается кнопка типа `types.InlineKeyboardButton`, где текст кнопки берется из списка `name`, а данные обратного вызова - из списка `data`.
3.  Формирование рядов кнопок: Если количество кнопок четное, они добавляются на клавиатуру попарно, формируя ряды из двух кнопок. Если количество кнопок нечетное, все кнопки, кроме последней, добавляются попарно, а последняя кнопка добавляется в отдельном ряду.
4.  Возврат клавиатуры: Сформированная клавиатура возвращается.

**ASCII flowchart**:

```
Начало
    ↓
Создание клавиатуры (keyboard)
    ↓
Создание списка кнопок (buttons)
    ↓
Проверка на четность количества кнопок
    ├── Четное ── Добавление кнопок попарно
    │   ↓
    └── Нечетное ── Добавление кнопок попарно, затем добавление последней кнопки отдельно
    ↓
Возврат клавиатуры (keyboard)
    ↓
Конец
```

**Примеры**:

```python
from telebot import types

# Пример данных и названий кнопок
data = ['data1', 'data2', 'data3']
name = ['Кнопка 1', 'Кнопка 2', 'Кнопка 3']

# Создание объекта класса keyboards
keyboard_creator = keyboards()

# Создание клавиатуры
keyboard = keyboard_creator._keyboard_two_blank(data, name)

# Вывод для примера (в реальном коде клавиатура отправляется пользователю)
print(keyboard)
```

#### `_reply_keyboard`

```python
def _reply_keyboard(self, name: list[str]):
    """Создает обычную клавиатуру с кнопками.

    Args:
        name (list[str]): Список названий кнопок.

    Returns:
        markup: Объект обычной клавиатуры.
    """
```

**Назначение**:
Функция создает обычную клавиатуру (`ReplyKeyboardMarkup`) для Telegram-бота. Обычная клавиатура отображается в нижней части экрана и позволяет пользователю выбирать один из предложенных вариантов ответа.

**Параметры**:
- `name` (list[str]): Список строк, представляющих текст, отображаемый на кнопках клавиатуры.

**Возвращает**:
- `markup`: Объект обычной клавиатуры, готовый для отправки пользователю.

**Как работает функция**:

1.  Инициализация клавиатуры: Создается объект `types.ReplyKeyboardMarkup` с параметром `resize_keyboard=True`, что позволяет автоматически изменять размер клавиатуры в зависимости от количества кнопок.
2.  Создание кнопок: Для каждого элемента в списке `name` создается кнопка типа `types.KeyboardButton`, где текст кнопки берется из списка `name`.
3.  Добавление кнопок на клавиатуру: Каждая созданная кнопка добавляется на клавиатуру.
4.  Возврат клавиатуры: Сформированная клавиатура возвращается.

**ASCII flowchart**:

```
Начало
    ↓
Создание клавиатуры (markup)
    ↓
Создание списка кнопок (buttons)
    ↓
Добавление кнопок на клавиатуру
    ↓
Возврат клавиатуры (markup)
    ↓
Конец
```

**Примеры**:

```python
from telebot import types

# Пример названий кнопок
name = ['Кнопка 1', 'Кнопка 2', 'Кнопка 3']

# Создание объекта класса keyboards
keyboard_creator = keyboards()

# Создание клавиатуры
keyboard = keyboard_creator._reply_keyboard(name)

# Вывод для примера (в реальном коде клавиатура отправляется пользователю)
print(keyboard)
```

### `PromptsCompressor`

**Описание**: Класс `PromptsCompressor` предназначен для сжатия и обработки текстовых подсказок (prompts) для Telegram-бота.

**Принцип работы**:
Класс позволяет формировать текстовые подсказки на основе заданных параметров, заменяя placeholders в шаблонах подсказок на конкретные значения. Также класс включает функциональность для вставки HTML-тегов в текст подсказки, что позволяет форматировать текст.

**Методы**:

- `__init__(self)`: Инициализирует класс, определяя размеры команд.
- `get_prompt(self, info: list[str], ind: int) -> str`: Получает текстовую подсказку на основе переданной информации и индекса.
- `html_tags_insert(response: str) -> str`: Вставляет HTML-теги в текст ответа.

#### `__init__`

```python
def __init__(self):
    """Инициализирует класс, определяя размеры команд."""
```

**Назначение**:
Конструктор класса `PromptsCompressor`. Инициализирует атрибут `commands_size`, который представляет собой список списков, определяющих ожидаемые размеры входных данных для различных типов команд.

**Как работает функция**:

1. Инициализация `commands_size`: Атрибуту `self.commands_size` присваивается список списков. Каждый внутренний список определяет порядок и количество параметров, ожидаемых для определенного типа команды.

**Примеры**:

```python
# Создание объекта класса PromptsCompressor
compressor = PromptsCompressor()

# Вывод для примера (в реальном коде это используется внутри класса)
print(compressor.commands_size)
```

#### `get_prompt`

```python
def get_prompt(self, info: list[str], ind: int) -> str:
    """Получает текстовую подсказку на основе переданной информации и индекса.

    Args:
        info (list[str]): Список информации для заполнения шаблона подсказки.
        ind (int): Индекс команды.

    Returns:
        str: Сформированная текстовая подсказка.
    """
```

**Назначение**:
Функция извлекает и формирует текстовую подсказку (prompt) на основе предоставленной информации и индекса команды.

**Параметры**:
- `info` (list[str]): Список строк, содержащих информацию для заполнения шаблона подсказки.
- `ind` (int): Индекс, указывающий, какой шаблон подсказки следует использовать.

**Возвращает**:
- `str`: Сформированная текстовая подсказка, где placeholders заменены на предоставленные данные.

**Как работает функция**:

1.  Чтение шаблона подсказки: Функция открывает JSON-файл `ToolBox/BaseSettings/prompts.json`, загружает его содержимое и извлекает шаблон подсказки по указанному индексу `ind`.
2.  Замена placeholders: Функция итерируется по списку ожидаемых параметров для данной команды (определяется через `self.commands_size[ind]`) и заменяет соответствующие placeholders в шаблоне подсказки на значения из списка `info`. Placeholders имеют формат `[PARAM_NAME]`.
3.  Возврат сформированной подсказки: Функция возвращает сформированную текстовую подсказку.

**ASCII flowchart**:

```
Начало
    ↓
Чтение шаблона подсказки из JSON-файла
    ↓
Итерация по списку параметров
    ↓
Замена placeholders в шаблоне на значения из списка info
    ↓
Возврат сформированной подсказки
    ↓
Конец
```

**Примеры**:

```python
# Пример данных и индекса команды
info = ['Интересная тема', 'Для широкой аудитории', 'Позитивный', 'Краткий', 'Дополнительная информация']
ind = 6  # Индекс команды

# Создание объекта класса PromptsCompressor
compressor = PromptsCompressor()

# Получение подсказки
prompt = compressor.get_prompt(info, ind)

# Вывод для примера
print(prompt)
```

#### `html_tags_insert`

```python
@staticmethod
def html_tags_insert(response: str) -> str:
    """Вставляет HTML-теги в текст ответа.

    Args:
        response (str): Текст ответа, в который нужно вставить HTML-теги.

    Returns:
        str: Текст с вставленными HTML-тегами.
    """
```

**Назначение**:
Статический метод, который вставляет HTML-теги в текст ответа на основе заданных регулярных выражений.

**Параметры**:
- `response` (str): Строка, в которой нужно заменить определенные шаблоны текста на HTML-теги.

**Возвращает**:
- `str`: Строка, в которой шаблоны заменены на соответствующие HTML-теги.

**Как работает функция**:

1.  Определение шаблонов: Задается список кортежей, где каждый кортеж содержит регулярное выражение для поиска шаблона и строку замены, содержащую HTML-теги.
2.  Замена шаблонов: Функция итерируется по списку шаблонов и использует `re.sub` для замены каждого найденного шаблона на соответствующий HTML-тег. Флаг `re.DOTALL` позволяет регулярному выражению соответствовать переносам строк.
3.  Возврат измененного текста: Функция возвращает измененный текст с вставленными HTML-тегами.

**ASCII flowchart**:

```
Начало
    ↓
Определение списка шаблонов и HTML-тегов для замены
    ↓
Итерация по списку шаблонов
    ↓
Замена шаблонов на HTML-теги с использованием re.sub
    ↓
Возврат измененного текста
    ↓
Конец
```

**Примеры**:

```python
# Пример текста для обработки
text = "#### Заголовок 4 уровня\n### Заголовок 3 уровня\n**Полужирный текст**\n*Курсив*"

# Вставка HTML-тегов
html_text = PromptsCompressor.html_tags_insert(text)

# Вывод для примера
print(html_text)
```