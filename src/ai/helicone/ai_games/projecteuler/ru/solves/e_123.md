## Ответ на Задачу No 123: Наименьшее значение n для остатка > 10^10

### 1. Анализ задачи и решение
**Понимание задачи:**
* Нам нужно найти наименьшее натуральное число *n*, для которого остаток от деления (*p<sub>n</sub>*-1)<sup>*n*</sup> + (*p<sub>n</sub>*+1)<sup>*n*</sup> на *p<sub>n</sub>*<sup>2</sup>  превышает 10<sup>10</sup>.
*  *p<sub>n</sub>* обозначает *n*-е простое число.
*  Задача сводится к последовательному вычислению остатков для разных *n* и сравнению их с 10<sup>10</sup>.
* Нужно написать функцию для проверки, является ли число простым, и функцию для генерации простых чисел.

**Решение:**

1. **Функция `is_prime(num)`:**  Проверяет, является ли число простым.
2. **Функция `generate_primes()`:** Генерирует последовательность простых чисел. Используем ленивую генерацию для экономии памяти.
3. **Основной цикл:**
    * Получаем очередное простое число *p<sub>n</sub>*.
    * Вычисляем остаток от деления (*p<sub>n</sub>*-1)<sup>*n*</sup> + (*p<sub>n</sub>*+1)<sup>*n*</sup> на *p<sub>n</sub>*<sup>2</sup>.
    * Сравниваем остаток с 10<sup>10</sup>. Если остаток больше, то возвращаем текущее значение *n*.
    * Иначе, переходим к следующему *n*.

### 2. Алгоритм решения
1. Начать
2. Инициализировать `n` = 1
3. Создать генератор простых чисел `primes`
4. Цикл:
    * Получить *p<sub>n</sub>* из `primes`
    * Вычислить остаток `remainder` =  ((*p<sub>n</sub>*-1)<sup>*n*</sup> + (*p<sub>n</sub>*+1)<sup>*n*</sup>) % *p<sub>n</sub>*<sup>2</sup>
    * Если `remainder` > 10<sup>10</sup>:
        * Вернуть `n`
    * Увеличить `n` на 1
5. Конец

### 3. Реализация на Python 3.12
```python
def is_prime(num):
    """Проверяет, является ли число простым."""
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_primes():
    """Генерирует последовательность простых чисел."""
    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1

def find_smallest_n():
    """Находит наименьшее n для которого остаток превышает 10^10."""
    n = 1
    primes = generate_primes()
    for prime in primes:
        if n == 1:
          p_n = prime
        else:
          p_n = prime
        remainder = ((p_n - 1)**n + (p_n + 1)**n) % (p_n**2)
        if remainder > 10**10:
            return n
        n += 1

# Пример использования:
result = find_smallest_n()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeN((Инициализировать n = 1))
    InitializeN --> CreatePrimeGenerator((Создать генератор простых чисел))
    CreatePrimeGenerator --> LoopStart((Начать цикл))
    LoopStart --> GetPrime((Получить p_n из генератора))
    GetPrime --> CalculateRemainder((Вычислить остаток: ((p_n-1)^n + (p_n+1)^n) % p_n^2))
    CalculateRemainder --> CheckRemainder((Проверить: остаток > 10^10?))
    CheckRemainder -- Да --> ReturnN((Вернуть n))
    CheckRemainder -- Нет --> IncrementN((Увеличить n на 1))
    IncrementN --> LoopStart
     ReturnN --> End((Конец))
```
**Legenda:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать n = 1:** Присваиваем начальное значение 1 переменной `n`.
* **Создать генератор простых чисел:** Создаем генератор, который будет поочередно выдавать простые числа.
* **Начать цикл:** Начало бесконечного цикла, в котором перебираются n и соответствующие простые числа.
* **Получить p_n из генератора:** Получаем следующее простое число из генератора.
* **Вычислить остаток:** Вычисляем остаток от деления выражения (*p<sub>n</sub>*-1)<sup>*n*</sup> + (*p<sub>n</sub>*+1)<sup>*n*</sup> на *p<sub>n</sub>*<sup>2</sup>.
* **Проверить: остаток > 10^10?** Проверяем, больше ли вычисленный остаток, чем 10<sup>10</sup>.
* **Вернуть n:** Если условие выполнено, то возвращаем текущее значение `n`.
* **Увеличить n на 1:**  Увеличиваем значение n на 1 для следующей итерации.
