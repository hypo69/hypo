# Анализ кода модуля `gomoko.py`

**Качество кода**
10
- Плюсы
    - Код хорошо структурирован и логически разделен на функции.
    - Реализация игры "Гомоку" соответствует описанию и правилам.
    - Присутствуют комментарии, объясняющие основные блоки кода.
    - Используются функции для вывода доски, проверки победителя и ничьей.
    - Есть проверка допустимости хода игрока.
- Минусы
    - Отсутствует reStructuredText (RST) для комментариев и docstring.
    - Не используется `j_loads` или `j_loads_ns` для чтения файлов (в данном коде нет чтения файлов).
    - Не используется логирование ошибок через `src.logger.logger`.
    - Использование `try-except` не всегда оправдано, можно использовать `logger.error`.

**Рекомендации по улучшению**

1.  **Формат документации**:
    -   Переписать все комментарии и docstring в формате reStructuredText (RST).
    -   Добавить документацию к каждой функции, методу и классу.

2.  **Обработка данных**:
    -   В данном коде нет чтения файлов, поэтому этот пункт пропускается.

3.  **Импорты**:
    -   Добавить импорт `from src.logger.logger import logger` для логирования.

4.  **Логирование ошибок**:
    -   Использовать `logger.error` вместо стандартных блоков `try-except` для обработки ошибок при вводе данных.

5.  **Общий рефакторинг**:
    -   Переименовать переменные для большей ясности (например, `game_on` -> `is_game_active`).
    -   Улучшить читаемость кода, добавив пустые строки между логическими блоками.

**Оптимизированный код**

```python
"""
Модуль для игры в Гомоку (пять в ряд)
=========================================================================================

Этот модуль реализует игру Гомоку (пять в ряд) для двух игроков, где один игрок
ходит против компьютера. Игровое поле представляет собой матрицу 15x15.

Правила игры:
1. Игра проходит на доске 15x15.
2. Игроки ходят по очереди, ставя свои фишки ('X' для первого игрока, 'O' для второго).
3. Цель игры - первым выстроить непрерывную линию из пяти своих фишек по вертикали, горизонтали или диагонали.
4. Игра заканчивается победой одного из игроков или ничьей, если доска полностью заполнена и никто не построил линию из пяти.
5. Игроки вводят свои ходы в виде координат x и y.

Пример использования
--------------------

.. code-block:: python

    python gomoko.py

"""
__author__ = 'hypo69 (hypo69@davidka.net)'

import random
from src.logger.logger import logger # Импорт logger для логирования

# 1. Инициализация:
# 1.1. Создание пустой доски 15x15
board = [[' ' for _ in range(15)] for _ in range(15)]
# 1.2. Установка флага начала игры
is_game_active = True
# 1.3. Установка флага игрока, P = 1 (игрок 1 ходит первым)
current_player = 1


def print_board(board: list[list[str]]) -> None:
    """
    Выводит текущее состояние игрового поля в консоль.

    :param board: Двумерный список, представляющий игровое поле.
    """
    print("   ", end="")
    for i in range(15):
        print(f"{i:2}", end=" ")
    print()
    print("  " + "----" * 15)
    for i, row in enumerate(board):
        print(f"{i:2}|", end=" ")
        for cell in row:
            print(f"{cell:2}", end=" ")
        print()
    print()


def check_winner(board: list[list[str]], player: int) -> bool:
    """
    Проверяет наличие победной линии на игровом поле для заданного игрока.

    :param board: Двумерный список, представляющий игровое поле.
    :param player: Номер игрока (1 или 2).
    :return: True, если есть победитель, иначе False.
    """
    symbol = 'X' if player == 1 else 'O'
    # Проверка горизонтальных линий
    for row in board:
        for i in range(len(row) - 4):
            if row[i] == row[i + 1] == row[i + 2] == row[i + 3] == row[i + 4] == symbol:
                return True
    # Проверка вертикальных линий
    for col in range(15):
        for i in range(15 - 4):
            if board[i][col] == board[i + 1][col] == board[i + 2][col] == board[i + 3][col] == board[i + 4][col] == symbol:
                return True
    # Проверка диагоналей (сверху-слева направо-вниз)
    for row in range(15 - 4):
        for col in range(15 - 4):
            if board[row][col] == board[row + 1][col + 1] == board[row + 2][col + 2] == board[row + 3][col + 3] == board[row + 4][col + 4] == symbol:
                return True
    # Проверка диагоналей (сверху-справа налево-вниз)
    for row in range(15 - 4):
        for col in range(4, 15):
            if board[row][col] == board[row + 1][col - 1] == board[row + 2][col - 2] == board[row + 3][col - 3] == board[row + 4][col - 4] == symbol:
                return True
    return False


def check_full_board(board: list[list[str]]) -> bool:
    """
    Проверяет, заполнено ли игровое поле.

    :param board: Двумерный список, представляющий игровое поле.
    :return: True, если поле заполнено, иначе False.
    """
    for row in board:
        for cell in row:
            if cell == ' ':
                return False  # Если есть хотя бы одна свободная ячейка, то игра не окончена
    return True  # Если нет пустых ячеек - ничья


# 2. Основной игровой цикл
while is_game_active:
    # 2.1. Выводим текущее состояние доски
    print_board(board)

    # 2.2. Ход игрока (P = 1)
    if current_player == 1:
        while True:
            try:
                # 2.2.1. Запрашиваем координаты хода X, Y
                x = int(input("Игрок 1 (X) введите x (0-14): "))
                y = int(input("Игрок 1 (X) введите y (0-14): "))

                # 2.2.2. Проверяем допустимость хода:
                if 0 <= x < 15 and 0 <= y < 15 and board[x][y] == ' ':
                    # 2.2.3. Ставим на доску символ хода текущего игрока (X)
                    board[x][y] = 'X'
                    break
                else:
                    print("Недопустимый ход. Попробуйте еще раз.")
            except ValueError as e:
                logger.error("Некорректный ввод. Пожалуйста, введите целые числа", exc_info=e)  # Логирование ошибки
                print("Некорректный ввод. Пожалуйста, введите целые числа")
        # 2.2.4. Меняем флаг игрока
        current_player = 2
    # 2.3. Ход компьютера (P = 2)
    else:
        print("Ход компьютера:")
        while True:
            # 2.3.1. Компьютер выбирает случайный ход
            x = random.randint(0, 14)
            y = random.randint(0, 14)
            if board[x][y] == ' ':
                # 2.3.2. Ставим на доску символ хода текущего игрока (O)
                board[x][y] = 'O'
                break

        # 2.3.3. Меняем флаг игрока
        current_player = 1

    # 2.4. Проверка на победителя или ничью
    if check_winner(board, 1 if current_player == 2 else 2):
        print_board(board)
        print(f"Победил игрок {'1 (X)' if current_player == 2 else '2 (O)'}!")
        is_game_active = False  # Завершаем игру
    elif check_full_board(board):
        print_board(board)
        print("Ничья!")
        is_game_active = False  # Завершаем игру

"""
Объяснение кода:
1.  **Инициализация**:
    -   `board = [[' ' for _ in range(15)] for _ in range(15)]`: Создает игровое поле 15x15, заполненное пробелами (пустые ячейки).
    -   `is_game_active = True`: Устанавливает флаг, сигнализирующий, что игра продолжается.
    -   `current_player = 1`: Устанавливает текущего игрока на первого (игрок 1).

2.  **Функция `print_board(board)`**:
    -   Выводит текущее состояние игрового поля в консоль. Нумерация строк и столбцов для удобства.

3.  **Функция `check_winner(board, player)`**:
    -   Проверяет, есть ли победитель.
    -   Символ текущего игрока ('X' для игрока 1, 'O' для игрока 2).
    -   Проверяет горизонтальные, вертикальные и обе диагональные линии на наличие пяти подряд идущих символов.
    -   Возвращает `True`, если победитель найден, иначе `False`.

4.  **Функция `check_full_board(board)`**:
    -   Проверяет, заполнено ли игровое поле.
    -   Возвращает `True`, если нет пустых клеток, иначе `False`.

5.  **Основной цикл игры `while is_game_active:`**:
    -   Продолжается, пока `is_game_active` равно `True`.
    -   Выводит текущую доску.
    -   **Ход игрока**:
        -   Если `current_player` равен 1, то это ход первого игрока.
        -   Запрашивает ввод координат x и y.
        -   Проверяет, что координаты в допустимых пределах и ячейка пуста. Если нет, повторяет запрос.
        -   Устанавливает символ 'X' в выбранную ячейку.
        -   Переключает текущего игрока на второго (`current_player = 2`).
    -   **Ход компьютера**:
        -   Если `current_player` равен 2, то это ход компьютера.
        -   Компьютер выбирает случайные координаты x и y.
        -   Проверяет, что ячейка не занята.
        -   Устанавливает символ 'O' в выбранную ячейку.
        -   Переключает текущего игрока на первого (`current_player = 1`).
    -   **Проверка на победу или ничью**:
        -   Вызывает `check_winner()` для проверки наличия победителя, и если он есть выводит на консоль сообщение о победе, и устанавливает `is_game_active` в `False`.
        -   Вызывает `check_full_board()` для проверки, заполнено ли поле. Если поле заполнено, то выводит сообщение о ничьей и завершает игру.

"""
```