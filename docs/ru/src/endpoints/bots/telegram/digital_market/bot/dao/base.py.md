# Модуль `base.py`

## Обзор

Модуль `base.py` предоставляет базовый класс `BaseDAO` для взаимодействия с базой данных с использованием SQLAlchemy. 
Он содержит набор методов для выполнения стандартных операций CRUD (создание, чтение, обновление, удаление) и других полезных операций, таких как пагинация, подсчет количества записей и массовое обновление.

## Подробнее

Этот модуль предназначен для упрощения работы с базой данных в контексте проекта `hypotez`. Он предоставляет абстракцию над SQLAlchemy, позволяя избежать написания однотипного кода для каждой модели данных. `BaseDAO` использует generics для обеспечения типовой безопасности и может быть унаследован для создания DAO (Data Access Object) для конкретных моделей.

## Классы

### `BaseDAO`

**Описание**:
Базовый класс для реализации DAO (Data Access Object). Предоставляет методы для выполнения CRUD-операций и других операций с базой данных.

**Как работает класс**:
Класс `BaseDAO` является универсальным (generic) классом, параметризованным типом `T`, который должен быть подклассом `Base` (базовый класс SQLAlchemy). Он предоставляет набор статических методов для выполнения операций с базой данных, таких как поиск, добавление, обновление и удаление записей. Все методы принимают `AsyncSession` для выполнения асинхронных операций с базой данных.

**Методы**:

- `find_one_or_none_by_id`: Найти запись по ID.
- `find_one_or_none`: Найти одну запись по фильтрам.
- `find_all`: Найти все записи по фильтрам.
- `add`: Добавить одну запись.
- `add_many`: Добавить несколько записей.
- `update`: Обновить записи по фильтрам.
- `delete`: Удалить записи по фильтру.
- `count`: Подсчитать количество записей.
- `paginate`: Пагинация записей.
- `find_by_ids`: Найти несколько записей по списку ID.
- `upsert`: Создать запись или обновить существующую.
- `bulk_update`: Массовое обновление записей.

## Функции

### `find_one_or_none_by_id`

```python
@classmethod
async def find_one_or_none_by_id(cls, data_id: int, session: AsyncSession):
    """Найти запись по ID
    Args:
        data_id (int): ID записи.
        session (AsyncSession): Асинхровая сессия SQLAlchemy.

    Returns:
        T | None: Найденная запись или `None`, если запись не найдена.

    Raises:
        SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

    Как работает функция:
        1.  Логирует информацию о начале поиска записи по ID.
        2.  Выполняет запрос к базе данных для поиска записи с указанным ID.
        3.  Извлекает найденную запись из результата запроса.
        4.  Логирует информацию о результате поиска (найдена или не найдена).
        5.  Возвращает найденную запись или `None`, если запись не найдена.

    Внутри функции происходят следующие действия и преобразования:
    Поиск записи по ID
    |
    -- Выполнение запроса к базе данных
    |
    Извлечение записи из результата запроса
    |
    Логирование результата поиска
    """
```

**Параметры**:

- `data_id` (int): ID записи.
- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.

**Возвращает**:

- `T | None`: Найденная запись или `None`, если запись не найдена.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_one_or_none_by_id
data_id = 123
session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
record = await BaseDAO.find_one_or_none_by_id(data_id=data_id, session=session)
if record:
    print(f"Найдена запись с ID: {record.id}")
else:
    print(f"Запись с ID {data_id} не найдена.")
```

### `find_one_or_none`

```python
 @classmethod
    async def find_one_or_none(cls, session: AsyncSession, filters: BaseModel):
        """Найти одну запись по фильтрам
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            filters (BaseModel): Фильтры для поиска записи.

        Returns:
            T | None: Найденная запись или `None`, если запись не найдена.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.
        Как работает функция:
            1. Преобразует фильтры из BaseModel в словарь, исключая неустановленные значения.
            2. Логирует информацию о начале поиска записи по фильтрам.
            3. Выполняет запрос к базе данных для поиска записи с указанными фильтрами.
            4. Извлекает найденную запись из результата запроса.
            5. Логирует информацию о результате поиска (найдена или не найдена).
            6. Возвращает найденную запись или `None`, если запись не найдена.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров в словарь
        |
        -- Поиск записи по фильтрам
        |
        Выполнение запроса к базе данных
        |
        Извлечение записи из результата запроса
        |
        Логирование результата поиска
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `filters` (BaseModel): Фильтры для поиска записи.

**Возвращает**:

- `T | None`: Найденная запись или `None`, если запись не найдена.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_one_or_none
class MyFilters(BaseModel):
    name: str = "Example"
    age: int = 30

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
record = await BaseDAO.find_one_or_none(session=session, filters=filters)
if record:
    print(f"Найдена запись с именем: {record.name}")
else:
    print(f"Запись с фильтрами {filters} не найдена.")
```

### `find_all`

```python
    @classmethod
    async def find_all(cls, session: AsyncSession, filters: BaseModel | None = None):
        """Найти все записи по фильтрам
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            filters (BaseModel | None, optional): Фильтры для поиска записей. По умолчанию `None`.

        Returns:
            List[T]: Список найденных записей.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует фильтры из BaseModel в словарь, исключая неустановленные значения, если фильтры предоставлены.
            2. Логирует информацию о начале поиска всех записей по фильтрам.
            3. Выполняет запрос к базе данных для поиска всех записей с указанными фильтрами.
            4. Извлекает все найденные записи из результата запроса.
            5. Логирует количество найденных записей.
            6. Возвращает список найденных записей.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров в словарь
        |
        -- Поиск всех записей по фильтрам
        |
        Выполнение запроса к базе данных
        |
        Извлечение записей из результата запроса
        |
        Логирование количества найденных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `filters` (BaseModel | None, optional): Фильтры для поиска записей. По умолчанию `None`.

**Возвращает**:

- `List[T]`: Список найденных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_all
class MyFilters(BaseModel):
    name: str = "Example"
    age: int = 30

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
records = await BaseDAO.find_all(session=session, filters=filters)
print(f"Найдено {len(records)} записей.")
for record in records:
    print(f"Запись с именем: {record.name}")
```

### `add`

```python
    @classmethod
    async def add(cls, session: AsyncSession, values: BaseModel):
        """Добавить одну запись
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            values (BaseModel): Значения для добавления записи.

        Returns:
            T: Добавленная запись.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует значения из BaseModel в словарь, исключая неустановленные значения.
            2. Логирует информацию о начале добавления записи с указанными параметрами.
            3. Создает новый экземпляр модели с использованием предоставленных значений.
            4. Добавляет новый экземпляр в сессию.
            5. Подтверждает изменения в сессии.
            6. Логирует информацию об успешном добавлении записи.
            7. Возвращает добавленную запись.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование значений в словарь
        |
        -- Создание нового экземпляра модели
        |
        Добавление экземпляра в сессию
        |
        Подтверждение изменений в сессии
        |
        Логирование результата добавления
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `values` (BaseModel): Значения для добавления записи.

**Возвращает**:

- `T`: Добавленная запись.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции add
class MyValues(BaseModel):
    name: str = "New Example"
    age: int = 25

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
values = MyValues()
new_record = await BaseDAO.add(session=session, values=values)
print(f"Добавлена запись с именем: {new_record.name}")
```

### `add_many`

```python
   @classmethod
    async def add_many(cls, session: AsyncSession, instances: List[BaseModel]):
        """Добавить несколько записей
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            instances (List[BaseModel]): Список экземпляров BaseModel для добавления.

        Returns:
            List[T]: Список добавленных записей.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует список экземпляров BaseModel в список словарей, исключая неустановленные значения.
            2. Логирует информацию о начале добавления нескольких записей.
            3. Создает список новых экземпляров модели с использованием предоставленных значений.
            4. Добавляет все новые экземпляры в сессию.
            5. Подтверждает изменения в сессии.
            6. Логирует информацию об успешном добавлении записей.
            7. Возвращает список добавленных записей.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование экземпляров в список словарей
        |
        -- Создание списка новых экземпляров модели
        |
        Добавление экземпляров в сессию
        |
        Подтверждение изменений в сессии
        |
        Логирование результата добавления
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `instances` (List[BaseModel]): Список экземпляров `BaseModel` для добавления.

**Возвращает**:

- `List[T]`: Список добавленных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции add_many
class MyValues(BaseModel):
    name: str = "Example"
    age: int = 30

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
instances = [MyValues(name=f"Example {i}", age=30 + i) for i in range(3)]
new_records = await BaseDAO.add_many(session=session, instances=instances)
print(f"Добавлено {len(new_records)} записей.")
for record in new_records:
    print(f"Запись с именем: {record.name}")
```

### `update`

```python
    @classmethod
    async def update(cls, session: AsyncSession, filters: BaseModel, values: BaseModel):
        """Обновить записи по фильтрам
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            filters (BaseModel): Фильтры для поиска записей для обновления.
            values (BaseModel): Значения для обновления записей.

        Returns:
            int: Количество обновленных записей.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует фильтры и значения из BaseModel в словари, исключая неустановленные значения.
            2. Логирует информацию о начале обновления записей по указанному фильтру с указанными параметрами.
            3. Формирует запрос на обновление записей, соответствующих фильтру, с использованием предоставленных значений.
            4. Выполняет запрос к базе данных.
            5. Подтверждает изменения в сессии.
            6. Логирует количество обновленных записей.
            7. Возвращает количество обновленных записей.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров и значений в словари
        |
        -- Формирование запроса на обновление
        |
        Выполнение запроса к базе данных
        |
        Подтверждение изменений в сессии
        |
        Логирование количества обновленных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `filters` (BaseModel): Фильтры для поиска записей для обновления.
- `values` (BaseModel): Значения для обновления записей.

**Возвращает**:

- `int`: Количество обновленных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции update
class MyFilters(BaseModel):
    name: str = "Example"

class MyValues(BaseModel):
    age: int = 35

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
values = MyValues()
updated_count = await BaseDAO.update(session=session, filters=filters, values=values)
print(f"Обновлено {updated_count} записей.")
```

### `delete`

```python
    @classmethod
    async def delete(cls, session: AsyncSession, filters: BaseModel):
        """Удалить записи по фильтру
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            filters (BaseModel): Фильтры для поиска записей для удаления.

        Returns:
            int: Количество удаленных записей.

        Raises:
            ValueError: Если не предоставлен ни один фильтр для удаления.
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует фильтры из BaseModel в словарь, исключая неустановленные значения.
            2. Логирует информацию о начале удаления записей по указанному фильтру.
            3. Проверяет, что предоставлен хотя бы один фильтр для удаления.
            4. Формирует запрос на удаление записей, соответствующих фильтру.
            5. Выполняет запрос к базе данных.
            6. Подтверждает изменения в сессии.
            7. Логирует количество удаленных записей.
            8. Возвращает количество удаленных записей.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров в словарь
        |
        -- Проверка наличия фильтров
        |
        Формирование запроса на удаление
        |
        Выполнение запроса к базе данных
        |
        Подтверждение изменений в сессии
        |
        Логирование количества удаленных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `filters` (BaseModel): Фильтры для поиска записей для удаления.

**Возвращает**:

- `int`: Количество удаленных записей.

**Вызывает исключения**:

- `ValueError`: Если не предоставлен ни один фильтр для удаления.
- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции delete
class MyFilters(BaseModel):
    name: str = "Example"

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
deleted_count = await BaseDAO.delete(session=session, filters=filters)
print(f"Удалено {deleted_count} записей.")
```

### `count`

```python
    @classmethod
    async def count(cls, session: AsyncSession, filters: BaseModel | None = None):
        """Подсчитать количество записей
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            filters (BaseModel | None, optional): Фильтры для поиска записей. По умолчанию `None`.

        Returns:
            int: Количество записей, соответствующих фильтрам.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует фильтры из BaseModel в словарь, исключая неустановленные значения, если фильтры предоставлены.
            2. Логирует информацию о начале подсчета количества записей по указанному фильтру.
            3. Формирует запрос на подсчет количества записей, соответствующих фильтру.
            4. Выполняет запрос к базе данных.
            5. Извлекает количество записей из результата запроса.
            6. Логирует количество найденных записей.
            7. Возвращает количество записей.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров в словарь
        |
        -- Формирование запроса на подсчет
        |
        Выполнение запроса к базе данных
        |
        Извлечение количества записей из результата запроса
        |
        Логирование количества найденных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `filters` (BaseModel | None, optional): Фильтры для поиска записей. По умолчанию `None`.

**Возвращает**:

- `int`: Количество записей, соответствующих фильтрам.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции count
class MyFilters(BaseModel):
    name: str = "Example"

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
count = await BaseDAO.count(session=session, filters=filters)
print(f"Найдено {count} записей.")
```

### `paginate`

```python
    @classmethod
    async def paginate(cls, session: AsyncSession, page: int = 1, page_size: int = 10, filters: BaseModel = None):
        """Пагинация записей
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            page (int, optional): Номер страницы. По умолчанию `1`.
            page_size (int, optional): Размер страницы. По умолчанию `10`.
            filters (BaseModel, optional): Фильтры для поиска записей. По умолчанию `None`.

        Returns:
            List[T]: Список записей на указанной странице.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует фильтры из BaseModel в словарь, исключая неустановленные значения, если фильтры предоставлены.
            2. Логирует информацию о начале пагинации записей по указанному фильтру, странице и размеру страницы.
            3. Формирует запрос на выбор записей, соответствующих фильтру, с учетом номера страницы и размера страницы.
            4. Выполняет запрос к базе данных.
            5. Извлекает список записей из результата запроса.
            6. Логирует количество найденных записей на странице.
            7. Возвращает список записей на указанной странице.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование фильтров в словарь
        |
        -- Формирование запроса на выбор записей с учетом пагинации
        |
        Выполнение запроса к базе данных
        |
        Извлечение списка записей из результата запроса
        |
        Логирование количества найденных записей на странице
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `page` (int, optional): Номер страницы. По умолчанию `1`.
- `page_size` (int, optional): Размер страницы. По умолчанию `10`.
- `filters` (BaseModel, optional): Фильтры для поиска записей. По умолчанию `None`.

**Возвращает**:

- `List[T]`: Список записей на указанной странице.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции paginate
class MyFilters(BaseModel):
    name: str = "Example"

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
filters = MyFilters()
page = 2
page_size = 5
records = await BaseDAO.paginate(session=session, page=page, page_size=page_size, filters=filters)
print(f"Найдено {len(records)} записей на странице {page}.")
for record in records:
    print(f"Запись с именем: {record.name}")
```

### `find_by_ids`

```python
    @classmethod
    async def find_by_ids(cls, session: AsyncSession, ids: List[int]) -> List[Any]:
        """Найти несколько записей по списку ID
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            ids (List[int]): Список ID записей для поиска.

        Returns:
            List[Any]: Список найденных записей.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Логирует информацию о начале поиска записей по списку ID.
            2. Формирует запрос на выбор записей, ID которых находятся в указанном списке.
            3. Выполняет запрос к базе данных.
            4. Извлекает список записей из результата запроса.
            5. Логирует количество найденных записей по списку ID.
            6. Возвращает список найденных записей.

        Внутри функции происходят следующие действия и преобразования:
        Логирование информации о поиске
        |
        -- Формирование запроса на выбор записей по списку ID
        |
        Выполнение запроса к базе данных
        |
        Извлечение списка записей из результата запроса
        |
        Логирование количества найденных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `ids` (List[int]): Список ID записей для поиска.

**Возвращает**:

- `List[Any]`: Список найденных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции find_by_ids
session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
ids = [1, 2, 3]
records = await BaseDAO.find_by_ids(session=session, ids=ids)
print(f"Найдено {len(records)} записей по списку ID.")
for record in records:
    print(f"Запись с ID: {record.id}")
```

### `upsert`

```python
    @classmethod
    async def upsert(cls, session: AsyncSession, unique_fields: List[str], values: BaseModel):
        """Создать запись или обновить существующую
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            unique_fields (List[str]): Список уникальных полей, используемых для поиска существующей записи.
            values (BaseModel): Значения для создания или обновления записи.

        Returns:
            T: Созданная или обновленная запись.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Преобразует значения из BaseModel в словарь, исключая неустановленные значения.
            2. Формирует словарь фильтров на основе уникальных полей и предоставленных значений.
            3. Логирует информацию о начале операции upsert.
            4. Пытается найти существующую запись по указанным фильтрам.
            5. Если запись существует, обновляет ее значения и подтверждает изменения в сессии.
            6. Если запись не существует, создает новую запись и добавляет ее в сессию.
            7. Подтверждает изменения в сессии.
            8. Логирует информацию о результате операции (обновлена или создана).
            9. Возвращает созданную или обновленную запись.

        Внутри функции происходят следующие действия и преобразования:
        Преобразование значений в словарь
        |
        -- Формирование словаря фильтров
        |
        Поиск существующей записи
        |
        -- Обновление существующей записи (если найдена)
        |
        -- Создание новой записи (если не найдена)
        |
        Подтверждение изменений в сессии
        |
        Логирование результата операции
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `unique_fields` (List[str]): Список уникальных полей, используемых для поиска существующей записи.
- `values` (BaseModel): Значения для создания или обновления записи.

**Возвращает**:

- `T`: Созданная или обновленная запись.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции upsert
class MyValues(BaseModel):
    name: str = "Example"
    email: str = "example@example.com"
    age: int = 30

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
unique_fields = ["email"]
values = MyValues(name="Updated Example", email="example@example.com", age=35)
record = await BaseDAO.upsert(session=session, unique_fields=unique_fields, values=values)
print(f"Запись с email {record.email} обновлена или создана.")
```

### `bulk_update`

```python
    @classmethod
    async def bulk_update(cls, session: AsyncSession, records: List[BaseModel]) -> int:
        """Массовое обновление записей
        Args:
            session (AsyncSession): Асинхровая сессия SQLAlchemy.
            records (List[BaseModel]): Список экземпляров BaseModel для массового обновления.

        Returns:
            int: Количество обновленных записей.

        Raises:
            SQLAlchemyError: Если произошла ошибка при выполнении запроса к базе данных.

        Как работает функция:
            1. Логирует информацию о начале массового обновления записей.
            2. Итерируется по списку записей для обновления.
            3. Для каждой записи формирует запрос на обновление, исключая поле 'id' из значений для обновления.
            4. Выполняет запрос к базе данных.
            5. Подсчитывает количество обновленных записей.
            6. Подтверждает изменения в сессии.
            7. Логирует общее количество обновленных записей.
            8. Возвращает общее количество обновленных записей.

        Внутри функции происходят следующие действия и преобразования:
        Логирование информации о начале массового обновления
        |
        -- Итерация по списку записей
        |
        -- Формирование запроса на обновление для каждой записи
        |
        -- Исключение поля 'id' из значений для обновления
        |
        Выполнение запроса к базе данных для каждой записи
        |
        Подсчет количества обновленных записей
        |
        Подтверждение изменений в сессии
        |
        Логирование общего количества обновленных записей
        """
```

**Параметры**:

- `session` (AsyncSession): Асинхровая сессия SQLAlchemy.
- `records` (List[BaseModel]): Список экземпляров `BaseModel` для массового обновления.

**Возвращает**:

- `int`: Количество обновленных записей.

**Вызывает исключения**:

- `SQLAlchemyError`: Если произошла ошибка при выполнении запроса к базе данных.

**Примеры**:

```python
# Пример использования функции bulk_update
class MyValues(BaseModel):
    id: int
    name: str
    age: int

session = AsyncSession()  # Предположим, что AsyncSession уже создан и настроен
records = [
    MyValues(id=1, name="Example 1", age=31),
    MyValues(id=2, name="Example 2", age=32),
    MyValues(id=3, name="Example 3", age=33),
]
updated_count = await BaseDAO.bulk_update(session=session, records=records)
print(f"Обновлено {updated_count} записей.")