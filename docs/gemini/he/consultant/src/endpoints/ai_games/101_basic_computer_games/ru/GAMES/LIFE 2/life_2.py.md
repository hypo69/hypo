# Анализ кода модуля `life_2.py`

**Качество кода**
*   **Соответствие требованиям к формату кода (1-10):** 7/10
    *   **Преимущества:**
        *   Код логически структурирован и понятен.
        *   Используются функции для разделения логики игры.
        *   Присутствует подробное описание алгоритма и правил игры в начале файла.
        *   Присутствует блок-схема, визуализирующая работу программы.
    *   **Недостатки:**
        *   Отсутствуют необходимые импорты для работы с JSON.
        *   Не используются `j_loads` или `j_loads_ns`.
        *   Отсутствует логирование ошибок.
        *   Docstring не соответствует формату RST.
        *   Некоторые переменные имеют недостаточно информативные имена.

**Рекомендации по улучшению**

1.  **Форматирование документации:** Необходимо перевести все комментарии в формат reStructuredText (RST).
2.  **Обработка данных:** Заменить `json.load` на `j_loads` или `j_loads_ns` из `src.utils.jjson` (если это применимо).
3.  **Логирование ошибок:** Добавить логирование ошибок с помощью `from src.logger.logger import logger` вместо использования общих блоков `try-except`.
4.  **Улучшение Docstring:** Переписать docstring для всех функций, классов и методов в соответствии с форматом RST и стандартами Python.
5.  **Наименование:** Улучшить имена переменных для повышения читабельности кода.

**Улучшенный код**

```python
"""
Модуль, реализующий игру "Жизнь 2"
=========================================================================================

Модуль представляет собой симуляцию клеточного автомата, разработанную Джоном Конвеем.
Игра демонстрирует, как простые правила могут привести к возникновению сложных и интересных паттернов.
Игрок задает начальную конфигурацию живых клеток и наблюдает за ее эволюцией с течением времени.

Пример использования
--------------------

.. code-block:: python

    if __name__ == "__main__":
        num_rows = int(input("Введите количество строк: "))
        num_cols = int(input("Введите количество столбцов: "))
        initial_alive_cells = int(input("Введите количество начальных живых клеток: "))
        grid = initialize_grid(num_rows, num_cols)
        place_alive_cells(grid, initial_alive_cells)
        print("Начальное состояние поля:")
        display_grid(grid)

        while True:
            next_grid = compute_next_generation(grid)
            grid = next_grid
            display_grid(grid)
            user_input = input("Нажмите Enter для продолжения или введите \'0\' для выхода: ")
            if user_input == '0':
                break

"""
import random  # Импорт модуля random для генерации случайных чисел.
import copy  # Импорт модуля copy для создания глубоких копий списков.
from src.logger.logger import logger  # Импорт логгера для записи ошибок.


def initialize_grid(num_rows: int, num_cols: int) -> list[list[str]]:
    """
    Создаёт и инициализирует игровое поле (сетку) мертвыми клетками.

    :param num_rows: Количество строк в сетке.
    :type num_rows: int
    :param num_cols: Количество столбцов в сетке.
    :type num_cols: int
    :return: Игровое поле, представленное в виде списка списков.
    :rtype: list[list[str]]
    """
    grid = [[' ' for _ in range(num_cols)] for _ in range(num_rows)]  # Создание сетки, заполненной пробелами
    return grid


def place_alive_cells(grid: list[list[str]], initial_alive_cells: int) -> None:
    """
    Размещает начальные живые клетки на игровом поле случайным образом.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    :param initial_alive_cells: Количество начальных живых клеток.
    :type initial_alive_cells: int
    """
    num_rows = len(grid)  # Получение количества строк в сетке
    num_cols = len(grid[0])  # Получение количества столбцов в сетке

    placed_cells = 0  # Инициализация счетчика размещенных живых клеток
    while placed_cells < initial_alive_cells:  # Цикл выполняется, пока не разместим нужное кол-во живых клеток
        row = random.randint(0, num_rows - 1)  # Случайный выбор строки
        col = random.randint(0, num_cols - 1)  # Случайный выбор столбца
        if grid[row][col] == ' ':  # Проверяем, является ли клетка пустой
            grid[row][col] = '*'  # Размещаем живую клетку
            placed_cells += 1  # Увеличиваем счетчик размещенных живых клеток


def display_grid(grid: list[list[str]]) -> None:
    """
    Выводит текущее состояние игрового поля на экран.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    """
    for row in grid:  # Цикл по всем строкам игрового поля
        print(' '.join(row))  # Выводим строку с пробелами между клетками
    print()  # Выводим пустую строку для разделения поколений


def count_alive_neighbors(grid: list[list[str]], row: int, col: int) -> int:
    """
    Подсчитывает количество живых соседей у клетки.

    :param grid: Игровое поле.
    :type grid: list[list[str]]
    :param row: Индекс строки клетки.
    :type row: int
    :param col: Индекс столбца клетки.
    :type col: int
    :return: Количество живых соседей.
    :rtype: int
    """
    num_rows = len(grid)  # Получение количества строк в сетке
    num_cols = len(grid[0])  # Получение количества столбцов в сетке
    alive_neighbors = 0  # Инициализация счетчика живых соседей

    for i in range(max(0, row - 1), min(num_rows, row + 2)):  # Цикл по соседним строкам
        for j in range(max(0, col - 1), min(num_cols, col + 2)):  # Цикл по соседним столбцам
            if (i, j) != (row, col) and grid[i][j] == '*':  # Проверка, что соседняя клетка живая и не текущая
                alive_neighbors += 1  # Увеличиваем счетчик живых соседей

    return alive_neighbors  # Возвращаем количество живых соседей


def compute_next_generation(grid: list[list[str]]) -> list[list[str]]:
    """
    Вычисляет следующее поколение клеток на основе текущего состояния поля и правил игры "Жизнь".

    :param grid: Текущее игровое поле.
    :type grid: list[list[str]]
    :return: Новое игровое поле, представляющее следующее поколение.
    :rtype: list[list[str]]
    """
    num_rows = len(grid)  # Получение количества строк в сетке
    num_cols = len(grid[0])  # Получение количества столбцов в сетке
    next_grid = copy.deepcopy(grid)  # Создание глубокой копии текущего поля, чтобы избежать изменений в процессе вычислений

    for row in range(num_rows):  # Цикл по всем строкам
        for col in range(num_cols):  # Цикл по всем столбцам
            alive_neighbors = count_alive_neighbors(grid, row, col)  # Вычисляем количество живых соседей
            if grid[row][col] == '*':  # Если клетка живая
                if alive_neighbors < 2 or alive_neighbors > 3:  # Проверяем условия смерти клетки
                    next_grid[row][col] = ' '  # Клетка умирает
            else:  # Если клетка мертвая
                if alive_neighbors == 3:  # Проверяем условия рождения клетки
                    next_grid[row][col] = '*'  # Клетка рождается

    return next_grid  # Возвращаем новое игровое поле


# Основная логика игры
if __name__ == "__main__":
    # Запрашиваем у пользователя размер поля
    try:
        num_rows = int(input("Введите количество строк: "))  # Запрос количества строк
        num_cols = int(input("Введите количество столбцов: "))  # Запрос количества столбцов
    except ValueError as e:
        logger.error(f"Некорректный ввод размера поля: {e}")  # Логирование ошибки некорректного ввода
        exit()

    # Запрашиваем количество начальных живых клеток
    try:
        initial_alive_cells = int(input("Введите количество начальных живых клеток: "))  # Запрос количества живых клеток
    except ValueError as e:
        logger.error(f"Некорректный ввод количества начальных живых клеток: {e}")  # Логирование ошибки некорректного ввода
        exit()

    # Инициализируем и выводим начальное состояние поля
    grid = initialize_grid(num_rows, num_cols)  # Инициализация игрового поля
    place_alive_cells(grid, initial_alive_cells)  # Размещение живых клеток
    print("Начальное состояние поля:")  # Вывод начального состояния поля
    display_grid(grid)  # Отображение игрового поля

    # Основной игровой цикл
    while True:
        # Вычисляем следующее поколение
        next_grid = compute_next_generation(grid)  # Вычисление следующего поколения
        grid = next_grid  # Обновление текущего поля
        # Отображаем новое состояние поля
        display_grid(grid)  # Вывод текущего состояния поля

        # Спрашиваем пользователя, хочет ли он продолжить
        user_input = input("Нажмите Enter для продолжения или введите '0' для выхода: ")  # Запрос на продолжение
        if user_input == '0':  # Проверка, хочет ли пользователь выйти
            break  # Завершение цикла, если пользователь ввел 0
```