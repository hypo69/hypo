# Модуль тестирования управления Tiny Troupe

## Обзор

Этот модуль содержит модульные тесты для проверки функциональности управления в Tiny Troupe, включая запуск, создание контрольных точек и завершение симуляций с участием агентов, миров и фабрик персонажей.

## Подробнее

Этот модуль тестирует различные аспекты управления симуляциями в Tiny Troupe, включая корректное создание, сохранение состояния и завершение симуляций. Он использует pytest для организации тестов и включает вспомогательные функции для очистки тестовых файлов и настройки окружения.

## Функции

### `test_begin_checkpoint_end_with_agent_only`

```python
def test_begin_checkpoint_end_with_agent_only(setup):
    """
    Тестирует последовательность begin-checkpoint-end с использованием только агентов.

    Args:
        setup: Фикстура pytest для настройки тестового окружения.

    Raises:
        AssertionError: Если состояние симуляции не соответствует ожидаемому.
    """
```

**Как работает функция**:

1.  **Удаление файла кэша**: Удаляет файл `control_test.cache.json`, если он существует.
2.  **Сброс состояния управления**: Вызывает `control.reset()` для сброса состояния управления симуляцией.
3.  **Проверка отсутствия активной симуляции**: Утверждает, что `control._current_simulations["default"] is None`, чтобы убедиться, что нет активной симуляции.
4.  **Запуск симуляции**: Вызывает `control.begin("control_test.cache.json")` для запуска новой симуляции.
5.  **Проверка статуса симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STARTED`, чтобы убедиться, что симуляция запущена.
6.  **Создание агентов**: Создает два агента, `agent_1` (Oscar the Architect) и `agent_2` (Lisa the Data Scientist), с использованием вспомогательных функций.
7.  **Добавление способностей агентам**: Добавляет каждому агенту способности (`tooluse_faculty`) и определяет атрибуты (`age`, `nationality`).
8.  **Проверка наличия трассировки**: Утверждает, что `control._current_simulations["default"].cached_trace is not None` и `control._current_simulations["default"].execution_trace is not None`, чтобы убедиться, что трассировка кэширована и существует.
9.  **Создание контрольной точки**: Вызывает `control.checkpoint()` для создания контрольной точки симуляции.
10. **Взаимодействие агентов**: Агенты взаимодействуют, вызывая `listen_and_act()`.
11. **Проверка создания файла контрольной точки**: Утверждает, что файл `control_test.cache.json` существует.
12. **Завершение симуляции**: Вызывает `control.end()` для завершения симуляции.
13. **Проверка статуса завершения симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STOPPED`, чтобы убедиться, что симуляция остановлена.

**ASCII-схема работы функции**:

```
Удаление файла кэша
    ↓
Сброс состояния управления
    ↓
Запуск симуляции
    ↓
Создание агентов
    ↓
Добавление способностей агентам
    ↓
Создание контрольной точки
    ↓
Взаимодействие агентов
    ↓
Завершение симуляции
```

**Примеры**:

```python
# Пример вызова функции
test_begin_checkpoint_end_with_agent_only(setup)
```

### `test_begin_checkpoint_end_with_world`

```python
def test_begin_checkpoint_end_with_world(setup):
    """
    Тестирует последовательность begin-checkpoint-end с использованием мира (TinyWorld).

    Args:
        setup: Фикстура pytest для настройки тестового окружения.

    Raises:
        AssertionError: Если состояние симуляции не соответствует ожидаемому.
    """
```

**Как работает функция**:

1.  **Удаление файла кэша**: Удаляет файл `control_test_world.cache.json`, если он существует.
2.  **Сброс состояния управления**: Вызывает `control.reset()` для сброса состояния управления симуляцией.
3.  **Проверка отсутствия активной симуляции**: Утверждает, что `control._current_simulations["default"] is None`, чтобы убедиться, что нет активной симуляции.
4.  **Запуск симуляции**: Вызывает `control.begin("control_test_world.cache.json")` для запуска новой симуляции.
5.  **Проверка статуса симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STARTED`, чтобы убедиться, что симуляция запущена.
6.  **Создание мира**: Создает мир `TinyWorld` с двумя агентами (Oscar the Architect и Lisa the Data Scientist).
7.  **Обеспечение доступности агентов**: Вызывает `world.make_everyone_accessible()`, чтобы агенты могли взаимодействовать друг с другом.
8.  **Проверка наличия трассировки**: Утверждает, что `control._current_simulations["default"].cached_trace is not None` и `control._current_simulations["default"].execution_trace is not None`, чтобы убедиться, что трассировка кэширована и существует.
9.  **Запуск мира**: Вызывает `world.run(2)` для запуска симуляции мира на два шага.
10. **Создание контрольной точки**: Вызывает `control.checkpoint()` для создания контрольной точки симуляции.
11. **Проверка создания файла контрольной точки**: Утверждает, что файл `control_test_world.cache.json` существует.
12. **Завершение симуляции**: Вызывает `control.end()` для завершения симуляции.
13. **Проверка статуса завершения симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STOPPED`, чтобы убедиться, что симуляция остановлена.

**ASCII-схема работы функции**:

```
Удаление файла кэша
    ↓
Сброс состояния управления
    ↓
Запуск симуляции
    ↓
Создание мира
    ↓
Обеспечение доступности агентов
    ↓
Запуск мира
    ↓
Создание контрольной точки
    ↓
Завершение симуляции
```

**Примеры**:

```python
# Пример вызова функции
test_begin_checkpoint_end_with_world(setup)
```

### `test_begin_checkpoint_end_with_factory`

```python
def test_begin_checkpoint_end_with_factory(setup):
    """
    Тестирует последовательность begin-checkpoint-end с использованием фабрики персонажей (TinyPersonFactory).

    Args:
        setup: Фикстура pytest для настройки тестового окружения.

    Raises:
        AssertionError: Если состояние симуляции не соответствует ожидаемому.
    """
```

**Внутренние функции**:

#### `aux_simulation_to_repeat`

```python
def aux_simulation_to_repeat(iteration, verbose=False):
    """
    Вспомогательная функция для повторения симуляции с использованием фабрики персонажей.

    Args:
        iteration (int): Номер итерации симуляции.
        verbose (bool): Флаг для включения подробного логирования. По умолчанию `False`.

    Returns:
        agent: Сгенерированный агент.

    Raises:
        AssertionError: Если состояние симуляции не соответствует ожидаемому.
    """
```

**Как работает внутренняя функция `aux_simulation_to_repeat`**:

1.  **Сброс состояния управления**: Вызывает `control.reset()` для сброса состояния управления симуляцией.
2.  **Проверка отсутствия активной симуляции**: Утверждает, что `control._current_simulations["default"] is None`, чтобы убедиться, что нет активной симуляции.
3.  **Запуск симуляции**: Вызывает `control.begin("control_test_personfactory.cache.json")` для запуска новой симуляции.
4.  **Проверка статуса симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STARTED`, чтобы убедиться, что симуляция запущена.
5.  **Создание фабрики персонажей**: Создает фабрику персонажей `TinyPersonFactory`.
6.  **Проверка наличия трассировки**: Утверждает, что `control._current_simulations["default"].cached_trace is not None` и `control._current_simulations["default"].execution_trace is not None`, чтобы убедиться, что трассировка кэширована и существует.
7.  **Генерация персонажа**: Генерирует персонажа с использованием фабрики.
8.  **Создание контрольной точки**: Вызывает `control.checkpoint()` для создания контрольной точки симуляции.
9.  **Проверка создания файла контрольной точки**: Утверждает, что файл `control_test_personfactory.cache.json` существует.
10. **Завершение симуляции**: Вызывает `control.end()` для завершения симуляции.
11. **Проверка статуса завершения симуляции**: Утверждает, что `control._current_simulations["default"].status == Simulation.STATUS_STOPPED`, чтобы убедиться, что симуляция остановлена.
12. **Логирование (опционально)**: Если `verbose` установлен в `True`, логирует информацию об итерации симуляции и конфигурации персонажа.
13. **Возврат агента**: Возвращает сгенерированного агента.

**ASCII-схема работы внутренней функции `aux_simulation_to_repeat`**:

```
Сброс состояния управления
    ↓
Запуск симуляции
    ↓
Создание фабрики персонажей
    ↓
Генерация персонажа
    ↓
Создание контрольной точки
    ↓
Завершение симуляции
    ↓
Логирование (опционально)
    ↓
Возврат агента
```

**Как работает основная функция `test_begin_checkpoint_end_with_factory`**:

1.  **Сброс кэша**: Проверяет, что нет промахов и попаданий в кэш.
2.  **Первая симуляция**: Вызывает `aux_simulation_to_repeat` для запуска первой симуляции и получает агента `agent_1`.
3.  **Извлечение атрибутов**: Извлекает атрибуты `age_1`, `nationality_1` и `minibio_1` из агента `agent_1`.
4.  **Вторая симуляция**: Вызывает `aux_simulation_to_repeat` для запуска второй симуляции и получает агента `agent_2`.
5.  **Извлечение атрибутов**: Извлекает атрибуты `age_2`, `nationality_2` и `minibio_2` из агента `agent_2`.
6.  **Проверка кэша**: Проверяет, что нет промахов в кэше и есть попадания в кэш.
7.  **Сравнение атрибутов**: Утверждает, что атрибуты агентов из обеих симуляций совпадают (`age_1 == age_2`, `nationality_1 == nationality_2`, `minibio_1 == minibio_2`).
8.  **Проверка содержимого файла кэша**: Читает содержимое файла `control_test_personfactory.cache.json` и проверяет, что он содержит определенные вызовы (`_aux_model_call`, `_setup_agent`) и не содержит другие (`define`, `define_several`).

**ASCII-схема работы основной функции `test_begin_checkpoint_end_with_factory`**:

```
Сброс кэша
    ↓
Первая симуляция (aux_simulation_to_repeat)
    ↓
Извлечение атрибутов агента 1
    ↓
Вторая симуляция (aux_simulation_to_repeat)
    ↓
Извлечение атрибутов агента 2
    ↓
Проверка кэша
    ↓
Сравнение атрибутов агентов
    ↓
Проверка содержимого файла кэша
```

**Примеры**:

```python
# Пример вызова функции
test_begin_checkpoint_end_with_factory(setup)