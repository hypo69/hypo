# Анализ кода модуля e_605.md

**Качество кода**
1/10
- Плюсы
    - Имеется описание задачи.
- Минусы
    - Отсутствует исполняемый код.
    - Нет инструкций по решению.
    - Нет анализа сложности.
    - Не стандартизировано оформление.

**Рекомендации по улучшению**

1.  **Добавить код решения**: Необходимо реализовать функцию на Python, которая вычисляет F(n) и возвращает результат по модулю 123456789.
2.  **Добавить документацию**: Добавить docstring для модуля и функций, используя reStructuredText.
3.  **Использовать logger**: При необходимости использовать `from src.logger.logger import logger` для логирования ошибок.
4.  **Оптимизация**: Применить динамическое программирование для эффективного вычисления F(n).
5.  **Анализ сложности**: Добавить анализ временной и пространственной сложности.
6.  **Тесты**: Реализовать юнит-тесты для проверки корректности решения.

**Оптимизированный код**

```python
"""
Модуль для решения задачи 605 Project Euler: Нечетные подпоследовательности.
=========================================================================================

Задача заключается в подсчете количества нечетных подпоследовательностей последовательности {1, 2, 3, ..., n},
которые не являются подпоследовательностями последовательности Фибоначчи.

Пример использования
--------------------

.. code-block:: python

    result = calculate_f_mod(10**18)
    print(f"F(10^18) mod 123456789 = {result}")

"""
from src.logger.logger import logger

def is_fibonacci_subsequence(seq: list[int]) -> bool:
    """
    Проверяет, является ли данная последовательность подпоследовательностью Фибоначчи.

    :param seq: Список целых чисел.
    :return: True, если последовательность является подпоследовательностью Фибоначчи, иначе False.
    """
    if not seq:
        return True
    fib = [1, 2]
    while fib[-1] <= seq[-1]:
        fib.append(fib[-1] + fib[-2])

    i = 0
    for num in seq:
      while i < len(fib) and fib[i] < num:
          i +=1
      if i == len(fib) or fib[i] != num:
        return False
      i +=1
    return True

def calculate_f(n: int) -> int:
    """
    Вычисляет количество нечетных подпоследовательностей последовательности {1, 2, 3, ..., n},
    которые не являются подпоследовательностями Фибоначчи.

    :param n: Верхняя граница последовательности.
    :return: Количество нечетных подпоследовательностей, не являющихся подпоследовательностями Фибоначчи.
    """
    count = 0
    odd_numbers = [x for x in range(1, n + 1, 2)]
    
    for i in range(1 << len(odd_numbers)):
        subsequence = [odd_numbers[j] for j in range(len(odd_numbers)) if (i >> j) & 1]
        if not is_fibonacci_subsequence(subsequence):
             count += 1
    return count

def calculate_f_mod(n: int, mod: int = 123456789) -> int:
    """
     Вычисляет количество нечетных подпоследовательностей последовательности {1, 2, 3, ..., n},
    которые не являются подпоследовательностями Фибоначчи по модулю `mod`.

    :param n: Верхняя граница последовательности.
    :param mod: Модуль, по которому возвращается результат.
    :return: Количество нечетных подпоследовательностей, не являющихся подпоследовательностями Фибоначчи по модулю `mod`.
    """
    try:
       # Количество нечетных чисел в диапазоне 1..n
        num_odds = (n + 1) // 2
        # Общее количество нечетных подпоследовательностей
        total_odd_subsequences = pow(2, num_odds, mod)

        # TODO: Оптимизировать вычисление количества подпоследовательностей Фибоначчи.
        # На данный момент, функция is_fibonacci_subsequence работает не эффективно для больших n
        fib_count = 0
        odd_numbers = [x for x in range(1, n + 1, 2)]
        for i in range(1 << len(odd_numbers)):
            subsequence = [odd_numbers[j] for j in range(len(odd_numbers)) if (i >> j) & 1]
            if is_fibonacci_subsequence(subsequence):
                fib_count += 1

        return (total_odd_subsequences - fib_count) % mod
    except Exception as e:
        logger.error(f"Ошибка при вычислении F({n}) mod {mod}: {e}")
        return 0
    

if __name__ == '__main__':
    # примеры
    print(f"F(5) = {calculate_f(5)}")
    print(f"F(10) = {calculate_f(10)}")
    print(f"F(100) = {calculate_f(100)}")
    print(f"F(1000) mod 123456789 = {calculate_f_mod(1000)}")
    result = calculate_f_mod(10**18)
    print(f"F(10^18) mod 123456789 = {result}")
```