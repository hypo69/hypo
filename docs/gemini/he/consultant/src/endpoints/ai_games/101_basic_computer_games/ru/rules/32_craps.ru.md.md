# Анализ кода модуля `32_craps.ru.md`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):** 8
    - **Преимущества:**
        - Код представляет собой описание правил игры в формате Markdown, что соответствует задаче.
        - Структура документа логичная и понятная, с выделенными разделами.
        - Присутствуют примеры работы программы.
    - **Недостатки:**
        -  Код не является исполняемым Python-кодом, а скорее описанием правил и логики игры.
        - Отсутствуют docstring и комментарии, необходимые для автоматической документации.
        - Не используется формат reStructuredText (RST) для docstring.
        - Отсутствует импорт необходимых модулей (если бы код был Python).
        - Не используются `j_loads` или `j_loads_ns`.
        - Нет обработки исключений и логирования.
        - Нет кода для тестирования.

**Рекомендации по улучшению**
1. Преобразовать описание игры в исполняемый Python код.
2.  Использовать `j_loads` или `j_loads_ns` для загрузки данных, если это необходимо.
3.  Добавить docstring в формате reStructuredText (RST) для модулей, функций и классов.
4.  Добавить логирование ошибок с помощью `from src.logger.logger import logger`.
5.  Добавить обработку исключений с помощью `try-except` или логирование ошибок, избегая чрезмерного использования try-except.
6.  Улучшить читаемость кода за счет комментариев.
7. Реализовать автоматизированные тесты для проверки логики игры.
8.  Соблюдать PEP 8 при написании кода.

**Улучшенный код**
```markdown
# Анализ кода модуля `32_craps.ru.md`

**Качество кода**
- **Соответствие требованиям к формату кода (1-10):** 8
    - **Преимущества:**
        - Код представляет собой описание правил игры в формате Markdown, что соответствует задаче.
        - Структура документа логичная и понятная, с выделенными разделами.
        - Присутствуют примеры работы программы.
    - **Недостатки:**
        -  Код не является исполняемым Python-кодом, а скорее описанием правил и логики игры.
        - Отсутствуют docstring и комментарии, необходимые для автоматической документации.
        - Не используется формат reStructuredText (RST) для docstring.
        - Отсутствует импорт необходимых модулей (если бы код был Python).
        - Не используются `j_loads` или `j_loads_ns`.
        - Нет обработки исключений и логирования.
        - Нет кода для тестирования.

**Рекомендации по улучшению**
1. Преобразовать описание игры в исполняемый Python код.
2.  Использовать `j_loads` или `j_loads_ns` для загрузки данных, если это необходимо.
3.  Добавить docstring в формате reStructuredText (RST) для модулей, функций и классов.
4.  Добавить логирование ошибок с помощью `from src.logger.logger import logger`.
5.  Добавить обработку исключений с помощью `try-except` или логирование ошибок, избегая чрезмерного использования try-except.
6.  Улучшить читаемость кода за счет комментариев.
7. Реализовать автоматизированные тесты для проверки логики игры.
8.  Соблюдать PEP 8 при написании кода.

**Улучшенный код**
```python
"""
Модуль для реализации игры CRAPS (кости).
=========================================================================================

Этот модуль содержит функции для имитации игры в кости CRAPS, 
основанной на правилах стандартного стола для игры в кости.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    game = CrapsGame()
    game.start_game()

"""
import random
from src.logger.logger import logger # импорт модуля для логирования

def roll_dice() -> int:
    """
    Имитирует бросок двух костей.

    :return: Сумма значений двух костей.
    :rtype: int
    """
    dice1 = random.randint(1, 6) # бросок первой кости
    dice2 = random.randint(1, 6) # бросок второй кости
    return dice1 + dice2 # возвращает сумму бросков

class CrapsGame:
    """
    Класс для управления игрой CRAPS.
    """
    def __init__(self):
        """
        Инициализирует игру CRAPS.
        """
        self.point = None  # точка, которая устанавливается после первого броска
        self.bet_amount = 0 # сумма ставки игрока

    def start_game(self):
        """
        Запускает игру CRAPS.
        """
        print('Добро пожаловать в игру CRAPS!') # приветствие игрока
        try: # обрабатываем возможные исключения
            self.bet_amount = self.get_bet_amount() # получаем ставку игрока
        except ValueError as e:
            logger.error(f'Ошибка ввода ставки: {e}') # логируем ошибку ввода ставки
            return
        self.play_round() # начинаем игровой раунд
        while self.play_again():  # предлагаем игроку сыграть еще раз
            self.point = None # сбрасываем точку
            self.play_round() # начинаем новый раунд

    def get_bet_amount(self) -> int:
        """
        Запрашивает у игрока сумму ставки.

        :return: Сумма ставки игрока.
        :rtype: int
        :raises ValueError: Если введенное значение не является целым числом в диапазоне от 1 до 10000.
        """
        while True: # запрашиваем ставку пока не будет введено корректное значение
            try:
                bet = int(input('Введите вашу ставку (от $1 до $10,000): '))  # получаем ставку игрока
                if 1 <= bet <= 10000: # проверяем, что ставка в допустимом диапазоне
                    return bet
                else:
                    print('Некорректная ставка. Введите значение от $1 до $10,000.')  # выводим сообщение об ошибке
            except ValueError:
                logger.error('Некорректный ввод. Введите целое число.') # логируем ошибку ввода
                print('Некорректный ввод. Введите целое число.') # выводим сообщение об ошибке

    def play_round(self):
        """
        Проводит один раунд игры CRAPS.
        """
        print('Вы бросаете кости.') # сообщаем игроку о начале броска
        result = roll_dice()  # бросаем кости
        print(f'Ваш бросок: {result}') # выводим результат броска
        if self.point is None:  # проверяем, установлен ли point
            self.handle_come_out_roll(result)  # если нет, обрабатываем первый бросок
        else:
            self.handle_point_stage(result)  # если да, обрабатываем броски в стадии point

    def handle_come_out_roll(self, result: int):
        """
        Обрабатывает результаты первого броска (come-out roll).

        :param result: Результат броска костей.
        :type result: int
        """
        if result in (7, 11):  # проверяем, выиграл ли игрок
            print('Вы выиграли! Поздравляем!') # выводим сообщение о выигрыше
        elif result in (2, 3, 12): # проверяем, проиграл ли игрок
            print('Вы проиграли.') # выводим сообщение о проигрыше
        else:
            self.point = result # устанавливаем point
            print(f'Точка установлена: {self.point}') # выводим сообщение об установке point
            self.handle_point_stage(roll_dice()) # переходим к стадии point

    def handle_point_stage(self, result: int):
        """
        Обрабатывает результаты бросков в стадии point.

        :param result: Результат броска костей.
        :type result: int
        """
        while True: # цикл для бросков пока не будет получен point или 7
            print(f'Ваш бросок: {result}') # выводим результат броска
            if result == self.point:  # проверяем, совпадает ли результат с point
                print('Вы выиграли!') # выводим сообщение о выигрыше
                break  # заканчиваем раунд
            elif result == 7: # проверяем, выпала ли 7
                print('Вы проиграли.') # выводим сообщение о проигрыше
                break  # заканчиваем раунд
            else:
                result = roll_dice()  # продолжаем бросать кости

    def play_again(self) -> bool:
        """
        Запрашивает у игрока, хочет ли он сыграть снова.

        :return: True, если игрок хочет сыграть снова, False в противном случае.
        :rtype: bool
        """
        while True: # запрашиваем ввод, пока не получим корректный ответ
            answer = input('Хотите сыграть снова? (да/нет) ').lower() # получаем ответ игрока
            if answer in ('да', 'нет'): # проверяем, является ли ответ корректным
                return answer == 'да'  # возвращаем результат
            else:
                print('Некорректный ввод. Введите "да" или "нет".') # выводим сообщение об ошибке

if __name__ == '__main__':
    game = CrapsGame() # создаем экземпляр класса игры
    game.start_game() # начинаем игру
```