```markdown
# trough

[![Build][badge-build-image]][badge-build-url]
[![Coverage][badge-coverage-image]][badge-coverage-url]
[![Downloads][badge-downloads-image]][badge-downloads-url]
[![Size][badge-size-image]][badge-size-url]

`trough` is a flexible middleware utility for creating asynchronous pipelines.

## Overview

`trough` provides a simple and powerful way to chain asynchronous functions (middleware) together, handling errors and managing data flow efficiently.  It's particularly useful when building systems that accept various plugins or processing steps.

## Key Features

* **Asynchronous Support:**  Handles both synchronous and asynchronous middleware functions, ensuring smooth data flow through the pipeline.
* **Error Handling:** Gracefully manages errors that may occur during middleware execution, preventing crashes.
* **Data Flow:**  Allows middleware to modify and pass data along the pipeline.
* **Flexibility:** Adapts to different input formats and output styles, including promises and callbacks.

## Getting Started

This package is ESM-only.

### Installation

```bash
npm install trough
```

### Usage (Node.js)

```javascript
import { trough } from 'trough';
import fs from 'node:fs/promises';
import path from 'node:path';

const pipeline = trough();

// Middleware example:
pipeline.use(async (fileName) => {
  console.log('Checking file:', fileName);
  return path.join(process.cwd(), fileName); // Return the resolved path
});

pipeline.use(async (filePath) => {
  try {
    const stats = await fs.stat(filePath);
    if (stats.isFile()) {
      return { filePath, stats };
    } else {
      throw new Error(`File ${filePath} is not a file.`);
    }
  } catch (error) {
    throw new Error(`Error accessing file: ${error.message}`); // Re-throw for error handling
  }
});

pipeline.use((ctx) => {
  console.log('Reading file:', ctx.filePath);
  return fs.readFile(ctx.filePath, 'utf-8'); // Reads the file
});

pipeline.run('readme.md')
  .then((result) => console.log('File content:', result))
  .catch((error) => console.error('Error:', error));
```

This example demonstrates a pipeline that checks if a file exists, reads it, and then prints the content.  Error handling is crucial for robust pipelines.

## API

### `trough()`

Creates a new pipeline instance.

### `use(middleware)`

Adds a middleware function to the pipeline. Middleware functions are executed sequentially.

*   `middleware`: The middleware function to add.  It should ideally be async, and return a promise or a value.


### `run(input, ...additionalInput)`

Executes the pipeline with the input.

*   `input`: The initial input to the pipeline.
*   `additionalInput`:  Optional additional input for middleware functions that accept multiple arguments.
    *   This method now returns a `Promise` which resolves to the final output of the pipeline or rejects if any middleware throws an error.



## Error Handling

Errors thrown by middleware functions halt the pipeline and are propagated through the `catch` block of the `.run()` method.


## Advanced Usage (Handling multiple inputs)

If your middleware needs to handle more than one input, you can use the `...additionalInput` arguments in `.run()`.  The middleware function can then access these inputs using `arguments` or spread syntax:


```javascript
// Middleware example for multiple inputs
pipeline.use((filename, options) => {
    // ...
});

pipeline.run("myFile.txt", { encoding: "utf-8" }).then(result => { ... });
```

This example shows how to pass options to middleware.



## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## License

[MIT](LICENSE)


```
