# Модуль `report_generator.py`

## Обзор

Модуль предназначен для генерации HTML и PDF отчетов для мехиронов Казаринова. Он включает в себя классы и методы, необходимые для загрузки данных из JSON, создания HTML-контента на основе шаблонов Jinja2, сохранения HTML в файлы, преобразования HTML в PDF и DOCX, а также запуска полного цикла генерации отчета.

## Подробнее

Этот модуль играет ключевую роль в создании отчетов на основе данных, специфичных для мехиронов Казаринова. Он использует шаблоны Jinja2 для генерации HTML-контента, который затем может быть преобразован в PDF или DOCX форматы. Модуль также предоставляет возможность отправки сгенерированных отчетов через Telegram бота.

## Классы

### `ReportGenerator`

**Описание**: Класс для генерации HTML- и PDF-отчётов на основе данных из JSON.

**Принцип работы**: Класс `ReportGenerator` предоставляет методы для создания отчетов в форматах HTML, PDF и DOCX. Он использует шаблоны Jinja2 для генерации HTML-контента, который затем может быть преобразован в другие форматы.

**Аттрибуты**:
- `if_need_html` (bool): Флаг, указывающий на необходимость генерации HTML-отчета.
- `if_need_pdf` (bool): Флаг, указывающий на необходимость генерации PDF-отчета.
- `if_need_docx` (bool): Флаг, указывающий на необходимость генерации DOCX-отчета.
- `storage_path` (Path): Путь к директории для хранения сгенерированных отчетов. По умолчанию `gs.path.external_storage / ENDPOINT`.
- `html_path` (Path | str): Путь к HTML-файлу.
- `pdf_path` (Path | str): Путь к PDF-файлу.
- `docx_path` (Path | str): Путь к DOCX-файлу.
- `html_content` (str): Содержимое HTML-файла.
- `data` (dict): Данные для генерации отчета.
- `lang` (str): Язык отчета.
- `mexiron_name` (str): Имя мехирона.
- `env` (Environment): Объект окружения Jinja2 для работы с шаблонами.

**Методы**:
- `__init__`: Инициализирует объект `ReportGenerator` и определяет, какие форматы данных требуется вернуть.
- `create_reports_async`: Создает отчеты всех типов: HTML, PDF, DOCX.
- `service_apendix`: Возвращает словарь с данными для сервисного приложения.
- `create_html_report_async`: Генерирует HTML-контент на основе шаблона и данных.
- `create_pdf_report_async`: Генерирует PDF-отчет из HTML-контента.
- `create_docx_report_async`: Создает DOCX-файл из HTML-контента.

### `ReportGenerator.__init__`

```python
def __init__(self, 
                 if_need_pdf:Optional[bool] = True, 
                 if_need_docx:Optional[bool] = True, 
            ):
```

**Назначение**: Инициализирует объект `ReportGenerator` и определяет, какие форматы данных требуется вернуть.

**Параметры**:
- `if_need_pdf` (Optional[bool], optional): Флаг, указывающий на необходимость генерации PDF-отчета. По умолчанию `True`.
- `if_need_docx` (Optional[bool], optional): Флаг, указывающий на необходимость генерации DOCX-отчета. По умолчанию `True`.

**Возвращает**:
- `None`

**Вызывает исключения**:
- `None`

**Как работает функция**:
1. Функция инициализирует объект `ReportGenerator`.
2. Устанавливает значения атрибутов `if_need_pdf` и `if_need_docx` на основе переданных параметров.

**Примеры**:
```python
r = ReportGenerator(if_need_pdf=True, if_need_docx=False)
```

### `ReportGenerator.create_reports_async`

```python
async def create_reports_async(self,\
                             bot: telebot.TeleBot,\
                             chat_id: int,\
                             data:dict,\
                             lang:str,\
                             mexiron_name:str,\
                             ) -> tuple:
```

**Назначение**: Создает отчеты во всех поддерживаемых форматах (HTML, PDF, DOCX) асинхронно.

**Параметры**:
- `bot` (telebot.TeleBot): Объект Telegram бота для отправки отчетов.
- `chat_id` (int): ID чата Telegram, куда нужно отправить отчет.
- `data` (dict): Данные для генерации отчета.
- `lang` (str): Язык отчета.
- `mexiron_name` (str): Имя мехирона, для которого генерируется отчет.

**Возвращает**:
- `tuple`: Не реализовано, функция должна возвращать `True` если все отчеты сгенерированы успешно и `False` в противном случае.

**Как работает функция**:

1.  Устанавливает `mexiron_name` из входных параметров.
2.  Определяет путь для экспорта, используя `storage_path` и `mexiron_name`.
3.  Формирует пути для сохранения HTML, PDF и DOCX файлов.
4.  Создает HTML отчет, используя `create_html_report_async`.
5.  Если HTML отчет не создан, возвращает `False`.
6.  Если `if_need_pdf` установлено в `True`, создает PDF отчет, используя `create_pdf_report_async`.
7.  Если `if_need_docx` установлено в `True`, создает DOCX отчет, используя `create_pdf_report_async`.

**ASCII flowchart**:

```
A: Установка имени мехирона
|
B: Определение путей для экспорта
|
C: Создание HTML отчета
|
D: Проверка HTML отчета
|
E: Если if_need_pdf, создание PDF отчета
|
F: Если if_need_docx, создание DOCX отчета
```

**Примеры**:
```python
# Пример вызова функции create_reports_async
# await r.create_reports_async(bot, chat_id, data, 'ru', 'test_mexiron')
```

### `ReportGenerator.service_apendix`

```python
def service_apendix(self, lang:str) -> dict:
```

**Назначение**: Возвращает словарь с данными для сервисного приложения.

**Параметры**:
- `lang` (str): Язык, на котором нужно вернуть данные.

**Возвращает**:
- `dict`: Словарь с данными для сервисного приложения, включающий `product_id`, `product_name`, `specification` и `image_local_saved_path`.

**Как работает функция**:
1.  Определяет имя продукта в зависимости от языка (`ru` или любой другой).
2.  Считывает текст спецификации из HTML-файла, расположенного в каталоге шаблонов, и заменяет символы новой строки (`\n`) на `<br>`.
3.  Генерирует случайное изображение и сохраняет путь к нему.
4.  Возвращает словарь, содержащий все эти данные.

**Примеры**:
```python
# Пример вызова функции service_apendix
# service_data = r.service_apendix('ru')
```

### `ReportGenerator.create_html_report_async`

```python
async def create_html_report_async(self, data:dict, lang:str, html_path:Optional[ str|Path] ) -> str | None:
```

**Назначение**: Генерирует HTML-контент на основе шаблона и данных.

**Параметры**:
- `data` (dict): Словарь с данными для заполнения шаблона.
- `lang` (str): Язык отчёта (`he` для иврита, в остальных случаях используется `ru`).
- `html_path` (Optional[str  |  Path], optional): Путь для сохранения HTML-файла. Если не указан, используется `self.html_path`.

**Возвращает**:
- `str | None`: HTML-контент в виде строки, или `None` в случае ошибки.

**Как работает функция**:

1.  Определяет путь для сохранения HTML-файла, используя переданный аргумент `html_path` или `self.html_path`, если `html_path` не указан.
2.  Получает данные сервисного приложения, используя метод `self.service_apendix(lang)`.
3.  Добавляет полученные данные в список продуктов в `data['products']`.
4.  Определяет имя шаблона в зависимости от языка (`template_table_he.html` для иврита, `template_table_ru.html` для остальных языков).
5.  Формирует путь к шаблону.
6.  Считывает содержимое шаблона из файла.
7.  Создает объект шаблона Jinja2 из строки.
8.  Генерирует HTML-контент, объединяя шаблон с данными.
9.  Пытается сохранить HTML-контент в файл по указанному пути.
10. В случае успеха возвращает сгенерированный HTML-контент, в случае неудачи - логирует ошибку и возвращает `None`.

**ASCII flowchart**:

```
A: Определение пути HTML-файла
|
B: Получение данных сервисного приложения
|
C: Добавление данных сервисного приложения в данные отчета
|
D: Определение имени шаблона
|
E: Формирование пути к шаблону
|
F: Считывание содержимого шаблона
|
G: Создание объекта шаблона Jinja2
|
H: Генерация HTML-контента
|
I: Сохранение HTML-контента в файл
```

**Примеры**:
```python
# Пример вызова функции create_html_report_async
# html_content = await r.create_html_report_async(data, 'ru', '/path/to/report.html')
```

### `ReportGenerator.create_pdf_report_async`

```python
async def create_pdf_report_async(self, 
                                data: dict, 
                                lang:str, 
                                pdf_path:str |Path) -> bool:
```

**Назначение**: Генерирует PDF-отчет из HTML-контента.

**Параметры**:
- `data` (dict):  Содержимое HTML-файла
- `lang` (str): Язык отчёта.
- `pdf_path` (str | Path): Путь для сохранения PDF-файла.

**Возвращает**:
- `bool`: `True`, если PDF-отчет был успешно создан и отправлен (если указан бот), `False` в случае ошибки.

**Как работает функция**:

1.  Определяет путь для сохранения PDF-файла, используя переданный аргумент `pdf_path` или `self.pdf_path`, если `pdf_path` не указан.
2.  Инициализирует `html_content` из параметра `data` или из атрибута `self.html_content`, если `data` не указан.
3.  Использует класс `PDFUtils` для сохранения HTML-контента в PDF-файл.
4.  Если сохранение PDF-файла не удалось, логирует ошибку и отправляет сообщение об ошибке через Telegram бот (если он указан).
5.  Если бот указан, пытается отправить PDF-файл через Telegram.
6.  Возвращает `True`, если PDF-отчет был успешно создан и отправлен (если указан бот), `False` в случае ошибки.

**ASCII flowchart**:

```
A: Определение пути PDF-файла
|
B: Инициализация HTML-контента
|
C: Сохранение HTML-контента в PDF-файл
|
D: Проверка успешности сохранения PDF
|
E: Отправка PDF-файла через Telegram (если бот указан)
```

**Примеры**:
```python
# Пример вызова функции create_pdf_report_async
# success = await r.create_pdf_report_async(data, 'ru', '/path/to/report.pdf')
```

### `ReportGenerator.create_docx_report_async`

```python
async def create_docx_report_async(self, html_path:str|Path, docx_path:str|Path) -> bool :
```

**Назначение**: Создает DOCX-файл из HTML-контента.

**Параметры**:
- `html_path` (str | Path): Путь к HTML-файлу.
- `docx_path` (str | Path): Путь для сохранения DOCX-файла.

**Возвращает**:
- `bool`: `True`, если DOCX-файл был успешно создан, `False` в случае ошибки.

**Как работает функция**:
1.  Использует функцию `html_to_docx` для преобразования HTML-файла в DOCX-файл.
2.  Если преобразование не удалось, логирует ошибку и возвращает `False`.
3.  В случае успеха возвращает `True`.

**Примеры**:
```python
# Пример вызова функции create_docx_report_async
# success = await r.create_docx_report_async('/path/to/report.html', '/path/to/report.docx')
```

## Функции

### `main`

```python
def main(maxiron_name:str, lang:str) ->bool:
```

**Назначение**: Функция для запуска процесса генерации отчетов.

**Параметры**:
- `maxiron_name` (str): Имя мехирона.
- `lang` (str): Язык отчетов.

**Возвращает**:
- `bool`: Возвращает `True` в случае успеха, `False` в случае ошибки. В текущей реализации всегда возвращает `None`

**Как работает функция**:

1.  Определяет пути к файлам данных, HTML, PDF и DOCX на основе имени мехирона и языка.
2.  Загружает данные из JSON-файла.
3.  Создает экземпляр класса `ReportGenerator`.
4.  Запускает асинхронный процесс создания отчетов.

**ASCII flowchart**:
```
A: Определение путей к файлам
|
B: Загрузка данных из JSON
|
C: Создание экземпляра ReportGenerator
|
D: Запуск асинхронного процесса создания отчетов
```

**Примеры**:
```python
# Пример вызова функции main
# main('250127221657987', 'ru')
```

```python
if __name__ == "__main__":
    maxiron_name = '250127221657987' # <- debug
    lang:str = 'ru'
    
    main(maxiron_name, lang)