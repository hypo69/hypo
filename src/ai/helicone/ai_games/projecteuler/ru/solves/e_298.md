## Ответ на Задачу No 298: Наилучшая стратегия

### 1. Анализ задачи и решение

**Понимание задачи:**
* Два игрока, А и Б, играют в игру, где каждый начинает с N фишками.
* Игроки по очереди берут фишки с любого конца своего ряда.
* Выбор конца фишек является случайным и равновероятным.
* E(N) — это ожидаемое количество фишек, оставшихся у другого игрока, когда один из игроков забирает все свои фишки при оптимальной игре.
* Нужно найти E(10).

**Решение:**

Задача решается с помощью динамического программирования.
Обозначим `dp[n]` как ожидаемое количество фишек у другого игрока, когда у текущего игрока осталось `n` фишек. Рассмотрим случай хода первого игрока.
Когда у первого игрока остается `n` фишек, он может забрать фишку слева или справа с вероятностью 0.5.
После этого у второго игрока остается `n` фишек. 
Далее второй игрок также забирает фишку.
Если у первого игрока осталось 1 фишка, то второй игрок либо забрал эту фишку (ожидание 1), либо нет (ожидание 0),  следовательно E(1)=1.
Если у первого игрока остается 2 фишки, то после его хода может остаться 2 фишки у второго игрока (1 фишка у первого, 2 фишки у второго) или (2 фишки у первого, 1 фишка у второго).  В конце игры либо у первого игрока будет 0 фишек и ожидаемое число фишек у второго E(2), либо у второго 0 фишек и у первого E(2).

Общая формула для `E(n)` получается как:
`E(n) = 0.25 * (E(n-1) + E(n-1) + 2 + 2 * E(n-2))`
`E(n) = 0.5 * E(n-1) + 0.5 * 0.5 * (1 + E(n-2)) + 0.5 * 0.5 * (1 + E(n-2)) =  0.5 * E(n - 1) + 0.5 + 0.5 * E(n-2)`

Преобразуем уравнение:
`E(n) = 0.5 * E(n-1) + 0.5 * ( 1 + E(n-2) )`
`E(n) = 0.5 * E(n-1) + 0.5  + 0.25 * E(n-2) `

   * **Базовые случаи:** E(1) = 1, E(2) = 4/3
   * **Рекуррентное соотношение:**
        E(n) = 0.5 * E(n - 1) + 0.5 * (1 + E(n - 2))

### 2. Алгоритм решения
1. Начать
2. Инициализировать массив `dp` размером N+1.
3. Присвоить `dp[1] = 1`.
4. Присвоить `dp[2] = 4/3`.
5. Для `i` от 3 до N:
   *   `dp[i] = 0.5 * dp[i-1] + 0.5 + 0.25 * dp[i-2]`
6. Вернуть `dp[N]`
7. Конец

### 3. Реализация на Python 3.12
```python
def calculate_expected_chips(n):
    """
    Calculates the expected number of chips remaining for the other player 
    when one player has taken all their chips.

    Args:
        n: The initial number of chips for each player.

    Returns:
        The expected number of chips.
    """
    if n == 1:
        return 1.0
    if n == 2:
        return 4/3
    
    dp = [0.0] * (n + 1)
    dp[1] = 1.0
    dp[2] = 4.0 / 3.0

    for i in range(3, n + 1):
        dp[i] = 0.5 * dp[i-1] + 0.5 + 0.25 * dp[i-2]
        
    return dp[n]
    

# Пример использования:
result = calculate_expected_chips(10)
print(f"{result:.8f}")

```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeDP((Инициализировать массив dp[n+1]))
    InitializeDP --> SetBaseCases((dp[1] = 1, dp[2] = 4/3))
    SetBaseCases --> LoopStart((Начать цикл: i от 3 до N))
    LoopStart --> CalculateDP((dp[i] = 0.5 * dp[i-1] + 0.5 + 0.25 * dp[i-2]))
    CalculateDP --> LoopStart
    LoopStart --> ReturnResult((Вернуть dp[N]))
    ReturnResult --> End((Конец))
```

**Легенда:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Инициализировать массив dp[n+1]:** Создаем массив `dp` для хранения промежуточных результатов.
* **dp[1] = 1, dp[2] = 4/3:**  Установка начальных значений.
* **Начать цикл: i от 3 до N, Конец цикла:** Определяют начало и конец цикла перебора чисел от 3 до N.
* **dp[i] = 0.5 * dp[i-1] + 0.5 + 0.25 * dp[i-2]:** Вычисление текущего значения `dp[i]`.
* **Вернуть dp[N]:**  Возвращает результат  `dp[N]`.
