## Ответ на Задачу No 428: Точки на круге

### 1. Анализ задачи и решение
**Понимание задачи:**

*   Задача требует найти количество целых точек (точек с целыми координатами) на окружности радиуса *r* с центром в начале координат. Это количество обозначается N(r).
*   Затем нужно вычислить сумму значений N(r²) для всех *r* от 1 до *n*. Эта сумма обозначается S(n).
*   В конце необходимо найти значение S(10¹¹), взяв остаток от деления на 1000000007.

**Решение:**

1.  **N(r):** Количество целых точек на окружности радиуса *r* связано с разложением числа *r²* на сумму двух квадратов. N(r) можно найти по формуле:
    N(r) = 4 * (d1(r) - d3(r)), где d1(r) - кол-во делителей r вида 4k+1 , а d3(r) - кол-во делителей r вида 4k+3
    
2. **S(n):**  Так как нам нужно вычислить `S(n) = Σ N(r²)` для `1 ≤ r ≤ n`, а `N(r²) = 4 * (d1(r²) - d3(r²))`, то
   необходимо рассмотреть свойства делителей чисел вида `r²`. Если r = p1^a1 * p2^a2 * ... pk^ak, то r^2 = p1^(2*a1) * p2^(2*a2) *... pk^(2*ak).
   Количество делителей для r^2 легко вычислить через формулу: (2*a1 + 1) * (2*a2 + 1) *...*(2*ak+1).
   При этом, количество делителей вида 4k+1 и 4k+3 можно вычислить только для простых делителей числа r, причем если простой делитель имеет вид 4k+1, то  он не влияет на разность `d1 - d3`, а если имеет вид 4k+3, то его степень в разложении числа `r`, определяет знак разности `d1 - d3`. Если степень четная, то `d1 - d3` = 0, иначе  `d1 - d3` != 0.
   
3.  **Оптимизация:** Вместо того, чтобы перебирать все `r` от 1 до `n` и считать `N(r²)` для каждого, можно использовать оптимизацию, основанную на том, что делители чисел встречаются парами,  и суммировать `N(r²)` для `r` от 1 до n.
4.  **Модульная арифметика:** Все операции необходимо проводить по модулю 1000000007, чтобы избежать переполнения.
5. **Обратная функция:** Необходимо воспользоваться функцией `d(x) = x / i`, так как нам нужно перебрать все пары `i, x/i` для которых  `i * x/i = x` и при этом  `x/i <= n`
   Тогда мы получим, что `i` принимает значения  от 1 до  `sqrt(x)`, а `x` принимает значения от 1 до `n^2`.


### 2. Алгоритм решения

1.  Начать.
2.  Инициализировать `total_sum` = 0, `MOD` = 1000000007.
3.  Для каждого `x` от 1 до `n`
    *   Для каждого `i` от 1 до `n/x`, где n = 10^11
        *   если i - простое, тогда смотрим на вид i по модулю 4
            * если `i % 4 == 1`, то ничего не делаем
            * если `i % 4 == 3`, то total_sum += 4 * (-1)**(кол-во раз i в x) % MOD
    *  если i не простое, тогда раскладываем i на множители и проверяем как простые множители влияют на результат `d1-d3`.
4.  Вычислить `total_sum % MOD`
5.  Вернуть `total_sum`
6. Конец

### 3. Реализация на Python 3.12

```python
def is_prime(num):
  """Проверяет, является ли число простым."""
  if num < 2:
      return False
  for i in range(2, int(num**0.5) + 1):
      if num % i == 0:
          return False
  return True

def sum_of_points_on_circle(n, mod=1000000007):
    """Вычисляет S(n) с использованием оптимизации."""
    total_sum = 1  # Учитываем случай r=0
    for x in range(1, int(n**0.5) + 1):
        for i in range(1, int(n / x) + 1):
            if is_prime(i):
                if i % 4 == 1:
                  continue
                else:
                  count = 0
                  temp_x = x
                  while temp_x % i == 0:
                    count += 1
                    temp_x //= i
                  total_sum += 4 * pow(-1, count, mod)
            else:
               
                temp = i
                mul = 1
                while temp != 1:
                  for j in range(2, temp+1):
                     if temp % j == 0 and is_prime(j):
                        count = 0
                        while temp % j == 0:
                          count += 1
                          temp //= j
                        if j % 4 == 1:
                           continue
                        else:
                           mul = mul * pow(-1,count, mod)
                        break
                total_sum += 4 * mul
            total_sum %= mod
    return total_sum % mod

# Пример использования:
limit = 10**11
result = sum_of_points_on_circle(limit)
print(result)

```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> Initialize((Инициализация: total_sum = 1, MOD = 1000000007))
    Initialize --> LoopXStart((Начать цикл: x от 1 до sqrt(n)))
    LoopXStart --> LoopIStart((Начать цикл: i от 1 до n/x))
    LoopIStart --> CheckPrime((Проверить: i простое?))
    CheckPrime -- Да --> CheckMod4((Проверить: i % 4 == 1?))
    CheckMod4 -- Да --> LoopIStart
    CheckMod4 -- Нет --> CountPowers((Подсчитать степень i в x))
    CountPowers --> AddToSum1((total_sum += 4 * (-1)^count))
    AddToSum1 --> LoopIStart
    CheckPrime -- Нет --> FindPrimeFactors((Найти простые множители i))
    FindPrimeFactors -->  CalcMul((Вычислить mul))
    CalcMul --> AddToSum2((total_sum += 4 * mul))
    AddToSum2 --> LoopIStart
    LoopIStart --> LoopXEnd((Закончить цикл i))
    LoopXEnd --> LoopXStart((Закончить цикл x))
     LoopXStart --> CalculateResult((Вычислить total_sum % MOD))
    CalculateResult --> Output((Вывести total_sum))
    Output --> End((Конец))
```

**Legenda:**
*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализация:** Инициализация переменных `total_sum` (сумма) и `MOD`.
*   **Начать цикл: x от 1 до sqrt(n):** Начало внешнего цикла по переменной `x`.
*   **Начать цикл: i от 1 до n/x:** Начало внутреннего цикла по переменной `i`.
*   **Проверить: i простое?:** Проверка, является ли текущее значение `i` простым числом.
*   **Проверить: i % 4 == 1?:** Проверка остатка от деления `i` на 4. Если остаток 1, переходим к следующему шагу цикла `i`.
*   **Подсчитать степень i в x:** Подсчитывает, сколько раз `i` встречается в разложении числа `x` на множители.
*   **total_sum += 4 \* (-1)^count:** Обновляет сумму, добавляя `4 * (-1)^count` (модульно).
*   **Найти простые множители i:** Находит простые множители числа `i`.
*  **Вычислить mul:** вычисляет вклад простых множителей `i` в результат.
*   **total_sum += 4 * mul:** Обновляет сумму, добавляя `4 * mul`.
*    **Закончить цикл i:** Конец внутреннего цикла по переменной `i`.
*   **Закончить цикл x:** Конец внешнего цикла по переменной `x`.
*   **Вычислить total_sum % MOD:**  Вычисление остатка от деления суммы на `MOD`.
*   **Вывести total_sum:** Вывод итоговой суммы.
