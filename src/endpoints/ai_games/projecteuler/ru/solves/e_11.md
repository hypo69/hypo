## Ответ на Задачу No 11: Наибольшее произведение в сетке

### 1. Анализ задачи и решение
**Понимание задачи:**
* Нам дана сетка чисел 20x20.
* Необходимо найти наибольшее произведение четырех смежных чисел в любом направлении (вверх, вниз, вправо, влево, по диагоналям).
* Это означает, что нам нужно проверить все возможные комбинации четырех чисел в каждом из этих направлений и выбрать наибольшее произведение.

**Решение:**
1. **Представление сетки:** Сохраним сетку в виде двумерного массива (списка списков).
2. **Функция для проверки направления:** Создадим функцию, которая для заданной позиции в сетке и направления (вертикальное, горизонтальное, диагональное) будет возвращать произведение 4 смежных чисел. Если такая комбинация выходит за границы массива, функция должна возвращать 0.
3. **Перебор всех возможных комбинаций:** Мы пройдем по каждой ячейке сетки, и для каждой ячейки вызовем функцию для каждого из 8 направлений.
4. **Нахождение максимума:** Будем сохранять максимальное произведение, которое мы нашли.
5. **Возврат результата:** В конце возвращаем максимальное произведение.

### 2. Алгоритм решения
1. Начать
2. Инициализировать `max_product` значением 0.
3. Задать сетку `grid` как двумерный список.
4. Определить функцию `calculate_product(grid, row, col, direction)`, которая будет вычислять произведение 4 смежных чисел в заданном направлении:
    - Определить смещение по строкам `row_delta` и по столбцам `col_delta` в зависимости от направления.
    - Инициализировать `product` значением 1.
    - Для i от 0 до 3:
      - Вычислить `current_row` = `row` + i * `row_delta`
      - Вычислить `current_col` = `col` + i * `col_delta`
       - Если `current_row` или `current_col` выходят за границы `grid`, вернуть 0
       - Иначе, `product` = `product` * `grid[current_row][current_col]`
    - Вернуть `product`.
5. Для каждой строки `row` от 0 до 19:
    - Для каждого столбца `col` от 0 до 19:
       - Для каждого направления `direction` в списке направлений (вправо, вниз, по диагонали вниз-вправо, по диагонали вверх-вправо и их обратные):
           - Вычислить `current_product` = `calculate_product(grid, row, col, direction)`
           - Если `current_product` > `max_product`:
             - Обновить `max_product` = `current_product`
6. Вернуть `max_product`
7. Конец

### 3. Реализация на Python 3.12
```python
def calculate_product(grid, row, col, direction):
    row_delta, col_delta = direction
    product = 1
    for i in range(4):
        current_row = row + i * row_delta
        current_col = col + i * col_delta
        if 0 <= current_row < len(grid) and 0 <= current_col < len(grid[0]):
           product *= grid[current_row][current_col]
        else:
           return 0
    return product


def find_max_product(grid):
    max_product = 0
    directions = [
        (0, 1),  # вправо
        (1, 0),  # вниз
        (1, 1),  # диагональ вниз-вправо
        (1, -1), # диагональ вниз-влево
        (0, -1),  # влево
        (-1, 0),  # вверх
        (-1, -1),  # диагональ вверх-влево
        (-1, 1),  # диагональ вверх-вправо
    ]


    for row in range(len(grid)):
        for col in range(len(grid[0])):
            for direction in directions:
                current_product = calculate_product(grid, row, col, direction)
                max_product = max(max_product, current_product)
    return max_product



grid = [
    [8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 17, 12, 94],
    [13, 49, 49, 58, 40, 7, 8, 16, 96, 30, 36, 68, 42, 57, 6, 39, 70, 83, 51, 54],
    [24, 75, 37, 29, 33, 90, 69, 94, 4, 71, 23, 67, 10, 4, 39, 21, 50, 31, 95, 96],
    [49, 18, 77, 20, 91, 60, 8, 60, 68, 97, 26, 67, 56, 40, 49, 61, 78, 14, 98, 92],
    [31, 49, 31, 73, 56, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14, 70, 11, 33, 28, 77],
    [94, 45, 95, 26, 12, 39, 49, 16, 8, 88, 96, 10, 71, 61, 28, 89, 92, 71, 16, 85],
    [16, 98, 59, 53, 40, 28, 25, 51, 96, 12, 53, 95, 14, 39, 69, 61, 92, 14, 71, 87],
    [43, 67, 15, 43, 82, 59, 48, 57, 24, 6, 37, 99, 71, 62, 76, 95, 83, 30, 25, 78],
    [14, 39, 67, 53, 53, 49, 55, 96, 57, 17, 28, 39, 72, 83, 17, 88, 79, 98, 76, 56],
    [4, 98, 90, 80, 90, 49, 91, 72, 85, 16, 70, 47, 12, 19, 19, 68, 3, 60, 40, 54],
    [30, 14, 64, 31, 27, 49, 11, 98, 20, 87, 29, 99, 95, 8, 52, 32, 43, 69, 72, 26],
    [16, 98, 53, 42, 67, 14, 92, 19, 46, 91, 16, 92, 51, 31, 9, 53, 10, 61, 16, 59],
    [54, 70, 34, 96, 56, 16, 45, 64, 81, 92, 39, 97, 86, 29, 17, 71, 58, 51, 71, 77],
    [60, 20, 78, 46, 97, 69, 40, 65, 31, 48, 95, 40, 56, 79, 45, 41, 81, 77, 35, 99],
    [70, 81, 85, 54, 27, 98, 88, 36, 77, 87, 15, 77, 78, 48, 98, 25, 39, 65, 3, 18],
    [67, 16, 36, 51, 0, 88, 80, 95, 18, 35, 59, 78, 41, 47, 85, 36, 10, 92, 98, 72],
    [93, 37, 15, 0, 60, 94, 17, 20, 78, 93, 67, 8, 87, 57, 48, 26, 2, 98, 86, 27],
    [69, 75, 34, 96, 67, 87, 63, 64, 87, 17, 6, 98, 99, 76, 31, 27, 97, 92, 29, 51],
    [85, 88, 60, 64, 52, 81, 97, 96, 44, 85, 60, 98, 88, 15, 77, 40, 99, 84, 59, 75],
    [12, 49, 77, 29, 60, 78, 87, 76, 65, 84, 76, 83, 81, 89, 98, 83, 79, 99, 76, 7],
]
result = find_max_product(grid)
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InitializeMaxProduct((Инициализировать max_product = 0))
    InitializeMaxProduct --> DefineGrid((Определить сетку grid))
    DefineGrid --> DefineDirections((Определить направления))
    DefineDirections --> LoopRowsStart((Начать цикл по строкам))
    LoopRowsStart --> LoopColsStart((Начать цикл по столбцам))
    LoopColsStart --> LoopDirectionsStart((Начать цикл по направлениям))
    LoopDirectionsStart --> CalculateCurrentProduct((Вычислить текущее произведение))
    CalculateCurrentProduct --> CheckMaxProduct((Проверить: текущее произведение > max_product?))
    CheckMaxProduct -- Да --> UpdateMaxProduct((Обновить max_product))
    UpdateMaxProduct --> LoopDirectionsEnd((Закончить цикл по направлениям))
    CheckMaxProduct -- Нет --> LoopDirectionsEnd
    LoopDirectionsEnd --> LoopColsEnd((Закончить цикл по столбцам))
    LoopColsEnd --> LoopRowsEnd((Закончить цикл по строкам))
    LoopRowsEnd --> ReturnMaxProduct((Вернуть max_product))
    ReturnMaxProduct --> End((Конец))

subgraph Calculate_Product_Subroutine
    CalculateProductStart((Начало подпрограммы calculate_product)) --> CalculateDeltas((Вычислить смещения row_delta, col_delta))
    CalculateDeltas --> InitializeProduct((Инициализировать product = 1))
    InitializeProduct --> LoopProductStart((Начать цикл i от 0 до 3))
    LoopProductStart --> CalculateCurrentRowCol((Вычислить current_row, current_col))
    CalculateCurrentRowCol --> CheckBounds((Проверить границы сетки))
    CheckBounds -- Да --> MultiplyProduct((product = product * grid[current_row][current_col]))
    MultiplyProduct --> LoopProductEnd
    CheckBounds -- Нет --> ReturnZero((Вернуть 0))
    LoopProductEnd --> LoopProductStart
    LoopProductStart --> ReturnProduct((Вернуть product))
    ReturnProduct --> CalculateProductEnd((Конец подпрограммы calculate_product))
    ReturnZero --> CalculateProductEnd
end
```

**Легенда:**
*   **Начало, Конец:** Начало и конец основного алгоритма.
*   **Инициализировать `max_product`:** Инициализация переменной `max_product` нулем.
*   **Определить сетку `grid`:** Задание сетки как двумерный массива.
*   **Определить направления:** Задание списка возможных направлений для поиска смежных чисел.
*    **Начать цикл по строкам, Конец цикла по строкам:** Цикл для перебора строк сетки.
*   **Начать цикл по столбцам, Конец цикла по столбцам:** Цикл для перебора столбцов сетки.
*   **Начать цикл по направлениям, Конец цикла по направлениям:** Цикл для перебора всех направлений.
*   **Вычислить текущее произведение:** Вызов подпрограммы `calculate_product` для вычисления произведения четырех чисел в текущем направлении.
*   **Проверить: текущее произведение > `max_product`?:** Проверка, больше ли текущее произведение, чем `max_product`.
*   **Обновить `max_product`:** Обновление `max_product`, если найдено большее произведение.
*   **Вернуть `max_product`:** Вывод итогового максимального произведения.

* **Начало подпрограммы calculate_product, Конец подпрограммы calculate_product:** Начало и конец подпрограммы для вычисления произведения.
* **Вычислить смещения `row_delta, col_delta`:** Вычисление смещений по строкам и столбцам в зависимости от направления.
* **Инициализировать `product = 1`:** Инициализация переменной для вычисления произведения.
*  **Начать цикл i от 0 до 3, Конец цикла i от 0 до 3:** цикл для вычисления произведения 4х чисел
* **Вычислить `current_row, current_col`:** Вычисление текущих координат.
* **Проверить границы сетки:** Проверка, не выходят ли текущие координаты за пределы сетки.
* **`product = product * grid[current_row][current_col]`:** Умножение `product` на значение сетки.
*  **Вернуть `product`:** Возвращение результата произведения.
*  **Вернуть 0:** Возврат нуля, если координаты выходят за пределы сетки.
