# Анализ кода модуля `checkr.py`

**Качество кода**
8
- Плюсы
    - Код хорошо структурирован и разбит на функции, что делает его читаемым и понятным.
    - Имеется подробная документация в начале файла, включая описание игры, алгоритм и блок-схему.
    - Присутствуют комментарии, поясняющие логику работы кода.
    - Код использует константы для размеров доски и обозначения игроков, что улучшает читаемость.
- Минусы
    - Используются стандартные `input` и `print` для взаимодействия с пользователем, что ограничивает возможности интерфейса.
    - Отсутствует обработка ошибок при вводе пользователя, кроме `ValueError`.
    - Нет логирования ошибок.
    - Нет обработки особых случаев, таких как множественные прыжки.
    - Не реализовано превращение шашки в дамку при достижении противоположного конца доски.
    - Используется стандартный модуль `random`, что может быть заменено на более криптостойкий источник.

**Рекомендации по улучшению**
1. **Документация:**
    - Переписать документацию в формате reStructuredText (RST) для соответствия стандартам оформления docstring в Python и корректного отображения в Sphinx.
    - Добавить документацию для каждой функции и метода, включая описание параметров и возвращаемых значений.

2. **Импорты:**
    - Добавить необходимые импорты для логирования (`src.logger.logger`).

3. **Обработка ошибок:**
    - Использовать `logger.error` для логирования ошибок вместо `print`.
    - Добавить обработку ошибок при преобразовании ввода пользователя в числа.

4. **Рефакторинг:**
    - Разбить функцию `is_valid_move` на несколько более мелких функций для улучшения читаемости и тестируемости.
    - Применить более элегантные способы проверки валидности хода.

5. **Улучшения логики:**
    - Реализовать возможность множественных прыжков.
    - Реализовать превращение шашки в дамку при достижении противоположного конца доски.

6.  **Безопасность:**
    - Рассмотреть возможность замены `random` на `secrets` для генерации случайных ходов компьютера, если это необходимо для безопасности.

**Оптимизированный код**
```python
"""
Модуль для реализации игры в шашки.
=========================================================================================

Этот модуль содержит функции для инициализации, отрисовки доски, обработки ходов игроков (человека и компьютера),
а также проверки условий победы в игре "Шашки".

Игра представляет собой текстовую реализацию упрощенной версии игры в шашки на доске 8x8.

Правила игры:
1. Игрок и компьютер ходят по очереди.
2. Игрок управляет шашками, обозначаемыми '1'.
3. Компьютер управляет шашками, обозначаемыми '2'.
4. Доска представляет собой сетку 8x8, где '.' обозначает пустое место.
5. Игрок вводит координаты текущей позиции и желаемой позиции.
6. Ход шашки - перемещение на одну клетку по диагонали вперед.
7. Шашка может перепрыгивать через шашку противника, если за ней есть свободное место (не реализовано).
8. Если шашка достигает противоположного конца доски, она превращается в дамку (не реализовано).
9. Компьютер делает случайный допустимый ход.
10. Игра заканчивается, если одна из сторон достигает конца доски или не имеет допустимых ходов.

Пример использования
--------------------

Пример запуска игры:

.. code-block:: python

    if __name__ == "__main__":
        play_checkers()
"""
import random # Модуль `random` используется для выбора случайного хода компьютера.
from src.logger.logger import logger # Импортируем logger для логирования ошибок.

# Глобальные переменные для представления доски
BOARD_SIZE = 8 # Размер игровой доски.
EMPTY = '.' # Символ для обозначения пустой клетки.
PLAYER = '1' # Символ для обозначения шашки игрока.
COMPUTER = '2' # Символ для обозначения шашки компьютера.

def initialize_board() -> list[list[str]]:
    """
    Инициализирует доску 8x8 с начальным расположением шашек.

    :return: Двумерный список, представляющий игровую доску.
    :rtype: list[list[str]]
    """
    board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)] # Создает пустую доску.
    # Размещаем шашки игрока и компьютера в начальных позициях
    for i in range(3): # Проходим по первым трем строкам для размещения шашек игрока.
        for j in range(BOARD_SIZE):
            if (i + j) % 2 != 0:
                board[i][j] = PLAYER # Размещаем шашки игрока.
    for i in range(BOARD_SIZE - 3, BOARD_SIZE): # Проходим по последним трем строкам для размещения шашек компьютера.
        for j in range(BOARD_SIZE):
            if (i + j) % 2 != 0:
                board[i][j] = COMPUTER # Размещаем шашки компьютера.
    return board

def draw_board(board: list[list[str]]):
    """
    Отрисовывает текущее состояние доски в консоль.

    :param board: Двумерный список, представляющий игровую доску.
    :type board: list[list[str]]
    """
    print("  ", end="") # Выводим пробелы для выравнивания нумерации столбцов.
    for i in range(BOARD_SIZE):
        print(i, end=" ") # Выводим номера столбцов.
    print() # Переходим на новую строку.
    for i, row in enumerate(board): # Проходим по строкам доски.
        print(i, " ".join(row)) # Выводим номер строки и содержимое строки.

def _is_within_board(row: int, col: int) -> bool:
     """
     Проверяет, находятся ли заданные координаты в пределах доски.

     :param row: Номер строки.
     :type row: int
     :param col: Номер столбца.
     :type col: int
     :return: True, если координаты внутри доски, иначе False.
     :rtype: bool
     """
     return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE # Возвращает True, если координаты в пределах доски, иначе False.

def _is_player_piece(board: list[list[str]], row: int, col: int, player: str) -> bool:
     """
     Проверяет, является ли клетка на доске шашкой заданного игрока.

     :param board: Игровая доска.
     :type board: list[list[str]]
     :param row: Номер строки.
     :type row: int
     :param col: Номер столбца.
     :type col: int
     :param player: Символ игрока ('1' или '2').
     :type player: str
     :return: True, если клетка содержит шашку игрока, иначе False.
     :rtype: bool
     """
     return board[row][col] == player # Проверяет, является ли клетка шашкой игрока.

def _is_empty_cell(board: list[list[str]], row: int, col: int) -> bool:
     """
     Проверяет, является ли клетка на доске пустой.

     :param board: Игровая доска.
     :type board: list[list[str]]
     :param row: Номер строки.
     :type row: int
     :param col: Номер столбца.
     :type col: int
     :return: True, если клетка пустая, иначе False.
     :rtype: bool
     """
     return board[row][col] == EMPTY # Проверяет, является ли клетка пустой.

def _is_valid_diagonal_move(row: int, col: int, new_row: int, new_col: int) -> bool:
     """
     Проверяет, является ли перемещение диагональным на одну клетку.

     :param row: Текущая строка.
     :type row: int
     :param col: Текущий столбец.
     :type col: int
     :param new_row: Новая строка.
     :type new_row: int
     :param new_col: Новый столбец.
     :type new_col: int
     :return: True, если перемещение диагональное, иначе False.
     :rtype: bool
     """
     row_diff = new_row - row # Вычисляем разницу строк.
     col_diff = new_col - col # Вычисляем разницу столбцов.
     return abs(row_diff) == 1 and abs(col_diff) == 1 # Возвращает True, если перемещение диагональное на одну клетку.

def _is_valid_player_direction(row: int, new_row: int, player: str) -> bool:
    """
    Проверяет, является ли направление хода допустимым для данного игрока.

    :param row: Текущая строка.
    :type row: int
    :param new_row: Новая строка.
    :type new_row: int
    :param player: Символ игрока ('1' или '2').
    :type player: str
    :return: True, если направление хода допустимо, иначе False.
    :rtype: bool
    """
    row_diff = new_row - row  # Вычисляем разницу строк.
    if player == PLAYER and row_diff > 0:
        return False
    if player == COMPUTER and row_diff < 0:
        return False
    return True


def is_valid_move(board: list[list[str]], row: int, col: int, new_row: int, new_col: int, player: str) -> bool:
    """
    Проверяет, является ли ход игрока допустимым.

    :param board: Игровая доска.
    :type board: list[list[str]]
    :param row: Текущая строка.
    :type row: int
    :param col: Текущий столбец.
    :type col: int
    :param new_row: Новая строка.
    :type new_row: int
    :param new_col: Новый столбец.
    :type new_col: int
    :param player: Символ игрока ('1' или '2').
    :type player: str
    :return: True, если ход допустим, иначе False.
    :rtype: bool
    """
    if not (_is_within_board(row, col) and _is_within_board(new_row, new_col)): # Проверяем, находятся ли координаты в пределах доски.
       return False
    if not _is_player_piece(board, row, col, player): # Проверяем, принадлежит ли шашка игроку.
       return False
    if not _is_empty_cell(board, new_row, new_col): # Проверяем, является ли целевая клетка пустой.
       return False
    if not _is_valid_diagonal_move(row, col, new_row, new_col):# Проверяем, является ли перемещение диагональным.
        return False
    if not _is_valid_player_direction(row, new_row, player): # Проверяем направление движения в зависимости от игрока.
        return False
    return True # Возвращает True, если все проверки пройдены.


def update_board(board: list[list[str]], row: int, col: int, new_row: int, new_col: int):
    """
    Обновляет доску после хода.

    :param board: Игровая доска.
    :type board: list[list[str]]
    :param row: Текущая строка.
    :type row: int
    :param col: Текущий столбец.
    :type col: int
    :param new_row: Новая строка.
    :type new_row: int
    :param new_col: Новый столбец.
    :type new_col: int
    """
    board[new_row][new_col] = board[row][col] # Перемещаем шашку в новую позицию.
    board[row][col] = EMPTY # Помечаем старую позицию как пустую.

def check_win(board: list[list[str]], player: str) -> bool:
    """
    Проверяет, достиг ли игрок или компьютер победы.

    :param board: Игровая доска.
    :type board: list[list[str]]
    :param player: Символ игрока ('1' или '2').
    :type player: str
    :return: True, если игрок победил, иначе False.
    :rtype: bool
    """
    if player == PLAYER: # Проверяем, победил ли игрок.
        for j in range(BOARD_SIZE):
          if board[BOARD_SIZE-1][j] == PLAYER: # Проверяем достижение шашкой игрока последней строки.
            return True
    if player == COMPUTER: # Проверяем, победил ли компьютер.
        for j in range(BOARD_SIZE):
          if board[0][j] == COMPUTER: # Проверяем достижение шашкой компьютера первой строки.
            return True
    return False # Возвращает False, если никто не победил.

def get_computer_moves(board: list[list[str]]) -> list[tuple[int, int, int, int]]:
    """
    Находит все возможные ходы компьютера.

    :param board: Игровая доска.
    :type board: list[list[str]]
    :return: Список кортежей с возможными ходами компьютера (row, col, new_row, new_col).
    :rtype: list[tuple[int, int, int, int]]
    """
    moves = [] # Инициализируем пустой список для хранения возможных ходов.
    for row in range(BOARD_SIZE): # Проходим по всем строкам доски.
        for col in range(BOARD_SIZE): # Проходим по всем столбцам доски.
            if board[row][col] == COMPUTER: # Проверяем, есть ли шашка компьютера в текущей позиции.
                for dr in [-1, 1]: # Перебираем возможные смещения строк (-1 для хода вверх, 1 для хода вниз).
                    for dc in [-1, 1]: # Перебираем возможные смещения столбцов (-1 для хода влево, 1 для хода вправо).
                       new_row, new_col = row + dr , col + dc # Вычисляем новые координаты.
                       if is_valid_move(board, row, col, new_row, new_col,COMPUTER): # Проверяем, является ли ход допустимым.
                            moves.append((row, col, new_row, new_col)) # Добавляем ход в список возможных ходов.
    return moves # Возвращаем список возможных ходов.

def computer_turn(board: list[list[str]]):
    """
    Выполняет ход компьютера.

    :param board: Игровая доска.
    :type board: list[list[str]]
    """
    possible_moves = get_computer_moves(board) # Находим все возможные ходы компьютера.
    if possible_moves: # Проверяем, есть ли возможные ходы.
        row, col, new_row, new_col = random.choice(possible_moves) # Выбираем случайный ход.
        update_board(board, row, col, new_row, new_col) # Обновляем доску, выполняя ход.

def player_turn(board: list[list[str]]):
    """
    Запрашивает и выполняет ход игрока.

    :param board: Игровая доска.
    :type board: list[list[str]]
    """
    while True: # Запускаем бесконечный цикл для запроса ввода, пока не будет введен корректный ход.
        try:
            current_row = int(input("Введите строку текущей позиции (0-7): ")) # Запрашиваем строку текущей позиции.
            current_col = int(input("Введите столбец текущей позиции (0-7): ")) # Запрашиваем столбец текущей позиции.
            new_row = int(input("Введите строку новой позиции (0-7): ")) # Запрашиваем строку новой позиции.
            new_col = int(input("Введите столбец новой позиции (0-7): ")) # Запрашиваем столбец новой позиции.
            if is_valid_move(board, current_row, current_col, new_row, new_col, PLAYER): # Проверяем, является ли ход допустимым.
                update_board(board, current_row, current_col, new_row, new_col) # Обновляем доску.
                break # Выходим из цикла, если ход допустим.
            else:
                print("Недопустимый ход, попробуйте еще раз.") # Выводим сообщение об ошибке, если ход недопустим.
        except ValueError as ex: # Обрабатываем ошибку ValueError, если ввод не является числом.
             logger.error('Ошибка ввода. Пожалуйста, введите целые числа.', exc_info=ex) # Логируем ошибку.
             print("Ошибка ввода. Пожалуйста, введите целые числа.")# Выводим сообщение об ошибке.


def play_checkers():
    """Основная функция игры в шашки."""
    board = initialize_board() # Инициализируем доску.
    draw_board(board) # Отрисовываем доску.
    while True: # Запускаем основной игровой цикл.
        player_turn(board) # Ход игрока.
        if check_win(board, PLAYER): # Проверяем, победил ли игрок.
            print("Поздравляю! Вы выиграли!") # Выводим сообщение о победе игрока.
            break # Завершаем игру.
        
        computer_turn(board) # Ход компьютера.
        if check_win(board, COMPUTER): # Проверяем, победил ли компьютер.
            print("Компьютер выиграл!") # Выводим сообщение о победе компьютера.
            break # Завершаем игру.
        draw_board(board) # Отрисовываем доску после каждого хода.


if __name__ == "__main__":
    play_checkers() # Запускаем игру, если файл запущен напрямую.

"""
Объяснение кода:

1.  **Импорт модулей**:
    - `import random`: Импортирует модуль `random`, который используется для выбора случайного хода компьютера.
    - `from src.logger.logger import logger`: Импортирует logger для логирования ошибок.

2.  **Глобальные переменные**:
    - `BOARD_SIZE`: Размер доски (8x8).
    - `EMPTY`: Символ для пустой клетки.
    - `PLAYER`: Символ для шашки игрока ('1').
    - `COMPUTER`: Символ для шашки компьютера ('2').

3.  **Функция `initialize_board()`**:
    - Создаёт и инициализирует игровую доску как список списков (двумерный массив).
    - Расставляет начальные позиции шашек игрока ('1') и компьютера ('2').

4.  **Функция `draw_board(board)`**:
    - Принимает текущее состояние доски.
    - Выводит доску в консоль с нумерацией строк и столбцов для удобства пользователя.

5.  **Функция `_is_within_board(row, col)`**:
    - Проверяет, находятся ли координаты в пределах доски.

6.  **Функция `_is_player_piece(board, row, col, player)`**:
    - Проверяет, является ли клетка на доске шашкой заданного игрока.

7.  **Функция `_is_empty_cell(board, row, col)`**:
    - Проверяет, является ли клетка на доске пустой.

8.  **Функция `_is_valid_diagonal_move(row, col, new_row, new_col)`**:
    - Проверяет, является ли перемещение диагональным на одну клетку.

9. **Функция `_is_valid_player_direction(row, new_row, player)`**:
    - Проверяет, является ли направление хода допустимым для данного игрока.

10. **Функция `is_valid_move(board, row, col, new_row, new_col, player)`**:
    - Проверяет, является ли ход игрока или компьютера допустимым.
    - Состоит из нескольких проверок: нахождение в пределах доски, принадлежность шашки игроку, пустота целевой клетки, движение только по диагонали на одну клетку, движение шашки игрока только вперед, движение шашки компьютера только вперед.

11. **Функция `update_board(board, row, col, new_row, new_col)`**:
    - Обновляет доску после хода.
    - Перемещает шашку из текущей позиции в новую.
    - Помечает текущую позицию как пустую.

12. **Функция `check_win(board, player)`**:
    - Проверяет, достиг ли игрок или компьютер конца доски, что означает победу.
    - Для игрока проверяется достижение шашкой последней строки.
    - Для компьютера проверяется достижение шашкой первой строки.

13. **Функция `get_computer_moves(board)`**:
    - Находит все возможные ходы компьютера.
    - Проходит по всем клеткам доски и ищет шашки компьютера.
    - Проверяет все возможные диагональные ходы для каждой шашки.
    - Возвращает список кортежей (row, col, new_row, new_col) доступных ходов.

14. **Функция `computer_turn(board)`**:
    - Выполняет ход компьютера.
    - Получает список возможных ходов.
    - Выбирает случайный ход из списка.
    - Обновляет доску в соответствии с выбранным ходом.

15. **Функция `player_turn(board)`**:
    - Запрашивает у игрока ввод координат текущей позиции и желаемой позиции.
    - Проверяет валидность ввода.
    - Выполняет ход, если ввод валидный.
    - Если ввод невалидный, запрашивает повторный ввод.

16. **Функция `play_checkers()`**:
    - Основная функция игры.
    - Инициализирует доску.
    - Выводит доску на экран.
    - Запускает игровой цикл, пока не будет достигнута победа одной из сторон.
    - Ход игрока.
    - Проверка победы игрока.
    - Ход компьютера.
    - Проверка победы компьютера.
    - Вывод доски после каждого хода.

17. **Запуск игры**:
    - `if __name__ == "__main__":`: Этот блок гарантирует, что функция `play_checkers()` будет запущена, только если файл исполняется напрямую, а не импортируется как модуль.
    - `play_checkers()`: Вызывает функцию для начала игры.
"""
```