## Ответ на Задачу No 302: Гиперкубические числа

### 1. Анализ задачи и решение

**Понимание задачи:**

*   **h(n):**  Множество всех возможных сумм кубов целых чисел, где каждое слагаемое – куб целого числа, по модулю не превышающего n.
*   **H(n):**  Количество различных элементов в множестве h(n).
*   **S(N):** Сумма всех H(n) для n от 1 до N.
*   Нам требуется найти S(10^6).

**Решение:**

1.  **Генерация h(n):** Для каждого n нам нужно сгенерировать все возможные суммы кубов чисел от -n до n. Важно заметить, что размер множества  h(n) достаточно велик и хранить его целиком в памяти для больших n будет неэффективно.
2.  **Оптимизация вычисления H(n):**  Мы не будем генерировать все элементы h(n), а будем использовать set для подсчета уникальных значений. После добавления всех возможных сумм, размер set будет соответствовать H(n).
3.  **Вычисление S(N):**  Последовательно вычисляем H(n) для каждого n от 1 до N и суммируем их.

**Оптимизация:**
   *   Можно заметить, что множество кубов чисел от -n до n симметрично относительно нуля. Поэтому для подсчета *H(n)* достаточно сгенерировать все суммы кубов, в которых используются только неотрицательные значения. После этого необходимо будет учесть отрицательные суммы. Учитывая, что куб отрицательного числа будет отрицательным, достаточно будет перебрать все возможные комбинации положительных и отрицательных слагаемых для всех кубов от 0 до *n* и добавить их в set.
   *   Максимальное значение суммы будет равно n^3 * кол-во кубов. Кол-во кубов в худшем случае = 2n + 1. Порядок роста  H(n) имеет порядок O(n^4), поэтому прямое вычисление сумм может занять много времени.
   *   Можно заметить, что нам не нужно генерировать все суммы заново для каждого n, можно использовать подход динамического программирования. Для этого можно использовать рекурсивную функцию с мемоизацией. Это позволит нам переиспользовать вычисленные значения и снизит время вычислений.

### 2. Алгоритм решения

1.  Начать
2.  Инициализировать переменную `total_sum` со значением 0.
3.  Создать кэш `memo`, который будет хранить уже вычисленные значения H(n).
4.  Для каждого `n` от 1 до N:
    *   Если значение `H(n)` есть в `memo`, то взять его из кэша.
    *   Иначе:
        * Инициализировать пустой set `unique_sums`
        *  Рекурсивно сгенерировать все суммы кубов, используя числа от `-n` до `n` (оптимизированная версия)
            * Для каждого числа `i` от 0 до `n`:
               * Для каждой суммы `current_sum` в `unique_sums`:
                  *  Добавить к `unique_sums` `current_sum + i^3`
                  *  Добавить к `unique_sums` `current_sum - i^3`
            *  Добавить в `unique_sums` `0`
        *   Записать размер `unique_sums` в кэш `memo[n]`
        *   Присвоить `H(n)` размер `unique_sums`
    *   Прибавить `H(n)` к `total_sum`
5.  Вернуть `total_sum`
6.  Конец

### 3. Реализация на Python 3.12

```python
def calculate_h_n(n, memo):
  """Calculates the number of unique sums of cubes for a given n."""
  if n in memo:
    return memo[n]

  unique_sums = {0}  # Start with 0 to account for no cubes
  for i in range(1, n + 1):
        new_sums = set()
        for sum_val in unique_sums:
            new_sums.add(sum_val + i**3)
            new_sums.add(sum_val - i**3)
        unique_sums.update(new_sums)


  memo[n] = len(unique_sums)
  return memo[n]

def calculate_s_n(limit):
  """Calculates the sum of H(n) for n from 1 to limit."""
  total_sum = 0
  memo = {}
  for n in range(1, limit + 1):
    total_sum += calculate_h_n(n, memo)
  return total_sum


# Example usage:
result = calculate_s_n(10)
print(f"S(10) = {result}")

result = calculate_s_n(10**6)
print(f"S(10^6) = {result}")
```

### 4. Блок-схема в формате mermaid

```mermaid
flowchart TD
    Start((Начало)) --> InitializeSum((Инициализировать total_sum = 0, memo = {}))
    InitializeSum --> LoopStart((Начать цикл: n от 1 до N))
    LoopStart --> CheckMemo((Проверить: H(n) в memo?))
    CheckMemo -- Да --> GetHFromMemo((H(n) = memo[n]))
    CheckMemo -- Нет --> InitializeUniqueSums((unique_sums = {0}))
    InitializeUniqueSums --> InnerLoopStart((Начать цикл: i от 1 до n))
    InnerLoopStart --> GenerateNewSums((new_sums = {}))
    GenerateNewSums --> IterateUniqueSums((Цикл по sum_val в unique_sums))
    IterateUniqueSums --> AddCubePlus((Добавить sum_val + i^3 в new_sums))
    AddCubePlus --> AddCubeMinus((Добавить sum_val - i^3 в new_sums))
    AddCubeMinus --> IterateUniqueSums
    IterateUniqueSums --> UpdateUniqueSums((unique_sums = unique_sums U new_sums))
    UpdateUniqueSums --> InnerLoopStart
    InnerLoopStart --> CalculateH((H(n) = len(unique_sums)))
    CalculateH --> SaveHInMemo((memo[n] = H(n)))
    SaveHInMemo --> GetHFromMemo
    GetHFromMemo --> AddHToSum((total_sum = total_sum + H(n)))
     AddHToSum --> LoopStart
    LoopStart --> End((Конец: Вернуть total_sum))
```

**Легенда:**

*   **Начало, Конец:** Начало и конец алгоритма.
*   **Инициализировать total\_sum = 0, memo = {}:** Инициализация переменной для хранения общей суммы и словаря для кэширования результатов.
*   **Начать цикл: n от 1 до N:** Начало внешнего цикла по значениям `n` от 1 до `N`.
*  **Проверить: H(n) в memo?:** Проверка, вычислялось ли значение H(n) ранее.
*  **H(n) = memo[n]:** Получение ранее вычисленного значения из кэша.
*   **unique\_sums = {0}:** Инициализация множества для хранения уникальных сумм кубов.
*   **Начать цикл: i от 1 до n:** Начало внутреннего цикла по значениям `i` от 1 до `n`.
* **new_sums = {}:** Инициализация множества для хранения новых сумм на текущей итерации.
*   **Цикл по sum\_val в unique\_sums:** Начало цикла по всем уникальным суммам на текущем этапе.
*   **Добавить sum\_val + i^3 в new\_sums:**  Добавление новой суммы с использованием куба i
*   **Добавить sum\_val - i^3 в new\_sums:**  Добавление новой суммы с использованием куба i c обратным знаком.
*   **unique_sums = unique_sums U new_sums:** Обновление уникальных сумм
*   **H(n) = len(unique\_sums):** Вычисление размера множества уникальных сумм для текущего `n`.
*   **memo[n] = H(n):** Сохранение вычисленного значения в кэше.
*   **total\_sum = total\_sum + H(n):** Добавление H(n) к общей сумме.
*   **Конец: Вернуть total\_sum:** Возврат итоговой суммы.
