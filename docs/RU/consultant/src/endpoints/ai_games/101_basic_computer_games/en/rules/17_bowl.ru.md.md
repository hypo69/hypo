# Анализ кода модуля `17_bowl.ru.md`

**Качество кода: 7/10**

- **Плюсы:**
    - Документ хорошо структурирован и понятен для пользователя.
    - Присутствует подробное описание игры, пошаговая инструкция и пример работы программы.
    - Описаны различные типы бросков (ГАТТЕР, СТРАЙК, СПЭР, ОШИБКА).
    - Указаны ограничения.
- **Минусы:**
    - Документ не содержит исполняемого кода, поэтому невозможно оценить его качество в плане синтаксиса Python.
    - Отсутствуют комментарии в формате reStructuredText (RST).
    - Не используются логирование ошибок с помощью `from src.logger.logger import logger`.
    - Нет разделения на отдельные функции или модули, только общее описание игры.
    - Не используются `j_loads` или `j_loads_ns` из `src.utils.jjson`.

**Рекомендации по улучшению:**

1.  **Добавить исполняемый код**: Необходимо добавить пример кода на Python, реализующий описанную игру.
2.  **Использовать RST для комментариев**: Все комментарии к модулям, функциям, методам и переменным должны быть переписаны в формате reStructuredText (RST).
3.  **Включить логирование**: Использовать `from src.logger.logger import logger` для логирования ошибок.
4.  **Структурировать код**: Разделить код на функции и модули для лучшей читаемости и поддержки.
5.  **Обрабатывать ошибки**: Вместо стандартных `try-except`, использовать `logger.error` для обработки ошибок.
6.  **Использовать `j_loads` или `j_loads_ns`**: При необходимости чтения файлов использовать  `j_loads` или `j_loads_ns` из `src.utils.jjson`.

**Оптимизированный код**

```markdown
### Название игры: **BOWL** (Боулинг)

#### Описание
Игра "BOWL" — это симуляция игры в боулинг для одного до четырёх игроков. В игре используются стандартные правила боулинга: каждый игрок выполняет 10 фреймов, и его задача — сбить все 10 кеглей за два броска. После каждого броска компьютер отображает оставшиеся кегли и анализирует результат: "ГАТТЕР", "СТРАЙК", "СПЭР" или "ОШИБКА".

---

### Пошаговая инструкция для реализации

#### 1. **Инициализация игры**
   - Игрок выбирает количество участников (от 1 до 4).
   - Каждый игрок выполняет 10 фреймов.
   - Чтобы бросить мяч, нужно ввести команду "ROLL".

#### 2. **Основной цикл игры**
   - **Бросок игрока:**
     1. Игрок вводит команду "ROLL", чтобы сделать бросок.
     2. После каждого броска компьютер выводит на экран диаграмму оставшихся кеглей:
        - "0" — означает, что кегля сбита.
        - "+" — означает, что кегля стоит.
     3. Результат броска отображается в виде "ГАТТЕР", "СТРАЙК", "СПЭР" или "ОШИБКА" (если после второго броска остаются кегли).

#### 3. **Типы бросков**
   - **ГАТТЕР (GUTTER)** — мяч не попал в кегли.
   - **СТРАЙК (STRIKE)** — все 10 кеглей сбиты с первого броска.
   - **СПЭР (SPARE)** — все 10 кеглей сбиты за два броска.
   - **ОШИБКА (ERROR)** — если после второго броска остались стоящие кегли.

#### 4. **Подсчёт победителя**
   - Каждый игрок выполняет 10 фреймов.
   - После всех бросков программа выводит итоговый счёт и объявляет победителя:
     ```
     Итоговый счёт игрока: 120
     ```

#### 5. **Завершение игры**
   - После завершения игры игрокам предлагается сыграть ещё раз или выйти:
     ```
     Хотите сыграть снова? (да/нет)
     ```

---

### Пример работы программы

1. **Начало игры:**
   ```
   Добро пожаловать в боулинг!
   Сколько игроков участвуют? (1-4)
   > 2
   Игрок 1, ваш ход.
   РОЛЛ
   ```

2. **После первого броска:**
   ```
   Оставшиеся кегли: 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
   Результат: СТРАЙК!
   ```

3. **Второй игрок:**
   ```
   Игрок 2, ваш ход.
   РОЛЛ
   Оставшиеся кегли: 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
   Результат: СПЭР!
   ```

4. **Завершение игры:**
   ```
   Итоговый счёт игрока 1: 150
   Итоговый счёт игрока 2: 130
   Победил игрок 1!
   Хотите сыграть снова? (да/нет)
   > нет
   До свидания!
   ```

---

### Возможные ограничения
- Игра предполагает, что игроки делают только два броска в каждом фрейме.
- Игроки должны вводить команду "ROLL" для выполнения броска.

---

### Реализация
Игра реализуется с помощью базовых операций ввода-вывода, а также генерации случайных чисел для имитации результатов бросков в боулинге.

```python
"""
Модуль реализует игру в боулинг для нескольких игроков.
=========================================================================================

В этом модуле реализована простая симуляция игры в боулинг.
Игра позволяет от 1 до 4 игрокам участвовать в игре.

Пример использования
--------------------

Пример использования:

.. code-block:: python

    bowl_game = BowlGame()
    bowl_game.start_game()
"""
import random
from src.logger.logger import logger # Импортируем модуль логирования
from typing import List

class BowlGame:
    """
    Класс, представляющий игру в боулинг.
    """
    def __init__(self):
        """
        Инициализирует игру.
        """
        self.players = 0
        self.scores = {}

    def get_players_count(self) -> int:
        """
        Запрашивает у пользователя количество игроков.

        :return: Количество игроков.
        """
        while True:
            try:
                # Код запрашивает ввод количества игроков
                players = int(input("Сколько игроков участвуют? (1-4) > "))
                if 1 <= players <= 4:
                    # Код проверяет валидность ввода
                    return players
                else:
                   logger.error("Неверное количество игроков. Введите число от 1 до 4.")
            except ValueError:
                logger.error("Неверный ввод. Введите целое число.")

    def display_pins(self, pins: List[str]) -> None:
        """
        Отображает текущее состояние кеглей.

        :param pins: Список строк, представляющих кегли.
        """
        print("Оставшиеся кегли: " + " ".join(pins))

    def roll(self, pins: List[str]) -> List[str]:
        """
        Имитирует бросок мяча.

        :param pins: Список строк, представляющих кегли.
        :return: Обновленный список кеглей после броска.
        """
        # Код имитирует бросок мяча
        for i in range(10):
            if random.random() < 0.5: # Вероятность сбить кеглю 50%
                pins[i] = '0'
        return pins

    def check_result(self, pins: List[str]) -> str:
        """
        Проверяет результат броска.

        :param pins: Список строк, представляющих кегли.
        :return: Результат броска (СТРАЙК, СПЭР, ОШИБКА, ГАТТЕР).
        """
        # Код проверяет результат броска
        if all(pin == '0' for pin in pins):
            return "СТРАЙК!"
        elif pins.count('0') > 0:
             return "СПЭР!" if pins.count('0') == 10 else "ОШИБКА"
        else:
             return "ГАТТЕР"

    def play_frame(self, player_id: int) -> int:
        """
        Выполняет один фрейм для игрока.

        :param player_id: Идентификатор игрока.
        :return: Набранные очки за фрейм.
        """
        pins = ['+' for _ in range(10)] # Инициализируем кегли
        score = 0
        for _ in range(2): # Делаем два броска
            input("РОЛЛ")
            pins = self.roll(pins) # Выполняем бросок
            self.display_pins(pins) # Отображаем кегли
            result = self.check_result(pins) # Проверяем результат
            print("Результат: " + result) # Выводим результат

            if result == "СТРАЙК!":
                score += 10
                break  # Если страйк, второй бросок не нужен
            elif result == "СПЭР!":
                score += 10
                break  # Если спер, второй бросок не нужен
            else:
                score += pins.count('0') # Добавляем количество сбитых кеглей к счету
        return score

    def calculate_scores(self) -> None:
        """
        Вычисляет итоговые результаты и определяет победителя.
        """
        for player_id in range(1, self.players + 1):
            total_score = 0
            for frame in range(10):
               print(f"Игрок {player_id}, ваш ход. Фрейм {frame+1}")
               total_score += self.play_frame(player_id) # Учитываем результаты фрейма

            self.scores[player_id] = total_score
            print(f"Итоговый счёт игрока {player_id}: {total_score}")

    def display_winner(self) -> None:
        """
        Отображает победителя игры.
        """
        if not self.scores:
            return
        winner = max(self.scores, key=self.scores.get) # Определяем победителя
        print(f"Победил игрок {winner}!") # Выводим победителя

    def start_game(self) -> None:
        """
        Запускает игру.
        """
        print("Добро пожаловать в боулинг!")
        self.players = self.get_players_count() # Запрашиваем количество игроков
        self.calculate_scores() # Высчитываем очки
        self.display_winner() # Выводим победителя

        while True:
            play_again = input("Хотите сыграть снова? (да/нет) > ").lower()
            if play_again == "да":
                self.scores = {}
                self.start_game() # Начинаем игру заново
                break
            elif play_again == "нет":
                print("До свидания!")
                break
            else:
                logger.error("Некорректный ввод. Введите 'да' или 'нет'.")

if __name__ == "__main__":
    bowl_game = BowlGame()
    bowl_game.start_game()
```