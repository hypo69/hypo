## Ответ на Задачу No 412: Гудвинские квадраты

### 1. Анализ задачи и решение
**Понимание задачи:**

*   Задача состоит из двух частей: подсчет гудвинских путей `G(n)` и подсчет циклов `C(n)`.
*   Гудвинский путь — это путь из (1, 1) в (n, n), где каждый ход увеличивает либо x, либо y.
*   Цикл — это путь, начинающийся в (1,1), состоящий из ходов, увеличивающих x или y, без самопересечений, и содержащий 4 и более ходов.
*   Нам нужно найти `S(n) = G(n) + C(n)` для `n = 10^6` и взять результат по модулю `10^8`.
*  Из анализа первых значений можно сделать вывод что G(n) = `C(2n-2, n-1)` = `(2n-2)! / ((n-1)! * (n-1)!)` (Биномиальный коэффициент)
*  Количество циклов равно количеству возможных прямоугольников, образованных ходами по направлению +x или +y.  Для сетки n x n количество циклов =  `(n-1)*(n-2) / 2`.
* Таким образом S(n) = G(n) + C(n) = `C(2n-2, n-1) + (n-1)*(n-2)/2`

**Решение:**
1.  **Вычисление `G(n)`:**  `G(n)` представляет собой количество способов добраться из (1, 1) в (n, n), двигаясь только вправо или вниз. Это эквивалентно количеству способов выбрать `n-1` шагов вправо из общего количества шагов `2n-2`, то есть биномиальному коэффициенту `C(2n-2, n-1)`. `C(2n-2, n-1) = (2n-2)! / ((n-1)! * (n-1)!)`.
2. **Вычисление C(n):** Количество циклов C(n) = (n-1)(n-2)/2;
3.  **Вычисление `S(n)`:** Складываем `G(n)` и `C(n)`.
4.  **Модуль:** Берем результат по модулю `10^8`.
5.  Для вычисления `C(2n-2, n-1)` используем метод сокращения факториалов и вычисления по модулю.
    Вычисления факториала с помощью рекурсии может привести к переполнению стека. Поэтому используется итеративный метод.

### 2. Алгоритм решения
1. Начать
2. Присвоить `n = 10^6`
3. Вычислить `g_n = calculate_binomial_coefficient(2 * n - 2, n - 1)`
4. Вычислить `c_n = (n-1) * (n-2) // 2`
5. Вычислить `s_n = (g_n + c_n) % 100000000`
6. Вернуть `s_n`
7. Конец

Функция  `calculate_binomial_coefficient(n, k)`:
1.  Если `k` больше `n - k`, то `k = n - k`
2.  Инициализировать переменную `result = 1`
3.  В цикле от 0 до `k`
   * `result = (result * (n - i)) // (i + 1)`
4.  Вернуть `result`

### 3. Реализация на Python 3.12
```python
def calculate_binomial_coefficient(n, k):
    if k > n - k:
        k = n - k
    result = 1
    for i in range(k):
        result = (result * (n - i)) // (i + 1)
    return result

def solve():
    n = 10**6
    g_n = calculate_binomial_coefficient(2 * n - 2, n - 1)
    c_n = (n - 1) * (n - 2) // 2
    s_n = (g_n + c_n) % 100000000
    return s_n

result = solve()
print(result)
```

### 4. Блок-схема в формате mermaid
```mermaid
flowchart TD
    Start((Начало)) --> InputN((Ввод n = 10^6))
    InputN --> CalculateG(("<center>Вычислить G(n):<br> calculate_binomial_coefficient(2n-2, n-1)</center>"))
    CalculateG --> CalculateC((Вычислить C(n): (n-1)*(n-2)//2))
    CalculateC --> CalculateS((Вычислить S(n): (G(n) + C(n)) mod 10^8))
    CalculateS --> OutputS((Вывод S(n)))
    OutputS --> End((Конец))
    
    subgraph calculate_binomial_coefficient
        BCStart((Начало calculate_binomial_coefficient)) --> BCInput((Ввод n, k))
        BCInput --> BCCheck((k > n - k?))
        BCCheck -- Да --> BCUpdateK((k = n - k))
        BCUpdateK --> BCInitResult((result = 1))
        BCCheck -- Нет --> BCInitResult
        BCInitResult --> BCLoopStart((Начать цикл i от 0 до k-1))
        BCLoopStart --> BCUpdateResult((result = result * (n - i) // (i + 1)))
        BCUpdateResult --> BCLoopStart
        BCLoopStart -- Конец цикла --> BCReturn((Вернуть result))
        BCReturn --> BCEnd((Конец calculate_binomial_coefficient))
    end
    CalculateG --> BCStart
```

**Legenda:**
* **Начало, Конец:** Начало и конец алгоритма.
* **Ввод n:** Присваиваем переменной n значение `10^6`.
* **Вычислить G(n):** Вызываем функцию `calculate_binomial_coefficient` для расчета количества Гудвинских путей.
* **Вычислить C(n):** Вычисляем количество циклов.
* **Вычислить S(n):** Складываем G(n) и C(n) и берем остаток от деления на `10^8`.
* **Вывод S(n):** Выводим результат.
*   **Начало calculate\_binomial\_coefficient, Конец calculate\_binomial\_coefficient:**  Начало и конец функции для расчета биномиального коэффициента.
*   **Ввод n, k:** Получаем значения n и k.
*   **k > n - k?:** Проверяем, больше ли k, чем n-k.
*   **k = n - k:** Если k больше n-k, то заменяем k на n-k
*   **result = 1:** Инициализируем переменную result единицей.
*   **Начать цикл i от 0 до k-1:**  Начало цикла для вычисления биномиального коэффициента.
*   **result = result \* (n - i) // (i + 1):** Обновляем значение result на каждой итерации цикла.
*    **Вернуть result:** Возвращаем вычисленный биномиальный коэффициент.
